Code complexity is a multidimensional concept that goes beyond the mere file structure of a project. It encompasses various factors that influence the intricacy of codebases. These factors include algorithmic complexity, such as the presence of nested loops or conditional statements that affect the execution flow and processing time. Additionally, the coupling and cohesion between classes and modules impact complexity. Highly interconnected components with extensive dependencies tend to introduce intricacies. Cyclomatic complexity, a metric based on control flow, evaluates the number of possible execution paths, revealing the intricacy of decision-making processes. Code duplication can also contribute to complexity, as it requires maintenance efforts and increases the chances of inconsistencies. Furthermore, the proper utilization of design patterns and architectural principles can simplify or complicate a project. It's important to consider these factors when assessing code complexity, allowing for a more accurate understanding beyond the surface-level file structure.
Using above information we will try to find which is the most complex project.
There are total 23 projects. Below we will get details about each of these projects one by one: 

1: Project Name : CreativeCaptions.ai-Language-model-that-can-create-creative-captions
This project contains 6 main files, namely /models_folder/dummy.txt, /README.md, /main.py, /main2.py, /modules.py, /requirements.txt
Below we will get details about each of these files one by one:
	
File no 1: /models_folder/dummy.txt


File no 2: /README.md
[Language-model-that-can-create-creative-captions] CreativeCaptions.ai Language Model that creates catchy, exciting, innovative, captivating, creative and engaging captions instead of just a description of the picture. Samples 1. Output 2. Output How to use it Environment setup Folder Structure Download the repository and make sure we have below file structure. CreativeCaptions.ai-Language-model-that-can-create-creative-captions/ | ├── images/ | |__ Images5.png | |__ Images6.png | ├── models_folder/ | |__ gpt2_medium_joke_insta.pt | |__ .. | ├── main.py | ├── main2.py | ├── modules.py | └── requirements.txt Change your working directory to CreativeCaptions.ai-Language-model-that-can-create-creative-captions. Download the model gpt2_medium_joke_insta.pt from https://www.kaggle.com/datasets/raj401/creativetext and store it in models_folder Dependencies Install below libraries. pip install sentencepiece pip install transformers pip install torch pip install fastapi pip install starlette pip install aiofiles pip install python-multipart pip install Pillow pip install uvicorn Inference Everything is set up now. We can now run python main2.py images/Image6.png from terminal to see the output for Image6. Next we wrap this codebase inside FastAPI kind of microservice. And we can use this as an API. To launch it on localhost http://127.0.0.1:8000, we run below cmd from the terminal. uvicorn main:app --reload Below is a demo of how our page looks. How it works: It addresses the problem in two steps: It converts an image into simple caption It converts simple captions into something more interesting/creative text. For the 1st step, I am using Encoder-Decoder type model(pretrained model from hugging face). For the 2nd step, I have used GPT-2 Model from Hugging face and fine-tuned it. In this step our model tries to change a sentence in a humorous/creative text given any input word or words it has never seen before. For this task , I took two datasets (short jokes from reddit + movie title puns). Below is some samples from the datasets Type Jokes from reddit movie title puns Output For the Jokes in our dataset we took only those which were question,answer types and started with Why,When,How,etc. Then processed all the data in this format <|soq|> question <|sep|> answer <|endoftext|> It looks like an input to Question answering system , only the whole string is treated as one string , instead of getting different token_type_ids for Questions and Asnwers References/Datasources short jokes from reddit: https://www.kaggle.com/datasets/abhinavmoudgil95/short-jokes movie title puns: https://www.kaggle.com/datasets/mikahama/movie-title-puns?select=humor_titles.csv Go You can’t perform that action at this time.

File no 3: /main.py
from main2 import * app = FastAPI(title="Image Captioning API", description="An API for generating caption for image.") class ImageCaption(BaseModel): caption: str @app.post("/predict/", response_model=ImageCaption) def predict(file: UploadFile = File(...)): # Load the image file into memory contents = file.file.read() image = Image.open(io.BytesIO(contents)) result = predict_step([image]) result = [clean_text(st) for st in result] return JSONResponse(content={"caption": result}) # Redirect the user to the documentation @app.get("/", include_in_schema=False) def index(): return RedirectResponse(url="/docs")

File no 4: /main2.py
from modules import * model = VisionEncoderDecoderModel.from_pretrained("nlpconnect/vit-gpt2-image-captioning") feature_extractor = ViTFeatureExtractor.from_pretrained("nlpconnect/vit-gpt2-image-captioning") tokenizer = AutoTokenizer.from_pretrained("nlpconnect/vit-gpt2-image-captioning") device = torch.device("cuda" if torch.cuda.is_available() else "cpu") model.to(device) max_length = 16 num_beams = 4 gen_kwargs = {"max_length": max_length, "num_beams": num_beams} def predict_step(images_): images = [] for image_ in images_: i_image = image_ if i_image.mode != "RGB": i_image = i_image.convert(mode="RGB") images.append(i_image) pixel_values = feature_extractor(images=images, return_tensors="pt").pixel_values pixel_values = pixel_values.to(device) output_ids = model.generate(pixel_values, **gen_kwargs) preds = tokenizer.batch_decode(output_ids, skip_special_tokens=True) preds = [pred.strip() for pred in preds] preds1 = make_creative(preds[0],64,3) return [preds[0]] + preds1 # HElper Function def choose_from_top(probs, n=5): ind = np.argpartition(probs, -n)[-n:] top_prob = probs[ind] top_prob = top_prob / np.sum(top_prob) # Normalize choice = np.random.choice(n, 1, p = top_prob) token_id = ind[choice][0] return int(token_id) ## Start Creative Captioning class config: Tokenizer = GPT2Tokenizer.from_pretrained('gpt2-medium') # Model Loading model_inst = GPT2LMHeadModel.from_pretrained('gpt2-medium') special_tokens_dict = {'pad_token': '<PAD>','bos_token':'<soq>','sep_token':'<eoq>'} num_added_toks = config.Tokenizer.add_special_tokens(special_tokens_dict) print('We have added', num_added_toks, 'tokens') model_inst.resize_token_embeddings(len(config.Tokenizer)) #loading Model state models_path = "models_folder\gpt2_medium_joke_insta.pt" #model.load_state_dict(torch.load(models_path, map_location=torch.device('cpu'))) model_inst.load_state_dict(torch.load(models_path, map_location=torch.device('cpu'))) model_inst.to(device) def make_creative(start_of_joke,length_of_joke=96,number_of_jokes=2): joke_num = 0 model_inst.eval() all_jokes = [] with torch.no_grad(): for joke_idx in range(number_of_jokes): joke_finished = False cur_ids = torch.tensor(config.Tokenizer.encode(start_of_joke)).unsqueeze(0).to(device) for i in range(length_of_joke): outputs = model_inst(cur_ids, labels=cur_ids) loss, logits = outputs[:2] softmax_logits = torch.softmax(logits[0,-1], dim=0) #Take the first(from only one in this case) batch and the last predicted embedding if i < 3: n = 20 else: n = 3 next_token_id = choose_from_top(softmax_logits.to('cpu').numpy(), n=n) #Randomly(from the topN probability distribution) select the next word cur_ids = torch.cat([cur_ids, torch.ones((1,1)).long().to(device) * next_token_id], dim = 1) # Add the last word to the running sequence if next_token_id in config.Tokenizer.encode('<|endoftext|>'): joke_finished = True break if joke_finished: joke_num = joke_num + 1 output_list = list(cur_ids.squeeze().to('cpu').numpy()) output_text = config.Tokenizer.decode(output_list) #print(output_text+'\n') all_jokes.append(output_text) return all_jokes # # Start Predicting # predict("How do you feel",64,1) def clean_text(st): # 'a man kicking a soccer ball on a field <PAD> a man kicking a soccer ball on a field <|endoftext|>' st=st.split("<eoq>")[-1] for k,j in enumerate([" ", ""]): for i in ["<soq>", "<eoq>" , "<|endoftext|>", "<PAD>"]: if k ==0: st= st.replace(j+i+j, " ") else: st= st.replace(j+i+j, "") return st.strip() if __name__ == "__main__": path = sys.argv[1] img = Image.open(path) result = predict_step([img]) result = [clean_text(st) for st in result] for r in result: print(r)

File no 5: /modules.py
from fastapi import FastAPI, File, UploadFile from fastapi.responses import JSONResponse, HTMLResponse, RedirectResponse from pydantic import BaseModel import io import json import requests from transformers import VisionEncoderDecoderModel, ViTFeatureExtractor, AutoTokenizer import torch from PIL import Image # Preliminaries import os import sys import numpy as np import pandas as pd #transformers from transformers import GPT2LMHeadModel from transformers import GPT2Tokenizer # Pytorch import torch import torch.nn as nn #warnings import warnings warnings.filterwarnings('ignore') # My Module #import config

File no 6: /requirements.txt
﻿aiofiles==23.1.0 anyio==3.7.0 certifi==2023.5.7 charset-normalizer==3.1.0 click==8.1.3 colorama==0.4.6 fastapi==0.95.2 filelock==3.12.0 fsspec==2023.5.0 h11==0.14.0 huggingface-hub==0.15.1 idna==3.4 Jinja2==3.1.2 MarkupSafe==2.1.3 mpmath==1.3.0 networkx==3.1 numpy==1.24.3 packaging==23.1 pandas==2.0.2 Pillow==9.5.0 pydantic==1.10.8 python-dateutil==2.8.2 python-multipart==0.0.6 pytz==2023.3 PyYAML==6.0 regex==2023.5.5 requests==2.31.0 sentencepiece==0.1.99 six==1.16.0 sniffio==1.3.0 starlette==0.27.0 sympy==1.12 tokenizers==0.13.3 torch==2.0.1 tqdm==4.65.0 transformers==4.29.2 typing_extensions==4.6.3 tzdata==2023.3 urllib3==2.0.2 uvicorn==0.22.0

2: Project Name : EV-Enrouting
This project contains 6 main files, namely /report/Challenges_EV.pdf, /report/InternCertificateAman.pdf, /report/Solutions_EV.pdf, /src/configs.py, /src/utils.py, /README.md
Below we will get details about each of these files one by one:
	
File no 1: /report/Challenges_EV.pdf
EV-Enrouting/report/Challenges_EV.pdf at main · ar8372/EV-Enrouting · GitHub Skip to content Toggle navigation Sign up In this repository All GitHub ↵ Jump to ↵ No suggested jump to results In this repository All GitHub ↵ Jump to ↵ In this user All GitHub ↵ Jump to ↵ In this repository All GitHub ↵ Jump to ↵ Sign in Sign up You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session. You switched accounts on another tab or window. Reload to refresh your session. ar8372 / EV-Enrouting Public Notifications Fork 0 Star 5 Permalink main Switch branches/tags Branches Tags Name already in use A tag already exists with the provided branch name. Many Git commands accept both tag and branch names, so creating this branch may cause unexpected behavior. Are you sure you want to create this branch? EV-Enrouting/report/Challenges_EV.pdf Go to file Go to file T Go to line L Copy path Copy permalink This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository. Cannot retrieve contributors at this time 541 KB Download Open with Desktop Download Delete file Sorry, something went wrong. Reload? Sorry, we cannot display this file. Sorry, this file is invalid so it cannot be displayed. Viewer requires iframe. Go You can’t perform that action at this time.

File no 2: /report/InternCertificateAman.pdf
EV-Enrouting/report/InternCertificateAman.pdf at main · ar8372/EV-Enrouting · GitHub Skip to content Toggle navigation Sign up In this repository All GitHub ↵ Jump to ↵ No suggested jump to results In this repository All GitHub ↵ Jump to ↵ In this user All GitHub ↵ Jump to ↵ In this repository All GitHub ↵ Jump to ↵ Sign in Sign up You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session. You switched accounts on another tab or window. Reload to refresh your session. ar8372 / EV-Enrouting Public Notifications Fork 0 Star 5 Permalink main Switch branches/tags Branches Tags Name already in use A tag already exists with the provided branch name. Many Git commands accept both tag and branch names, so creating this branch may cause unexpected behavior. Are you sure you want to create this branch? EV-Enrouting/report/InternCertificateAman.pdf Go to file Go to file T Go to line L Copy path Copy permalink This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository. Cannot retrieve contributors at this time 517 KB Download Open with Desktop Download Delete file Sorry, something went wrong. Reload? Sorry, we cannot display this file. Sorry, this file is invalid so it cannot be displayed. Viewer requires iframe. Go You can’t perform that action at this time.

File no 3: /report/Solutions_EV.pdf
EV-Enrouting/report/Solutions_EV.pdf at main · ar8372/EV-Enrouting · GitHub Skip to content Toggle navigation Sign up In this repository All GitHub ↵ Jump to ↵ No suggested jump to results In this repository All GitHub ↵ Jump to ↵ In this user All GitHub ↵ Jump to ↵ In this repository All GitHub ↵ Jump to ↵ Sign in Sign up You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session. You switched accounts on another tab or window. Reload to refresh your session. ar8372 / EV-Enrouting Public Notifications Fork 0 Star 5 Permalink main Switch branches/tags Branches Tags Name already in use A tag already exists with the provided branch name. Many Git commands accept both tag and branch names, so creating this branch may cause unexpected behavior. Are you sure you want to create this branch? EV-Enrouting/report/Solutions_EV.pdf Go to file Go to file T Go to line L Copy path Copy permalink This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository. Cannot retrieve contributors at this time 2.31 MB Download Open with Desktop Download Delete file Sorry, something went wrong. Reload? Sorry, we cannot display this file. Sorry, this file is invalid so it cannot be displayed. Viewer requires iframe. Go You can’t perform that action at this time.

File no 4: /src/configs.py
import numpy as np class _globals: def __init__(self): self.size = 1000 self.noise = False self.battery = True self.find_optimal_CS = False self.static_quality_score = False self.dynamic_quality_score = False self.demo = False #---------------------------- self.tile_size = 10 self.drag = False self.Last_CS = (-100, -100) self.HOME = [] self.AGENT = 0 self.Grid_shape = (50,50) #(100,100) # later set automatically self.no_actions = 4 self.terminatos = [] self.optimal_path = np.zeros((50,50)) self.non_path_reward = -80 ######################################## self.optimal_value = 0 self.state =0 self.can_initial_reward = -1 ## self.optimal_policy = 0 def load(self, no): pass """ ## FUNCTIONALITIES size = 1000 #1000 #500 noise = False battery = True find_optimal_CS = False static_quality_score = False dynamic_quality_score = False demo = False ##################################### tile_size = 10 drag = False Last_CS = (-100,-100) # something which is not in 50*50 HOME = [] #0 AGENT = 0 Grid_shape = (50,50) #(100,100) # later set automatically no_actions = 4 terminatos = [] optimal_path = np.zeros((50,50)) non_path_reward = -80 ######################################## optimal_value = 0 state =0 can_initial_reward = -1 ## optimal_policy = 0 """

File no 5: /src/utils.py
import numpy as np import pandas as pd import cv2 import matplotlib.pyplot as plt import seaborn as sns import random #sns.set(rc={'figure.figsize':(11.7,8.27)}) #sns.set(rc={'figure.figsize':(8,10)}) #plt.rcParams['figure.figsize']= (5,5) #!pip install plotly #!pip install cufflinks from plotly import __version__ print(__version__) import cufflinks as cv from plotly.offline import download_plotlyjs, init_notebook_mode, plot,iplot init_notebook_mode(connected=True) cv.go_offline() #pd.DataFrame(new_value).iplot(kind='surface',) import sys sys.setrecursionlimit(4000) #2000 print(sys.getrecursionlimit()) size = 500 width= 10 # Noise from sklearn.datasets import make_blobs import time from configs import * def CreateNoiseImage(input_image): global size global noise_matrix data = make_blobs(n_samples= 2800, n_features= 13, centers= 4, cluster_std =3, random_state=1) #plt.figure(figsize=(8,8)) #plt.scatter(data[0][:,0],data[0][:,1], c = data[1], cmap='rainbow') if size==1000: data1=(((data[0]-np.min(data[0]))/(np.max(data[0])-np.min(data[0])))*860).astype(int) elif size== 500: data1=(((data[0]-np.min(data[0]))/(np.max(data[0])-np.min(data[0])))*460).astype(int) data1[:,1] += 10 noise_matrix = -1*np.ones((size,size,3)) for i,j in data1[:,:2]: noise_matrix[j,i,:] = -5 import matplotlib.pyplot as plt """ im = plt.imread('../Images/img4.jpg')[:size,:size,:] #[:1000,:1000,:] # img4.jpg plt.figure(figsize=(10,10)) implot = plt.imshow(im) plt.scatter(data1[:,0],data1[:,1], c = data[1], cmap='rainbow') plt.axis('off') plt.savefig("../Images/img4_noise.jpg",bbox_inches='tight',transparent=True, pad_inches=0) plt.show() """ fig = plt.figure() im = input_image plt.figure(figsize=(10,10)) implot = plt.imshow(im) plt.scatter(data1[:,0],data1[:,1], c = data[1], cmap='rainbow') plt.axis('off') plt.savefig("../Images/img4_noise.jpg",bbox_inches='tight',transparent=True, pad_inches=0) plt.close() out_image = plt.imread("../Images/img4_noise.jpg") #plt.show() return out_image def Calculate_noise(img): global width global size mean_img = img.copy() img_transition_value = np.zeros((size//width,size//width)) for i in range(0,size,width): for j in range(0,size,width): # got all the points t = img[i:i+width,j:j+width,:] no_5 = (t==-5).sum() #pixel_value = np.max(img[i:i+width,j:j+width,:]) #if pixel_value==-5: # print(pixel_value) if no_5 <= 3: #200 didn't work mean_img[i:i+width,j:j+width,:] = 250 else: mean_img[i:i+width,j:j+width,:] = 0 #pixel_value #kernel = np.ones((5,5), np.uint8) #img_dilation = cv2.dilate(mean_img, kernel, iterations=1) img_dilation = mean_img.copy() img_transition_value=np.where(img_dilation<230,0,255) # 230 #cv2.imwrite("dilated_5_2.jpg",img_transition_value) # final image look BGR looks black and white img_transition_value=img_transition_value[::width,::width,0] img_transition_value=np.where(img_transition_value<120,-7,-1) # 230 return img_transition_value img = cv2.imread("../Images/img4.jpg")[:size,:size,:] #[:1000,:1000,:] def Calculate_transition_matrix(img): global noise_matrix global width global size global noise mean_img = img.copy() img_transition_value = np.zeros((size//width,size//width)) for i in range(0,size,width): for j in range(0,size,width): # got all the points pixel_value = np.mean(img[i:i+width,j:j+width,:]) if pixel_value >210: #200 didn't work mean_img[i:i+width,j:j+width,:] = 250 else: mean_img[i:i+width,j:j+width,:] = 0 #pixel_value #kernel = np.ones((5,5), np.uint8) #img_dilation = cv2.dilate(mean_img, kernel, iterations=1) img_dilation = mean_img.copy() img_transition_value=np.where(img_dilation<230,0,255) # 230 #cv2.imwrite("dilated_5_2.jpg",img_transition_value) # final image look BGR looks black and white img_transition_value=img_transition_value[::width,::width,0] img_transition_value=np.where(img_transition_value<120,-80,-1) # 230 ## noise #i1 = cv2.imread("noise1.PNG") #i1=cv2.resize(i1,(size,size)) #img_transition_value = np.minimum(i2,img_transition_value) if noise == True: i2=Calculate_noise(noise_matrix) img_transition_value = np.minimum(img_transition_value,i2 ) ## #print("final reward") #sns.heatmap(img_transition_value) #plt.show() return img_transition_value def Sweep(Value, Policy,terminators,transition_value): # create transition matrix globally that is not possible since we will create dynamic wall New_Value = Value.copy() delta = 0 x,y = Value.shape for i in range(x): # x left = 0 right = 0 top = 0 bottom = 0 for j in range(y): # y # (i,j) if (i,j) in terminators: pass else: same= Value[i,j] if i==0: left = same else: left = Value[i-1,j] if i==x-1: right= same else: right = Value[i+1,j] if j==0: top= same else: top = Value[i,j-1] if j==y-1: bottom= same else: bottom = Value[i ,j+1] # if (i,j) in red: # transition_reward = -10 # else: # transition_reward = -1 transition_reward = transition_value[i,j] total_value = Policy[(y)*i+j,0]*(transition_reward+left) + Policy[(y)*i+j,1]*(transition_reward+right) + Policy[(y)*i+j,2]*(transition_reward+top) + Policy[(y)*i+j,3]*(transition_reward+bottom) #print(total_value, New_Value[i,j]) delta = max(delta, np.abs(total_value- Value[i,j])) New_Value[i,j] = total_value #print("Sweep") return New_Value, delta def Improve_Policy(Value, Policy): New_Policy = Policy.copy() #terminators = (0,1), (0,2),(0,3), (2,0),(2,1),(2,2) x,y = Value.shape for i in range(x): for j in range(y): # y # (i,j) left = 0 right = 0 top = 0 bottom = 0 same= Value[i,j] if i==0: left = same else: left = Value[i-1,j] if i==x-1: right= same else: right = Value[i+1,j] if j==0: top= same else: top = Value[i,j-1] if j==y-1: bottom= same else: bottom = Value[i ,j+1] my_list = [left,right, top,bottom] max_val = max(my_list) my_list = np.array(my_list) my_list = (my_list==max_val).astype(int) my_list = my_list/np.sum(my_list) New_Policy[(y)*i+j,:] = my_list #print("Improve_Policy") return New_Policy call =0 def Evaluate_value(Value, Policy,theta,terminators,transition_value): Policy = Policy.copy() theta = theta terminators = terminators.copy() Policy = Policy.copy() global call call += 1 #terminators = (0,1), (0,2),(0,3), (2,0),(2,1),(2,2) delta = float(np.inf) while delta> theta: delta = 0 Value, delta = Sweep(Value, Policy, terminators,transition_value) #print(delta,theta, delta>theta) #>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> New_Policy = Improve_Policy(Value, Policy) if np.all(Policy==New_Policy): #print("Evaluate_value_") return Value, New_Policy, theta, terminators else: # repeat #print("Evaluate_value") return Evaluate_value(Value, New_Policy,theta, terminators,transition_value) def Calculate_optimal(Grid_shape,no_actions, terminators,img_mask): global img global find_optimal_CS global Charging_time_CS global static_quality_score global dynamic_quality_score global transition_value global actual_dynamic_overhead global actual_static_overhead # we can't add charging time before we calculate rem overhead x,y = Grid_shape State_action = np.ones((x*y,no_actions))*(1/no_actions) ####### L R T B Value = np.zeros((x,y)) theta = 0.1 #0.001 transition_value = Calculate_transition_matrix(img_mask) # for i,j in HOME: # transition_value[i,j] = 0 for no, (i,j) in enumerate(HOME): transition_value[i,j] = 0 if static_quality_score == True or dynamic_quality_score == True: if i != 0: # not touching left edge transition_value[i,j-1] = min(transition_value[i,j-1], -1*(actual_static_overhead[no]+actual_dynamic_overhead[no])-1) if i != 49: # not touching right edge transition_value[i,j+1] = min(transition_value[i,j+1], -1*(actual_static_overhead[no]+actual_dynamic_overhead[no])-1) if j != 0: # not touching top edge transition_value[i-1,j] = min(transition_value[i-1,j], -1*(actual_static_overhead[no]+actual_dynamic_overhead[no])-1) if j != 49: # not touching bottom edge transition_value[i+1,j] = min(transition_value[i+1,j], -1*(actual_static_overhead[no]+actual_dynamic_overhead[no])-1) # print("REWARD of each state:-") # sns.heatmap(transition_value) # plt.show() # Value[17,24] = 30 # terminators.append((17,24)) # print("terminators",terminators) #transition_value[25,25] = 1 #img[25*width-10-70:25*width+10-70,25*width-10:25*width+10,:] = 0 #Value[HOME] = 0 # No matter how low you make it (-4000) this will become optimal point because everywhere else value is calculated l,m,th,tr =Evaluate_value(Value,State_action,79, terminators, transition_value) #l:- value function m:- optimal action if find_optimal_CS == False and dynamic_quality_score== False: print('-'*40) print("calculating FUTURE REWARD of each state...") print("-"*40) print(l) print('FUTURE REWARD/Value Functions:-') # g2=sns.heatmap(l) # g2.tick_params(left=False) # remove the ticks #tick_params(left=False) # remove the ticks # plt.tight_layout() # plt.show() if dynamic_quality_score == False: f,(ax1,ax2) = plt.subplots(1,2,sharey=True,figsize=(18,6)) g1 = sns.heatmap(transition_value,ax=ax1) g1.set_ylabel('') g1.set_xlabel('') g2 = sns.heatmap(l,ax=ax2) g2.set_ylabel('') g2.set_xlabel('') plt.show() # layout1 = cv.Layout( # height=500, # width=500 # ) if static_quality_score == True and dynamic_quality_score == False: # 3d plot new_value = (l-np.min(l))/(np.max(l)-np.min(l)) pd.DataFrame(new_value).iplot(kind='surface',) # layout= layout1) #print("Calculate_optimal") # 80 for -100 , 9.5 for -10 , 100 for -1000 60 for -80 return l,m def recheck(x,y): global HOME global optimal_value global AGENT global dynamic_quality_score global actual_dynamic_overhead global actual_static_overhead global terminators global state global battery global Overhead_time_CS global Charging_time_CS global no_steps global stats_df index_no = HOME.index((x,y)) time_taken = -1* optimal_value[AGENT[0],AGENT[1]] rem_overhead = max(0,Overhead_time_CS[index_no] - time_taken) stats_df.loc[index_no,"CS_pos"] = str((x,y)) stats_df.loc[index_no,"travel_time"] = time_taken stats_df.loc[index_no, "rem_overhead"] = rem_overhead stats_df.loc[index_no, "total time"] = time_taken + rem_overhead + Charging_time_CS[index_no] if rem_overhead <= 0: # means none can be better than this cs. # stop #print(f"Overhead on the CS is {Overhead_time_CS[index_no]}") #print(f"Time taken to reach the CS is {time_taken}") #print(f"No of steps is {no_steps}") #print(f"Overhead on reaching CS {(x,y)} is: {rem_overhead} thus Total Time: {time_taken + rem_overhead}") print(stats_df) if battery == True: #print(f"REACHED_DEST [{x},{y}] in {no_steps} steps, time taken {-1*optimal_value[AGENT[0],AGENT[1]]} minutes") print(f"REACHED_DEST [{x},{y}] in {no_steps} steps, time taken {time_taken + rem_overhead + Charging_time_CS[index_no]} minutes") else: print(f"REACHED_DEST [{x},{y}] in {no_steps} steps, with reward of {optimal_value[AGENT[0],AGENT[1]]-rem_overhead-Charging_time_CS[index_no]}") print('-'*40) return else: # change transition matrix #print(f"Overhead on the CS is {Overhead_time_CS[index_no]}") #print(f"Time taken to reach the CS is {time_taken}") #print(f"No of steps is {no_steps}") #print(f"Overhead on reaching CS {(x,y)} is: {rem_overhead} thus Total Time: {time_taken + rem_overhead}") #print("Calculating...") print(stats_df) actual_dynamic_overhead[index_no] = rem_overhead actual_static_overhead[index_no] = Charging_time_CS[index_no] state = 112 """ Grid_shape = transition_matrix.shape no_actions = 4 optimal_value,optimal_policy = Calculate_optimal(Grid_shape,no_actions, terminators,img_mask) """ optimal_path = np.zeros((50,50)) collect_pts = [] def trace_path(optimal_value, optimal_policy,initial_pt): global optimal_path global width global collect_pts global dynamic_quality_score global Last_CS x,y = initial_pt # 48,25 if (x,y) in HOME: #== HOME: if dynamic_quality_score == True and (Last_CS != (x,y) or (x,y)== HOME[-1]): # we will check once again Last_CS = (x,y) recheck(x,y) else: # stop print("REACHED HOME") return if x<0 or x>= 50 or y<0 or y>= 50: # stop execution return # Plot a1 = width*y b1 = width*x a2 = width*y + width b2 = width*x + width # policy_index = x*50 + y l,r,t,b = optimal_policy[policy_index,:] max_index = (l,r,t,b).index(max(l,r,t,b)) # pick the first optimal index indexes = [i for i,j in enumerate((l,r,t,b)) if j==max(l,r,t,b)] max_index = random.choice(indexes) if max_index==0: # left #cv2.circle(img, ((a1+a2)//2,(b1+b2)//2),3,(0,250,0),2) #cv2.line(img,((a1+a2)//2,b1),((a1+a2)//2,b2), (0,0,0),3) trace_path(optimal_value, optimal_policy,(x-1,y)) optimal_path[x-1:x,y:y+1] += 1 elif max_index==1: # right #cv2.circle(img, ((a1+a2)//2,(b1+b2)//2),3,(0,250,0),2) #cv2.line(img,((a1+a2)//2,b1),((a1+a2)//2,b2), (0,0,0),3) trace_path(optimal_value, optimal_policy,(x,y+1)) optimal_path[x:x+1,y+1:y+2] += 1 elif max_index==2: # top #cv2.circle(img, ((a1+a2)//2,(b1+b2)//2),3,(0,250,0),2) #cv2.line(img,(a1,(b1+b2)//2),(a2,(b1+b2)//2), (0,0,0),3) trace_path(optimal_value, optimal_policy,(x,y-1)) optimal_path[x:x+1,y-1:y] += 1 elif max_index==3: # bottom #cv2.circle(img, ((a1+a2)//2,(b1+b2)//2),3,(0,250,0),2) #cv2.line(img,(a1,(b1+b2)//2),(a2,(b1+b2)//2), (0,0,0),3) trace_path(optimal_value, optimal_policy,(x,y+1)) optimal_path[x:x+1,y+1:y+2] += 1 else: print("ERROR") def draw_path(): global optimal_path global img global width global size print('calculating') Full_matrix = (np.repeat(np.repeat(optimal_path,width,axis=0),width,axis=1)*500).astype(int) img = ((np.clip((img - Full_matrix.reshape(size,size,1)).astype(int),0,255)).astype(int)).astype(np.uint8) def smart_trace(): #print('tracing path..') print("="*80) global optimal_value global optimal_policy global width global size global battery global dynamic_quality_score global actual_dynamic_overhead global Last_CS global no_checked_CS global no_steps global stats_df global Overhead_time_CS global HOME global Charging_time_CS if width == 20: w = 10 elif width == 10: w = 10 print("this is optimal pollicy") print(optimal_policy) T =np.argmax(optimal_policy, axis=1) x_dict = {0:-1,1:1,2:0,3:0} y_dict = {0:0,1:0,2:-1,3:1} x_axis=np.vectorize(x_dict.get)(T) y_axis=np.vectorize(y_dict.get)(T) #f_x ,f_y = HOME in_x, in_y = AGENT no_steps = 0 if width == 20: r = 2 elif width == 10: r = 3 while (in_x,in_y) not in HOME: #in_x != f_x or in_y != f_y: no_steps += 1 m = w*in_x l = w*in_y cv2.circle(img, ((2*l+w)//2,(2*m+w)//2),r,(0,255,0),5) new_loc = 50*in_x + in_y in_x += x_axis[new_loc] in_y += y_axis[new_loc] #print("action",x_axis[new_loc],y_axis[new_loc]) #print("reached",in_x,in_y) if l<0 or l>999 or m <0 or m>999: print('Not found',(2*l + w),(2*m + w)) return x,y = in_x, in_y # 48,25 if (x,y) in HOME: #== HOME: if dynamic_quality_score == True and (Last_CS != (x,y)) and no_checked_CS != len(actual_dynamic_overhead): # we will check once again no_checked_CS += 1 Last_CS = (x,y) recheck(x,y) else: # stop rem_overhead = 0 Charge_t = 0 if dynamic_quality_score == True: index_no = HOME.index((x,y)) time_taken = -1* optimal_value[AGENT[0],AGENT[1]] rem_overhead = max(0,Overhead_time_CS[index_no] - time_taken) stats_df.loc[index_no,"CS_pos"] = str((x,y)) stats_df.loc[index_no,"travel_time"] = time_taken stats_df.loc[index_no, "rem_overhead"] = rem_overhead stats_df.loc[index_no, "total time"] = time_taken + rem_overhead + Charging_time_CS[index_no] Charge_t = Charging_time_CS[index_no] print(stats_df) if battery == True: print(f"REACHED_DEST [{in_x},{in_y}] in {no_steps} steps, time taken {-1*optimal_value[AGENT[0],AGENT[1]]+rem_overhead+Charge_t} minutes") else: print(f"REACHED_DEST [{in_x},{in_y}] in {no_steps} steps, with reward of {optimal_value[AGENT[0],AGENT[1]]-rem_overhead-Charge_t}") print('-'*40) return def Calculate_Cost(index): global drag global state global HOME global AGENT global optimal_value global img global Grid_shape global no_action global terminators global optimal_path global width global size global optimal_policy global time_limit img_mask = cv2.imread("img4.jpg")[:size,:size,:] terminators = [(index[0],index[1])] HOME = terminators v,p= Calculate_optimal(Grid_shape,no_actions, terminators,img_mask) return v,p def Optimize_CS(): global non_path_reward #-80 global tile_size List_indices = [] List_costs = [] img_mask = cv2.imread("img4.jpg")[:size,:size,:] transition_value = Calculate_transition_matrix(img_mask) """ HOME = [(3,3)] for i,j in HOME: transition_value[i,j] = 0 """ mask = transition_value> non_path_reward+2 #print(np.where(mask==1)) # pick tile_size which can divide 50 like 10/50/2 etc no_subcell = 50//tile_size for i in range(0,no_subcell): for j in range(0,no_subcell): # (i,j) # pick su x,y = np.where(mask[i*tile_size: i*tile_size+tile_size, j*tile_size: j*tile_size+tile_size]) x = (i*tile_size) + x y = (j*tile_size) + y my_list = list(zip(x,y)) if my_list == []: print("no road here") else: print(my_list) length = len(my_list) if length %2 != 0: # odd no of terms middle = my_list[(length-1)//2] else: # even no of terms middle = my_list[(length//2) -1] temp_transition_value = (transition_value[i*tile_size: i*tile_size+tile_size, j*tile_size: j*tile_size+tile_size]).copy() print(f"Calculating cost for {middle}") temp_transition_value[middle[0]-(i*tile_size),middle[1]-(j*tile_size)] = 10 plt.figure(figsize=(3,2)) sns.heatmap(temp_transition_value) plt.show() List_indices.append(middle) v,p = Calculate_Cost(middle) cost = np.sum(v[mask]) List_costs.append(cost) #print(np.random.choice(my_list, size=8)) print(middle,"=",cost) print("#"*80) print(List_indices) print("+"*40) print(List_costs) print("+"*40) print("Optimal CS location") print(List_indices[List_costs.index(max(List_costs))], max(List_costs)) Calculate_Cost(List_indices[List_costs.index(max(List_costs))]) return [List_indices[List_costs.index(max(List_costs))]] def draw(event, x, y, flag, param): global drag global state global HOME global AGENT global optimal_value global img global Grid_shape global no_action global terminators global optimal_path global width global size global optimal_policy global find_optimal_CS global Last_CS global count if width == 20: # big rectangle w = 10 elif width == 10: w = 10 if event == cv2.EVENT_FLAG_LBUTTON: drag = True if event == cv2.EVENT_LBUTTONUP: drag=False #cv2.circle(img, (x,y),20,(0,0,0),3) if state == 111: """ AGENT = [y//w, x//w] print("AGENT location") print(AGENT) cv2.rectangle(img, (x+w,y-w),(x-w, y+w), (250,0,0),3 ) smart_trace() state=3 """ #- if demo== True: x = AGENT[1]*w y = AGENT[0]*w else: AGENT = [y//w, x//w] #- print("AGENT location") print(AGENT) cv2.rectangle(img, (x+w,y-w),(x-w, y+w), (250,0,0),3 ) # Limit Battery t = optimal_value[AGENT[0],AGENT[1]] if t< -1*time_limit and battery == True: print(f"Nearest Charging station is at {-1*t} second distance") print('*'*80) else: smart_trace() state=3 if state == 0: if find_optimal_CS == True: HOME= Optimize_CS()[::-1] x = HOME[0][1]*w y = HOME[0][0]*w find_optimal_CS = False else: #- if demo == True: temp = HOME[count][0]*w, HOME[count][1]*w x = HOME[count][1]*w y = HOME[count][0]*w count += 1 else: temp = (y//w,x//w) HOME.append(temp) print("CS locations") print(HOME) cv2.rectangle(img, (x+w,y-w),(x-w,y+w),(0,0,250),3) #state =1 elif state == 1: # draw car if demo== True: x = AGENT[1]*w y = AGENT[0]*w else: AGENT = [y//w, x//w] #- print("AGENT location") print(AGENT) cv2.rectangle(img, (x+w,y-w),(x-w,y+w),(250,0,0),3) #state = 2 elif state == 2: state = 3 # show color terminators = HOME #print("terminating locations") #print(terminators) img_mask = cv2.imread("../Images/img4.jpg")[:size,:size,:] #[:1000,:1000,:] # img4.jpg # this is the fresh copy not affected by any thing #print() #print("Calculating...") optimal_value,optimal_policy = Calculate_optimal(Grid_shape,no_actions, terminators,img_mask) l,m = optimal_value.shape # (100,100) #img[HOME[0]*10:HOME[0]*10+10,HOME[1]*10:HOME[0]*10+10,:] = (255,0,0) it is just to verify that we are indeed at right location # Method1 # Limit Battery t = optimal_value[AGENT[0],AGENT[1]] if t< -1*time_limit and battery == True: print(f"Nearest Charging station is at {-1*t} second distance") print('*'*80) else: smart_trace() #smart_trace() #plt.figure(figsize=(8,3), dpi=80) # sns.heatmap(optimal_value) # g2=sns.heatmap(optimal_value) # g2.tick_params(left=False) # remove the ticks #tick_params(left=False) # remove the ticks # plt.tight_layout() # plt.show() # Method2 """ trace_path(optimal_value,optimal_policy,AGENT) draw_path() f, axes = plt.subplots(1, 2) sns.heatmap( data=optimal_value, ax=axes[0]) sns.heatmap( data=optimal_path, ax=axes[1]) """ elif state == 3: #start game pass elif state == 4: #print("CAlled state 4") # # New map img state=5 if dynamic_quality_score == True: img_mask = cv2.imread("../Images/img4.jpg")[:size,:size,:] img = img_mask.copy() else: img_mask = img.copy() # img4.jpg # this is the fresh copy not affected by any thing for H in HOME: cv2.rectangle(img, (H[1]*w+w,H[0]*w-w),(H[1]*w-w,H[0]*w+w),(0,0,250),3) cv2.rectangle(img, (AGENT[1]*w+w,AGENT[0]*w-w),(AGENT[1]*w-w,AGENT[0]*w+w),(250,0,0),3) #print() #print("Calculating...") optimal_value,optimal_policy = Calculate_optimal(Grid_shape,no_actions, terminators,img_mask) l,m = optimal_value.shape # (100,100) # Method1 # Limit Battery t = optimal_value[AGENT[0],AGENT[1]] if t< -1*time_limit and battery == True: print(f"Nearest Charging station is at {-1*t} second distance") print('*'*80) else: smart_trace() #smart_trace() #plt.figure(figsize=(8,3), dpi=80) # g2=sns.heatmap(optimal_value) # g2.tick_params(left=False) # remove the ticks # plt.tight_layout() # plt.show() # Method2 [it was making linear search which was computationally heavy] """ #trace_path(optimal_value,optimal_policy,AGENT) #img[HOME[0]*10:HOME[0]*10+10,HOME[1]*10:HOME[0]*10+10,:] = (255,0,0) it is just to verify that we are indeed at right location #draw_path() #f, axes = plt.subplots(1, 2) #sns.heatmap( data=optimal_value, ax=axes[0]) #sns.heatmap( data=optimal_path, ax=axes[1]) """ if event == cv2.EVENT_MOUSEMOVE: if drag ==True: #state=4 cv2.circle(img, (x,y),5,(0,0,0),15) #cv2.circle(img, (x,y),2,(0,0,0),4) if state == 4 and dynamic_quality_score == True: # # New map img print("NEXT-->") state=5 if dynamic_quality_score == True: img_mask = cv2.imread("../Images/img4.jpg")[:size,:size,:] img = img_mask.copy() else: img_mask = img.copy() # img4.jpg # this is the fresh copy not affected by any thing for H in HOME: cv2.rectangle(img, (H[1]*w+w,H[0]*w-w),(H[1]*w-w,H[0]*w+w),(0,0,250),3) cv2.rectangle(img, (AGENT[1]*w+w,AGENT[0]*w-w),(AGENT[1]*w-w,AGENT[0]*w+w),(250,0,0),3) #print() #print("Calculating...") optimal_value,optimal_policy = Calculate_optimal(Grid_shape,no_actions, terminators,img_mask) l,m = optimal_value.shape # (100,100) # Method1 # Limit Battery t = optimal_value[AGENT[0],AGENT[1]] if t< -1*time_limit and battery == True: print(f"Nearest Charging station is at {-1*t} second distance") print('*'*80) else: smart_trace()

File no 6: /README.md
EV-Enrouting Find optimal path for electric vehicle using spatial information. Preprocessing :- Our algorithm solves 3 main problems: Finding Best Route Finding Optimal Location to setup a Charging Station Dealing with Overhead on Charging Stations Below we will see demo of these:- 1.Finding Best Route: a) Base problem Our algorithm gives us the best route which will take the shortest path out of all the available charging stations. b) Now with traffic data The benefit of this grid approach over graph approach is that we can very easily put layers of information on top and our algorithm will work fine. Like here we have added traffic information on top of it. c) With remaining battery We can also pass the information about available battery power and it will tell us if there is any charging station within our battery limit. We have given remaining battery of 100 minutes and now we see that many times it is not showing us any path because it is out of range of 100 minutes. Let's look at details of how it is working:- 2.Finding Optimal Location to setup a Charging Station: Finding the optimal location to set up a charging station is very tricky and we have to look at various factors, like where there is more demand and which is geographically the most feasible location from all places. So to solve this we applied three approaches. a) Brute force approach b) Sliding Window Technique c) Subblocks Technique a) In brute force approach we calculated total return by putting CS at each point of grid (50*50) and the point corresponding to maximum total return is the optimal point. b) In sliding window we took a window of 10*10 and moved over this 50*50 matrix. c) In Sub-blocks Technique we divided our whole grid into 4 sub grids (upper left, upper right, lower left, lower right). Then we calculated the return of the median point for each sub grid. We repeat the same for subgrid with max total return. [Optimality] Brute Force Approach >> Sliding Window Technique >> Sub-blocks method [Speed] Sub-blocks method >> Sliding Window Technique >> Brute Force Approach (So there is tradeoff between Speed and Optimality) Sliding Window Techniqe Sliding Window with traffic note: we see that due to traffic the optimal charging station position has changed, which makes sense. 3.Overhead on Charging stations: For this I have defined two types of overhead on the charging stations. a) Dynamic overhead b) Static Overhead Dynamic Overhead tells how many cars are there in the queue, i.e. if we reach the Charging station now then after how much time we will get the turn. Static Overhead tells about on an average when a vehicle is plugged in for charging how much time it takes to get fully charged. Together these two help us find a charging station which is best for us at that current moment. [case1] : only Static Overhead Charging Station Static Overhead travel time total time Cs1 50 20 70 Cs2 10 28 38 Cs3 5 38 43 So our algorithm will choose Cs2 >> Cs3 >> Cs1 Let’s verify below. [case2] : both Dynamic and Static Overhead Charging Station Dynamic Overhead travel time remaining overhead:- max(0, Dynamic_overhead-travel_time) Static Overhead Total Overhead:- rem_overhead + static_overhead Total time (total_overhead + travel_time Cs1 40 20 20 50 70 90 Cs2 48 28 20 10 30 58 Cs3 27 38 0 5 5 43 So our algorithm will choose Cs3 >> Cs2 >> Cs1 [ In this I have applied greedy search which allows us to find optimal CS without the need of calculating travel_time of each and every CS] note: Greedy Search in our case gives optimal solution, details of this method can be found in the report Theory Theory Notebook link: https://colab.research.google.com/drive/1zSd24UZs3tKTVcDbJ61VH8CpsZ8QZA8d?usp=sharing Go You can’t perform that action at this time.

3: Project Name : Framework3
This project contains 43 main files, namely /resources/temp.py, /src-framework3/auto_exp.py, /src-framework3/auto_feat.py, /src-framework3/create_folds.py, /src-framework3/create_folds_again.py, /src-framework3/custom_classes.py, /src-framework3/custom_models.py, /src-framework3/datasets_create.py, /src-framework3/datasets_init.py, /src-framework3/dummy_exp.py, /src-framework3/ensemble.py, /src-framework3/exp_infos.txt, /src-framework3/experiment.py, /src-framework3/feature_generator.py, /src-framework3/feature_picker.py, /src-framework3/find_roots.py, /src-framework3/global_variables.py, /src-framework3/grab.py, /src-framework3/info.txt, /src-framework3/keys.py, /src-framework3/metrics.py, /src-framework3/model_dispatcher.py, /src-framework3/optuna_search.py, /src-framework3/output.py, /src-framework3/predict.py, /src-framework3/preprocess.py, /src-framework3/pull.py, /src-framework3/push.py, /src-framework3/ref.txt, /src-framework3/removed_dup_in_dict.py, /src-framework3/requirements.txt, /src-framework3/run.sh, /src-framework3/seed_it.py, /src-framework3/settings.py, /src-framework3/show_importance.py, /src-framework3/show_input.py, /src-framework3/show_table.py, /src-framework3/split_input.py, /src-framework3/submit.py, /src-framework3/submit_one.py, /src-framework3/update_table.py, /src-framework3/utils.py, /README.md
Below we will get details about each of these files one by one:
	
File no 1: /resources/temp.py


File no 2: /src-framework3/auto_exp.py
import random import numpy as np import pandas as pd import time import os import gc # import quantumrandom import ast # for literal import tensorflow as tf import pickle from datetime import datetime from utils import * from feature_picker import * from experiment import * from settings import * def make_selection_prep(my_list, shuffle=True, random_state=24): # The first thing we do is set random state to make it reproducible: fix_random(random_state) # finds all possible SELECTION possible # col_list = ["f_00","f_01","f_02","f_05"] new_list = [] for i in range(2 ** len(my_list)): val = int(bin(i)[2:]) temp_list = [] counter = 1 while val != 0: if val % 10 == 1: # take it temp_list.append(my_list[-counter]) val = val // 10 counter += 1 new_list.append(temp_list) ch = random.choice(new_list) if shuffle == True: random.shuffle(ch) return ch # for list of list we must append each other but that is a manual task def make_selection(my_list, shuffle=True, random_state=24): print("start-->") # The first thing we do is set random state to make it reproducible: fix_random(random_state) # finds all possible SELECTION possible # col_list = ["f_00","f_01","f_02","f_05"] i = random.randint(0,2 ** len(my_list)) val = int(bin(i)[2:]) temp_list = [] counter = 1 while val != 0: if val % 10 == 1: # take it temp_list.append(my_list[-counter]) val = val // 10 counter += 1 ch = temp_list if shuffle == True: random.shuffle(ch) print("done-->") return ch # for list of list we must append each other but that is a manual task def generate_random_no(adder="--|--"): # makes sure each time we are at differnet random state # random_state should only be used for reproducibility and should not give a better model seed = int(datetime.now().strftime("%H%M%S")) # seed selected based on current time if adder != "--|--": seed += adder # datetime can't give new no in vicinity of fraction of seconds so introducing this adder os.environ["PYTHONHASHSEED"] = str(seed) np.random.seed(seed) random.seed(seed) tf.random.set_seed( seed ) # f"The truth value of a {type(self).__name__} is ambiguous. " return seed # np.random.randint(3, 1000) # it should return 5 def sanity_check(table, *rest): global counter counter += 1 for index, row in table.iterrows(): row = row.values # row assert len(rest) == len(row[1:]) same = True for i,(val1, val2) in enumerate(zip(rest, row[1:])): # i=5 optimize_on [0,2] special case #print(i, val1, val2) #best way to check if allow duplicates if not isinstance(val1, list): if val1 != val2: # "fold5" "fold10" same = False break if isinstance(val1, list) and i != 5: # list of lenght 2 # val2 is a list inform of string '[10,0]' but not '[10]' val2 = ast.literal_eval(val2) # val2 = val2[1:-1].split(',') # it is a list if val1[1] == 1: # order matters if val1[0] != val2: same = False break else: # order don't matter set1 = set(val1[0]) set2 = set(val2) if set1 != set2: same = False break # elif i == 5: # # if this elif is not written then it will consider all different optimize on duplicate # # it is optimize on # val2 = ast.literal_eval(val2) # if val1 != val2: # same = False # break if same == True: # duplicate print(row, "found in table") return True return False def auto_select(): with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() if comp_name == "amex": amex = amex_settings() elif comp_name == "amex2": amex = amex2_settings() elif comp_name == "amex3": amex = amex3_settings() elif comp_name == "amex4": amex = amex4_settings() elif comp_name == "getaroom": amex = getaroom_settings() else: raise Exception(f"comp name {comp_name} not valid") # ============================================================= # Features # # ============================================================== # seed it Fix random no for this auto_exp random_no = ( true_random(100) ) # never gives same random value quite random done to bring variabiligy # random_no = 111 # ============================================================ # each set must have a name in features for better visualisation # auto_features = ['ragnar'] # clean_features = amex.feature_dict2['ragnar'] """ auto_features = [] clean_features = [] v = list(amex.feature_dict2.keys()) auto_features = make_selection(v, shuffle=False, random_state=random_no) #amex.feature_keys #auto_features2 = random.choice([[random.choice(v)], []]) # f_base should always be there # # # deal with empty list while auto_features == []: print("features empty!!") #============================================================ # seed it random_no = (true_random(100)) #random_no = 111 #============================================================ auto_features = make_selection(v, shuffle=False, random_state = random_no) print() print(auto_features) print() # #------------------------------------------------ # for list of list we must append each other but that is a manual task #auto_features = ['ragnar', 'date_filter', 'cat_last_interact'] auto_features = ['ragnar' ]#, 'cat_last_interact'] """ #auto_features.append(random.choice( list(amex.feature_dict2.keys()) )) auto_features = random.choices( list(amex.feature_dict.keys())) clean_features = [] for f in auto_features: clean_features += amex.feature_dict[f] #clean_features += amex.filter_feature[auto_features[0]] #clean_features += amex.feature_dict2[auto_features[1]] # auto_features2 = ['filter4', 'filter5', 'filter6'] # for f in auto_features2: # clean_features += amex.filter_feature[f] # #clean_features += amex.feature_dict2[f] # auto_features += auto_features2 auto_features = list(set(auto_features)) clean_features = list(set(clean_features)) #------------------------------------------------- auto_features2 = random.choices( list(amex.filtered_features.keys())) clean_features2 = [] for f in auto_features2: clean_features2 += amex.filtered_features[f] #clean_features += amex.filter_feature[auto_features[0]] #clean_features += amex.feature_dict2[auto_features[1]] # auto_features2 = ['filter4', 'filter5', 'filter6'] # for f in auto_features2: # clean_features += amex.filter_feature[f] # #clean_features += amex.feature_dict2[f] # auto_features += auto_features2 auto_features2 = list(set(auto_features2)) clean_features2 = list(set(clean_features2)) auto_features = list(set(auto_features + auto_features2)) clean_features = list(set(clean_features + clean_features2)) # if len(clean_features) > 2000: # # cut it # fix_random(random_no) # clean_features = random.choices(clean_features, k=2000) # auto_features.append('trim') # print(len(clean_features),"no of features") # ------------------------------------------------------ print("seed:", random_no) print() # ============================================================= # prep_list # # ===================================-=========================== #auto_prep = make_selection_prep(amex.prep_list, shuffle=True, random_state=random_no) auto_prep = ["Mi", "Ro", "Sd", "Lg"] fix_random(random_no) auto_prep = random.choice(auto_prep) auto_prep= random.choice([[auto_prep], [], []]) # move prep towards empty since gives better performance #auto_prep = [] print("Preprocessing:") print(auto_prep) print() # ============================================================= # optimize_on # # ============================================================== # The first thing we do is set random state to make it reproducible: fix_random(random_no) fold_name = random.choice([i for i in ['fold3', 'fold5']]) #amex.fold_list]) # fold20 too much folds # fold5: then train on 80% data, fold3: then train on 66% data fold_name = "fold5" #fold_name = random.choice(["fold10", fold_name]) # move towards "fold10" #fold_name = random.choice(["fold3", "fold5"]) #random.choice([i for i in amex.fold_list]) #fold_name = "fold10" # fold_name : "fold3" fold_nos = [i for i in range(int(fold_name.split("d")[1]))] # fold_nos = [0,1,2] # for now let's pick only one [1] fix_random(random_no) optimize_on = [random.choice(fold_nos)] # [0,2] # optimize_on = make_selection(fold_nos, shuffle=False, random_state=random_no) # while optimize_on == [] or len(optimize_on) == len(fold_nos): # don't optimize on all folds or empty # optimize_on = make_selection(fold_nos, shuffle=False, random_state=random_no) print("optimizing on fold name:") print(fold_name) print() print("optimizing on fold:") print(optimize_on) print() # # The first thing we do is set random state to make it reproducible: # fix_random(random_no) # optimize_on = random.choice([i for i in range(locker["no_folds"])]) # print("optimizing on fold:") # print(optimize_on) # print() # ============================================================== print(auto_features, auto_prep, fold_name, optimize_on,"Is it duplicate") return clean_features,auto_features, auto_prep, fold_name, optimize_on # ================================================ def custom_select(exp_no, model_name): with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() # ================================================ # Selecting Features # ================================================ #amex = amex_settings() if comp_name == "amex": amex = amex_settings() elif comp_name == "amex2": amex = amex2_settings() elif comp_name == "amex3": amex = amex3_settings() else: raise Exception(f"comp name {comp_name}not valid") # ============================================================= # Features # # ============================================================== # no need to seed try: #input("Work on this part model name not defined") #model_name = input("Model Name: ") #print(f"../configs/configs-{comp_name}/auto_exp_tables/auto_exp_table_{model_name}.csv") auto_exp_table = pd.read_csv(f"../configs/configs-{comp_name}/auto_exp_tables/auto_exp_table_{model_name}.csv") assert auto_exp_table.model_name.values[0] == model_name except: raise Exception("There must be an auto_exp_table else we can't custom train!") # model_name feature_names prep_list fold_name optimize_on with_gpu #.feature_names[exp_no] # works when index and exp no same so will work only for Table since it captures all exp feature_names = ast.literal_eval(auto_exp_table[auto_exp_table.exp_no == exp_no].feature_names.values[0]) prep_list = ast.literal_eval(auto_exp_table[auto_exp_table.exp_no == exp_no].prep_list.values[0]) fold_name = auto_exp_table[auto_exp_table.exp_no == exp_no].fold_name.values[0] optimize_on = ast.literal_eval(auto_exp_table[auto_exp_table.exp_no == exp_no].optimize_on.values[0]) print("Retrieved:=>") print(feature_names, prep_list, fold_name, optimize_on) #====================================================================== #amex = amex_settings() clean_features = [] for f in feature_names: clean_features += amex.feature_dict[f] auto_prep = prep_list return clean_features, feature_names, auto_prep, fold_name, optimize_on def RUN_EXP(exp_no="--|--"): global no_exp, repeat, counter with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() # ================================================ # Selecting Features # ================================================ locker = load_pickle(f"../configs/configs-{comp_name}/locker.pkl") current_dict = load_pickle( f"../configs/configs-{locker['comp_name']}/current_dict.pkl" ) e_no = current_dict["current_exp_no"] print("Current Exp No :", e_no) print() # ================================================ # Running # ================================================ #model_name = "lgb" #"xgb" model_name = random.choice(["xgbr", "cbr", "gbmr", "rfr"]) model_name = "k1" comp_type = "regression" metrics_name = "getaroom_metrics" n_trials = 5 # we change this when there is great change in parameter set like , optimized on different parameter range with_gpu = True aug_type = "aug2" _dataset = "DigitRecognizerDataset" use_cutmix = False if exp_no != "--|--": note = f"repeat_exp_{exp_no}_with_{n_trials}_trials" else: note = f"Leap_" # ================================================ # ================================================ # ================================================ # Get Settings # ================================================ if exp_no != "--|--": # it's custom clean_features, auto_features, auto_prep, fold_name, optimize_on = custom_select(exp_no, model_name) print("Old Exp No :", exp_no) else: clean_features, auto_features, auto_prep, fold_name, optimize_on = auto_select() # e = Agent( # useful_features=clean_features, # model_name=model_name, # comp_type=comp_type, # metrics_name=metrics_name, # n_trials=n_trials, # prep_list=auto_prep, # fold_name = fold_name, # optimize_on=optimize_on, # with_gpu=with_gpu, # aug_type=aug_type, # _dataset=_dataset, # use_cutmix=use_cutmix, # note=note, # ) # Sanity check have we done the same experiment before: # What things to check: # 1> clean_features [order don't matter] # 2> model_name # 3> prep_list [order matters] # 4> optimize_on # each set must have a name in features for better visualisation # Table already created: Table = pd.DataFrame(columns=['exp_no','model_name','feature_names','prep_list',"optimize_on"]) try: auto_exp_table = pd.read_csv( f"../configs/configs-{comp_name}/auto_exp_tables/auto_exp_table_{model_name}.csv" ) except: print("Creating Table:") auto_exp_table = pd.DataFrame( columns=[ "exp_no", "n_trials", "model_name", "feature_names", "prep_list", "fold_name", "optimize_on", "with_gpu", ] ) auto_exp_table["exp_no"] = auto_exp_table["exp_no"].astype(int) #auto_exp_table["optimize_on"] = auto_exp_table["optimize_on"].astype(int) if not sanity_check( auto_exp_table, n_trials, model_name, [auto_features, 0], [auto_prep, 1], fold_name, optimize_on, with_gpu, ): # true means auto_exp_table.loc[auto_exp_table.shape[0], :] = [ int(e_no), n_trials, model_name, auto_features, auto_prep, fold_name, optimize_on, with_gpu, ] auto_exp_table["exp_no"] = auto_exp_table["exp_no"].astype(int) auto_exp_table["n_trials"] = auto_exp_table["n_trials"].astype(int) #auto_exp_table["optimize_on"] = auto_exp_table["optimize_on"].astype(int) print() print(auto_exp_table) e = Agent( useful_features=clean_features, model_name=model_name, comp_type=comp_type, metrics_name=metrics_name, n_trials=n_trials, prep_list=auto_prep, fold_name = fold_name, optimize_on=optimize_on, with_gpu=with_gpu, aug_type=aug_type, _dataset=_dataset, use_cutmix=use_cutmix, note=note, ) print("=" * 40) print("Useful_features:", clean_features) # critical part e.run() counter = 0 # resetting auto_exp_table.to_csv( f"../configs/configs-{comp_name}/auto_exp_tables/auto_exp_table_{model_name}.csv", index=False ) del e gc.collect() # Make prediction also os.system(f"python predict.py") return True else: print("Duplicate SET found!!!") if counter > 100: raise Exception("Too many times duplicte found ") no_exp += 1 #del e # already delted gc.collect() return False def Timer(rem_time, expected_time, exp_type, repeat): """ rem_time = 12 * 60 * 60 # Run it for 3 hours expected_time = 1 * 60 * 60 exp_type = "custom" # "auto" repeat = [261, 215] """ current = 0 no_exp = len(repeat) time_list = [] while (exp_type == "auto" and rem_time >= expected_time) or (exp_type == "custom" and current < no_exp): print("%" * 40) start_time = time.time() # ============================================ if exp_type == "custom": val = repeat[current] else: val = "--|--" #============================================= if RUN_EXP(val): # ============================================ end_time = time.time() rem_time -= end_time - start_time time_list.append(end_time - start_time) expected_time = np.max(time_list) # taking upper bound print(f"Experiment Done in {end_time- start_time} seconds") print("Rem Time:", rem_time) print("Expected Time:", expected_time) for i in range(5): print() else: print("=" * 40) print("Sanity Check Failed!, Trying again") print("=" * 40) current += 1 gc.collect() # break # #================================================ # # Saving # #================================================ # # # version data # from datetime import datetime # version_name = datetime.now().strftime("%Y%m%d-%H%M%S") # version_name += "_fresh" # print(f"Versioning at {version_name}") # # # configs # os.system(f"kaggle datasets version -m {version_name} -p /kaggle/configs/configs-{comp_name}/") # # # models # # #!kaggle datasets version -m {version_name} -p /kaggle/models/models-{comp_name}/ -r zip -q # # # src # # #!kaggle datasets version -m {version_name} -p /kaggle/src-{framework_name}/ no_exp = 0 passed = 0 counter = 0 if __name__ == "__main__": rem_time = 10 * 60 * 60 # Run it for 3 hours expected_time = 0.0001 * 60 * 60 # expected one hour to finish one exp_type ="auto" # "auto" # "auto" "custom" repeat = [284, 277, 278, 279, 282] Timer(rem_time, expected_time, exp_type, repeat) # lgbmc f_base, f_max, f_min, f_avg, f_last [] fold20 optimize_on 15 with_gpu = True

File no 3: /src-framework3/auto_feat.py
from optuna_search import OptunaOptimizer from feature_generator import features from feature_picker import Picker import os import sys import gc import pickle import pandas as pd import tracemalloc # from custom_models import UModel # from custom_models import * from utils import * from settings import * from experiment import Agent from show_importance import Importance if __name__ == "__main__": while True: """ # Feature selection process Starts """ with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() Table = load_pickle(f"../configs/configs-{comp_name}/Table.pkl") last_exp_no = -1 if last_exp_no == -1: row_e = Table[Table.exp_no == list(Table.exp_no.values)[-1]] last_exp_no = row_e.exp_no.values[0] else: row_e = Table[Table.exp_no == last_exp_no] # we get exp no of the latest experiment auto_feat_dict = load_json(f"../configs/configs-{comp_name}/auto_feat.json") print(last_exp_no) useful_features = auto_feat_dict[str(last_exp_no)] #useful_features += amzcomp1_settings().feature_dict["ver2"] useful_features = list(set(useful_features)) """ # Feature selection process Ends """ # ========================================================== model_name = "xgbr" # -----s---> """ [ "lgr", "lir", "xgb", "xgbc", "xgbr", "cbc", "cbr", "mlpc", "rg", "ls", "knnc", "dtc", "adbc", "gbmc" , "gbmr, "hgbc", "lgb", "lgbmc", "lgbmr", "rfc" , "rfr", # --------------->["k1", "k2", "k3", "tez1", "tez2", "p1" ,"pretrained"] """ comp_type = ( "2class" # -------->["regression", "2class","multi_class", "multi_label"] ) metrics_name = "amzcomp1_metrics" # --------->["getaroom_metrics", "amex_metric","amex_metric_mod", "accuracy","f1","recall","precision", "auc", "logloss","auc_tf","mae","mse","rmse","msle","rmsle","r2"] n_trials = 20 #30 # ------------> no of times to run optuna prep_list = [ "Sd", ] # ------> ["SiMe", "SiMd",~ "SiMo", "Mi", "Ro", "Sd", "Lg"] <= _prep_list prep_list = [] fold_name = "fold5" # ['fold3', 'fold5', 'fold10', 'fold20'] optimize_on = [random.choice(range(5))] #[4] # fold on which optimize # 0,1,2,4 with_gpu = True aug_type = "aug2" # "aug1", "aug2", "aug3", "aug4" _dataset = "DigitRecognizerDataset" # "BengaliDataset", "ImageDataset", "DigitRecognizerDataset", "DigitRecognizerDatasetTez2" use_cutmix = False # CALLBACKS # lgbmClassifiers callback: # https://lightgbm.readthedocs.io/en/latest/Python-API.html#callbacks """ ############################ change learning rate custom schedulers :=>cosine_decay , exponential_decay, simple_decay built in scheduler :=>"ReduceLROnPlateau" # EarlyStopping, ############################# save model :=>chk_pt : whether to use checkpoint or not ############################### stop training :=>terminate_on_NaN >Callbacks monitor a particular varaibable and stops exectuion when it crosses fixed value , >early_top also monitors a particular value but it stops when it stops improving it has some patience builtin callback :=>early_stopping custom callback :=>myCallback1 """ # don't use early_stopping with cyclic decay lr because model gets good and bad periodically and it doesn't mean we should terminate. # "swa", "cosine_decay", "exponential_decay", "simple_decay", "ReduceLROnPlateau", "chk_pt", "terminate_on_NaN", "early_stopping", "myCallback1" callbacks_list = ["terminate_on_NaN"] # ["exponential_decay", "terminate_on_NaN"] # [swa,early_stop] # ----------------------------------------------------------- note = "ragnar" e = Agent( useful_features=useful_features, model_name=model_name, comp_type=comp_type, metrics_name=metrics_name, n_trials=n_trials, prep_list=prep_list, fold_name = fold_name, optimize_on=optimize_on, with_gpu=with_gpu, aug_type=aug_type, _dataset=_dataset, use_cutmix=use_cutmix, callbacks_list=callbacks_list, note=note, ) print("=" * 40) print("Useful_features:", useful_features) e.run() del e # ------------------------------------------------------------- # exp_list = ["1"] # ----------------> [1,2,3,4] # e.show(exp_list) """ {'learning_rate': 0.010821262164314453, 'max_depth': 16, 'min_child_weight': 5, 'subsample': 0.4521783648128741, 'n_estimators': 500, 'objective': 'reg:squarederror', 'tree_method': 'gpu_hist', 'gpu_id': 0, 'predictor': 'gpu_predictor'} """ # Make prediction also os.system(f"python predict.py") # Let's save auto features direction = "minimize" technique = "bagging" # "weighted_mean" , "best" , "mean", "top50", "bagging" last_exp_no += 1 f = Importance(exp_no=last_exp_no) # helps when doing weighted mean base_features = None type_importance = "fold" #"fold", "opt" pick = None # pick top 2 trials out of 5 top = None threshold = 1 #f.show(technique= technique, top=top, threshold=threshold, direction=direction, pick = pick, type_importance= type_importance, base_features=base_features) useful_features = f.give(technique= technique, top=top, threshold=threshold, direction=direction, pick = pick, type_importance= type_importance, base_features=base_features) auto_feat_dict[str(last_exp_no)] = useful_features save_json(f"../configs/configs-{comp_name}/auto_feat.json", auto_feat_dict) #raise Exception('stop')

File no 4: /src-framework3/create_folds.py
import pandas as pd from sklearn import model_selection from iterstrat.ml_stratifiers import MultilabelStratifiedKFold import os import sys import pickle from collections import defaultdict from utils import * """ import os import sys import pickle with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() with open(f"../configs/configs-{comp_name}/locker.pkl", "rb") as f: a = pickle.load(f) """ if __name__ == "__main__": with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() with open(f"../configs/configs-{comp_name}/locker.pkl", "rb") as f: a = pickle.load(f) # # test = pd.read_csv(f"../input/input-{comp_name}/test.csv") # test = pd.read_parquet(f"../input/input-{comp_name}/test.parquet") # # test.to_csv(f"../configs/configs-{comp_name}/test.csv",index=False) # test.to_parquet(f"../configs/configs-{comp_name}/test.parquet", index=False) # df = pd.read_csv(f"../input/input-{comp_name}/train.csv") # df = df.sample(frac=1).reset_index(drop=True) # use later as it shuffles index # do it when you don't have id column or do it before creating Id columns # because for id col 0,1,2,3 it makes it look bad 12,3,0,111,... # for string id it is ok if a["comp_type"] == "multi_label": # df = df.sample(fracc=1).reset_index(drop=True) raise Exception("Now we have fold_dict instead of no_fold so change multi_label according in create folds") mskf = MultilabelStratifiedKFold( n_splits=a["no_folds"], shuffle=True, random_state=23 ) for fold, (train_idx, val_idx) in enumerate( mskf.split(df[a["id_name"]].values, df[a["target_name"]].values) ): print(len(train_idx), len(val_idx)) df.loc[val_idx, "fold"] = fold elif a["comp_type"] in ["binary", "multiclass", "2class"]: df = pd.read_parquet(f"../input/input-{comp_name}/train.parquet") if a["id_name"] in df.columns: # always create new ID column for train # keep it simple df.drop(a["id_name"], axis=1, inplace=True) # reset for all fix_random(231) # to make result reproducible df = df.sample(frac=1).reset_index(drop=True) # use later as it changes index df.index.name = a["id_name"] df = df.sort_index().reset_index() # sorting is very necessary for f,v in a['fold_dict'].items(): # 'fold5', 5 print(f,v,"=============>") df[f] = 1 kf = model_selection.StratifiedKFold( n_splits=v, shuffle=True, random_state=23 ) target_name = a["target_name"] for fold, (train_idx, val_idx) in enumerate( kf.split(X=df, y=df[target_name].values) ): print(fold+1,":",len(train_idx), len(val_idx)) df.loc[val_idx, f] = fold df[f] = df[f].astype('int8') # bydefault it is int64 print() else: df = pd.read_parquet(f"../input/input-{comp_name}/train.parquet") if a["id_name"] in df.columns: # always create new ID column for train # keep it simple df.drop(a["id_name"], axis=1, inplace=True) # reset for all fix_random(231) # to make result reproducible df = df.sample(frac=1).reset_index(drop=True) # use later as it changes index df.index.name = a["id_name"] df = df.sort_index().reset_index() # sorting is very necessary for f,v in a['fold_dict'].items(): # 'fold5', 5 print(f,v,"=============>") df[f] = 1 kf = model_selection.KFold( n_splits=v, shuffle=True, random_state=23 ) target_name = a["target_name"] for fold, (train_idx, val_idx) in enumerate( kf.split(X=df, y=df[target_name].values) ): print(fold+1,":",len(train_idx), len(val_idx)) df.loc[val_idx, f] = fold df[f] = df[f].astype('int8') # bydefault it is int64 print() if a["data_type"] in ["image_path", "image_df"]: # df.to_csv(f"../configs/configs-{comp_name}/my_folds.csv", index=False) df.to_parquet(f"../configs/configs-{comp_name}/my_folds.parquet", index=False) useful_features = [a["id_name"]] with open( f"../configs/configs-{a['comp_name']}/useful_features_l_1.pkl", "wb" ) as f: pickle.dump(useful_features, f) elif a["data_type"] == "tabular": # df.to_csv(f"../configs/configs-{comp_name}/my_folds.csv", index=False) df.to_parquet(f"../input/input-{comp_name}/my_folds.parquet", index=False) # test = pd.read_csv(f"../input/input-{comp_name}/test.csv") # Now no need to save test in cnfigs as we are saving it in input only [heavy files in input folder] #test = pd.read_parquet(f"../input/input-{comp_name}/test.parquet") ## test.to_csv(f"../configs/configs-{comp_name}/test.csv", index=False) #test.to_parquet(f"../configs/configs-{comp_name}/test.parquet", index=False) test = pd.read_parquet(f"../input/input-{comp_name}/test.parquet") useful_features = test.drop(a["id_name"], axis=1).columns.tolist() with open( f"../configs/configs-{a['comp_name']}/useful_features_l_1.pkl", "wb" ) as f: pickle.dump(useful_features, f) # --------------------------------dump current current_dict = defaultdict() current_dict["current_level"] = 1 current_dict["current_feature_no"] = 0 current_dict["current_exp_no"] = 0 current_dict["current_ens_no"] = 0 with open(f"../configs/configs-{a['comp_name']}/current_dict.pkl", "wb") as f: pickle.dump(current_dict, f) # --------------------------------dump features_dict feat_dict = defaultdict() feat_dict["base"] = [useful_features, 0] #feat_dict["l_1_f_0"] = [useful_features, 0, "base"] with open(f"../configs/configs-{a['comp_name']}/features_dict.pkl", "wb") as f: pickle.dump(feat_dict, f) # ---------------------------------dump Table Table = pd.DataFrame( columns=[ "exp_no", "model_name", "bv", "bp", "random_state", "with_gpu", "aug_type", "_dataset", "use_cutmix", "callbacks_list", "features_list", "level_no", "oof_fold_name", "opt_fold_name", "fold_no", "no_iterations", "prep_list", "metrics_name", "seed_mean", "seed_std", # ---\ "fold_mean", "fold_std", "pblb_single_seed", "pblb_all_seed", "pblb_all_fold", "notes", ] ) with open(f"../configs/configs-{a['comp_name']}/Table.pkl", "wb") as f: pickle.dump(Table, f) # -------------------------------------------

File no 5: /src-framework3/create_folds_again.py
import pandas as pd from sklearn import model_selection from iterstrat.ml_stratifiers import MultilabelStratifiedKFold import os import sys import pickle from collections import defaultdict from utils import * # Here we just creates folds and we don't recreate tables """ import os import sys import pickle with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() with open(f"../configs/configs-{comp_name}/locker.pkl", "rb") as f: a = pickle.load(f) """ if __name__ == "__main__": with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() with open(f"../configs/configs-{comp_name}/locker.pkl", "rb") as f: a = pickle.load(f) locker = a source= 'dummy' title = 'ver2' target_name = locker['target_name'] #"prediction" id_name = locker['id_name'] # "customer_ID" fold_list = ["fold3", "fold5", "fold10", "fold20"] # # test = pd.read_csv(f"../input/input-{comp_name}/test.csv") # test = pd.read_parquet(f"../input/input-{comp_name}/test.parquet") # # test.to_csv(f"../configs/configs-{comp_name}/test.csv",index=False) # test.to_parquet(f"../configs/configs-{comp_name}/test.parquet", index=False) # df = pd.read_csv(f"../input/input-{comp_name}/train.csv") # df = df.sample(frac=1).reset_index(drop=True) # use later as it shuffles index # do it when you don't have id column or do it before creating Id columns # because for id col 0,1,2,3 it makes it look bad 12,3,0,111,... # for string id it is ok if a["comp_type"] == "multi_label": # df = df.sample(fracc=1).reset_index(drop=True) raise Exception("Now we have fold_dict instead of no_fold so change multi_label according in create folds") mskf = MultilabelStratifiedKFold( n_splits=a["no_folds"], shuffle=True, random_state=23 ) for fold, (train_idx, val_idx) in enumerate( mskf.split(df[a["id_name"]].values, df[a["target_name"]].values) ): print(len(train_idx), len(val_idx)) df.loc[val_idx, "fold"] = fold else: try: df = pd.read_parquet(f"../input/input-{source}/train.parquet") except: try: df = pd.read_csv(f"../input/input-{source}/train.csv") except: raise Exception("train is neither parquet nor csv") if a["id_name"] in df.columns: # always create new ID column for train # keep it simple df.drop(a["id_name"], axis=1, inplace=True) # reset for all fix_random(231) # to make result reproducible df = df.sample(frac=1).reset_index(drop=True) # use later as it changes index df.index.name = a["id_name"] df = df.sort_index().reset_index() # sorting is very necessary for f,v in a['fold_dict'].items(): # 'fold5', 5 print(f,v,"=============>") df[f] = 1 kf = model_selection.StratifiedKFold( n_splits=v, shuffle=True, random_state=23 ) target_name = a["target_name"] for fold, (train_idx, val_idx) in enumerate( kf.split(X=df, y=df[target_name].values) ): print(fold+1,":",len(train_idx), len(val_idx)) df.loc[val_idx, f] = fold df[f] = df[f].astype('int8') # bydefault it is int64 print() if a["data_type"] in ["image_path", "image_df"]: raise Exception() # df.to_csv(f"../configs/configs-{comp_name}/my_folds.csv", index=False) df.to_parquet(f"../configs/configs-{comp_name}/my_folds.parquet", index=False) useful_features = [a["id_name"]] with open( f"../configs/configs-{a['comp_name']}/useful_features_l_1.pkl", "wb" ) as f: pickle.dump(useful_features, f) elif a["data_type"] == "tabular": # df.to_csv(f"../configs/configs-{comp_name}/my_folds.csv", index=False) #df.to_parquet(f"../input/input-{comp_name}/my_folds.parquet", index=False) # test = pd.read_csv(f"../input/input-{comp_name}/test.csv") # Now no need to save test in cnfigs as we are saving it in input only [heavy files in input folder] #test = pd.read_parquet(f"../input/input-{comp_name}/test.parquet") ## test.to_csv(f"../configs/configs-{comp_name}/test.csv", index=False) #test.to_parquet(f"../configs/configs-{comp_name}/test.parquet", index=False) try: test = pd.read_parquet(f"../input/input-{source}/test.parquet") except: try: # csv format data is present test = pd.read_csv(f"../input/input-{source}/test.csv") #test.to_parquet(f"../input/input-{comp_name}/test.parquet", index=False) # sample = pd.read_csv(f"../input/input-{comp_name}/sample.csv") # sample.to_parquet(f"../input/input-{comp_name}/sample.parquet", index=False) except: raise Exception("test is neither parquet nor csv") all_columns = list(test.drop(id_name, axis=1).columns) useful_features_l_1 = load_pickle(f"../configs/configs-{a['comp_name']}/useful_features_l_1.pkl") # any true if any(x in useful_features_l_1 for x in all_columns): #all_columns in useful_features_l_1): # some already present pass #raise Exception("Some features are already present in useful_features_l_1") print("These features will be added:") print(all_columns) v = input("Do you want to proceed? [y/n] : ") if v.lower() == 'n': raise Exception("Process Terminated") useful_features_l_1 += all_columns useful_features_l_1 = list(set(useful_features_l_1)) with open( f"../configs/configs-{a['comp_name']}/useful_features_l_1.pkl", "wb" ) as f: pickle.dump(useful_features_l_1, f) # train = df[all_columns].copy() test = test[all_columns].copy() train.to_parquet(f"../input/input-{comp_name}/train_{title}.parquet") test.to_parquet(f"../input/input-{comp_name}/test_{title}.parquet") input_dict = load_pickle(f"../input/input-{comp_name}/input_dict.pkl") input_dict[title] = all_columns save_pickle(f"../input/input-{comp_name}/input_dict.pkl", input_dict) #----------- print("New data Sucessfully added")

File no 6: /src-framework3/custom_classes.py
# --> to pass it to pytorch dataloader # > __init__ # > __len__ # > __getitem__ # each competition may require different # preprocessing and scaling from torch.utils.data import Dataset import numpy as np import pandas as pd import torch import os import sys import pickle import joblib import imageio import cv2 import os.path import albumentations from PIL import Image class TabularDataset: def __init__(self, data, target): self.data = data self.targets = targets def __len__(self): return self.data.shape[0] def __getitem__(self, idx): sample = self.data[idx, :] target = self.targets[idx] return { "x": torch.tensor(sample, dtype=float), "y": torch.tensor(target, dtype=long), } # classification / regression class TextDataset: def __init__(self, data, targets, tokenizer): self.data = data # list of texts self.targets = targets self.tokenizer = tokenizer def __len__(self): return len(data) def __getitem__(self, idx): # main part text = self.data[idx] # len(self.target.shape) will catch (30,) if len(self.target.shape) == 2 and self.target.shape[1] > 1: target = self.targets[idx, :] else: target = self.targets[idx] # binary: 0, 1, 1, 0 # multiclass: 1, 2, 0, 1 # regr(single col/ multicol): 0.3, 4, 5 # multilabel classification: [1, 0, 0, 1, 0], [1, 1, 0, 0, 0] # entity extraction # input_ids: text=> tokens i.e numbers input_ids = tokenizer(text) # transformers # input_ids : set of numbers [101, 42, 27, 216] # these seq can be of different length so do padding return { "text": torch.tensor(input_ids, dtype=torch.long), "target": torch.tensor( target ), # dtype= classification: torch.long, reg: torch.float) } class BengaliDataset(Dataset): def __init__(self, image_paths, targets, img_height, img_width, transform): with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() with open(f"../configs/configs-{comp_name}/locker.pkl", "rb") as f: self.locker = pickle.load(f) # self.csv = csv.reset_index() self.paths = image_paths self.targets = targets self.img_ids = self.paths # csv[self.locker["id_name"]] self.img_height = img_height self.img_width = img_width self.transform = transform def __len__(self): # return len(self.csv) return len(self.paths) def __getitem__(self, idx): path = self.paths[idx] path = f"{path}.png" # print("Found", path) # img = Image.open(path) img = Image.open(r"../input/input-bengaliai/train_images/Train_10.png") img = np.array(img) # print("Found-->") # img = joblib.load( # f"../input/input-{self.locker['comp_name']}/train_images/{img_id}.pkl" # ) # reshape 137, 236 # new dataset 128,128 img = img.reshape(self.img_height, self.img_width).astype(np.uint8) img = 255 - img # # make it 3dimensional (X,Y, RGB) if not img = img[:, :, np.newaxis] # np.repeat(item, no_times, along axis) # it repeats item along an axis # duplicates whole image 3 times to create RGB channels # img = img[img, 3, 2] img = np.repeat(img, 3, 2) # or # most of the models take RGB image convert PIL grayscale to "RGB" # img = Image.fromarray(image).convert("RGB") if self.transform is not None: img = self.transform(image=img)["image"] img = torch.tensor(img, dtype=torch.float) img = torch.permute(img, (2, 1, 0)) target_list = self.locker["target_name"] # target_1 = self.csv.iloc[index][target_list[0]].values # target_2 = self.csv.iloc[index][target_list[1]].values # target_3 = self.csv.iloc[index][target_list[2]].values target_1 = self.targets[idx, 0] # .iloc[index][target_list[0]].values target_2 = self.targets[idx, 1] # .iloc[index][target_list[1]].values target_3 = self.targets[idx, 2] # .iloc[index][target_list[2]].values return { "image": torch.tensor(img, dtype=torch.float), "grapheme_root": torch.tensor(target_1, dtype=torch.long), "vowel_diacritic": torch.tensor(target_2, dtype=torch.long), "consonant_diacritic": torch.tensor(target_3, dtype=torch.long), } # return img, np.array([target_1, target_2, target_3]) # tez2 1 channel pretrained 3channel models class DigitRecognizerDataset: def __init__(self, df, augmentations, model_name): # temp adding model name with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() with open(f"../configs/configs-{comp_name}/locker.pkl", "rb") as f: self.locker = pickle.load(f) self.df = df self.targets = self.df[self.locker["target_name"]].values self.df = self.df.drop(columns=[self.locker["target_name"]]) self.augmentations = augmentations if self.locker["comp_name"] == "twistmnist": self.images = self.df.to_numpy(dtype=np.float32).reshape((-1, 28, 50)) self.images = self.images[:, :, -28:] # remove the 1's else: self.images = self.df.to_numpy(dtype=np.float32).reshape((-1, 28, 28)) self.model_name = model_name def __len__(self): return len(self.df) def __getitem__(self, item): # item: index_no target = self.targets[item] image = self.images[item] if self.model_name == "pretrained": image = 255 - image image = image[:, :, np.newaxis] image = np.repeat(image, 3, 2) image = torch.tensor(image, dtype=torch.float) image = torch.permute(image, (2, 1, 0)) # or # image = np.transpose(iamge, (2,0,1)).astype(np.float32) # pytorch expects batch size * no of channels * height * weidth\ else: image = np.expand_dims(image, axis=0) # experimenting this is just for p1 which takes 1D input # image = image.reshape((-1)) # target = target.reshape((-1)) return { "image": torch.tensor(image, dtype=torch.float), "targets": torch.tensor(target, dtype=torch.float), } # this is for keras cutmix class CutMixImageDataGenerator: def __init__(self, generator1, generator2, img_size, batch_size): self.batch_index = 0 self.samples = generator1.samples self.class_indices = generator1.class_indices self.generator1 = generator1 self.generator2 = generator2 self.img_size = img_size self.batch_size = batch_size def reset_index(self): # Ordering Reset (If Shuffle is True, Shuffle Again) self.generator1._set_index_array() self.generator2._set_index_array() def reset(self): self.batch_index = 0 self.generator1.reset() self.generator2.reset() self.reset_index() def get_steps_per_epoch(self): quotient, remainder = divmod(self.samples, self.batch_size) return (quotient + 1) if remainder else quotient def __len__(self): self.get_steps_per_epoch() def __next__(self): if self.batch_index == 0: self.reset() crt_idx = self.batch_index * self.batch_size if self.samples > crt_idx + self.batch_size: self.batch_index += 1 else: # If current index over number of samples self.batch_index = 0 reshape_size = self.batch_size last_step_start_idx = (self.get_steps_per_epoch() - 1) * self.batch_size if crt_idx == last_step_start_idx: reshape_size = self.samples - last_step_start_idx X_1, y_1 = self.generator1.next() X_2, y_2 = self.generator2.next() cut_ratio = np.random.beta(a=1, b=1, size=reshape_size) cut_ratio = np.clip(cut_ratio, 0.2, 0.8) label_ratio = cut_ratio.reshape(reshape_size, 1) cut_img = X_2 X = X_1 for i in range(reshape_size): cut_size = int((self.img_size - 1) * cut_ratio[i]) y1 = random.randint(0, (self.img_size - 1) - cut_size) x1 = random.randint(0, (self.img_size - 1) - cut_size) y2 = y1 + cut_size x2 = x1 + cut_size cut_arr = cut_img[i][y1:y2, x1:x2] cutmix_img = X_1[i] cutmix_img[y1:y2, x1:x2] = cut_arr X[i] = cutmix_img y = y_1 * (1 - (label_ratio**2)) + y_2 * (label_ratio**2) return X, y def __iter__(self): while True: yield next(self)

File no 7: /src-framework3/custom_models.py
# tez ---------------------------- import os import sys import pickle import albumentations as A import pandas as pd import numpy as np import tez from tez.datasets import ImageDataset from tez.callbacks import EarlyStopping import torch import torch.nn as nn from torch.nn import functional as F from sklearn import metrics, model_selection, preprocessing import timm from sklearn.model_selection import KFold # ignoring warnings import warnings warnings.simplefilter("ignore") import os, cv2, json from PIL import Image import random # ------------------------------ from torch.nn import ( Linear, ReLU, CrossEntropyLoss, Sequential, Conv2d, MaxPool2d, Module, Softmax, BatchNorm2d, Dropout, ) from torch.optim import Adam, SGD # ----------------- import pretrainedmodels import torch.nn as nn from torch.nn import functional as F class trainer_p1: def __init__( self, model, train_loader, valid_loader, optimizer, scheduler, use_cutmix ): with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() with open(f"../configs/configs-{comp_name}/locker.pkl", "rb") as f: self.locker = pickle.load(f) self.model = model self.train_loader = train_loader self.valid_loader = valid_loader self.optimizer = optimizer # self.scheduler = torch.optim.lr_scheduler.ReduceLROnPlateau( # self.optimizer, mode="max", verbose=True, patience=7, factor=0.5 # ) self.scheduler = scheduler self.locc_fn = nn.CrossEntropyLoss() self.use_cutmix = use_cutmix def loss_fn_multilabel(self, outputs, targets): o1, o2, o3 = outputs t1, t2, t3 = targets l1 = nn.CrossEntropyLoss()(o1, t1) l2 = nn.CrossEntropyLoss()(o2, t2) l3 = nn.CrossEntropyLoss()(o3, t3) return (l1 + l2 + l3) / 3 def loss_fn(self, targets, output): device = "cuda" targets = targets.type(torch.LongTensor) targets = targets.to(device) output = output.to(device) return nn.CrossEntropyLoss()(output, targets) # output is the prediction # targets is the true label output = torch.argmax(output, dim=1) output = output.unsqueeze(1) targets = targets.unsqueeze(1) # use it for conv make it 2D print(output.shape, targets.shape) # For nn.CrossEntropyLoss the target has to be a single number from the interval [0, #classes] return nn.CrossEntropyLoss()(output, targets) # return nn.BCEWithLogitsLoss()(output, targets) def scheduler_fn(self): pass def optimizer_fn(self): learning_rate = 0.001 pass def rand_bbox(self, size, lam): W = size[2] H = size[3] cut_rat = np.sqrt(1.0 - lam) cut_w = np.int(W * cut_rat) cut_h = np.int(H * cut_rat) # uniform cx = np.random.randint(W) cy = np.random.randint(H) bbx1 = np.clip(cx - cut_w // 2, 0, W) bby1 = np.clip(cy - cut_h // 2, 0, H) bbx2 = np.clip(cx + cut_w // 2, 0, W) bby2 = np.clip(cy + cut_h // 2, 0, H) return bbx1, bby1, bbx2, bby2 def cutmix_data(self, data): inputs = data["image"] targets = data["targets"] self.lam = np.random.beta(1.0, 1.0) rand_index = torch.randperm(inputs.size()[0]) target = data["targets"] self.shuffled_targets = target[rand_index] bbx1, bby1, bbx2, bby2 = self.rand_bbox(inputs.size(), self.lam) inputs[:, :, bbx1:bbx2, bby1:bby2] = inputs[rand_index, :, bbx1:bbx2, bby1:bby2] self.lam = 1 - ( (bbx2 - bbx1) * (bby2 - bby1) / (inputs.size()[-1] * inputs.size()[-2]) ) return inputs, targets def train_one_epoch(self): self.model.train() # put model in train mode total_loss = 0 for batch_index, data in enumerate(self.train_loader): loss = self.train_one_step(data) # loss = self.loss_fn(data["targets"], output) total_loss += loss return total_loss def train_one_step(self, data): self.optimizer.zero_grad() for k, v in data.items(): data[k] = v.to("cuda") # make sure forward function of model has same keys # dictinary is passed using ** if self.use_cutmix == True: inputs, targets = self.cutmix_data(data) output = self.model(inputs) # **data) loss = self.loss_fn(targets, output) * self.lam + self.loss_fn( self.shuffled_targets, output ) * (1 - self.lam) else: if self.locker["comp_name"] == "bengaliai": image = data["image"] grapheme_root = data["grapheme_root"] vowel_diacritic = data["vowel_diacritic"] consonant_diacritic = data["consonant_diacritic"] image = image.to("cuda", dtype=torch.float) grapheme_root = grapheme_root.to("cuda", dtype=torch.long) vowel_diacritic = vowel_diacritic.to("cuda", dtype=torch.long) consonant_diacritic = consonant_diacritic.to("cuda", dtype=torch.long) targets = (grapheme_root, vowel_diacritic, consonant_diacritic) output = self.model(data["image"]) loss = self.loss_fn_multilabel(output, targets) else: output = self.model(data["image"]) loss = self.loss_fn(data["targets"], output) loss.backward() self.optimizer.step() return loss def validate_one_epoch(self): self.model.eval() total_loss = 0 for batch_index, data in enumerate(self.valid_loader): with torch.no_grad(): loss = self.validate_one_step(data) total_loss += loss return total_loss def validate_one_step(self, data): for k, v in data.items(): data[k] = v.to("cuda") # added if self.locker["comp_name"] == "bengaliai": image = data["image"] grapheme_root = data["grapheme_root"] vowel_diacritic = data["vowel_diacritic"] consonant_diacritic = data["consonant_diacritic"] image = image.to("cuda", dtype=torch.float) grapheme_root = grapheme_root.to("cuda", dtype=torch.long) vowel_diacritic = vowel_diacritic.to("cuda", dtype=torch.long) consonant_diacritic = consonant_diacritic.to("cuda", dtype=torch.long) targets = (grapheme_root, vowel_diacritic, consonant_diacritic) output = self.model(data["image"]) loss = self.loss_fn_multilabel(output, targets) else: # upto here # make sure forward function of model has same keys output = self.model(data["image"]) # **data) loss = self.loss_fn(data["targets"], output) return loss def fit(self, n_iter): for epoch in range(n_iter): epoch_loss = 0 counter = 0 train_loss = self.train_one_epoch() valid_loss = self.validate_one_epoch() # scheduler self.scheduler.step(valid_loss) if epoch % 2 == 0: print( f"epoch {epoch}, train loss {train_loss}, valid loss {valid_loss}" ) # self.optimizer.swap_swa_sgd() ## Here def predict_one_step(self, data): for k, v in data.items(): data[k] = v.to("cuda") output = self.model(data["image"]) return output def predict(self, test_loader): if self.locker["comp_type"] == "multi_label": outputs = [[], [], []] preds = [[], [], []] with torch.no_grad(): for batch_index, data in enumerate(test_loader): out = self.predict_one_step(data) outputs[0].append( out[0] ) # out.argmax(1) required when the final layer gives probabilites of classes and we want hard class outputs[1].append( out[1] ) # out.argmax(1) required when the final layer gives probabilites of classes and we want hard class outputs[2].append( out[2] ) # out.argmax(1) required when the final layer gives probabilites of classes and we want hard class preds[0] = torch.cat( outputs[0] ) # .view(-1) view(-1) is needed when we want 1D array preds[1] = torch.cat( outputs[1] ) # .view(-1) view(-1) is needed when we want 1D array preds[2] = torch.cat( outputs[2] ) # .view(-1) view(-1) is needed when we want 1D array else: outputs = [] with torch.no_grad(): for batch_index, data in enumerate(test_loader): out = self.predict_one_step(data) outputs.append( out ) # out.argmax(1) required when the final layer gives probabilites of classes and we want hard class preds = torch.cat( outputs ) # .view(-1) view(-1) is needed when we want 1D array return [ preds ] # make output as list of arrays for one d output make it a list of one element def save(self, path): state_dict = self.model.cpu().state_dict() self.model = self.model.cuda() torch.save(state_dict, path) class ResNet34(nn.Module): def __init__(self, pretrained): super(ResNet34, self).__init__() if pretrained is True: self.model = pretrainedmodels.__dict__["resnet34"](pretrained="imagenet") else: self.model = pretrainedmodels.__dict__["resnet34"](pretrained=None) self.l0 = nn.Linear(512, 168) self.l1 = nn.Linear(512, 11) self.l2 = nn.Linear(512, 7) def forward(self, x): # supports all kind of image size bs, _, _, _ = x.shape x = self.model.features(x) x = F.adaptive_avg_pool2d(x, 1).reshape(bs, -1) l0 = self.l0(x) l1 = self.l1(x) l2 = self.l2(x) return l0, l1, l2 class pretrained_models(nn.Module): # basic pytorch model # conv2d(in_channels, out_channels): # in_channels:- no of channels in the input image # out_channel:- no of channels in the output image # kernel_size:- size of convolving kernel def __init__(self, no_features): super().__init__() model_name = "resnet34" self.model = pretrainedmodels.__dict__[model_name](pretrained="imagenet") # adding a head in_features = self.model.last_linear.in_features self.model.last_linear = torch.nn.Linear(in_features, 10) # self.layer0 = nn.Conv2d(in_channels = 3, out_channels = 50, kernel_size=3, padding=1) # self.layer1 = nn.Linear(50, 32) # self.layer2 = nn.Linear(32, 16) # self.layer3 = nn.Linear(16, 1) # self.cnn_layers = Sequential( # # Defining a 2D convolution layer # Conv2d(1, 4, kernel_size=3, stride=1, padding=1), # BatchNorm2d(4), # ReLU(inplace=True), # MaxPool2d(kernel_size=2, stride=2), # # Defining another 2D convolution layer # Conv2d(4, 4, kernel_size=3, stride=1, padding=1), # BatchNorm2d(4), # ReLU(inplace=True), # MaxPool2d(kernel_size=2, stride=2), # ) # self.linear_layers = Sequential(Linear(4 * 7 * 7, 10)) def forward(self, data): # batch_size, no_featrues : xtrain.shape # use this if now using 1D array in starting # xtrain = data # x = self.layer1(xtrain) # x = self.layer2(x) # x = self.layer3(x) # return x x = data return self.model(x) # x = self.cnn_layers(x) # x = x.view(x.size(0), -1) # x = self.linear_layers(x) # return x class p1_model1(nn.Module): # basic pytorch model # conv2d(in_channels, out_channels): # in_channels:- no of channels in the input image # out_channel:- no of channels in the output image # kernel_size:- size of convolving kernel def __init__(self): super().__init__() # self.layer0 = nn.Conv2d(in_channels = 3, out_channels = 50, kernel_size=3, padding=1) # self.layer1 = nn.Linear(50, 32) # self.layer2 = nn.Linear(32, 16) # self.layer3 = nn.Linear(16, 1) self.cnn_layers = Sequential( # Defining a 2D convolution layer Conv2d(3, 4, kernel_size=3, stride=1, padding=1), BatchNorm2d(4), ReLU(inplace=True), MaxPool2d(kernel_size=2, stride=2), # Defining another 2D convolution layer Conv2d(4, 4, kernel_size=3, stride=1, padding=1), BatchNorm2d(4), ReLU(inplace=True), MaxPool2d(kernel_size=2, stride=2), ) self.linear_layers1 = nn.Linear(100, 168) # Sequential(Linear(4 * 7 * 7, 168)) self.linear_layers2 = nn.Linear(100, 11) # Sequential(Linear(4 * 7 * 7, 11)) self.linear_layers3 = nn.Linear(100, 7) # Sequential(Linear(4 * 7 * 7, 7)) def forward(self, data): # batch_size, no_featrues : xtrain.shape # use this if now using 1D array in starting # xtrain = data # x = self.layer1(xtrain) # x = self.layer2(x) # x = self.layer3(x) # return x x = data x = self.cnn_layers(x) x = x.view(x.size(0), -1) x1 = self.linear_layers1(x) x2 = self.linear_layers2(x) x3 = self.linear_layers3(x) return x1, x2, x3 class p1_model(nn.Module): # basic pytorch model # conv2d(in_channels, out_channels): # in_channels:- no of channels in the input image # out_channel:- no of channels in the output image # kernel_size:- size of convolving kernel def __init__(self): super().__init__() self.cnn_layers = Sequential( # Defining a 2D convolution layer Conv2d(1, 4, kernel_size=3, stride=1, padding=1), BatchNorm2d(4), ReLU(inplace=True), MaxPool2d(kernel_size=2, stride=2), # Defining another 2D convolution layer Conv2d(4, 4, kernel_size=3, stride=1, padding=1), BatchNorm2d(4), ReLU(inplace=True), MaxPool2d(kernel_size=2, stride=2), ) self.linear_layers = Sequential(Linear(4 * 7 * 7, 10)) def forward(self, data): x = data x = self.cnn_layers(x) x = x.view(x.size(0), -1) x = self.linear_layers(x) return x # tez1 class UModel(tez.Model): # nn.Module): #tez.Model): def __init__( self, model_name, num_classes, learning_rate, n_train_steps # , warmup_ratio ): super().__init__() self.learning_rate = learning_rate self.n_train_steps = n_train_steps # self.warmup_ratio = warmup_ratio self.model = timm.create_model( model_name, pretrained=True, in_chans=3, num_classes=num_classes ) self.step_scheduler_after = "batch" def monitor_metrics(self, outputs, targets): if targets is None: return {} outputs = torch.argmax(outputs, dim=1).cpu().detach().numpy() targets = targets.cpu().detach().numpy() accuracy = metrics.accuracy_score(targets, outputs) return {"accuracy": accuracy} def fetch_optimizer(self): opt = torch.optim.Adam(self.parameters(), lr=3e-4) return opt def fetch_scheduler(self): sch = torch.optim.lr_scheduler.CosineAnnealingWarmRestarts( self.optimizer, T_0=10, T_mult=1, eta_min=1e-6, last_epoch=-1 ) return sch def forward(self, image, targets=None): x = self.model(image) if targets is not None: loss = nn.CrossEntropyLoss()(x, targets) metrics = self.monitor_metrics(x, targets) return x, loss, metrics return x, 0, {} # tez2 class DigitRecognizerModel(nn.Module): def __init__(self, model_name, num_classes, learning_rate, n_train_steps): super().__init__() self.learning_rate = learning_rate self.n_train_steps = n_train_steps self.model = timm.create_model( model_name, pretrained=True, in_chans=1, num_classes=num_classes, ) def monitor_metrics(self, outputs, targets): device = targets.get_device() outputs = np.argmax(outputs.cpu().detach().numpy(), axis=1) targets = targets.cpu().detach().numpy() acc = metrics.accuracy_score(targets, outputs) acc = torch.tensor(acc, device=device) return {"accuracy": acc} def optimizer_scheduler(self): opt = torch.optim.SGD( self.parameters(), lr=self.learning_rate, momentum=0.9, ) sch = torch.optim.lr_scheduler.ReduceLROnPlateau( opt, factor=0.5, patience=2, verbose=True, mode="max", threshold=1e-4, ) return opt, sch def forward(self, image, targets=None): x = self.model(image) if targets is not None: targets = targets.type(torch.LongTensor) targets = targets.to("cuda") # print(targets.device, x.device, "these are devices") # very strong sanity check loss = nn.CrossEntropyLoss()(x, targets) metrics = self.monitor_metrics(x, targets) return x, loss, metrics return x, 0, {}

File no 8: /src-framework3/datasets_create.py
import os import sys import json def create_datasets(): with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() # -------------------CREATE-FOLDERS----------------------------------# try: os.system(f"kaggle datasets create -p ../configs/{'configs-'+ comp_name}/") print( f"configs-{comp_name} dataset created on kaggle." ) except: print(f"configs-{comp_name} dataset already created on kaggle.") # --------------------models----------------------------------------# print("=" * 40) try: os.system(f"kaggle datasets create -p ../models/{'models-'+ comp_name}/") print(f"models-{comp_name} dataset created on kaggle.") except: print(f"models-{comp_name} dataset already created on kaggle.") # --------------------input----------------------------------------# print("=" * 40) try: os.system(f"kaggle datasets create -p ../input/{'input-'+ comp_name}/") print(f"input-{comp_name} dataset created on kaggle.") except: print(f"input-{comp_name} dataset already created on kaggle.") print("=" * 40) if __name__ == "__main__": # [ IF RUN 2nd time will throw error] # CALL IT ONLY ONCE after init_folders.py from next time just call push.py create_datasets() print("Done")

File no 9: /src-framework3/datasets_init.py
import os import sys import json def initialize_folders(): with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() # -------------------CREATE-FOLDERS----------------------------------# # --------------------configs----------------------------------------# try: os.mkdir(f"../configs/configs-{comp_name}/") os.mkdir(f"../configs/configs-{comp_name}/logs/") os.mkdir(f"../configs/configs-{comp_name}/oof_preds/") os.mkdir(f"../configs/configs-{comp_name}/test_preds/") os.mkdir(f"../configs/configs-{comp_name}/test_feats/") os.mkdir(f"../configs/configs-{comp_name}/train_feats/") os.mkdir(f"../configs/configs-{comp_name}/ensemble_logs/") os.mkdir(f"../configs/configs-{comp_name}/feature_importance/") os.mkdir(f"../configs/configs-{comp_name}/auto_exp_tables/") print(f"configs-{comp_name} folder and subfolders logs/oof_preds/test_preds created.") except: print(f"configs-{comp_name} and subfolders logs/oof_preds/test_preds already exists.") # --------------------models----------------------------------------# try: os.mkdir(f"../models/models-{comp_name}/") print(f"models-{comp_name} folder created.") except: print(f"models-{comp_name} already exists.") # --------------------input----------------------------------------# try: os.mkdir(f"../input/input-{comp_name}/") print(f"input-{comp_name} folder created.") except: print(f"input-{comp_name} already exists.") # -------------------ADD-META DATA----------------------------------# # --------------------configs----------------------------------------# print("=" * 40) # --------------------meta data create os.system(f"kaggle datasets init -p ../configs/{'configs-'+ comp_name}/") os.system(f"kaggle datasets init -p ../models/{'models-'+ comp_name}/") os.system(f"kaggle datasets init -p ../input/{'input-'+ comp_name}/") # read the json file with open(f"../configs/configs-{comp_name}/dataset-metadata.json") as f: dataset_meta = json.load(f) try: dataset_meta["id"] = f"raj401/configs-{comp_name}" dataset_meta["title"] = f"configs-{comp_name}" with open( f"../configs/configs-{comp_name}/dataset-metadata.json", "w" ) as outfile: json.dump(dataset_meta, outfile) print(outfile) with open(f"../configs/configs-{comp_name}/jj.txt", "w") as x: x.write("demo") x.close() print( f"configs-{comp_name} folder meta-data added." ) except: print(f"configs-{comp_name} meta-data already exists.") # --------------------models----------------------------------------# print("=" * 40) try: dataset_meta["id"] = f"raj401/models-{comp_name}" dataset_meta["title"] = f"models-{comp_name}" with open( f"../models/models-{comp_name}/dataset-metadata.json", "w" ) as outfile: json.dump(dataset_meta, outfile) print(outfile) with open(f"../models/models-{comp_name}/jj.txt", "w") as x: x.write("demo") x.close() print(f"models-{comp_name} folder meta-data added.") except: print(f"models-{comp_name} meta-data already exists.") # --------------------input----------------------------------------# print("=" * 40) try: dataset_meta["id"] = f"raj401/input-{comp_name}" dataset_meta["title"] = f"input-{comp_name}" with open(f"../input/input-{comp_name}/dataset-metadata.json", "w") as outfile: json.dump(dataset_meta, outfile) print(outfile) with open(f"../input/input-{comp_name}/jj.txt", "w") as x: x.write("demo") x.close() print(f"input-{comp_name} folder meta-data added.") except: print(f"input-{comp_name} meta-data already exists.") print("=" * 40) if __name__ == "__main__": #[ CAN CALL IT MULTIPLE TIMES, no harm will be done in calling] # each time it will reset .json file """ It Creates 3 folders: configs-{}, models-{}, input-{} It then initializes their metadata It then modifies their meta data accordingly sets the name and rug It then puts a demo txt file jj """ initialize_folders() print("Done")

File no 10: /src-framework3/dummy_exp.py
import os ,sys import pandas as pd import numpy as np from utils import load_pickle, save_pickle class dummy: def __init__(self): with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() self.comp_name = comp_name # put it here for the mkdir of lgb callback self.locker = load_pickle(f"../configs/configs-{comp_name}/locker.pkl") self.current_dict = load_pickle( f"../configs/configs-{self.locker['comp_name']}/current_dict.pkl" ) self.Table = load_pickle(f"../configs/configs-{self.locker['comp_name']}/Table.pkl") self.Table = pd.DataFrame(self.Table) # update it with the lates values self.get_exp_no() print("=" * 30) print(f"Current Exp no: {self.current_exp_no}") print("=" * 30) def get_exp_no(self): # exp_no, current_level self.current_dict = load_pickle( f"../configs/configs-{self.locker['comp_name']}/current_dict.pkl" ) self.current_exp_no = int(self.current_dict["current_exp_no"]) def get_row(self, pull_exp_no): if pull_exp_no == -1: return self.Table.loc[self.Table.shape[0]-1, :].copy() else: # since this table stores all the experiment so index no corresponds to exp_no return self.Table.loc[pull_exp_no, :].copy() def insert_row(self, changer, pull_exp_no): raw_row = self.get_row(pull_exp_no) print("Original row") print(raw_row) print() for key,value in changer.items(): if value != "--|--": # to change it raw_row[key] = value raw_row['exp_no'] = self.current_exp_no if pull_exp_no == -1: raw_row["notes"] = f"dummy_{self.Table.shape[0]-1}" else: raw_row["notes"] = f"dummy_{pull_exp_no}" print("Modified row") print(raw_row) self.Table.loc[self.Table.shape[0], :] = raw_row.values print() print(self.Table.tail(3)) m = input("Do you want to insert this row!!, Type Y/y to proceed, else type any other key.\n: ") if m.lower() == "y": self._save_models() print("Updated!!") else: print("Aborted!!") def _save_models(self): self.current_exp_no += 1 # --------------- dump experiment no self.current_dict["current_exp_no"] = self.current_exp_no save_pickle( f"../configs/configs-{self.locker['comp_name']}/current_dict.pkl", self.current_dict, ) #---------------- sanity check table self.Table.exp_no = self.Table.exp_no.astype(int) self.Table.level_no = self.Table.level_no.astype(int) self.Table.no_iterations = self.Table.no_iterations.astype(int) self.Table.random_state = self.Table.random_state.astype(int) # ---------------- dump table save_pickle(f"../configs/configs-{self.locker['comp_name']}/Table.pkl", self.Table) def show_variables(self): print() for i, (k, v) in enumerate(self.__dict__.items()): print(f"{i}. {k} :=======>", v) print() if __name__ == "__main__": d = dummy() changer= { "exp_no": "--|--", "model_name": "--|--", "bv": 100, # to keep it on top "bp": {'learning_rate': 0.010821262164314453, 'max_depth': 16, 'min_child_weight': 5, 'subsample': 0.4521783648128741, 'n_estimators': 500, 'objective': 'reg:squarederror', 'tree_method': 'gpu_hist', 'gpu_id': 0, 'predictor': 'gpu_predictor'}, "random_state": "--|--", "with_gpu": "--|--", "aug_type": "--|--", "_dataset": "--|--", "use_cutmix": "--|--", "callbacks_list": "--|--", "features_list": "--|--", "level_no": "--|--", "oof_fold_name": [], "opt_fold_name": "--|--", "no_iterations": "--|--", "prep_list": "--|--", "metrics_name": "--|--", # Below and some of the above things shold be empty when creating a new row "seed_mean": None, "seed_std": None, "fold_mean": [], "fold_std": [], "pblb_single_seed": None, "pblb_all_seed": None, "pblb_all_fold": [], "notes": "--|--", } pull_exp_no = 7 d.insert_row(changer, pull_exp_no)

File no 11: /src-framework3/ensemble.py
import numpy as np import pandas as pd import os import sys import gc from utils import * from metrics import * from collections import defaultdict class Ensembler: def __init__(self): with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() self.comp_name = comp_name self.locker = load_pickle(f"../configs/configs-{self.comp_name}/locker.pkl") self.current_dict = load_pickle(f"../configs/configs-{self.comp_name}/current_dict.pkl") self.current_ens_no = self.current_dict['current_ens_no'] print("="*40) print("Current ens no:", self.current_ens_no) print("="*40) self.cv_score = [] # of fold3, all, single self.pblb_score = [] # corresponding self.Table = load_pickle(f"../configs/configs-{self.comp_name}/Table.pkl") #self.my_folds = pd.read_parquet(f"../input/input-{self.comp_name}/my_folds.parquet") self.id_folds_target = pd.read_parquet(f"../input/input-{self.comp_name}/id_folds_target.parquet") self.target = self.id_folds_target[self.locker['target_name']] #self.my_folds[self.locker["target_name"]].values self.id = self.id_folds_target[self.locker["id_name"]].values self.sample = pd.read_parquet(f"../input/input-{self.comp_name}/sample.parquet") #del self.my_folds gc.collect() def access_predictions(self, submission_list): self.submission_list = submission_list self.train_list = [] self.test_list = [] for i,j in submission_list: # access it if j.startswith("fold"): # it is a prediction self.train_list.append( load_pickle(f"../configs/configs-{self.comp_name}/oof_preds/oof_pred_e_{i}_{j}.pkl").reshape(-1,)) self.test_list.append( load_pickle(f"../configs/configs-{self.comp_name}/test_preds/test_pred_e_{i}_{j}.pkl").reshape(-1,)) # exp_no and index match for table so works names = self.Table.loc[i, "oof_fold_name"] ind = names.index(j) print() print("exp_no",i) try: self.pblb_score.append(self.Table.loc[i, 'pblb_all_fold'][ind]) print(f"pblb: {self.Table.loc[i, 'pblb_all_fold'][ind]}") except: print("pblb_score not found") try: self.cv_score.append(self.Table.loc[i, 'fold_mean'][ind]) print(f"cv: {self.Table.loc[i, 'fold_mean'][ind]}") except: print("cv_score is not found") elif j in ["all", "single"]: raise Exception("Need to work on it") elif j.startswith("feat"): # these are features raise Exception("Need to work on it") self.column_names.append(f"feat_l_1_e_{i}_feat") elif j.startswith("../working"): # picked some public kernel assert j.endswith(".csv") # must be a csv # [[0.7977, 0.799], "../working/.."] assert len(i) == 2 self.cv_score.append(i[0]) self.pblb_score.append(i[1]) print(f"cv: {i[0]} , pblb: {i[1]}") # no training self.train_list.append( np.ones((self.id_folds_target.shape[0], )) ) self.test_list.append( pd.read_csv(j)[self.locker['target_name']]) # got train and test #self.train_list = np.array() # draw correlation plot col_names = [str(i[0]) for i in submission_list] train_corr = (pd.DataFrame(np.array(self.train_list + [self.id_folds_target[self.locker['target_name']]]).T, columns= col_names + [self.locker['target_name']])).corr() test_corr = (pd.DataFrame(np.array(self.test_list).T, columns= col_names)).corr() print("-"*40) print("Train corr") print(train_corr) print("-"*40) print("Test corr") print(test_corr) print("-"*40) def save_process(self, save_dict): # save submissions_list a # technique # no need to save seperately contained in submissions_list name # update current_dict save_json(f"../configs/configs-{self.comp_name}/ensemble_logs/ens_{self.current_ens_no}.json", save_dict) self.current_ens_no += 1 self.current_dict['current_ens_no'] = self.current_ens_no save_pickle(f"../configs/configs-{self.locker['comp_name']}/current_dict.pkl", self.current_dict) def combine(self, technique): self.technique = technique if technique == "power_averaging_basic": # self.train_list is a list where each element is a list of submissions , [0] picking the first since not multi-class problem train_pred = [ np.sum([0.2 * i for i in f], axis=0) for f in [self.train_list]][0] test_pred = [ np.sum([0.2 * i for i in f], axis=0) for f in [self.test_list]][0] elif technique == "weight_averaging_by_pblb": train_pred = [ np.sum([i*j for i,j in zip(f,self.pblb_score) ], axis=0) for f in [self.train_list]][0] test_pred = [ np.sum([i*j for i,j in zip(f,self.pblb_score)], axis=0) for f in [self.test_list]][0] elif technique == "weight_average_by_cv": train_pred = [ np.sum([i*j for i,j in zip(f,self.cv_score) ], axis=0) for f in [self.train_list]][0] test_pred = [ np.sum([i*j for i,j in zip(f,self.cv_score)], axis=0) for f in [self.test_list]][0] print(test_pred) train_pred = np.array(train_pred)/sum(self.cv_score) test_pred = np.array(test_pred)/sum(self.cv_score) elif technique == "median": train_pred = [ np.median(f) for f in [self.train_list]][0] test_pred = [ np.median(f) for f in [self.test_list]][0] print(train_pred.shape, test_pred.shape) # save oof predictions #score = amex_metric(self.target, train_pred) score = getaroom_metrics(self.target, train_pred) print("train score: ",score) save_dict = defaultdict() save_dict["submission_list"] = self.submission_list save_dict["cv_score"] = score save_dict["technique"] = technique self.sample[self.locker['target_name']] = test_pred print() print(self.sample.head(3)) # Now working withing same comp because folds hold for same datset and not amex, amex2 input("Want to proceed!") self.sample.to_parquet(f"../working/{self.comp_name}_ens_{self.current_ens_no}.parquet") self.save_process(save_dict) if __name__ == "__main__": # For now works only for fold prediction # submission_list = [ # [215, "fold5"], # [1, "fold5"], # [265, "fold5"], # [49, "fold5"], # [138, "fold5"] # ] submission_list = [ # 1,8,20,18, 47, 14, 54, 43, 56, 42, 35, 3, 34, 6, 41 # [294,'fold5'], # [297,'fold5'], # [273,'fold5'], # [254,'fold5'], [[0.7977, 0.799], "../working/rr_mean_submission.csv"], [[0.7977, 0.799], "../working/rr_submission.csv"], [[0.7977, 0.799], "../working/rr_submission1.csv"] #[1, "fold5"], #[8, "fold5"], #[20, "fold5"], # [18, "fold5"], # [47, "fold5"], # [14, "fold5"], # [54, "fold5"], #[61, "fold5"], # [43, "fold5"], # [56, "fold5"], # [42, "fold5"], # [35, "fold5"], # [3, "fold5"], # [34, "fold5"], # [6, "fold5"], # [41, "fold5"], # [8, "fold5"], # [20, "fold5"], # [18, "fold5"], # [35, "fold5"], # [29, "fold5"], # [1, "fold5"], # [45, "fold5"], # [54, "fold5"], # [56, "fold5"], # [14, "fold5"], # [43, "fold5"], # [34, "fold5"], # [47, "fold5"], # [27, "fold5"], # [3, "fold5"], # [55, "fold5"], # [6, "fold5"], # [42, "fold5"], # [41, "fold5"], # [7, "fold5"], # [2, "fold5"], # [32, "fold5"], # [15, "fold5"], # [44, "fold5"], # [80, "fold5"], #[43, "fold5"], #[15, "fold5"], # [1, "fold5"], # [8, "fold5"], # [14, "fold5"], # [15, "fold5"], # [17, "fold5"], # [45, "fold5"], #[79, "fold5"], #[98, 'fold5'], #[111, 'fold5'], #[1, "fold5"], #[44, "fold5"], #[15, "fold5"], #[[0.798, 0.799], "../working/mean_submission.csv"], #[[0.7977, 0.799], "../working/test_lgbm_baseline_5fold_seed_blend.csv"], #[112, "fold5"], ] # "median", "mean" , "weighted_mean", "best", "rank", "weigh_by_cv", "weight_averaging_by_pblb", "weigh_by_cv_pblb_jump", "power_averaging_basic" technique = "weight_average_by_cv" #"weight_average_by_cv" #"power_averaging_basic" # "mean" # "weighted_mean" , "best" , "mean" e = Ensembler() e.access_predictions(submission_list) e.combine(technique) """ 0.795 215 fold5, 1 fold5, 265 fold5 , 0.796 49 fold5, 138 fold5 """ # some ideas # larger the jump b/w cv and pblb score better is the model pblb > cv not cv < pblb

File no 12: /src-framework3/exp_infos.txt
1: did feature extraction 2: used extracted features and score cv increased repeated till exp3 exp 4 to exp 10 ran xgbc

File no 13: /src-framework3/experiment.py
from optuna_search import OptunaOptimizer from feature_generator import features from feature_picker import Picker import os import sys import gc import pickle import pandas as pd import tracemalloc # from custom_models import UModel # from custom_models import * from utils import * from settings import * class Agent: def __init__( self, useful_features=[], model_name="", comp_type="2class", metrics_name="accuracy", n_trials=5, prep_list=[], fold_name = 'fold5', optimize_on=0, save_models=True, with_gpu=False, aug_type="Aug1", _dataset="ImageDataset", use_cutmix=True, callbacks_list=[], note="---", ): with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() self.locker = load_pickle(f"../configs/configs-{comp_name}/locker.pkl") self.current_dict = load_pickle( f"../configs/configs-{comp_name}/current_dict.pkl" ) print("=" * 30) print(f"Current Exp no: {self.current_dict['current_exp_no']}") print("=" * 30) # ---------------------------------------------------------- self.useful_features = useful_features self.model_name = model_name self.comp_type = comp_type self.metrics_name = metrics_name self.n_trials = n_trials self.prep_list = prep_list self.fold_name = fold_name self.optimize_on = optimize_on self.save_models = True self.with_gpu = with_gpu self.aug_type = aug_type self._dataset = _dataset self.use_cutmix = use_cutmix self.callbacks_list = callbacks_list self.note = note def sanity_check(self): if "--|--" in [ self.useful_features, self.model_name, self.comp_type, self.metrics_name, self.n_trials, self.prep_list, self.fold_name, self.optimize_on, self.save_models, self.with_gpu, self.aug_type, self._dataset, self.note, ]: raise Exception("Found --|--- while sanity check!") def run( self, useful_features="--|--", model_name="--|--", comp_type="--|--", metrics_name="--|--", n_trials="--|--", prep_list="--|--", fold_name = "--|--", optimize_on="--|--", save_models="--|--", with_gpu="--|--", aug_type="--|--", _dataset="--|--", ): tracemalloc.start() check_memory_usage("Experiment started", self, 0) ###################################### # Memory uage # ###################################### if useful_features != "--|--": self.useful_features = useful_features if model_name != "--|--": self.model_name = model_name if comp_type != "--|--": self.comp_type = comp_type if metrics_name != "--|--": self.metrics_name = metrics_name if n_trials != "--|--": self.n_trials = n_trials if prep_list != "--|--": self.prep_list = prep_list if fold_name != "--|--": self.fold_name = fold_name if optimize_on != "--|--": self.optimize_on = optimize_on if save_models != "--|--": self.save_models = save_models if with_gpu != "--|--": self.with_gpu = with_gpu if aug_type != "--|--": self.aug_type = aug_type if _dataset != "--|--": self._dataset = _dataset self.sanity_check() # # my_folds = pd.read_csv(f"../configs/configs-{self.locker['comp_name']}/my_folds.csv")[self.useful_features + [self.locker["target_name"] , self.locker["id_name"], "fold"] ] # my_folds = pd.read_parquet( # f"../input/input-{self.locker['comp_name']}/my_folds.parquet", # columns=self.useful_features # + [self.locker["target_name"], self.locker["id_name"], "fold"], # ) # [self.useful_features + [self.locker["target_name"] , self.locker["id_name"], "fold"] ] # # print(my_folds.head(2)) # # taking only what is needed to reduce memory issue opt = OptunaOptimizer( model_name=self.model_name, comp_type=self.comp_type, metrics_name=self.metrics_name, n_trials=self.n_trials, prep_list=self.prep_list, fold_name = self.fold_name, optimize_on=self.optimize_on, with_gpu=self.with_gpu, save_models=self.save_models, aug_type=self.aug_type, _dataset=self._dataset, use_cutmix=self.use_cutmix, callbacks_list=self.callbacks_list, ) print(f"Total no of trials: {self.n_trials}") self.study, random_state = opt.run( self.useful_features) del opt # delete object gc.collect() if self.save_models == True: self._save_models(self.study, random_state) # Let's make perdiction on Test Set: # self._seed_it() check_memory_usage("run experiment Ends", self) tracemalloc.stop() def get_exp_no(self): # exp_no, current_level self.current_dict = load_pickle( f"../configs/configs-{self.locker['comp_name']}/current_dict.pkl" ) self.current_exp_no = int(self.current_dict["current_exp_no"]) def _save_models(self, study, random_state): Table = load_pickle(f"../configs/configs-{self.locker['comp_name']}/Table.pkl") Table = pd.DataFrame(Table) # what unifies it self.get_exp_no() # ExpNo- self.current_exp_no print("=" * 30) print(f"Current Exp no: {self.current_exp_no}") print("=" * 30) # # temp # whenever need to add new column # Table["callbacks_list"] = None # Table = Table[ # [ # "exp_no", # "model_name", # "bv", # "bp", # "random_state", # "with_gpu", # "aug_type", # "_dataset", # "use_cutmix", # "callbacks_list", # "features_list", # "level_no", # "oof_fold_name" # "opt_fold_name" # ###############"fold_no", # "no_iterations", # "prep_list", # "metrics_name", # "seed_mean", # "seed_std", # ---\ # "fold_mean", [] # "fold_std", [] # "pblb_single_seed", # "pblb_all_seed", # "pblb_all_fold", [] # "notes", # ] # ] # print(Table.columns) # input("What you see:") # # temp # Rule # initialize int/str feature with None and list with [] Table.loc[Table.shape[0], :] = [ self.current_exp_no, self.model_name, study.best_trial.value, study.best_trial.params, random_state, self.with_gpu, self.aug_type, self._dataset, self.use_cutmix, self.callbacks_list, self.useful_features, 1, #self.current_dict["current_level"], [], # oof on fold name self.fold_name, # opt on fold name self.optimize_on, self.n_trials, self.prep_list, self.metrics_name, None, None, [], [], None, None, [], self.note, ] self.current_exp_no += 1 # --------------- dump experiment no self.current_dict["current_exp_no"] = self.current_exp_no save_pickle( f"../configs/configs-{self.locker['comp_name']}/current_dict.pkl", self.current_dict, ) #---------------- sanity check table Table.exp_no = Table.exp_no.astype(int) Table.level_no = Table.level_no.astype(int) Table.no_iterations = Table.no_iterations.astype(int) # ---------------- dump table save_pickle(f"../configs/configs-{self.locker['comp_name']}/Table.pkl", Table) def show_variables(self): print() for i, (k, v) in enumerate(self.__dict__.items()): print(f"{i}. {k} :=======>", v) print() if __name__ == "__main__": # '100_165', # ['100_165', '98_166', '93_168', '91_171', '90_172', '89_173', '88_182', '87_183', '85_185', '84_188', '83_195', '82_186', '78_188', '75_191', '74_194', '72_195', '71_196', '70_201', '69_205', '68_208', '66_209', '65_216', '64_220', '63_229', '62_235', '61_242', '60_244', '59_245', '58_248', '52_234', '51_235', '50_237', '49_238', '48_239', '47_241', '44_242', '43_247', '42_258', '40_263', '39_266', '38_268', '37_270', 'filter35_165', 'filter34_168', 'filter33_186', 'filter32_265', 'filter31_256', 'filter30_234', 'filter29_273', 'filter28_313', 'filter27_275', 'filter26_317', 'filter25_319', 'filter24_324', 'filter23_336', 'filter22_340', 'filter21_347', 'filter20_355', 'filter19_368', 'filter18_375', 'filter17_377', 'filter16_386', 'filter15_430', 'filter14_448', 'filter13_481', 'filter12_527', 'filter11_537', 'filter10_580', 'filter9_594', 'filter8_569', 'filter7_1364', 'filter6.1_43', 'filter6_37', 'filter5_38', 'filter4_45', 'filter2_49', 'filter1_54']: for jd in [ '93_168', '91_171', '88_182', '83_195', '78_188', '70_201', '64_220', '52_234','filter23_336','filter7_1364', 'filter6.1_43']: #for jd in ['100_165', '98_166', '93_168', '91_171', '90_172', '89_173', '88_182', '87_183', '85_185', '84_188', '83_195', '82_186', '78_188', '75_191', '74_194', '72_195', '71_196', '70_201', '69_205', '68_208', '66_209', '65_216', '64_220', '63_229', '62_235', '61_242', '60_244', '59_245', '58_248', '52_234', '51_235', '50_237', '49_238', '48_239', '47_241', '44_242', '43_247', '42_258', '40_263', '39_266', '38_268', '37_270', 'filter35_165', 'filter34_168', 'filter33_186', 'filter32_265', 'filter31_256', 'filter30_234', 'filter29_273', 'filter28_313', 'filter27_275', 'filter26_317', 'filter25_319', 'filter24_324', 'filter23_336', 'filter22_340', 'filter21_347', 'filter20_355', 'filter19_368', 'filter18_375', 'filter17_377', 'filter16_386', 'filter15_430', 'filter14_448', 'filter13_481', 'filter12_527', 'filter11_537', 'filter10_580', 'filter9_594', 'filter8_569', 'filter7_1364', 'filter6.1_43', 'filter6_37', 'filter5_38', 'filter4_45', 'filter2_49', 'filter1_54']: # ========================================================== useful_features = [] # auto_features =['ver2_statistical'] # for f in auto_features: # useful_features += amzcomp1_settings().feature_dict[f] auto_features = [jd] for f in auto_features: useful_features += amzcomp1_settings().auto_filtered_features[f] useful_features = list(set(useful_features)) # exp 20 features added #useful_features += ['Water_Supply_Once in two days', 'Dust_and_Noise_Medium', 'Property_Area', 'Dust_and_Noise_Low', 'Crime_Rate_Well above average', 'Property_Type_Bungalow', 'Traffic_Density_Score', 'Crime_Rate_Slightly below average', 'Number_of_Windows', 'Property_Type_Single-family home', 'Power_Backup_Yes', 'Air_Quality_Index', 'Frequency_of_Powercuts', 'Crime_Rate_Well below average', 'Neighborhood_Review', 'Property_Type_Apartment', 'Water_Supply_Once in a day - Evening', 'Furnishing_Semi_Furnished', 'Water_Supply_Once in a day - Morning', 'Property_Type_Container Home', 'Property_Type_Duplex', 'Water_Supply_NOT MENTIONED', 'Number_of_Doors', 'Power_Backup_No', 'Furnishing_Unfurnished'] # ========================================================== model_name = "xgbr" # -----s---> """ [ "lgr", "lir", "xgb", "xgbc", "xgbr", "cbc", "cbr", "mlpc", "rg", "ls", "knnc", "dtc", "adbc", "gbmc" , "gbmr, "hgbc", "lgb", "lgbmc", "lgbmr", "rfc" , "rfr", # --------------->["tabnetr", "tabnetc", "k1", "k2", "k3", "tez1", "tez2", "p1" ,"pretrained"] """ comp_type = ( "2class" # -------->["regression", "2class","multi_class", "multi_label"] ) metrics_name = "amzcomp1_metrics" # --------->["getaroom_metrics", "amex_metric","amex_metric_mod", "accuracy","f1","recall","precision", "auc", "logloss","auc_tf","mae","mse","rmse","msle","rmsle","r2"] n_trials = 100 #0 #30 # ------------> no of times to run optuna prep_list = [ "Sd", ] # ------> ["SiMe", "SiMd",~ "SiMo", "Mi", "Ro", "Sd", "Lg"] <= _prep_list prep_list = [] fold_name = "fold5" # ['fold3', 'fold5', 'fold10', 'fold20'] optimize_on = [random.choice(range(5))] # [0] # fold on which optimize # 0,1,2,4 with_gpu = True aug_type = "aug2" # "aug1", "aug2", "aug3", "aug4" _dataset = "DigitRecognizerDataset" # "BengaliDataset", "ImageDataset", "DigitRecognizerDataset", "DigitRecognizerDatasetTez2" use_cutmix = False # CALLBACKS # lgbmClassifiers callback: # https://lightgbm.readthedocs.io/en/latest/Python-API.html#callbacks """ ############################ change learning rate custom schedulers :=>cosine_decay , exponential_decay, simple_decay built in scheduler :=>"ReduceLROnPlateau" # EarlyStopping, ############################# save model :=>chk_pt : whether to use checkpoint or not ############################### stop training :=>terminate_on_NaN >Callbacks monitor a particular varaibable and stops exectuion when it crosses fixed value , >early_top also monitors a particular value but it stops when it stops improving it has some patience builtin callback :=>early_stopping custom callback :=>myCallback1 """ # don't use early_stopping with cyclic decay lr because model gets good and bad periodically and it doesn't mean we should terminate. # "swa", "cosine_decay", "exponential_decay", "simple_decay", "ReduceLROnPlateau", "chk_pt", "terminate_on_NaN", "early_stopping", "myCallback1" callbacks_list = ["terminate_on_NaN"] # ["exponential_decay", "terminate_on_NaN"] # [swa,early_stop] # ----------------------------------------------------------- note = "ragnar" e = Agent( useful_features=useful_features, model_name=model_name, comp_type=comp_type, metrics_name=metrics_name, n_trials=n_trials, prep_list=prep_list, fold_name = fold_name, optimize_on=optimize_on, with_gpu=with_gpu, aug_type=aug_type, _dataset=_dataset, use_cutmix=use_cutmix, callbacks_list=callbacks_list, note=note, ) print("=" * 40) print("Useful_features:", useful_features) e.run() del e # ------------------------------------------------------------- # exp_list = ["1"] # ----------------> [1,2,3,4] # e.show(exp_list) """ {'learning_rate': 0.010821262164314453, 'max_depth': 16, 'min_child_weight': 5, 'subsample': 0.4521783648128741, 'n_estimators': 500, 'objective': 'reg:squarederror', 'tree_method': 'gpu_hist', 'gpu_id': 0, 'predictor': 'gpu_predictor'} """ # Make prediction also os.system(f"python predict.py") #break

File no 14: /src-framework3/feature_generator.py
import pandas as pd import numpy as np from scipy.stats import skew from scipy.stats import median_abs_deviation #from statsmodels import robust from sklearn import model_selection import os import sys import pickle from collections import defaultdict from utils import * #from auto_exp import * """ generates new features on top of some existing featrues. and stores this info(title: [column_names_generated, columns_name_used_to_generate]) as a dictionary. # This dictionary is used only to diplay it is not used to get access of features> # Features accessed by their name initials: pred_.. feat_... """ class features: def __init__(self): with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() self.comp_name = comp_name self.locker = load_pickle(f"../configs/configs-{comp_name}/locker.pkl") # ------------------------------------- self.test_feat_path = f"../configs/configs-{comp_name}/test_feats/" self.train_feat_path = f"../configs/configs-{comp_name}/train_feats/" self.level_no = None self.current_dict = None #-------------------------------------------------- self.get_feat_no() # load level_no and current_feature_no from DISC # self.level_no and self.current_feature_no is update along with selfcurrent_dict #---------------------------------------------------- self.useful_features = load_pickle( f"../configs/configs-{self.locker['comp_name']}/useful_features_l_{self.level_no}.pkl" ) # from patsylearn import PatsyTransformer # transformer = PatsyTransformer("y ~ a + b + a^2 + b^2") # transformer.fit(data) def change_level(self, new_val="--|--"): if new_val != "--|--": self.level_no = new_val else: self.level_no += 1 self.current_dict["current_level"] = self.level_no save_pickle( f"../configs/configs-{self.locker['comp_name']}/current_dict.pkl", self.current_dict, ) def display_features_generated(self): # display all the feature engineering done so far # Key:- f"l{self.level_no}_f{feat_no}" # value:- [created, from , info] self.feat_dict = load_pickle( f"../configs/configs-{self.locker['comp_name']}/features_dict.pkl" ) for key, value in self.feat_dict.items(): print(f"Title: {key}") print("features created:") print(value[0]) # print("from:") # print(value[1]) print() def show_variables(self): print() for i, (k, v) in enumerate(self.__dict__.items()): print(f"{i}. {k} :=======>", v) print() def get_feat_no(self): # exp_no, current_level, current_feature_no self.current_dict = load_pickle( f"../configs/configs-{self.locker['comp_name']}/current_dict.pkl" ) self.level_no = int(self.current_dict["current_level"]) self.current_feature_no = int(self.current_dict["current_feature_no"]) def isRepetition(self, gen_features, old_features, feat_title): # f"create_statistical_features_l_{self.level_no}_f_{self.feat_no}" # Standard naming convention # f"feat_l_{self.level_no}_f_{self.feat_no}_csf # feat_dict[f"exp_{self.exp_no}"] = [ # [f"pred_e_{self.exp_no}_{self.fold_name}"], # self.useful_features # ] # feat_l_2_f_23_std # self.curr for key, value in self.feat_dict.items(): if key.split("_")[0]== "feat": # it is a feature entry # feat_l_{self.level_no}_f_{feat_no}_nan_count # old_features same and title same if set(value[0]) == set(old_features) and key.split("_")[-1] == feat_title: raise Exception(f"This set of feature is already there. details key name: {key}") # for key, value in self.feat_dict.items(): # f1, f2, ft = value # if f2 == 0: # # from base # pass # elif len(f1[0].split("_")[0]) < 5 or ( # f1[0].split("_")[0][0] == "l" and f1[0].split("_")[0][2] == "f" # ): # # originate from base so f2 can't be split # f1 = ["_".join(f.split("_")[2:]) for f in f1] # gen_features = ["_".join(f.split("_")[2:]) for f in gen_features] # else: # f2 = ["_".join(f.split("_")[2:]) for f in f2] # old_features = ["_".join(f.split("_")[2:]) for f in old_features] # f1 = ["_".join(f.split("_")[2:]) for f in f1] # gen_features = ["_".join(f.split("_")[2:]) for f in gen_features] # if f1 == gen_features and f2 == old_features and ft == feat_title: # raise Exception("This feature is already present!") def create_statistical_features(self, useful_features="--|--"): fill_na_with = -100 if useful_features == "--|--": useful_features = self.useful_features else: self.useful_features = useful_features # Get train, test from bottleneck: #------------------------------------------------------------------------ # BOTTLENECK return_type = "numpy_array" self.optimize_on = None # just to make sure it is not called fold_name = "fold_check" #self._state = "seed" state = "seed" self.val_idx, self.my_folds, self.xvalid, self.ytrain, self.yvalid, ordered_list_test = bottleneck(self.locker['comp_name'],self.useful_features, fold_name, self.optimize_on, state, return_type) self.xvalid = None self.yvalid = None self.val_idx = None self.test,ordered_list_train = bottleneck_test(self.locker['comp_name'], self.useful_features, return_type) # sanity check: for i,j in zip(ordered_list_test, ordered_list_train): if i != j: raise Exception(f"Features don't correspond in test - train {i},{j}") ordered_list_test = None ordered_list_train = None # self.test, self.my_folds #------------------------------------------------------------------------ self.get_feat_no() # --updated self.current_feature_no to the latest feat no # self.level_no, self.current_feature_no self.feat_dict = load_pickle( f"../configs/configs-{self.locker['comp_name']}/features_dict.pkl" ) # new set of feature is created so increase feat no feat_no = self.current_feature_no + 1 #feat_no = 10 feat_title = f"feat_l_{self.level_no}_f_{feat_no}_csf{fill_na_with}" # to mke it unique in the dictionary # ------------------------------------------ new_features = [ f"feat_l_{self.level_no}_f_{feat_no}_nan_count", f"feat_l_{self.level_no}_f_{feat_no}_num_missing_std", f"feat_l_{self.level_no}_f_{feat_no}_abs_sum", f"feat_l_{self.level_no}_f_{feat_no}_sem", f"feat_l_{self.level_no}_f_{feat_no}_std", f"feat_l_{self.level_no}_f_{feat_no}_medianad", f"feat_l_{self.level_no}_f_{feat_no}_meanad", f"feat_l_{self.level_no}_f_{feat_no}_avg", f"feat_l_{self.level_no}_f_{feat_no}_median", f"feat_l_{self.level_no}_f_{feat_no}_max", f"feat_l_{self.level_no}_f_{feat_no}_min", f"feat_l_{self.level_no}_f_{feat_no}_skew", ] # --------------------------Duplicacy check self.isRepetition( new_features, useful_features, feat_title ) # check for duplicate process print(self.train_feat_path) print(self.test_feat_path) print() #------------------------------------------------- # nan_count try: # for dataframe: self.test.isnull().sum(axis=1) val1= np.isnan(self.test).sum(axis=1) save_pickle(self.test_feat_path+ f"test_feat_l_{self.level_no}_f_{feat_no}_nan_count.pkl", val1) val2= np.isnan(self.my_folds).sum(axis=1) save_pickle(self.train_feat_path+ f"train_feat_l_{self.level_no}_f_{feat_no}_nan_count.pkl", val2) print(val2) print(val1) print() except: raise Exception(f"Couldn't create feat_l_{self.level_no}_f_{feat_no}_nan_count") #-------------------------------------------------------------- # num_missing_std try: # for dataframe: self.test.isnull().sum(axis=1) val1= np.isnan(self.test).std(axis=1).astype("float") save_pickle(self.test_feat_path+ f"test_feat_l_{self.level_no}_f_{feat_no}_num_missing_std.pkl", val1) val2= np.isnan(self.my_folds).std(axis=1).astype("float") save_pickle(self.train_feat_path+ f"train_feat_l_{self.level_no}_f_{feat_no}_num_missing_std.pkl", val2) print(val2) print(val1) print() except: raise Exception(f"Couldn't create feat_l_{self.level_no}_f_{feat_no}_num_missing_std") # below all are affected by nan # ------------------------------------------------- # So first fill nan self.my_folds[np.isnan(self.my_folds)] = fill_na_with self.test[np.isnan(self.test)] = fill_na_with # sanity check assert np.isnan(self.my_folds).sum() ==0 assert np.isnan(self.test).sum() ==0 # quite different value is added #----------------------------------------------------- # abs_sum : nan affected try: # for dataframe: self.test.isnull().sum(axis=1) val1= np.abs(self.test).sum(axis=1) print(val1.shape, "abs_sum") save_pickle(self.test_feat_path+ f"test_feat_l_{self.level_no}_f_{feat_no}_abs_sum.pkl", val1) val2= np.abs(self.my_folds).sum(axis=1) save_pickle(self.train_feat_path+ f"train_feat_l_{self.level_no}_f_{feat_no}_abs_sum.pkl", val2) print(val2) print(val1) print() except: raise Exception(f"Couldn't create feat_l_{self.level_no}_f_{feat_no}_abs_sum") # sem : nan affected try: # for dataframe: self.test.isnull().sum(axis=1) val1= np.std(self.test, axis=1)/np.sqrt(self.test.shape[1]) print(val1.shape, "val1") save_pickle(self.test_feat_path+ f"test_feat_l_{self.level_no}_f_{feat_no}_sem.pkl", val1) val2= np.std(self.my_folds, axis=1)/np.sqrt(self.my_folds.shape[1]) save_pickle(self.train_feat_path+ f"train_feat_l_{self.level_no}_f_{feat_no}_sem.pkl", val2) print(val2) print(val1) print() except: raise Exception(f"Couldn't create feat_l_{self.level_no}_f_{feat_no}_sem") # std : nan affected try: # for dataframe: self.test.isnull().sum(axis=1) val1= np.std(self.test, axis=1) save_pickle(self.test_feat_path+ f"test_feat_l_{self.level_no}_f_{feat_no}_std.pkl", val1) val2= np.std(self.my_folds, axis=1) save_pickle(self.train_feat_path+ f"train_feat_l_{self.level_no}_f_{feat_no}_std.pkl", val2) print(val2) print(val1) print() except: raise Exception(f"Couldn't create feat_l_{self.level_no}_f_{feat_no}_std") # medianad : nan affected try: # for dataframe: self.test.isnull().sum(axis=1) # need to reshpae since medina creates 1D array and thus can't be broadcasted to 2D #val1= np.median(np.absolute(self.test - np.median(self.test, axis=1)), axis=1).reshape(-1) #val1 = self.test.mad(axis=1) #robust.mad(self.test, axis=1) val1 = median_abs_deviation(self.test, axis=1) save_pickle(self.test_feat_path+ f"test_feat_l_{self.level_no}_f_{feat_no}_medianad.pkl", val1) #val2= np.median(np.absolute(self.my_folds - np.median(self.my_folds, axis=1)), axis=1).reshape(-1) #val2 = self.my_folds.mad(axis=1) #robust.mad(self.my_folds, axis=1) val2 = median_abs_deviation(self.my_folds, axis=1) save_pickle(self.train_feat_path+ f"train_feat_l_{self.level_no}_f_{feat_no}_medianad.pkl", val2) print(val2) print(val1) print() except: raise Exception(f"Couldn't create feat_l_{self.level_no}_f_{feat_no}_medianad") # meanad : nan affected try: # for dataframe: self.test.isnull().sum(axis=1) # need to reshpae since medina creates 1D array and thus can't be broadcasted to 2D #val1= np.median(np.absolute(self.test - np.median(self.test, axis=1)), axis=1).reshape(-1) val1 = np.mean(np.abs(self.test - np.mean(self.test, axis=1).reshape(-1,1)), axis=1) save_pickle(self.test_feat_path+ f"test_feat_l_{self.level_no}_f_{feat_no}_meanad.pkl", val1) #val2= np.median(np.absolute(self.my_folds - np.median(self.my_folds, axis=1)), axis=1).reshape(-1) val2 = np.mean(np.abs(self.my_folds - np.mean(self.my_folds, axis=1).reshape(-1,1)), axis=1) save_pickle(self.train_feat_path+ f"train_feat_l_{self.level_no}_f_{feat_no}_meanad.pkl", val2) print(val2) print(val1) print() except: raise Exception(f"Couldn't create feat_l_{self.level_no}_f_{feat_no}_meanad") # avg : nan affected try: # for dataframe: self.test.isnull().sum(axis=1) # need to reshpae since medina creates 1D array and thus can't be broadcasted to 2D val1= np.mean(self.test, axis=1) save_pickle(self.test_feat_path+ f"test_feat_l_{self.level_no}_f_{feat_no}_avg.pkl", val1) val2= np.mean(self.my_folds, axis=1) save_pickle(self.train_feat_path+ f"train_feat_l_{self.level_no}_f_{feat_no}_avg.pkl", val2) print(val2) print(val1) print() except: raise Exception(f"Couldn't create feat_l_{self.level_no}_f_{feat_no}_avg") # median : nan affected try: # for dataframe: self.test.isnull().sum(axis=1) # need to reshpae since medina creates 1D array and thus can't be broadcasted to 2D val1= np.median(self.test, axis=1) save_pickle(self.test_feat_path+ f"test_feat_l_{self.level_no}_f_{feat_no}_median.pkl", val1) val2= np.median(self.my_folds, axis=1) save_pickle(self.train_feat_path+ f"train_feat_l_{self.level_no}_f_{feat_no}_median.pkl", val2) print(val2) print(val1) print() except: raise Exception(f"Couldn't create feat_l_{self.level_no}_f_{feat_no}_median") # max : nan affected try: # for dataframe: self.test.isnull().sum(axis=1) # need to reshpae since medina creates 1D array and thus can't be broadcasted to 2D val1= np.max(self.test, axis=1) save_pickle(self.test_feat_path+ f"test_feat_l_{self.level_no}_f_{feat_no}_max.pkl", val1) val2= np.max(self.my_folds, axis=1) save_pickle(self.train_feat_path+ f"train_feat_l_{self.level_no}_f_{feat_no}_max.pkl", val2) print(val2) print(val1) print() except: raise Exception(f"Couldn't create feat_l_{self.level_no}_f_{feat_no}_max") # min : nan affected try: # for dataframe: self.test.isnull().sum(axis=1) # need to reshpae since medina creates 1D array and thus can't be broadcasted to 2D val1= np.min(self.test, axis=1) save_pickle(self.test_feat_path+ f"test_feat_l_{self.level_no}_f_{feat_no}_min.pkl", val1) val2= np.min(self.my_folds, axis=1) save_pickle(self.train_feat_path+ f"train_feat_l_{self.level_no}_f_{feat_no}_min.pkl", val2) print(val2) print(val1) print() except: raise Exception(f"Couldn't create feat_l_{self.level_no}_f_{feat_no}_min") # skew : nan affected try: # for dataframe: self.test.isnull().sum(axis=1) # need to reshpae since medina creates 1D array and thus can't be broadcasted to 2D val1= np.min(self.test, axis=1) save_pickle(self.test_feat_path+ f"test_feat_l_{self.level_no}_f_{feat_no}_skew.pkl", val1) val2= np.min(self.my_folds, axis=1) save_pickle(self.train_feat_path+ f"train_feat_l_{self.level_no}_f_{feat_no}_skew.pkl", val2) print(val2) print(val1) print() except: raise Exception(f"Couldn't create feat_l_{self.level_no}_f_{feat_no}_skew") del val1, val2 gc.collect() print(new_features) print() v = input("Are you sure you want to add these features?: [y/n]") if v.lower() == 'n': raise Exception("Process terminated.") # -----------------------------dump current dict self.current_feature_no = feat_no self.current_dict["current_level"] = self.level_no self.current_dict["current_feature_no"] = self.current_feature_no save_pickle( f"../configs/configs-{self.locker['comp_name']}/current_dict.pkl", self.current_dict, ) # -----------------------------dump feature dictionary feat_dict = load_pickle( f"../configs/configs-{self.locker['comp_name']}/features_dict.pkl" ) feat_dict[feat_title] = [new_features, useful_features] # feat_dict[f"l_{self.level_no}_f_{feat_no}"] = [ # new_features, # useful_features, # feat_title, # ] save_pickle( f"../configs/configs-{self.locker['comp_name']}/features_dict.pkl", feat_dict, ) print("New features created:- ") print(new_features) def create_unique_characters(self, useful_features="--|--"): raise Exception("Don't enter") feat_title = "unique_characters" self.my_folds = pd.read_csv( f"../configs/configs-{self.locker['comp_name']}/my_folds.csv" ) self.test = pd.read_csv( f"../configs/configs-{self.locker['comp_name']}/test.csv" ) if useful_features == "--|--": useful_features = self.useful_features self.get_feat_no() # --updated self.current_feature_no to the latest feat no self.feat_dict = load_pickle( f"../configs/configs-{self.locker['comp_name']}/features_dict.pkl" ) feat_no = self.current_feature_no + 1 # ------------------------------------------ # From https://www.kaggle.com/ambrosm/tpsmay22-eda-which-makes-sense new_features = [] for i in range(10): new_features.append(f"ch{i}") new_features.append(f"unique_characters") # ------------------------------------------------- self.isRepetition( new_features, useful_features, feat_title ) # check for duplicate process # ------------------------------------------------- for df in [self.test, self.my_folds]: for i in range(10): df[f"ch{i}"] = df.f_27.str.get(i).apply(ord) - ord("A") df["unique_characters"] = df.f_27.apply(lambda s: len(set(s))) # -----------------------------dump data self.my_folds.to_csv( f"../configs/configs-{self.locker['comp_name']}/my_folds.csv", index=False ) self.test.to_csv( f"../configs/configs-{self.locker['comp_name']}/test.csv", index=False ) # -----------------------------dump current dict self.current_feature_no = feat_no self.current_dict["current_level"] = self.level_no self.current_dict["current_feature_no"] = self.current_feature_no save_pickle( f"../configs/configs-{self.locker['comp_name']}/current_dict.pkl", self.current_dict, ) # -----------------------------dump feature dictionary feat_dict = load_pickle( f"../configs/configs-{self.locker['comp_name']}/features_dict.pkl" ) feat_dict[f"l_{self.level_no}_f_{feat_no}"] = [ new_features, useful_features, feat_title, ] save_pickle( f"../configs/configs-{self.locker['comp_name']}/features_dict.pkl", feat_dict, ) print("New features create:- ") print(new_features) def create_interaction_features(self, useful_features="--|--"): raise Exception("Don't enter") feat_title = "interaction_features" self.my_folds = pd.read_csv( f"../configs/configs-{self.locker['comp_name']}/my_folds.csv" ) self.test = pd.read_csv( f"../configs/configs-{self.locker['comp_name']}/test.csv" ) if useful_features == "--|--": useful_features = self.useful_features else: self.useful_features = useful_features self.get_feat_no() # --updated self.current_feature_no to the latest feat no self.feat_dict = load_pickle( f"../configs/configs-{self.locker['comp_name']}/features_dict.pkl" ) feat_no = self.current_feature_no + 1 # ------------------------------------------ # From https://www.kaggle.com/ambrosm/tpsmay22-eda-which-makes-sense new_features = ["i_02_21", "i_05_22", "i_00_01_26"] # ------------------------------------------------- self.isRepetition( new_features, useful_features, feat_title ) # check for duplicate process # ------------------------------------------------- for df in [self.test, self.my_folds]: df["i_02_21"] = (df.f_21 + df.f_02 > 5.2).astype(int) - ( df.f_21 + df.f_02 < -5.3 ).astype(int) df["i_05_22"] = (df.f_22 + df.f_05 > 5.1).astype(int) - ( df.f_22 + df.f_05 < -5.4 ).astype(int) i_00_01_26 = df.f_00 + df.f_01 + df.f_26 df["i_00_01_26"] = (i_00_01_26 > 5.0).astype(int) - ( i_00_01_26 < -5.0 ).astype(int) # -----------------------------dump data self.my_folds.to_csv( f"../configs/configs-{self.locker['comp_name']}/my_folds.csv", index=False ) self.test.to_csv( f"../configs/configs-{self.locker['comp_name']}/test.csv", index=False ) # -----------------------------dump current dict self.current_feature_no = feat_no self.current_dict["current_level"] = self.level_no self.current_dict["current_feature_no"] = self.current_feature_no save_pickle( f"../configs/configs-{self.locker['comp_name']}/current_dict.pkl", self.current_dict, ) # -----------------------------dump feature dictionary feat_dict = load_pickle( f"../configs/configs-{self.locker['comp_name']}/features_dict.pkl" ) feat_dict[f"l_{self.level_no}_f_{feat_no}"] = [ new_features, useful_features, feat_title, ] save_pickle( f"../configs/configs-{self.locker['comp_name']}/features_dict.pkl", feat_dict, ) print("New features create:- ") print(new_features) def create_polynomial_features(self,title, useful_features="--|--"): if useful_features == "--|--": useful_features = self.useful_features else: self.useful_features = useful_features # Get train, test from bottleneck: #------------------------------------------------------------------------ # BOTTLENECK return_type = "numpy_array" self.optimize_on = None # just to make sure it is not called fold_name = "fold_check" #self._state = "seed" state = "seed" self.val_idx, self.xtrain, self.xvalid, self.ytrain, self.yvalid, ordered_list_train = bottleneck(self.locker['comp_name'],self.useful_features, fold_name, self.optimize_on, state, return_type) self.xvalid = None self.yvalid = None self.val_idx = None print(self.xtrain.shape) self.xtrain = pd.DataFrame(self.xtrain, columns = useful_features) print(self.xtrain.iloc[:10,:5]) self.test,ordered_list_test = bottleneck_test(self.locker['comp_name'], self.useful_features, return_type) print(self.test.shape) self.test = pd.DataFrame(self.test, columns = useful_features) # sanity check: for i,j in zip(ordered_list_test, ordered_list_train): if i != j: raise Exception(f"Features don't correspond in test - train {i},{j}") useful_features = ordered_list_test # just to make sure order ordered_list_test = None ordered_list_train = None # self.test, self.my_folds #------------------------------------------------------------------------ # This updated input folder #---------------------------------------------- # places where feature are updated #1> useful_features_l_1 #2> feature_dict (here base is never used so can skip) #3> input_dict self.input_dict = load_pickle( f"../input/input-{self.comp_name}/input_dict.pkl" ) print("input dict before") print(self.input_dict.keys()) useful_features_l_1 = load_pickle(f"../configs/configs-{self.comp_name}/useful_features_l_1.pkl") print("Total features before", len(useful_features_l_1)) # ------------------------------------------ self.xtrain = self.xtrain.values self.test = self.test.values train_dummy = np.array([], dtype=np.int8).reshape(self.xtrain.shape[0],0) test_dummy = np.array([], dtype=np.int8).reshape(self.test.shape[0],0) no_features = len(useful_features) generated_features = [] for i in range(no_features): f = useful_features[i] generated_features += [f"{f}*{useful_features[i]}" for i in range(no_features)] train_dummy = np.concatenate((train_dummy, self.xtrain* self.xtrain[:,i].reshape(-1,1)), axis=1) test_dummy = np.concatenate((test_dummy, self.test* self.test[:,i].reshape(-1,1)), axis=1) print("After") print(train_dummy.shape) print(test_dummy.shape) print(len(generated_features)) print(generated_features[:6]) # poly = PolynomialFeatures(degree=2, interaction_only=True, include_bias=False) # t= poly.fit_transform(self.xtrain) # print(t.shape) # print(t.iloc[:10,:5]) # # PUSH FEATURES self.input_dict[f"{title}_interact"] = generated_features print("input dict after ") print(self.input_dict.keys()) useful_features_l_1 += generated_features # sanity check remove duplicate if called twice #assert len(useful_features_l_1) == len(list(set(useful_features_l_1))) useful_features_l_1 = list(set(useful_features_l_1)) print("Total features after", len(useful_features_l_1)) print(useful_features_l_1[:4]) v = input("Do you want to create these features? y/Y or else: ") if v.lower() == "y": self.xtrain = pd.DataFrame(train_dummy , columns = generated_features) self.test = pd.DataFrame(test_dummy , columns = generated_features) self.xtrain.to_parquet(f"../input/input-{self.comp_name}/train_{title}_interact.parquet") self.test.to_parquet(f"../input/input-{self.comp_name}/test_{title}_interact.parquet") save_pickle(f"../input/input-{self.comp_name}/input_dict.pkl", self.input_dict) save_pickle(f"../configs/configs-{self.comp_name}/useful_features_l_1.pkl",useful_features_l_1) print("Updated!") print() print(f"Title: {title}_interact") print() print(generated_features) else: print("Aborted!") def pull_input(self, source_comp_name, source_feat_name): """ source_comp_name = "amex4" source_feat_name = "last_mean_diff" """ train_dummy = pd.read_parquet(f"../input/input-{source_comp_name}/train_{source_feat_name}.parquet") test_dummy = pd.read_parquet(f"../input/input-{source_comp_name}/test_{source_feat_name}.parquet") generated_features = list(train_dummy.columns) #---------------------------------------------- # places where feature are updated #1> useful_features_l_1 #2> feature_dict (here base is never used so can skip) #3> input_dict self.input_dict = load_pickle( f"../input/input-{self.comp_name}/input_dict.pkl" ) print("input dict before") print(self.input_dict.keys()) useful_features_l_1 = load_pickle(f"../configs/configs-{self.comp_name}/useful_features_l_1.pkl") print("Total features before", len(useful_features_l_1)) print("Total Generated features", len(generated_features)) # ------------------------------------------ # PUSH FEATURES self.input_dict[source_feat_name] = generated_features print("input dict after ") print(self.input_dict.keys()) useful_features_l_1 += generated_features # sanity check remove duplicate if called twice assert len(useful_features_l_1) == len(list(set(useful_features_l_1))) useful_features_l_1 = list(set(useful_features_l_1)) print("Total features after", len(useful_features_l_1)) print(useful_features_l_1[:4]) v = input("Do you want to create these features? y/Y or else: ") if v.lower() == "y": self.xtrain = pd.DataFrame(train_dummy , columns = generated_features) self.test = pd.DataFrame(test_dummy , columns = generated_features) self.xtrain.to_parquet(f"../input/input-{self.comp_name}/train_{source_feat_name}.parquet") self.test.to_parquet(f"../input/input-{self.comp_name}/test_{source_feat_name}.parquet") save_pickle(f"../input/input-{self.comp_name}/input_dict.pkl", self.input_dict) save_pickle(f"../configs/configs-{self.comp_name}/useful_features_l_1.pkl",useful_features_l_1) print("Updated!") print() print(generated_features) else: print("Aborted!") from settings import * if __name__ == "__main__": with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() with open(f"../configs/configs-{comp_name}/locker.pkl", "rb") as f: a = pickle.load(f) # ---------------------------------------------------------- # ----------------------------------------------------------- ft = features() ## Statistical features useful_features = amzcomp1_settings.feature_dict['ver2'] #ft.create_statistical_features( useful_features) # ------------ # ft.create_unique_characters() # ft.create_interaction_features() # Interaction/polynomial features #useful_features = amzcomp1_settings().filtered_features['filter6'] title = 'ver2' print("Feature to interact") print(useful_features) #input() ft.create_polynomial_features(title, useful_features) #ft.create_statistical_features(useful_features) #ft.display_features_generated() # title = '--' # amex = amex4_settings() # useful_features = amex.feature_dict2[title] # print(useful_features) # ft.create_polynomial_features(title,useful_features) # source_comp_name = "amexdummy" # source_feat_name = 'date' # ft.pull_input(source_comp_name=source_comp_name, source_feat_name=source_feat_name) # print("===================") # # ft.show_variables() # useful_features = getaroom_settings().feature_dict['base'] # title = "base" # print(useful_features) # ft.create_polynomial_features(title,useful_features)

File no 15: /src-framework3/feature_picker.py
import pandas as pd from sklearn import model_selection import os import sys import pickle from collections import defaultdict """ picks features for training a model params: list of levels, list of features, title. """ class Picker: def __init__(self): with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() self.locker = self.load_pickle(f"../configs/configs-{comp_name}/locker.pkl") # ---------------------------------------------------------- self.list_levels = [] self.list_features = [] self.list_feat_title = [] self.feat_dict = self.load_pickle( f"../configs/configs-{self.locker['comp_name']}/features_dict.pkl" ) def show_variables(self): print() for i, (k, v) in enumerate(self.__dict__.items()): print(f"{i}. {k} :=======>", v) print() def save_pickle(self, path, to_dump): with open(path, "wb") as f: pickle.dump(to_dump, f) def load_pickle(self, path): with open(path, "rb") as f: o = pickle.load(f) return o def find_keys( self, list_levels="--|--", list_features="--|--", list_feat_title="--|--" ): # -----------------------------dump feature dictionary if list_levels != "--|--": self.list_levels = list_levels if list_features != "--|--": self.list_features = list_features if list_feat_title != "--|--": self.list_feat_title = list_feat_title all_keys = list(self.feat_dict.keys()) valid_keys1 = list(self.feat_dict.keys()) valid_keys2 = list(self.feat_dict.keys()) valid_keys3 = list(self.feat_dict.keys()) if self.list_levels != []: valid_keys1 = [] for key in list(self.feat_dict.keys()): t = str(key).split("_")[1] if t in str(self.list_levels): valid_keys1.append(key) if self.list_features != []: valid_keys2 = [] for key in list(self.feat_dict.keys()): t = str(key).split("_")[3] if t in str(self.list_features): valid_keys2.append(key) if self.list_feat_title != []: valid_keys3 = [] for key, val in list(self.feat_dict.items()): if str(val[2]) in str(self.list_feat_title): valid_keys3.append(key) valid_keys = set(valid_keys1).intersection(set(valid_keys2)) valid_keys = list(valid_keys.intersection(set(valid_keys3))) return valid_keys def find_features( self, list_levels="--|--", list_features="--|--", list_feat_title="--|--" ): # -----------------------------dump feature dictionary if list_levels != "--|--": self.list_levels = list_levels if list_features != "--|--": self.list_features = list_features if list_feat_title != "--|--": self.list_feat_title = list_feat_title valid_keys = self.find_keys( self.list_levels, self.list_features, self.list_feat_title ) valid_features = [] for key in valid_keys: valid_features += self.feat_dict[key][0] return valid_features def help(self): # display all the feature engineering done so far # Key:- f"l{self.level_no}_f{feat_no}" # value:- [created, from , info] for key, value in self.feat_dict.items(): print(key, f"{value[-1]} :-") print("features created:") print(value[0]) print("from:") print(value[1]) print("=" * 40) if __name__ == "__main__": p = Picker() # p.list_levels = ["1"] # p.list_features = ["1", "2", "0"] p.list_feat_title = ["unique_characters"] print(p.find_keys()) print() print(p.find_features())

File no 16: /src-framework3/find_roots.py
import os import sys from utils import * def roots(exp_no): with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() Table = load_pickle(f"../configs/configs-{comp_name}/Table.pkl") base = load_pickle(f"../configs/configs-{comp_name}/useful_features_l_1.pkl") Features = [] Exp = [] exp_list = [exp_no] while True: current_features = [] temp = [] for e in exp_list: if e == 'base': temp.append((e, 'NA')) continue else: e = int(e) current_features += Table.loc[Table.exp_no == e, 'features_list'][e] temp.append((e, Table.loc[Table.exp_no == e, 'model_name'][e])) Exp.append(temp) # print(exp_list) # print() Features.append(current_features) entered = False exp_list = [] for feat in current_features: # if feat in base: exp_list.append('base') pass else: entered = True exp_list.append(feat.split("_")[2]) exp_list= list(sorted(set(exp_list))) if entered is False: # all base features # so break break # for f in Features: # print(f) # print() for i,j in enumerate(Exp[::-1]): print(f"LEVEL {i}:", j) print() if __name__ == '__main__': exp_no = 240 roots(exp_no)

File no 17: /src-framework3/global_variables.py
name = "temp" lr_start = 0 lr_end = 0 epochs = 0 # for the animation part of logs done = False # dart lgb max_score = 0.75 fold = 0 exp_no = None counter = 0 # mkdir exp_no = 0

File no 18: /src-framework3/grab.py
import os import pandas as pd import pickle import sys """ used to show stored variables: """ class Storage: def __init__(self): # read all stored files: # ----------------------------Keys and store it in [locker] with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() with open(f"../configs/configs-{comp_name}/locker.pkl", "rb") as f: self.locker = pickle.load(f) # ----------------------------current dict self.current_dict = self.load_pickle( f"../configs/configs-{self.locker['comp_name']}/current_dict.pkl" ) # -----------------------------features dict self.features_dict = self.load_pickle( f"../configs/configs-{self.locker['comp_name']}/features_dict.pkl" ) # ----------------------------base features self.useful_features_l1 = self.load_pickle( f"../configs/configs-{self.locker['comp_name']}/useful_features_l_1.pkl" ) # -----------------------------Table self.Table = self.load_pickle( f"../configs/configs-{self.locker['comp_name']}/Table.pkl" ) # ------------------------------my folds # self.my_folds = pd.read_csv( # f"../configs/configs-{self.locker['comp_name']}/my_folds.csv" # ) self.my_folds = pd.read_parquet( f"../input/input-{self.locker['comp_name']}/my_folds.parquet" ) # ------------------------------ test self.test = None if self.locker["data_type"] == "tabular": # self.test = pd.read_csv(f"../configs/configs-{self.locker['comp_name']}/test.csv") self.test = pd.read_parquet( f"../input/input-{self.locker['comp_name']}/test.parquet" ) # ---------------------------------container self.names = [ "locker", "current_dict", "features_dict", "useful_features_l1", "Table", "my_folds", "test", ] self.obj = [ self.locker, self.current_dict, self.features_dict, self.useful_features_l1, self.Table, self.my_folds, self.test, ] def show(self, list_keys): for k in list_keys: if int(k) < len(self.names) and int(k) >= 0: # valid if self.names[k] == "Table": print(f"{k}. {self.names[k]} :=======>") print(self.obj[k]) elif k == 2: # asked for feture dict # for f1,f2,ft in self.obj[k]: # print(ft) for i,(l,val) in enumerate(self.features_dict.items()): print(l) print(val[0],"-->",val[1]) print() print() #print(self.features_dict) #print(self.features_dict.keys()) else: print(f"{k}. {self.names[k]} :=======>", self.obj[k]) print() else: print(f"{k} is not a valid key!") def get(self, key_no): if int(key_no) < len(self.names) and int(key_no) >= 0: # valid return self.obj[key_no] else: raise Exception(f"{key_no} is not a valid key!") def get_log_table(self, exp_no): # -------------------------------log table log_table = self.load_pickle( f"../configs/configs-{self.locker['comp_name']}/log_exp_{exp_no}.pkl" ) return log_table def show_log_table(self, exp_no): print(self.get_log_table(exp_no)) def help(self): print("functions: show() get() show_log_table() get_log_table()") print() for i, n in enumerate(self.names): print(f"{i} :=======>", n) print() def save_pickle(self, path, to_dump): with open(path, "wb") as f: pickle.dump(to_dump, f) def load_pickle(self, path): with open(path, "rb") as f: o = pickle.load(f) return o if __name__ == "__main__": s = Storage() s.help() s.show([2]) # s.show([0, 1, 2, 3, 4])

File no 19: /src-framework3/info.txt
pip install -r requirements.txt conda install scikit-learn [TABULAR STEPS] STEP-->1 : First set ref STEP-->2 : run init_folders.py --> create_datasets.py STEP-->3 : put train.parquet, test.parquet, sample.parquet in input folder [requirement] train:- id_col, features, target ( train may or may not have id column but test must have id column) [if not in parquet then convert using csv_to_parquet.py] [Now see once input content train, sample, test using show_input.py] test:- id_col, features sample:- id_col, target STEP-->4 : run keys.py STEP-->5 : run create_folds.py [ Create New id columns for train] [ No need to sort test as test will always have submission with id column just never RESHUFFLE] [ Sort train by id column, if not create one by reshuffling since when we get folds we will also sort them] [No need to sort test, we just predict on them, no training] train------------------->my_folds # After this what should we have these files in input folder # what we did is train------------------->my_folds my_folds:- id_col, features, target , fold_cols test:- id_col, features sample:- id_col, target_col [You may now remove train folder] check once everything is as it should be using show_input.py STEP-->6 : run experiment.py / auto_exp.py # we should pass list of optimize_on in run() We won't be predicting for all the experiments we do. So keep log_exp_22.pkl file in a subfolder also make seperate folder for preds: oof_preds, test_preds # After 5-6 hr do plot the auto table to see which set performs well and you can limit the search in that direction # Like "f_base", "f_max" performs quite well STEP-->7 : run predict.py or run seed_it.py # calls opt() function but not run() so keep it that way as obj() don't require optimize_on Note : run() takes list optimize_on : obj() takes single integer optimize_on for each fold : both takes fold_name STEP-->8 : run output.py after running predict.py STEP-->9 : make submission submit.py kaggle competitions list kaggle competitions leaderboard amex-default-prediction --show | --download kaggle competitions submisssions amex-default-prediction kaggle competitions submit ventilator-pressure-prediction -f submission.csv -m "exp_{}_fold/single/all" #submit your submission.csv Note: all parquet file contains id and target , all pkl files contain 1d prediction STEP-->10 : auto_exp # initialize datasets # configs: should contain only those file which is used to reproduce the submission. So Table, and the log files[very small size file 1kb so keep it as it is used later for visualization] , my_folds, test, locker, current_dict # no need to store seed_all and seed_single file as they are not used in creating ensemble of models, # seed_all/seed_single since trained on full datasets are end points and can be only used to make submission and achieve highest possible. # tabular df: # image_df: image pixels are stored as dataframe STEPS: 1> move train.csv ,test.csv, sample.csv to models_ [make name train,test,sample] 2> decide: id_name : as that of train id columns target_name : as that of sample target column -----------Make format like below exactly ---------------------- train: ImageId, Label, pixel0, pixel1, pixel2, ... , pixel200, test: ImageId, pixel0, pixel1, pixel2, ... , pixel200 sample: ImageId, Label # sample may be huge in size and it don't change over time unline my_folds and test, so it is better to keep # fixed things in input 3> run keys.py after setting appropriate name of variables 4> run create_folds.py to create [my_folds.csv] # image_path: there is train.csv and sample.csv folder which contains image name and there are image folders initially> (before putting image ID column do sample(frac=1)) train.csv: image_id, target sample.csv: image_id, fake_target target_name >> sample target name id_name >> sample id name STEPS: 1> move train.csv to models_ by first rename id_name to image1.jpeg 2> move sample.csv to models_ as test.csv by first renaming id_name to image2.jpeg 3> move sample to models_ [image_id, target] 4> run keys.py after setting appropriate name of variables 5> run create_folds.py to create [my_folds.csv] # image folder # Note:- keep [self.valid_preds] and [spyelf.test_preds] ############################################################ # CREATE DATASETS # ############################################################ op 1> Create empty datasets on kaggle manually op 2> init datasets from cmd and create it after changing json names pickle is best but works only inside python while Feather is more portable across languages than pickle /home/pramit_mazumdar/anaconda3/envs/AKR_env2/bin/pip show pandas Need to be compatible in case of pickle #AKR_env2: 1.4.2 #AKR_env: 1.3.5 #kaggle: 1.3.5 # This is stable !pip install --upgrade pandas==1.3.5 For saving pandas dataframe parquet is best For saving 1D numpy array pkl is best # NOT THAT GREAT BENEFIT # Regarding improving speed in Case of exp:- save the optimize on fold in disc and call it everytime directly no need to preprocess and all Case of auto_exp:- Can't help here Case of seed:- save full dataset preprocessed Case of predict: Case of folds:- save each fold preprocessed ## To Do: implement First sort my_folds then save back [DONE] # then takeout predictions and keep separately [DONE] # save auto_logs separately for different model. reason:- different model has different sets of settings and same for all experiment with same model name Also saving different table is good because as no of exp increases then loading whole dataset will take up quit a space. # delete Table where ever possible # make oof/test preds contain fold10, fold5 do same for features_dict and while finding features in bottleneck and sanity_check [DONE] # remove reading test file each time inside for loop of predict # just after fitting model we can actually deleted xtrain, ytrain # idea source:- https://www.kaggle.com/code/ambrosm/amex-lightgbm-quickstart #--> Big Step do later # implement fillna_with parameter but in next comp # If we make sepearte Table for each model will that not help create multi-processing [ SPLIT EVERYTHING MODEL WISE ] ( so at one time only work on one experiment in a given model, but will allow to work on separate model simultaneously also loading time of table will decrease) # current dict of each model will be also different : Actually no need to maintain it just load from the table last row [Just store level no, and when we jump to level 2 we will not run any code for the moment, that we can do] In that way we don't have to deal with the issue of current dict overwritten by unwanted experiment 2 LEVEL REF comp_name >>> model_name ######################################################## # DATASETS # ######################################################## # amex: Some previous version of ambrosm """ has no nan so can train NN """ # amex2: V9: Better hyperparameters , ambrosm """ has nans so don't train NN """ fold3 3 =============> 1 : 305942 152971 2 : 305942 152971 3 : 305942 152971 fold5 5 =============> 1 : 367130 91783 2 : 367130 91783 3 : 367130 91783 4 : 367131 91782 5 : 367131 91782 fold10 10 =============> 1 : 413021 45892 2 : 413021 45892 3 : 413021 45892 4 : 413022 45891 5 : 413022 45891 6 : 413022 45891 7 : 413022 45891 8 : 413022 45891 9 : 413022 45891 10 : 413022 45891 fold20 20 =============> 1 : 435967 22946 2 : 435967 22946 3 : 435967 22946 4 : 435967 22946 5 : 435967 22946 6 : 435967 22946 7 : 435967 22946 8 : 435967 22946 9 : 435967 22946 10 : 435967 22946 11 : 435967 22946 12 : 435967 22946 13 : 435967 22946 14 : 435968 22945 15 : 435968 22945 16 : 435968 22945 17 : 435968 22945 18 : 435968 22945 19 : 435968 22945 20 : 435968 22945 # amex3: Devastator: train shape (458913, 2635), test shape (924621, 2634) #1815) fold3 3 =============> 1 : 305942 152971 2 : 305942 152971 3 : 305942 152971 fold5 5 =============> 1 : 367130 91783 2 : 367130 91783 3 : 367130 91783 4 : 367131 91782 5 : 367131 91782 fold10 10 =============> 1 : 413021 45892 2 : 413021 45892 3 : 413021 45892 4 : 413022 45891 5 : 413022 45891 6 : 413022 45891 7 : 413022 45891 8 : 413022 45891 9 : 413022 45891 10 : 413022 45891 fold20 20 =============> 1 : 435967 22946 2 : 435967 22946 3 : 435967 22946 4 : 435967 22946 5 : 435967 22946 6 : 435967 22946 7 : 435967 22946 8 : 435967 22946 9 : 435967 22946 10 : 435967 22946 11 : 435967 22946 12 : 435967 22946 13 : 435967 22946 14 : 435968 22945 15 : 435968 22945 16 : 435968 22945 17 : 435968 22945 18 : 435968 22945 19 : 435968 22945 20 : 435968 22945 # amex4: ragnar latest my_folds (458913, 3358), test (924621, 3353) # useful_features 3352 fold3 3 =============> 1 : 305942 152971 2 : 305942 152971 3 : 305942 152971 fold5 5 =============> 1 : 367130 91783 2 : 367130 91783 3 : 367130 91783 4 : 367131 91782 5 : 367131 91782 fold10 10 =============> 1 : 413021 45892 2 : 413021 45892 3 : 413021 45892 4 : 413022 45891 5 : 413022 45891 6 : 413022 45891 7 : 413022 45891 8 : 413022 45891 9 : 413022 45891 10 : 413022 45891 fold20 20 =============> 1 : 435967 22946 2 : 435967 22946 3 : 435967 22946 4 : 435967 22946 5 : 435967 22946 6 : 435967 22946 7 : 435967 22946 8 : 435967 22946 9 : 435967 22946 10 : 435967 22946 11 : 435967 22946 12 : 435967 22946 13 : 435967 22946 14 : 435968 22945 15 : 435968 22945 16 : 435968 22945 17 : 435968 22945 18 : 435968 22945 19 : 435968 22945 20 : 435968 22945

File no 20: /src-framework3/keys.py
from collections import defaultdict import pickle import os import sys """ generates keys and stores it in models-ultramnist """ class KeyMaker: def __init__( self, random_state=21, target_name="Survived", id_name="PassengerId", comp_type="2class", metrics_name="accuracy", fold_dict={'fold5':5}, data_type="image", # ["image", "tabular", "text"] ): # with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() self._comp_name = comp_name self.data_type = data_type self.metrics_list = [ "accuracy", "f1", "recall", "precision", "auc", "logloss", "auc_tf", "mae", "mse", "rmse", "msle", "rmsle", "r2", "amex_metric", ] self.data_list = ["tabular", "image", "text"] self.comp_list = ["regression", "2class", "multi_class", "multi_label"] self.random_state = random_state self.target_name = target_name self.id_name = id_name self.comp_type = comp_type self.metrics_name = metrics_name self.fold_dict = fold_dict self.locker = defaultdict() self.sanity_check() # --> sanity check self.update() # dumps files as pickel def sanity_check(self): if self.comp_type not in self.comp_list: raise Exception(f"{self.comp_type} not in the list {self.comp_list}") if self.metrics_name not in self.metrics_list: raise Exception(f"{self.metrics_name} not in the list {self.metrics_name}") if self.data_type not in self.data_list: raise Exception(f"{self.data_type} not in the list {self.data_type}") def help(self): print("comp_type:=> ", [comp for i, comp in enumerate(self.comp_list)]) print("metrics_index:=>", [mt for i, mt in enumerate(self.metrics_list)]) def __call__( self, random_state="--|--", target_name="--|--", id_name="--|--", comp_type="--|--", metrics_name="--|--", fold_dict="--|--", data_type="--|--", ): with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() with open(f"../configs/configs-{comp_name}/locker.pkl", "rb") as f: a = pickle.load(f) self.random_state = a["random_state"] self.target_name = a["target_name"] self.id_name = a["id_name"] self.comp_type = a["comp_type"] self.metrics_name = a["metrics_name"] self.fold_dict = a["fold_dict"] self.data_type = a["data_type"] if random_state != "--|--": # updated self.random_state = random_state if target_name != "--|--": # updated self.target_name = target_name if id_name != "--|--": # updated self.id_name = id_name if comp_type != "--|--": self.comp_type = comp_type if metrics_name != "--|--": self.metrics_name = metrics_name if fold_dict != "--|--": self.fold_dict = fold_dict if data_type != "--|--": self.data_type = data_type self.sanity_check() self.update() # dump files to pickel def update(self): # updates the locker a = self.locker self.locker["comp_name"] = self._comp_name self.locker["random_state"] = self.random_state self.locker["target_name"] = self.target_name self.locker["id_name"] = self.id_name self.locker["comp_type"] = self.comp_type self.locker["fold_dict"] = self.fold_dict self.locker["data_type"] = self.data_type with open(f"../configs/configs-{a['comp_name']}/locker.pkl", "wb") as f: pickle.dump(self.locker, f) def show_stored_keys(self): with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() with open(f"../configs/configs-{comp_name}/locker.pkl", "rb") as f: a = pickle.load(f) for k, v in a.items(): print(f"{k}:", v) def show_variables(self): print() for i, (k, v) in enumerate(self.__dict__.items()): print(f"{i}. {k} :=======>", v) print() if __name__ == "__main__": x = KeyMaker() # # ultramnist # x.id_name = "id" # x.target_name = "digit_sum" # x.comp_type = "multi_class" # x.no_folds = 5 # x.data_type = "image_path" ## mnist # x.id_name = "ImageId" # x.target_name = "Label" # x.comp_type = "multi_class" # x.no_folds = 5 # x.data_type = "image_df" # image_path, image_df, image_folder # twistmnist # x.id_name = "image_id" # x.target_name = "label" # x.comp_type = "multi_class" # x.no_folds = 5 # x.data_type = "image_df" # bengaliai # x.id_name = "image_id" # x.target_name = ['grapheme_root','vowel_diacritic','consonant_diacritic'] # x.comp_type = "multi_label" # x.no_folds = 5 # x.data_type = "image_path" # # tmay # x.id_name = "id" # x.target_name = "target" # x.comp_type = "2class" # x.no_folds = 5 # x.data_type = "tabular" # # # amex # x.id_name = "customer_ID" # x.target_name = "prediction" # x.comp_type = "2class" # x.fold_dict = { # no_folds : replace it # "fold3": 3, # "fold5": 5, # "fold10": 10, # "fold20": 20 # } # 10 # x.data_type = "tabular" # amex5 # x.id_name = "customer_ID" # x.target_name = "prediction" # x.comp_type = "2class" # x.no_folds = 5 # x.data_type = "tabular" # # getaroom # x.id_name = "Property_ID" # x.target_name = "Habitability_score" # x.comp_type = "regression" # x.fold_dict = { # no_folds : replace it # "fold3": 3, # "fold5": 5, # "fold10": 10, # "fold20": 20 # } # 10 # x.data_type = "tabular" x.id_name = "ID" x.target_name = "Time_taken" x.comp_type = "regression" x.fold_dict = { # no_folds : replace it "fold3": 3, "fold5": 5, "fold10": 10, "fold20": 20 } # 10 x.data_type = "tabular" x.update() # # x.show_stored_keys()

File no 21: /src-framework3/metrics.py
from sklearn import metrics as skmetrics import tensorflow as tf import numpy as np import pandas as pd # https://stackoverflow.com/questions/47152610/what-is-the-difference-between-xgb-train-and-xgb-xgbregressor-or-xgb-xgbclassif import xgboost as xgb # when calling the low level api """ Regression:=> use .predict() Classification:=> use.predict() except auc/log_loss auc/log_loss:= binary problem: (n_samples,) .predict_proba()[:,1] multiclass problem: (n_samples, n_classes) .predict_proba() true: [0,2,1,4,2] 1D array pred: [ [0.1, 0.7, 0.2], [0.2, 0.3, 0.5], ... ] """ def log_return(list_stock_prices): return np.log(list_stock_prices).diff() def realized_volatility(series_log_return): return np.sqrt(np.sum(series_log_return**2)) def rmspe(y_true, y_pred): return (np.sqrt(np.mean(np.square((y_true - y_pred) / y_true)))) def feval_RMSPE(preds, train_data): labels = train_data.get_label() return 'RMSPE', round(rmspe(y_true = labels, y_pred = preds),5), False def getaroom_metrics(y_true, y_pred): return max( 0, 100*(skmetrics.r2_score(y_true , y_pred))) def amzcomp1_metrics(y_true, y_pred): return max( 0, 100*(skmetrics.r2_score(y_true , y_pred))) class RegressionMetrics: def __init__(self): self.metrics = { "mae": self._mae, "mse": self._mse, "rmse": self._rmse, "msle": self._msle, "rmsle": self._rmsle, "r2": self._r2, } def __call__(self, metric, y_true, y_pred): if metric not in self.metrics: raise Exception(f"{metrics}: Metric not implemented") if metric == "mae": return self._mae(y_true=y_true, y_pred=y_pred) if metric == "mse": return self._mse(y_true=y_true, y_pred=y_pred) if metric == "rmse": return self._rmse(y_true=y_true, y_pred=y_pred) if metric == "msle": return self._msle(y_true=y_true, y_pred=y_pred) if metric == "rmsle": return self._rmsle(y_true=y_true, y_pred=y_pred) if metric == "r2": return self._r2(y_true=y_true, y_pred=y_pred) @staticmethod def _mae(y_true, y_pred): return skmetrics.mean_absolute_error(y_true=y_true, y_pred=y_pred) @staticmethod def _mse(y_true, y_pred): return skmetrics.mean_squared_error(y_true=y_true, y_pred=y_pred) def _rmse(self, y_true, y_pred): return np.sqrt(self._mse(y_true, y_pred)) @staticmethod def _msle(y_true, y_pred): return skmetrics.mean_squared_log_error(y_true=y_true, y_pred=y_pred) def _rmsle(self, y_true, y_pred): return np.sqrt(self._msle(y_true, y_pred)) @staticmethod def _r2(y_true, y_pred): return skmetrics.r2_score(y_true=y_true, y_pred=y_pred) class ClassificationMetrics: def __init__(self): self.metrics = { "accuracy": self._accuracy, "f1": self._f1, "recall": self._recall, "precision": self._precision, "auc": self._auc, "logloss": self._logloss, "auc_tf": self._auc_tf, "amex_metric": self.amex_metric, } # it allows to use an instance of this class as a function # a= Class..ics() then a("auc",y_true,y_pred) # y_pred is HARD CLASS 1,2,0,.. def __call__(self, metric, y_true, y_pred, y_proba=None): if metric not in self.metrics: raise Exception(f"{metric}: Metric not implemented") if metric == "auc": if y_proba is None: raise Exception(f"y_proba can't be None for {metric}") return self._auc(y_true=y_true, y_pred=y_proba) if metric == "logloss": if y_proba is None: raise Exception(f"y_proba can't be None for {metric}") return self._auc(y_true=y_true, y_pred=y_proba) if metric == "auc_tf": if y_proba is None: raise Exception(f"y_proba can't be None for {metric}") return self._auc_tf(y_true=y_true, y_pred=y_proba) if metric == "amex_metric": if y_proba is None: raise Exception(f"y_proba can't be None for {metric}") return self.amex_metric(y_true=y_true, y_pred=y_proba) else: return self.metrics[metric](y_true=y_true, y_pred=y_pred) @staticmethod def _accuracy(y_true, y_pred): return skmetrics.accuracy_score(y_true=y_true, y_pred=y_pred) @staticmethod def _f1(y_true, y_pred): return skmetrics.f1_score(y_true=y_true, y_pred=y_pred) @staticmethod def _recall(y_true, y_pred): return skmetrics.recall_score(y_true=y_true, y_pred=y_pred) @staticmethod def _precision(y_true, y_pred): return skmetrics.precision_score(y_true=y_true, y_pred=y_pred) @staticmethod def _auc(y_true, y_pred): # auc expects probability so we need y_proba return skmetrics.roc_auc_score(y_true=y_true, y_score=y_pred) @staticmethod def _logloss(y_true, y_pred): return skmetrics.log_loss(y_true=y_true, y_pred=y_pred) @staticmethod def _auc_tf(y_true, y_pred): # should have cuda enabled def fallback_auc(y_true, y_pred): try: return metrics.roc_auc_score(y_true, y_pred) except: return 0.5 return tf.py_function(fallback_auc, (y_true, y_pred), tf.double) @staticmethod def amex_metric(y_true: pd.DataFrame, y_pred: pd.DataFrame) -> float: def top_four_percent_captured( y_true: pd.DataFrame, y_pred: pd.DataFrame ) -> float: df = pd.concat([y_true, y_pred], axis="columns").sort_values( "prediction", ascending=False ) df["weight"] = df["target"].apply(lambda x: 20 if x == 0 else 1) four_pct_cutoff = int(0.04 * df["weight"].sum()) df["weight_cumsum"] = df["weight"].cumsum() df_cutoff = df.loc[df["weight_cumsum"] <= four_pct_cutoff] return (df_cutoff["target"] == 1).sum() / (df["target"] == 1).sum() def weighted_gini(y_true: pd.DataFrame, y_pred: pd.DataFrame) -> float: df = pd.concat([y_true, y_pred], axis="columns").sort_values( "prediction", ascending=False ) df["weight"] = df["target"].apply(lambda x: 20 if x == 0 else 1) df["random"] = (df["weight"] / df["weight"].sum()).cumsum() total_pos = (df["target"] * df["weight"]).sum() df["cum_pos_found"] = (df["target"] * df["weight"]).cumsum() df["lorentz"] = df["cum_pos_found"] / total_pos df["gini"] = (df["lorentz"] - df["random"]) * df["weight"] return df["gini"].sum() def normalized_weighted_gini( y_true: pd.DataFrame, y_pred: pd.DataFrame ) -> float: y_true_pred = y_true.rename(columns={"target": "prediction"}) return weighted_gini(y_true, y_pred) / weighted_gini(y_true, y_true_pred) # sanity check y_true = pd.DataFrame(y_true, columns=["target"]) y_pred = pd.DataFrame(y_pred, columns=["prediction"]) # g = normalized_weighted_gini(y_true, y_pred) d = top_four_percent_captured(y_true, y_pred) return 0.5 * (g + d) # @yunchonggan's fast metric implementation # From https://www.kaggle.com/competitions/amex-default-prediction/discussion/328020 def amex_metric(y_true: np.array, y_pred: np.array) -> float: # count of positives and negatives n_pos = y_true.sum() n_neg = y_true.shape[0] - n_pos # sorting by descring prediction values indices = np.argsort(y_pred)[::-1] preds, target = y_pred[indices], y_true[indices] # filter the top 4% by cumulative row weights weight = 20.0 - target * 19.0 cum_norm_weight = (weight / weight.sum()).cumsum() four_pct_filter = cum_norm_weight <= 0.04 # default rate captured at 4% d = target[four_pct_filter].sum() / n_pos # weighted gini coefficient lorentz = (target / n_pos).cumsum() gini = ((lorentz - cum_norm_weight) * weight).sum() # max weighted gini coefficient gini_max = 10 * n_neg * (1 - 19 / (n_pos + 20 * n_neg)) # normalized weighted gini coefficient g = gini / gini_max return 0.5 * (g + d) # ==================================================== # lgbmc amex metric # ==================================================== # custom callback: https://lightgbm.readthedocs.io/en/latest/pythonapi/lightgbm.LGBMClassifier.html def lgbmc_amex_metric(y_true, y_pred): # M1 # Classification # cl = ClassificationMetrics() # return ("amex", cl("amex_metric",y_true,"y_pred_dummy",y_pred), True) # M2 # https://www.kaggle.com/code/ambrosm/amex-lightgbm-quickstart """The competition metric with lightgbm's calling convention""" return ('amex', amex_metric(y_true, y_pred), True) # https://www.kaggle.com/kyakovlev # https://www.kaggle.com/competitions/amex-default-prediction/discussion/327534 def amex_metric_mod(y_true, y_pred): labels = np.transpose(np.array([y_true, y_pred])) labels = labels[labels[:, 1].argsort()[::-1]] weights = np.where(labels[:,0]==0, 20, 1) cut_vals = labels[np.cumsum(weights) <= int(0.04 * np.sum(weights))] top_four = np.sum(cut_vals[:,0]) / np.sum(labels[:,0]) gini = [0,0] for i in [1,0]: labels = np.transpose(np.array([y_true, y_pred])) labels = labels[labels[:, i].argsort()[::-1]] weight = np.where(labels[:,0]==0, 20, 1) weight_random = np.cumsum(weight / np.sum(weight)) total_pos = np.sum(labels[:, 0] * weight) cum_pos_found = np.cumsum(labels[:, 0] * weight) lorentz = cum_pos_found / total_pos gini[i] = np.sum((lorentz - weight_random) * weight) return 0.5 * (gini[1]/gini[0] + top_four) # ==================================================== # XGBOOST amex metric # ==================================================== def xgboost_amex_metric_mod(predt: np.ndarray, dtrain: xgb.DMatrix): y = dtrain.get_label() return 'AMEXcustom', 1 - amex_metric_mod(y, predt) def xgboost_amex_metric_mod1(predt: np.ndarray, dtrain: xgb.DMatrix): y = dtrain.get_label() return 'AMEXcustom', 1 - amzcomp1_metrics(y, predt) # ==================================================== # Amex metric # ==================================================== def amex_metric_lgb_base(y_true, y_pred): labels = np.transpose(np.array([y_true, y_pred])) labels = labels[labels[:, 1].argsort()[::-1]] weights = np.where(labels[:,0]==0, 20, 1) cut_vals = labels[np.cumsum(weights) <= int(0.04 * np.sum(weights))] top_four = np.sum(cut_vals[:,0]) / np.sum(labels[:,0]) gini = [0,0] for i in [1,0]: labels = np.transpose(np.array([y_true, y_pred])) labels = labels[labels[:, i].argsort()[::-1]] weight = np.where(labels[:,0]==0, 20, 1) weight_random = np.cumsum(weight / np.sum(weight)) total_pos = np.sum(labels[:, 0] * weight) cum_pos_found = np.cumsum(labels[:, 0] * weight) lorentz = cum_pos_found / total_pos gini[i] = np.sum((lorentz - weight_random) * weight) return 0.5 * (gini[1]/gini[0] + top_four) # ==================================================== # LGB amex metric # ==================================================== # https://www.kaggle.com/code/ragnar123/amex-lgbm-dart-cv-0-7963 def lgb_amex_metric(y_pred, y_true): y_true = y_true.get_label() return 'amex_metric', amex_metric_lgb_base(y_true, y_pred), True # ==================================================== # amex custom metrics for keras # ==================================================== from keras import backend as K import tensorflow as tf def amex_metric_tensorflow(y_true: tf.Tensor, y_pred: tf.Tensor) -> float: # convert dtypes to float64 y_true = tf.cast(y_true, dtype=tf.float64) y_pred = tf.cast(y_pred, dtype=tf.float64) # count of positives and negatives n_pos = tf.math.reduce_sum(y_true) n_neg = tf.cast(tf.shape(y_true)[0], dtype=tf.float64) - n_pos # sorting by descring prediction values indices = tf.argsort(y_pred, axis=0, direction='DESCENDING') preds, target = tf.gather(y_pred, indices), tf.gather(y_true, indices) # filter the top 4% by cumulative row weights weight = 20.0 - target * 19.0 cum_norm_weight = tf.cumsum(weight / tf.reduce_sum(weight)) four_pct_filter = cum_norm_weight <= 0.04 # default rate captured at 4% d = tf.reduce_sum(target[four_pct_filter]) / n_pos # weighted gini coefficient lorentz = tf.cumsum(target / n_pos) gini = tf.reduce_sum((lorentz - cum_norm_weight) * weight) # max weighted gini coefficient gini_max = 10 * n_neg * (1 - 19 / (n_pos + 20 * n_neg)) # normalized weighted gini coefficient g = gini / gini_max return 0.5 * (g + d) ########################################################### # cbc custom metrics ############################################################## # https://stackoverflow.com/questions/65462220/how-to-create-custom-eval-metric-for-catboost # https://www.kaggle.com/code/thedevastator/ensemble-lightgbm-catboost-xgboost def amex_metric_cbc(y_true, y_pred): labels = np.transpose(np.array([y_true, y_pred])) labels = labels[labels[:, 1].argsort()[::-1]] weights = np.where(labels[:,0]==0, 20, 1) cut_vals = labels[np.cumsum(weights) <= int(0.04 * np.sum(weights))] top_four = np.sum(cut_vals[:,0]) / np.sum(labels[:,0]) gini = [0,0] for i in [1,0]: labels = np.transpose(np.array([y_true, y_pred])) labels = labels[labels[:, i].argsort()[::-1]] weight = np.where(labels[:,0]==0, 20, 1) weight_random = np.cumsum(weight / np.sum(weight)) total_pos = np.sum(labels[:, 0] * weight) cum_pos_found = np.cumsum(labels[:, 0] * weight) lorentz = cum_pos_found / total_pos gini[i] = np.sum((lorentz - weight_random) * weight) return 0.5 * (gini[1]/gini[0] + top_four) class CustomMetric_cbc(object): def get_final_error(self, error, weight): return error def is_max_optimal(self): return True def evaluate(self, approxes, target, weight): return amex_metric_cbc(np.array(target), approxes[0]), 1.0

File no 22: /src-framework3/model_dispatcher.py
import custom_models MODEL_DISPATCHER = {"resnet34": custom_models.ResNet34} if __name__ == "__main__": pass

File no 23: /src-framework3/optuna_search.py
from metrics import ClassificationMetrics from metrics import RegressionMetrics from metrics import * from collections import defaultdict import pickle import sys from sklearn.model_selection import KFold from sklearn.metrics import roc_auc_score, accuracy_score, f1_score from sklearn.metrics import roc_auc_score from sklearn.ensemble import GradientBoostingClassifier, GradientBoostingRegressor, ExtraTreesClassifier from sklearn.ensemble import HistGradientBoostingClassifier, HistGradientBoostingRegressor from scipy import stats import gc import psutil import seaborn as sns import tracemalloc import pathlib from settings import * """ ################ """ # import albumentations import numpy as np import pandas as pd # import timm import torch import torch.nn as nn from sklearn import metrics, model_selection from torch.utils.data import Dataset, DataLoader ######### #Tabnet from pytorch_tabnet.metrics import Metric from pytorch_tabnet.tab_model import TabNetRegressor, TabNetClassifier from pytorch_tabnet.pretraining import TabNetPretrainer ######################## # use it only when using tez2 i.e latest version # from tez import Tez, TezConfig # from tez.callbacks import EarlyStopping # from tez.utils import seed_everything # use this will pip install tez # from tez import Tez, TezConfig # from tez.callbacks import EarlyStopping # from tez.utils import seed_everything import global_variables """ """ sns.set() from sklearn.impute import SimpleImputer from sklearn.preprocessing import StandardScaler, Normalizer, MinMaxScaler from sklearn.preprocessing import RobustScaler from sklearn.model_selection import KFold, StratifiedKFold from sklearn.linear_model import LogisticRegression, LinearRegression from sklearn.metrics import roc_auc_score, accuracy_score from xgboost import XGBClassifier, XGBRegressor # https://stackoverflow.com/questions/47152610/what-is-the-difference-between-xgb-train-and-xgb-xgbregressor-or-xgb-xgbclassif import xgboost as xgb # when calling the low level api from sklearn.preprocessing import PowerTransformer from sklearn.preprocessing import PolynomialFeatures from optuna.integration import LightGBMPruningCallback # get skewed features to impute median instead of mean from scipy.stats import skew from sklearn.ensemble import AdaBoostClassifier from sklearn.tree import DecisionTreeClassifier from imblearn.over_sampling import SMOTE from sklearn.ensemble import RandomForestClassifier, RandomForestRegressor from imblearn.pipeline import make_pipeline, Pipeline from sklearn import linear_model from sklearn.linear_model import Ridge, Lasso from sklearn.neighbors import KNeighborsClassifier from sklearn.svm import SVC from sklearn.decomposition import PCA from sklearn.metrics import roc_auc_score, f1_score from xgboost import XGBRegressor, XGBRFRegressor import itertools import optuna from lightgbm import LGBMClassifier, LGBMRegressor, log_evaluation import lightgbm as lgb from sklearn.neural_network import MLPClassifier, MLPRegressor from sklearn.ensemble import GradientBoostingClassifier from catboost import CatBoostRegressor, CatBoostClassifier # from sklearn.experimental import enable_hist_gradient_boosting from sklearn.ensemble import HistGradientBoostingClassifier # import the necessary packages from tensorflow.keras.preprocessing.image import ImageDataGenerator from tensorflow.keras.applications import VGG16 from tensorflow.keras.layers import AveragePooling2D from tensorflow.keras.layers import Dropout from tensorflow.keras.layers import Flatten from tensorflow.keras.layers import Dense from tensorflow.keras.layers import Input from tensorflow.keras.models import Model from tensorflow.keras.optimizers import Adam from tensorflow.keras.utils import to_categorical from sklearn.preprocessing import LabelBinarizer from sklearn.model_selection import train_test_split from sklearn.metrics import classification_report from sklearn.metrics import confusion_matrix from imutils import paths import matplotlib.pyplot as plt import pandas as pd import numpy as np import random import shutil import cv2 import os from keras.utils import np_utils from sklearn.preprocessing import LabelEncoder from keras.utils.np_utils import to_categorical from sklearn.utils import shuffle import keras import tensorflow as tf from keras.models import Model from keras.layers import ( Dense, Dropout, LSTM, Input, Activation, concatenate, Bidirectional, ) from keras import optimizers from keras.models import Sequential from keras.layers import ( Conv2D, MaxPool2D, Flatten, Dense, Dropout, BatchNormalization, LSTM, ) from keras import regularizers from tensorflow.keras.optimizers import Adam, RMSprop, SGD, Adamax from keras.callbacks import ( EarlyStopping, ModelCheckpoint, ReduceLROnPlateau, TerminateOnNaN, LearningRateScheduler, ) import warnings # Filter up and down np.random.seed(1337) # for reproducibility warnings.filterwarnings("ignore") from metrics import ClassificationMetrics, RegressionMetrics # tez ---------------------------- import os import albumentations as A import pandas as pd import numpy as np import tez from tez.datasets import ImageDataset from tez.callbacks import EarlyStopping import torch import torch.nn as nn from torch.nn import functional as F from sklearn import metrics, model_selection, preprocessing import timm from sklearn.model_selection import KFold # ignoring warnings import warnings warnings.simplefilter("ignore") import os, cv2, json from PIL import Image import random import tez from tez.datasets import ImageDataset from tez.callbacks import EarlyStopping from custom_models import * from custom_classes import * from utils import * # ------------------------------ # keras image from tensorflow.keras.preprocessing.image import ImageDataGenerator # ------------- """ self._state = fold, opt, seed """ ##---------------- import torch from torch.optim import Adam, SGD from torch.optim.lr_scheduler import ReduceLROnPlateau, CosineAnnealingWarmRestarts from torchcontrib.optim import SWA import torch.nn as nn from model_dispatcher import MODEL_DISPATCHER class OptunaOptimizer: def __init__( self, model_name="lgr", comp_type="2class", metrics_name="accuracy", n_trials=2, # 50, fold_name = "fold3", optimize_on=[0], prep_list=[], with_gpu=False, save_models=True, aug_type="aug2", _dataset="ImageDataset", use_cutmix=True, callbacks_list=[], ): with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() self.comp_name = comp_name # put it here for the mkdir of lgb callback self.locker = load_pickle(f"../configs/configs-{comp_name}/locker.pkl") self.current_dict = load_pickle( f"../configs/configs-{self.locker['comp_name']}/current_dict.pkl" ) self.exp_no = self.current_dict["current_exp_no"] # set it as default and will be changed by predict.py and seed_it.py self.calculate_feature_importance = False # later integrate it (No need just keep saving that's all or maybe) self.calculate_permutation_feature_importance = False self.save_models = save_models self._trial_score = None self._history = None self.use_cutmix = use_cutmix self.callbacks_list = callbacks_list self.all_callbacks = [ "cosine_decay", "exponential_decay", "simple_decay", "ReduceLROnPlateau", "chk_pt", "terminate_on_NaN", "early_stopping", "myCallback1", ] self.comp_list = ["regression", "2class", "multi_class", "multi_label"] self.metrics_list = [ "accuracy", "f1", "recall", "precision", "auc", "logloss", "auc_tf", "mae", "mse", "rmse", "msle", "rmsle", "r2", "amex_metric", "amex_metric_mod" "amex_metric_lgb_base", "getaroom_metrics", "amzcomp1_metrics", ] self.model_list = [ "lgr", "lir", "xgb", "xgbc", "xgbr", "cbc", "cbr", "mlpc", "mlpr", "rg", "ls", "knnc", "dtc", "adbc", "gbmc", "gbmr", "hgbc", "lgb", "lgbmc", "lgbmr", "rfc", "rfr", "tabnetc", "tabnetr", "k1", "k2", "k3", "k4", "tez1", "tez2", "p1", "pretrained", ] self._prep_list = ["SiMe", "SiMd", "SiMo", "Mi", "Ro", "Sd", "Lg"] self.metric_list = ["amzcomp1_metrics","getaroom_metrics", "amex_metric","amex_metric_mod", "amex_metric_lgb_base","accuracy","f1","recall","precision", "auc", "logloss","auc_tf","mae","mse","rmse","msle","rmsle","r2"] self.prep_list = prep_list self.comp_type = comp_type self.metrics_name = metrics_name self.with_gpu = with_gpu self.aug_type = aug_type self._dataset = _dataset self._log_table = None # will track experiments self._state = "opt" # ["opt","fold", "seed"] # in start we want to find best params then we will loop if self.metrics_name in [ "accuracy", "f1", "recall", "precision", "auc", "auc_tf", "r2", "amex_metric", "amex_metric_mod", "amex_metric_lgb_base", "getaroom_metrics", "amzcomp1_metrics", ]: self._aim = "maximize" else: self._aim = "minimize" self.n_trials = n_trials self.best_params = None self.best_value = None self.model_name = model_name self.fold_name = fold_name self.optimize_on = optimize_on self.sanity_check() def show_variables(self): print() for i, (k, v) in enumerate(self.__dict__.items()): print(f"{i}. {k} :=======>", v) gc.collect() print() def sanity_check(self): if self.comp_type not in self.comp_list: raise Exception(f"{self.comp_type} not in the list {self.comp_list}") if self.metrics_name not in self.metrics_list: raise Exception(f"{self.metrics_name} not in the list {self.metrics_list}") if self.model_name not in self.model_list: raise Exception(f"{self.model_name} not in the list {self.model_list}") if self.fold_name not in list(self.locker['fold_dict'].keys()): raise Exception( f"{self.fold_name} not in {list(self.locker['fold_dict'].keys())}" ) for f in self.optimize_on: if f >= self.locker['fold_dict'][self.fold_name]: # self.locker["no_folds"]: raise Exception( f"{self.optimize_on} out of range {self.locker['fold_dict'][self.fold_name]}" ) for p in self.prep_list: if p not in list(self._prep_list): raise Exception(f"{p} is invalid preprocessing type!") gc.collect() for c in self.callbacks_list: if c not in self.all_callbacks: raise Exception(f"{c} is invalid callback type!") gc.collect() def help(self): print("comp_type:=> ", [comp for i, comp in enumerate(self.comp_list)]) print("metrics_name:=>", [mt for i, mt in enumerate(self.metrics_list)]) print() models = [ "LogisticRegression", "LinearRegression", "XGBClassifier", "XGBRegressor", ] print("model_name:=>") for a, b in list( zip(self.model_list, models) ): # ,[mt for i,mt in enumerate(self.model_list)]) print(f"{a}:=> {b}") gc.collect() print() preps = [ "SimpleImputer_mean", "SimpleImputer_median", "SimpleImputer_mode", "RobustScaler", "StandardScaler", "LogarithmicScaler", ] print("preprocess_names:=>") for a, b in list( zip(self._prep_list, preps) ): # ,[mt for i,mt in enumerate(self.model_list)]) print(f"{a}:=> {b}") print("preprocess_names:=>", [p for i, p in enumerate(self._prep_list)]) ## preprocess # Si: SimpleImputer SiMe SiMd SiMo # Mi: MinMaxScaler # Ro: RobustScaler # Sd: StandardScaler # Lg: Logarithmic Scaler def generate_random_no(self): if self._state == "opt": comp_random_state = self.locker["random_state"] total_no_folds = self.locker['fold_dict'][self.fold_name] #self.locker["no_folds"] # fold_on = self.optimize_on metric_no = self.metrics_list.index(self.metrics_name) comp_type_no = self.comp_list.index(self.comp_type) model_no = self.model_list.index(self.model_name) prep_no = 0 for p in self._prep_list: if p == "Lg": prep_no += 10 else: prep_no += self._prep_list.index(p) # round_on # level_on # seed = ( comp_random_state + total_no_folds * 2 + metric_no * 3 #+ self.optimize_on * 4 ) for i,o in enumerate(self.optimize_on): seed = + o * (4+i) # seed = ( # comp_random_state # + total_no_folds * 2 # + metric_no * 3 # + self.optimize_on * 4 # ) seed += int( comp_type_no * 5 + model_no * 6 + prep_no * 7 + self.current_dict["current_level"] ) # + round_on * 4 + level_on * 5 if self.callbacks_list != []: for c in self.callbacks_list: seed += self.all_callbacks.index(c) seed = int(seed) else: seed = int(self._random_state) # it should be int type os.environ["PYTHONHASHSEED"] = str(seed) np.random.seed(seed) random.seed(seed) tf.random.set_seed( seed ) # f"The truth value of a {type(self).__name__} is ambiguous. " return seed # np.random.randint(3, 1000) # it should return 5 def get_params(self, trial): model_name = self.model_name if model_name == "lgr": params = { "class_weight": trial.suggest_categorical( "class_weight", [ "balanced", None, { 1: 1, 0: ( sum(list(self.ytrain == 0)) / sum(list(self.ytrain == 1)) ), }, ], ), "penalty": trial.suggest_categorical( "penalty", ["l2"] ), # ['l1','l2']), "C": trial.suggest_float("c", 0.01, 1000), } return params if model_name == "lir": params = { "max_depth": trial.suggest_int("max_depth", 2, 15), "subsample": trial.suggest_discrete_uniform( "subsample", 0.6, 1.0, 0.05 ), "n_estimators": trial.suggest_int("n_estimators", 1000, 10000, 100), "learning_rate": trial.suggest_discrete_uniform("learning_rate", 0.01, 0.1, 0.01), "reg_alpha": trial.suggest_int("reg_alpha", 1, 50), "reg_lambda": trial.suggest_int("reg_lambda", 5, 100), "min_child_weight": trial.suggest_int("min_child_weight", 2, 20), "colsample_bytree": trial.suggest_float("colsample_bytree", 0.1, 1.0), } return params if model_name == "xgb": # for regression # https://xgboost.readthedocs.io/en/stable/python/python_intro.html#setting-parameters # https://www.kaggle.com/code/sudalairajkumar/xgb-starter-in-python # https://www.kaggle.com/general/197091 params = { "objective": trial.suggest_categorical("objective", ['reg:squarederror']), #"eta": trial.suggest_categorical("eta", ['train']), "learning_rate": trial.suggest_float("learning_rate", 0,0.2), "max_depth": trial.suggest_categorical("max_depth", [6]), "silent": trial.suggest_categorical("silent", [1]), #"num_class": trial.suggest_categorical("num_class", [3]), "eval_metric": trial.suggest_categorical("eval_metric", ['rmse']), "min_child_weight": trial.suggest_categorical("min_child_weight", [1]), "subsample": trial.suggest_categorical("subsample", [0.7]), "colsample_bytree": trial.suggest_categorical("colsample_bytree", [0.7]), "booster": trial.suggest_categorical("booster", ['gbtree']), } # diff b/w .train() and .fit() # https://stackoverflow.com/questions/47152610/what-is-the-difference-between-xgb-train-and-xgb-xgbregressor-or-xgb-xgbclassif # .fit() is a wrapper over .train() # use evaluation metrics # https://stackoverflow.com/questions/60231559/how-to-set-eval-metrics-for-xgboost-train # xgb_parms = { # 'max_depth':4, # 'learning_rate':0.05, # 'subsample':0.8, # 'colsample_bytree':0.6, # 'eval_metric':'logloss', # 'objective':'binary:logistic', # 'tree_method':'gpu_hist', # 'predictor':'gpu_predictor', # 'random_state':SEED # } ## https://www.kaggle.com/code/karandora/xgboost-optuna Implement Features also from this notebook # param = { # 'booster':'gbtree', # 'tree_method':'gpu_hist', # "objective": "binary:logistic", # 'lambda': trial.suggest_loguniform( # 'lambda', 1e-3, 10.0 # ), # 'alpha': trial.suggest_loguniform( # 'alpha', 1e-3, 10.0 # ), # 'colsample_bytree': trial.suggest_float( # 'colsample_bytree', 0.5,1,step=0.1 # ), # 'subsample': trial.suggest_float( # 'subsample', 0.5,1,step=0.1 # ), # 'learning_rate': trial.suggest_float( # 'learning_rate', 0.001,0.05,step=0.001 # ), # 'n_estimators': trial.suggest_int( # "n_estimators", 80,1000,10 # ), # 'max_depth': trial.suggest_int( # 'max_depth', 2,10,1 # ), # 'random_state': 99, # 'min_child_weight': trial.suggest_int( # 'min_child_weight', 1,256,1 # ), # } # # https://www.kaggle.com/code/sietseschrder/xgboost-starter-0-793 # params = { # "max_depth": trial.suggest_int("max_depth", 2, 10), # 6 --> 10 # "subsample": trial.suggest_discrete_uniform( # "subsample", 0.6, 1.0, 0.05 # ), # #"n_estimators": trial.suggest_int("n_estimators", 10, 100, 10), # "learning_rate": trial.suggest_discrete_uniform("learning_rate", 0.001, 0.1, 0.005), # "eta" # #"reg_alpha": trial.suggest_int("reg_alpha", 1, 10), # #"reg_lambda": trial.suggest_int("reg_lambda", 5, 20), # #"min_child_weight": trial.suggest_int("min_child_weight", 2, 20), # "colsample_bytree": trial.suggest_float("colsample_bytree", 0.1, 1.0), # "objective": trial.suggest_categorical( # "objective", ["binary:logistic"] # ) # } # big file # params = { # "max_depth": trial.suggest_int("max_depth", 2, 4), # "subsample": trial.suggest_discrete_uniform( # "subsample", 0.6, 1.0, 0.05 # ), # "n_estimators": trial.suggest_int("n_estimators", 10, 100, 10), # "eta": trial.suggest_discrete_uniform("eta", 0.01, 0.1, 0.01), # "reg_alpha": trial.suggest_int("reg_alpha", 1, 10), # "reg_lambda": trial.suggest_int("reg_lambda", 5, 20), # "min_child_weight": trial.suggest_int("min_child_weight", 2, 20), # "colsample_bytree": trial.suggest_float("colsample_bytree", 0.1, 1.0), # } # --> base Good for small dataset # params = { # "max_depth": trial.suggest_int("max_depth", 2, 15), # "subsample": trial.suggest_discrete_uniform( # "subsample", 0.6, 1.0, 0.05 # ), # "n_estimators": trial.suggest_int("n_estimators", 1000, 10000, 100), # "eta": trial.suggest_discrete_uniform("eta", 0.01, 0.1, 0.01), # "reg_alpha": trial.suggest_int("reg_alpha", 1, 50), # "reg_lambda": trial.suggest_int("reg_lambda", 5, 100), # "min_child_weight": trial.suggest_int("min_child_weight", 2, 20), # "colsample_bytree": trial.suggest_float("colsample_bytree", 0.1, 1.0), # } if self.with_gpu == True: params.update( { "tree_method": trial.suggest_categorical( "tree_method", ["gpu_hist"] ), "gpu_id": trial.suggest_categorical("gpu_id", [0]), "predictor": trial.suggest_categorical( "predictor", ["gpu_predictor"] ), } ) return params if model_name == "xgbc": # diff b/w .train() and .fit() # https://stackoverflow.com/questions/47152610/what-is-the-difference-between-xgb-train-and-xgb-xgbregressor-or-xgb-xgbclassif # .fit() is a wrapper over .train() # use evaluation metrics # https://stackoverflow.com/questions/60231559/how-to-set-eval-metrics-for-xgboost-train # xgb_parms = { # 'max_depth':4, # 'learning_rate':0.05, # 'subsample':0.8, # 'colsample_bytree':0.6, # 'eval_metric':'logloss', # 'objective':'binary:logistic', # 'tree_method':'gpu_hist', # 'predictor':'gpu_predictor', # 'random_state':SEED # } ## https://www.kaggle.com/code/karandora/xgboost-optuna Implement Features also from this notebook # param = { # 'booster':'gbtree', # 'tree_method':'gpu_hist', # "objective": "binary:logistic", # 'lambda': trial.suggest_loguniform( # 'lambda', 1e-3, 10.0 # ), # 'alpha': trial.suggest_loguniform( # 'alpha', 1e-3, 10.0 # ), # 'colsample_bytree': trial.suggest_float( # 'colsample_bytree', 0.5,1,step=0.1 # ), # 'subsample': trial.suggest_float( # 'subsample', 0.5,1,step=0.1 # ), # 'learning_rate': trial.suggest_float( # 'learning_rate', 0.001,0.05,step=0.001 # ), # 'n_estimators': trial.suggest_int( # "n_estimators", 80,1000,10 # ), # 'max_depth': trial.suggest_int( # 'max_depth', 2,10,1 # ), # 'random_state': 99, # 'min_child_weight': trial.suggest_int( # 'min_child_weight', 1,256,1 # ), # } # # https://www.kaggle.com/code/sietseschrder/xgboost-starter-0-793 # params = { # "max_depth": trial.suggest_int("max_depth", 2, 6), # "subsample": trial.suggest_discrete_uniform( # "subsample", 0.6, 1.0, 0.05 # ), # #"n_estimators": trial.suggest_int("n_estimators", 10, 100, 10), # "learning_rate": trial.suggest_discrete_uniform("learning_rate", 0.01, 0.1, 0.01), # #"reg_alpha": trial.suggest_int("reg_alpha", 1, 10), # #"reg_lambda": trial.suggest_int("reg_lambda", 5, 20), # #"min_child_weight": trial.suggest_int("min_child_weight", 2, 20), # "colsample_bytree": trial.suggest_float("colsample_bytree", 0.1, 1.0), # "objective": trial.suggest_categorical( # "objective", ["binary:logistic"] # ), # # booster implemented from below discussion chris's comment # # https://www.kaggle.com/competitions/amex-default-prediction/discussion/333953 # # Which booster to use. Can be gbtree, gblinear or dart; gbtree and dart use tree based models while gblinear uses linear functions. # #"booster": trial.suggest_categorical("booster", ["dart", "gbtree", "gblinear"]) # "booster": trial.suggest_categorical("booster", [ "gbtree", "gblinear"]) # } # big file # params = { # "max_depth": trial.suggest_int("max_depth", 2, 4), # "subsample": trial.suggest_discrete_uniform( # "subsample", 0.6, 1.0, 0.05 # ), # "n_estimators": trial.suggest_int("n_estimators", 10, 100, 10), # "eta": trial.suggest_discrete_uniform("eta", 0.01, 0.1, 0.01), # "reg_alpha": trial.suggest_int("reg_alpha", 1, 10), # "reg_lambda": trial.suggest_int("reg_lambda", 5, 20), # "min_child_weight": trial.suggest_int("min_child_weight", 2, 20), # "colsample_bytree": trial.suggest_float("colsample_bytree", 0.1, 1.0), # } params = { "max_depth": trial.suggest_int("max_depth", 2, 15), "subsample": trial.suggest_discrete_uniform( "subsample", 0.6, 1.0, 0.05 ), "n_estimators": trial.suggest_int("n_estimators", 1000, 10000, 100), "learning_rate": trial.suggest_discrete_uniform("learning_rate", 0.01, 0.1, 0.01), "reg_alpha": trial.suggest_int("reg_alpha", 1, 50), "reg_lambda": trial.suggest_int("reg_lambda", 5, 100), "min_child_weight": trial.suggest_int("min_child_weight", 2, 20), "colsample_bytree": trial.suggest_float("colsample_bytree", 0.1, 1.0), "objective": trial.suggest_categorical( "objective", ["binary:logistic"] ), # booster implemented from below discussion chris's comment # https://www.kaggle.com/competitions/amex-default-prediction/discussion/333953 # Which booster to use. Can be gbtree, gblinear or dart; gbtree and dart use tree based models while gblinear uses linear functions. #"booster": trial.suggest_categorical("booster", ["dart", "gbtree", "gblinear"]) "booster": trial.suggest_categorical("booster", ["dart", "gbtree", "gblinear"]) } # --> base Good for small dataset # params = { # "max_depth": trial.suggest_int("max_depth", 2, 15), # "subsample": trial.suggest_discrete_uniform( # "subsample", 0.6, 1.0, 0.05 # ), # "n_estimators": trial.suggest_int("n_estimators", 1000, 10000, 100), # "eta": trial.suggest_discrete_uniform("eta", 0.01, 0.1, 0.01), # "reg_alpha": trial.suggest_int("reg_alpha", 1, 50), # "reg_lambda": trial.suggest_int("reg_lambda", 5, 100), # "min_child_weight": trial.suggest_int("min_child_weight", 2, 20), # "colsample_bytree": trial.suggest_float("colsample_bytree", 0.1, 1.0), # } if self.with_gpu == True: params.update( { "tree_method": trial.suggest_categorical( "tree_method", ["gpu_hist"] ), "gpu_id": trial.suggest_categorical("gpu_id", [0]), "predictor": trial.suggest_categorical( "predictor", ["gpu_predictor"] ), } ) return params if model_name == "xgbr": params = { "learning_rate": trial.suggest_float("learning_rate", 0.01, 0.5), "max_depth": trial.suggest_int("max_depth", 3,20), #[3, 5, 7, 10] "min_child_weight": trial.suggest_categorical( "min_child_weight", [1, 3, 5] ), "subsample": trial.suggest_float("subsample", 0.01, 0.5), "n_estimators": trial.suggest_categorical( "n_estimators", [100, 200, 300, 400, 500, 1000, 1200, 1500] ), "objective": trial.suggest_categorical( "objective", ["reg:squarederror"] ), } if self.with_gpu == True: params.update( { "tree_method": trial.suggest_categorical( "tree_method", ["gpu_hist"] ), "gpu_id": trial.suggest_categorical("gpu_id", [0]), "predictor": trial.suggest_categorical( "predictor", ["gpu_predictor"] ), } ) return params if model_name == "cbc": # CatBoostClassifier(iterations=1000, random_state=22, nan_mode='Min') # https://www.kaggle.com/code/bhavikardeshna/catboost-gradient-boosting-ensemble-learning/notebook # params = { # "iterations": trial.suggest_int("iterations", 300, 1200), # 'nan_mode' : trial.suggest_categorical('nan_mode', ["Min"]) # } # main params = { "iterations": trial.suggest_int("iterations", 300, 1200), "objective": trial.suggest_categorical( "objective", ["Logloss", "CrossEntropy"] ), "bootstrap_type": trial.suggest_categorical( "bootstrap_type", ["Bernoulli"] #["Bayesian", "Bernoulli", "MVS"] ), # 'MVS' for CPU and only can be used in CPU. For GPU it is 'Bernoulli' # https://www.kaggle.com/competitions/amex-default-prediction/discussion/328606#1809347 "od_wait": trial.suggest_int("od_wait", 500, 2000), "learning_rate": trial.suggest_uniform("learning_rate", 0.02, 1), "reg_lambda": trial.suggest_uniform("reg_lambda", 1e-5, 100), "random_strength": trial.suggest_uniform("random_strength", 10, 50), "depth": trial.suggest_int("depth", 1, 15), "min_data_in_leaf": trial.suggest_int("min_data_in_leaf", 1, 30), "leaf_estimation_iterations": trial.suggest_int( "leaf_estimation_iterations", 1, 15 ), "verbose": False, } if self.with_gpu == True: params.update( { "task_type": trial.suggest_categorical("task_type", ["GPU"]), "devices": trial.suggest_categorical("devices", ["0"]), } ) return params if model_name == "cbr": # main params = { "iterations": trial.suggest_int("iterations", 300, 1000), "objective": trial.suggest_categorical( "objective", ["RMSE"] #, "MultiRMSE", "SurvivalAft", "MAE", "Quantile", "LogLinQuantile", "Poisson", "MAPE", "Lq"] ), "bootstrap_type": trial.suggest_categorical( "bootstrap_type", ["Bernoulli"] #["Bayesian", "Bernoulli", "MVS"] ), # 'MVS' for CPU and only can be used in CPU. For GPU it is 'Bernoulli' # https://www.kaggle.com/competitions/amex-default-prediction/discussion/328606#1809347 "od_wait": trial.suggest_int("od_wait", 500, 600), #900), # 2000 "learning_rate": trial.suggest_uniform("learning_rate", 0.02, 1), "reg_lambda": trial.suggest_uniform("reg_lambda", 1e-5, 30), #50), "random_strength": trial.suggest_uniform("random_strength", 10, 30), "depth": trial.suggest_int("depth", 1, 10), #15), "min_data_in_leaf": trial.suggest_int("min_data_in_leaf", 1, 20), "leaf_estimation_iterations": trial.suggest_int( "leaf_estimation_iterations", 1, 15 ), "verbose": False, } if self.with_gpu == True: params.update( { "task_type": trial.suggest_categorical("task_type", ["GPU"]), "devices": trial.suggest_categorical("devices", ["0"]), } ) return params if model_name == "mlpc": params = { "learning_rate": trial.suggest_categorical( "learning_rate", ["constant", "invscaling", "adaptive"] ), "hidden_layer_sizes": trial.suggest_categorical( "hidden_layer_sizes", [(5, 10, 5), (20, 10), (10, 20), (50, 50), (100, 100)], ), "alpha": trial.suggest_categorical( "alpha", [0.3, 0.1, 0.01, 0.001, 0.0001] ), "activation": trial.suggest_categorical( "activation", ["logistic", "relu", "tanh"] ), # "solver": trial.suggest_categorical("solver",['lbfgs']) } return params if model_name == "mlpr": params = { "learning_rate": trial.suggest_categorical( "learning_rate", ["constant", "invscaling", "adaptive"] ), "hidden_layer_sizes": trial.suggest_categorical( "hidden_layer_sizes", [(100, 100), (200,100,80),(800,40)], ), "alpha": trial.suggest_categorical( "alpha", [0.3, 0.1, 0.01, 0.001, 0.0001] ), "activation": trial.suggest_categorical( "activation", ["relu", "tanh", "identity"] ), # "solver": trial.suggest_categorical("solver",['lbfgs']) } # params = { # "learning_rate": trial.suggest_categorical( # "learning_rate", ["constant", "invscaling", "adaptive"] # ), # "hidden_layer_sizes": trial.suggest_categorical( # "hidden_layer_sizes", # [(5, 10, 5), (20, 10), (10, 20), (50, 50), (100, 100)], # ), # "alpha": trial.suggest_categorical( # "alpha", [0.3, 0.1, 0.01, 0.001, 0.0001] # ), # "activation": trial.suggest_categorical( # "activation", ["relu", "tanh", "identity"] # ), # # "solver": trial.suggest_categorical("solver",['lbfgs']) # } return params if model_name == "rg": params = { "alpha": trial.suggest_categorical( "alpha", list(np.linspace(1, 100, 100)) ), "solver": trial.suggest_categorical( "solver", ["auto", "svd", "cholesky", "lsqr", "sparse_cg", "sag", "saga"], ), "fit_intercept": trial.suggest_categorical("fit_intercept", [True]), } return params if model_name == "ls": params = { "alpha": trial.suggest_categorical( "alpha", [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0] ), "selection": trial.suggest_categorical( "selection", ["cyclic", "random"] ), "fit_intercept": trial.suggest_categorical("fit_intercept", [True]), } return params if model_name == "knnc": params = { "leaf_size": trial.suggest_categorical( "leaf_size", [5, 10, 15, 20, 25, 30, 35, 40, 45] ), "n_neighbors": trial.suggest_categorical( "n_neighbors", [3, 4, 5, 6, 7, 8, 9, 10] ), "algorithm": trial.suggest_categorical( "algorithm", ["auto", "ball_tree", "kd_tree", "brute"] ), "weights": trial.suggest_categorical( "weights", ["uniform", "distance"] ), } return params if model_name == "dtc": params = { "class_weight": trial.suggest_categorical( "class_weight", [ "balanced", None, {1: 1, 0: (sum(list(ytrain == 0)) / sum(list(ytrain == 1)))}, ], ), "criterion": trial.suggest_categorical( "criterion", ["entropy", "gini"] ), "max_depth": trial.suggest_categorical("max_depth", [None, 5, 20, 70]), "min_samples_leaf": trial.suggest_categorical( "min_samples_leaf", [5, 10, 15, 20, 25] ), "min_samples_split": trial.suggest_categorical( "min_samples_split", [2, 10, 20] ), } return params if model_name == "adbc": params = { # "device_type": trial.suggest_categorical("device_type", ['gpu']), "n_estimators": trial.suggest_categorical( "n_estimators", [10, 100, 200, 500] ), # ,1000,10000 "learning_rate": trial.suggest_float("learning_rate", 0.01, 0.3), "algorithm": trial.suggest_categorical( "algorithm", ["SAMME", "SAMME.R"] ), } return params if model_name == "gbmc": params = { # "device_type": trial.suggest_categorical("device_type", ['gpu']), "n_estimators": trial.suggest_categorical( "n_estimators", [10, 100, 200, 500] ), # ,1000,10000 "learning_rate": trial.suggest_float("learning_rate", 0.01, 0.3), "max_depth": trial.suggest_int("max_depth", 3, 12), "loss": trial.suggest_categorical("loss", ["deviance", "exponential"]), "criterion": trial.suggest_categorical( "criterion", ["friedman_mse", "mse", "mae"] ), "max_features": trial.suggest_categorical( "max_features", ["auto", "sqrt", "log2"] ), "min_samples_split": trial.suggest_float("min_samples_split", 0.1, 0.5), "min_samples_leaf": trial.suggest_float("min_samples_split", 0.1, 0.5), "subsample": trial.suggest_categorical( "subsample", [0.5, 0.618, 0.8, 0.85, 0.9, 0.95, 1.0] ), } return params if model_name == "gbmr": params = { # "device_type": trial.suggest_categorical("device_type", ['gpu']), "n_estimators": trial.suggest_categorical( "n_estimators", [10, 100, 200, 500] ), # ,1000,10000 "learning_rate": trial.suggest_float("learning_rate", 0.01, 0.3), "max_depth": trial.suggest_int("max_depth", 3, 12), "loss": trial.suggest_categorical("loss", ['squared_error']), #, 'absolute_error', 'huber', 'quantile']), "criterion": trial.suggest_categorical( "criterion", ["friedman_mse", "squared_error", "mse"] ), "max_features": trial.suggest_categorical( "max_features", ["auto", "sqrt", "log2"] ), "min_samples_split": trial.suggest_float("min_samples_split", 0.1, 0.5), "min_samples_leaf": trial.suggest_float("min_samples_split", 0.1, 0.5), "subsample": trial.suggest_categorical( "subsample", [0.5, 0.618, 0.8, 0.85, 0.9, 0.95, 1.0] ), } return params if model_name == "hgbc": params = { "l2_regularization": trial.suggest_loguniform( "l2_regularization", 1e-10, 10.0 ), "early_stopping": trial.suggest_categorical( "early_stopping", ["False"] ), "learning_rate": trial.suggest_loguniform("learning_rate", 0.001, 0.1), "max_iter": trial.suggest_categorical( "max_iter", [i for i in range(1000, 12000, 100)] ), "max_depth": trial.suggest_int("max_depth", 2, 30), "max_bins": trial.suggest_int("max_bins", 100, 255), "min_samples_leaf": trial.suggest_int("min_samples_leaf", 20, 100000), "max_leaf_nodes": trial.suggest_int("max_leaf_nodes", 20, 80), } return params if model_name == "xgbdd": params = { "objective": trial.suggest_categorical("objective", ['regression']), #"eta": trial.suggest_categorical("eta", ['train']), "learning_rate": trial.suggest_float("learning_rate", 0,0.2), "max_depth": trial.suggest_categorical("max_depth", [6]), "silent": trial.suggest_categorical("silent", [1]), "num_class": trial.suggest_categorical("num_class", [3]), "eval_metric": trial.suggest_categorical("eval_metric", ['rmse']), "min_child_weight": trial.suggest_categorical("min_child_weight", [1]), "subsample": trial.suggest_categorical("subsample", [0.7]), "colsample_bytree": trial.suggest_categorical("colsample_bytree", [0.7]), } # param = {} # param['objective'] = 'multi:softprob' # param['eta'] = 0.1 # param['max_depth'] = 6 # param['silent'] = 1 # param['num_class'] = 3 # param['eval_metric'] = "mlogloss" # param['min_child_weight'] = 1 # param['subsample'] = 0.7 # param['colsample_bytree'] = 0.7 # param['seed'] = seed_val return params if model_name == "lgb": # dart: https://www.kaggle.com/code/ragnar123/amex-lgbm-dart-cv-0-7963 # params = { # 'objective': 'binary', # 'metric': "binary_logloss", # 'boosting': 'dart', # 'seed': CFG.seed, # 'num_leaves': 100, # 'learning_rate': 0.01, # 'feature_fraction': 0.20, # 'bagging_freq': 10, # 'bagging_fraction': 0.50, # 'n_jobs': -1, # 'lambda_l2': 2, # 'min_data_in_leaf': 40 # } """ params = { "objective": trial.suggest_categorical("objective", ["binary"]), "metric": trial.suggest_categorical("metric", ["binary_log_loss"]), "boosting": trial.suggest_categorical("boosting", ["dart"]), "num_leaves": trial.suggest_int("num_leaves", 80, 100, step=5), "learning_rate": trial.suggest_float("learning_rate", 0.01, 0.3), "feature_fraction": trial.suggest_float("feature_fraction", 0.2, 0.95, step=0.1), "bagging_freq": trial.suggest_categorical("bagging_freq", [1,10, 20]), "feature_fraction": trial.suggest_float("feature_fraction", 0.2, 0.95, step=0.1), "lambda_l2": trial.suggest_int("lambda_l2", 0, 10, step=2), "min_data_in_leaf": trial.suggest_int( "min_data_in_leaf", 20, 100, step=10), } """ # https://www.kaggle.com/competitions/amex-default-prediction/discussion/332575 # params = { # 'objective': 'binary', # 'metric': "amex_metric", # } # set metric as same as we set in feval: "amex_metric" # params = { # "objective": trial.suggest_categorical("objective", ["binary"]), # "metric": trial.suggest_categorical("metric", ["amex_metric"]), # "boosting": trial.suggest_categorical("boosting", ["dart"]), # "learning_rate": trial.suggest_float("learning_rate", 0.01, 0.3) # } """ params_lgbm = { 'task': 'train', 'boosting_type': 'gbdt', 'learning_rate': 0.01, 'objective': 'regression', 'metric': 'None', 'max_depth': -1, 'n_jobs': -1, 'feature_fraction': 0.7, 'bagging_fraction': 0.7, 'lambda_l2': 1, 'verbose': -1 #'bagging_freq': 5 } """ params = { "task": trial.suggest_categorical("task", ['train']), "boosting_type": trial.suggest_categorical("boosting_type", ['gbdt', 'dart']), "learning_rate": trial.suggest_float("learning_rate", 0,0.2), "objective": trial.suggest_categorical("objective", ['regression']), "metric": trial.suggest_categorical("metric", ['None']), "max_depth": trial.suggest_categorical("max_depth", [-1]), "n_jobs": trial.suggest_categorical("n_jobs", [-1]), #"feature_fraction": trial.suggest_categorical("feature_fraction", [0.7]), "feature_fraction": trial.suggest_categorical("feature_fraction", [0.7]), #"bagging_fraction": trial.suggest_categorical("bagging_fraction", [0.7]), "bagging_fraction": trial.suggest_categorical("bagging_fraction", [0.7]), "lambda_l2": trial.suggest_categorical("lambda_l2", [1]), "verbose": trial.suggest_categorical("verbose", [-1]), #"bagging_freq": trial.suggest_categorical("bagging_freq", [5]), # "objective": trial.suggest_categorical("objective", ["regression"]),#["binary"]), # "metric": trial.suggest_categorical("metric", [None]),#["binary_logloss"]), # "boosting": trial.suggest_categorical("boosting", ["dart"]), # "learning_rate": trial.suggest_float("learning_rate", 0.009, 0.011), # "seed": trial.suggest_categorical("seed", [241]), # "num_leaves": trial.suggest_categorical("num_leaves", [95,101,105]), # "feature_fraction": trial.suggest_float("feature_fraction", 0.15,0.22), # "bagging_freq": trial.suggest_categorical("bagging_freq" , [9,11,12]), # "bagging_fraction": trial.suggest_float("bagging_fraction", 0.45,0.52), # "n_jobs": trial.suggest_categorical("n_jobs" , [-1]), # "lambda_l2": trial.suggest_categorical("lambda_l2" , [1,2,3]), # "min_data_in_leaf": trial.suggest_categorical("min_data_in_leaf" , [35,41,45]), } # params = { # "objective": trial.suggest_categorical("objective", ["regression"]),#["binary"]), # "metric": trial.suggest_categorical("metric", [None]),#["binary_logloss"]), # "boosting": trial.suggest_categorical("boosting", ["dart"]), # "learning_rate": trial.suggest_float("learning_rate", 0.009, 0.011), # "seed": trial.suggest_categorical("seed", [241]), # "num_leaves": trial.suggest_categorical("num_leaves", [95,101,105]), # "feature_fraction": trial.suggest_float("feature_fraction", 0.15,0.22), # "bagging_freq": trial.suggest_categorical("bagging_freq" , [9,11,12]), # "bagging_fraction": trial.suggest_float("bagging_fraction", 0.45,0.52), # "n_jobs": trial.suggest_categorical("n_jobs" , [-1]), # "lambda_l2": trial.suggest_categorical("lambda_l2" , [1,2,3]), # "min_data_in_leaf": trial.suggest_categorical("min_data_in_leaf" , [35,41,45]), # } if self.with_gpu == True: params.update( { "device_type": trial.suggest_categorical( "device_type", ["gpu"] ), } ) return params if model_name == "lgbmc": # amex amrosm # link: https://www.kaggle.com/code/ambrosm/amex-lightgbm-quickstart params = { "n_estimators": trial.suggest_categorical( "n_estimators", [i for i in range(1100, 1300, 100)] ), # 10000 "learning_rate": trial.suggest_float("learning_rate", 0.01, 0.3), "num_leaves": trial.suggest_int("num_leaves", 80, 100, step=5), "colsample_bytree": trial.suggest_float("colsample_bytree", 0.1,0.2), "max_bins": trial.suggest_int("max_bins", 500,520, step=5), # https://lightgbm.readthedocs.io/en/latest/pythonapi/lightgbm.LGBMClassifier.html "boosting_type": trial.suggest_categorical("boosting_type", ['dart']) #"max_depth": trial.suggest_int("max_depth", 3, 12), # "min_data_in_leaf": trial.suggest_int( # "min_data_in_leaf", 200, 10000, step=100 # ), #"lambda_l1": trial.suggest_int("lambda_l1", 0, 100, step=5), #"lambda_l2": trial.suggest_int("lambda_l2", 0, 100, step=5), #"min_gain_to_split": trial.suggest_float("min_gain_to_split", 0, 15), # "bagging_fraction": trial.suggest_float( # "bagging_fraction"lgbmc, 0.2, 0.95, step=0.1 # ), #"bagging_freq": trial.suggest_categorical("bagging_freq", [1]), # "feature_fraction": trial.suggest_float( # "feature_fraction", 0.2, 0.95, step=0.1 # ), } # main # params = { # "n_estimators": trial.suggest_categorical( # "n_estimators", [i for i in range(1000, 10000, 100)] # ), # 10000 # "learning_rate": trial.suggest_float("learning_rate", 0.01, 0.3), # "num_leaves": trial.suggest_int("num_leaves", 20, 3000, step=20), # "max_depth": trial.suggest_int("max_depth", 3, 12), # "min_data_in_leaf": trial.suggest_int( # "min_data_in_leaf", 200, 10000, step=100 # ), # "lambda_l1": trial.suggest_int("lambda_l1", 0, 100, step=5), # "lambda_l2": trial.suggest_int("lambda_l2", 0, 100, step=5), # "min_gain_to_split": trial.suggest_float("min_gain_to_split", 0, 15), # "bagging_fraction": trial.suggest_float( # "bagging_fraction", 0.2, 0.95, step=0.1 # ), # "bagging_freq": trial.suggest_categorical("bagging_freq", [1]), # "feature_fraction": trial.suggest_float( # "feature_fraction", 0.2, 0.95, step=0.1 # ), # } ## gpu build if self.with_gpu == True: params.update( { "device_type": trial.suggest_categorical( "device_type", ["gpu"] ), } ) return params if model_name == "lgbmr": params = { "n_estimators": trial.suggest_categorical("n_estimators", [10000]), "learning_rate": trial.suggest_float("learning_rate", 0.01, 0.3), "num_leaves": trial.suggest_int("num_leaves", 20, 3000, step=20), "max_depth": trial.suggest_int("max_depth", 3, 12), "min_data_in_leaf": trial.suggest_int( "min_data_in_leaf", 200, 10000, step=100 ), "lambda_l1": trial.suggest_int("lambda_l1", 0, 100, step=5), "lambda_l2": trial.suggest_int("lambda_l2", 0, 100, step=5), "min_gain_to_split": trial.suggest_float("min_gain_to_split", 0, 15), "bagging_fraction": trial.suggest_float( "bagging_fraction", 0.2, 0.95, step=0.1 ), "bagging_freq": trial.suggest_categorical("bagging_freq", [1]), "feature_fraction": trial.suggest_float( "feature_fraction", 0.2, 0.95, step=0.1 ), "objective": trial.suggest_categorical("objective", ["regression"]), } if self.with_gpu == True: params.update( { "device_type": trial.suggest_categorical( "device_type", ["gpu"] ), } ) return params if model_name == "rfc": params = { "n_estimators": trial.suggest_int("n_estimators", 50, 1000), "max_depth": trial.suggest_int("max_depth", 4, 50), "min_samples_split": trial.suggest_int("min_samples_split", 2, 150), "min_samples_leaf": trial.suggest_int("min_samples_leaf", 2, 60), } return params if model_name == "rfr": params = { "n_estimators": trial.suggest_int("n_estimators", 5, 50), "max_depth": trial.suggest_int("max_depth", 4, 20), "min_samples_split": trial.suggest_int("min_samples_split", 2, 150), "min_samples_leaf": trial.suggest_int("min_samples_leaf", 2, 60), # "n_estimators": trial.suggest_int("n_estimators", 50, 1000), # "max_depth": trial.suggest_int("max_depth", 4, 50), # "min_samples_split": trial.suggest_int("min_samples_split", 2, 150), # "min_samples_leaf": trial.suggest_int("min_samples_leaf", 2, 60), } return params if model_name == "tabnetc": # https://www.kaggle.com/code/wangqihanginthesky/baseline-tabnet # params = { # "gamma": trial.suggest_uniform("gamma", 0, 3) # } params = { # cat_idxs=cat_idxs, # cat_emb_dim=1, "n_d": trial.suggest_categorical("n_d", [16]), "n_a": trial.suggest_categorical("n_a", [16]), "n_steps": trial.suggest_categorical("n_steps", [2]), "gamma": trial.suggest_categorical("gamma", [1.4690246460970766]), "n_independent": trial.suggest_categorical("n_independent", [9]), "n_shared": trial.suggest_categorical("n_shared", [4]), "lambda_sparse": trial.suggest_categorical("lambda_sparse", [0]), "optimizer_fn": trial.suggest_categorical("optimizer_fn", [Adam]), "optimizer_params": trial.suggest_categorical("optimizer_params", [dict(lr = (0.024907164557092944))]), "mask_type": trial.suggest_categorical("mask_type", ["entmax"]), "scheduler_params": trial.suggest_categorical("scheduler_params", [dict(T_0=200, T_mult=1, eta_min=1e-4, last_epoch=-1, verbose=False)]), "scheduler_fn": trial.suggest_categorical("scheduler_fn", [CosineAnnealingWarmRestarts]), "seed": trial.suggest_categorical("seed", [42]), "verbose": trial.suggest_categorical("verbose", [10]), # n_d = 16, # n_a = 16, # n_steps = 2, # gamma = 1.4690246460970766, # n_independent = 9, # n_shared = 4, # lambda_sparse = 0, # optimizer_fn = Adam, # optimizer_params = dict(lr = (0.024907164557092944)), # mask_type = "entmax", # scheduler_params = dict(T_0=200, T_mult=1, eta_min=1e-4, last_epoch=-1, verbose=False), # scheduler_fn = CosineAnnealingWarmRestarts, # seed = 42, # verbose = 10, } return params if model_name == "tabnetr": # https://www.kaggle.com/code/wangqihanginthesky/baseline-tabnet # params = { # "gamma": trial.suggest_uniform("gamma", 0, 3) # } params = { # cat_idxs=cat_idxs, # cat_emb_dim=1, "n_d": trial.suggest_categorical("n_d", [16]), "n_a": trial.suggest_categorical("n_a", [16]), "n_steps": trial.suggest_categorical("n_steps", [2]), #"n_steps": trial.suggest_categorical("n_steps", [2, 4, 7]), "gamma": trial.suggest_categorical("gamma", [1.4690246460970766]), #"gamma": trial.suggest_uniform("gamma", 0.1, 2), "n_independent": trial.suggest_categorical("n_independent", [9]), "n_shared": trial.suggest_categorical("n_shared", [4]), "lambda_sparse": trial.suggest_categorical("lambda_sparse", [0]), "optimizer_fn": trial.suggest_categorical("optimizer_fn", [Adam]), "optimizer_params": trial.suggest_categorical("optimizer_params", [dict(lr = (0.024907164557092944))]), "mask_type": trial.suggest_categorical("mask_type", ["entmax"]), "scheduler_params": trial.suggest_categorical("scheduler_params", [dict(T_0=200, T_mult=1, eta_min=1e-4, last_epoch=-1, verbose=False)]), "scheduler_fn": trial.suggest_categorical("scheduler_fn", [CosineAnnealingWarmRestarts]), "seed": trial.suggest_categorical("seed", [42]), "verbose": trial.suggest_categorical("verbose", [10]), # n_d = 16, # n_a = 16, # n_steps = 2, # gamma = 1.4690246460970766, # n_independent = 9, # n_shared = 4, # lambda_sparse = 0, # optimizer_fn = Adam, # optimizer_params = dict(lr = (0.024907164557092944)), # mask_type = "entmax", # scheduler_params = dict(T_0=200, T_mult=1, eta_min=1e-4, last_epoch=-1, verbose=False), # scheduler_fn = CosineAnnealingWarmRestarts, # seed = 42, # verbose = 10, } return params if model_name == "k1": # params = { # "epochs": trial.suggest_int("epochs", 10, 55, step=5, log=False), # 5,55 # "batchsize": trial.suggest_int("batchsize", 8, 40, step=16, log=False), # "learning_rate": trial.suggest_uniform("learning_rate", 0, 3), # "o": trial.suggest_categorical("o", [True, False]), # } params = { "epochs": trial.suggest_int("epochs", 2, 55, step=5, log=False), # 5,55 "batchsize": trial.suggest_int("batchsize", 8, 40, step=16, log=False), "learning_rate": trial.suggest_uniform("learning_rate", 0, 3), "o": trial.suggest_categorical("o", [True, False]), } return params if model_name == "k2": params = { "epochs": trial.suggest_int("epochs", 5, 55, step=5, log=False), # 5,55 "batchsize": trial.suggest_int("batchsize", 8, 40, step=16, log=False), "learning_rate": trial.suggest_uniform("learning_rate", 0, 3), "prime": trial.suggest_categorical( "prime", [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31] ), "drop_val": trial.suggest_uniform("drop", 0.01, 0.9), "o": trial.suggest_categorical("o", [True, False]), } return params if model_name == "k3": no_hidden_layers = trial.suggest_int("no_hidden_layers", 1, 30, step=1) dropout_placeholder = [ trial.suggest_uniform(f"drop_rate_{i+1}", 0, 0.99) for i in range(no_hidden_layers) ] units_placeholder = [ trial.suggest_int( f"units_val_{j+1}", int((self.xtrain.shape[1] + 1) ** (1 / 3)), int((self.xtrain.shape[1] + 1) ** 3), step=1, log=False, ) for j in range(no_hidden_layers) ] batch_norm_placeholder = [ trial.suggest_categorical(f"batch_norm_val_{i+1}", [0, 1]) for i in range(no_hidden_layers) ] activation_placeholder = [ trial.suggest_categorical( f"activation_string_{i+1}", ["relu", "sigmoid", "tanh"] ) for i in range(no_hidden_layers) ] epochs = trial.suggest_int("epochs", 2, 3, step=5, log=False) # 5,55 batchsize = trial.suggest_int("batchsize", 8, 40, step=16, log=False) learning_rate = trial.suggest_uniform("learning_rate", 0, 3) # epochs = trial.suggest_int("epochs", 5, 100, step=5, log=False) # 5,55 # batchsize = trial.suggest_int("batchsize", 8, 40, step=16, log=False) # learning_rate = trial.suggest_uniform("learning_rate", 0, 3) o = trial.suggest_categorical("o", [True, False]) params = { "no_hidden_layers": no_hidden_layers, "dropout_placeholder": dropout_placeholder, "units_placeholder": units_placeholder, "batch_norm_placeholder": batch_norm_placeholder, "activation_placeholder": activation_placeholder, "epochs": epochs, "batchsize": batchsize, "learning_rate": learning_rate, "o": o, } return params if model_name == "tez1": # -batch_size = 16 # -epochs = 5 # =====seed = 42 # ===target_size = 28 # -learning_rate = 0.002 params = { "batch_size": trial.suggest_categorical( "batch_size", [16] ), # ,32,64, 128,256, 512]), # "epochs": trial.suggest_int( # "epochs", 1, 2, step=1, log=False # ), # 55, step=5, log=False), # 5,55 "epochs": trial.suggest_categorical("epochs", [5]), "learning_rate": trial.suggest_uniform("learning_rate", 2, 8), "patience": trial.suggest_categorical("patience", [5]), } return params if model_name == "tez2": # -batch_size = 16 # -epochs = 5 # =====seed = 42 # ===target_size = 28 # -learning_rate = 0.002 params = { "batch_size": trial.suggest_categorical( "batch_size", [16] ), # ,32,64, 128,256, 512]), # "epochs": trial.suggest_int( # "epochs", 1, 2, step=1, log=False # ), # 55, step=5, log=False), # 5,55 "epochs": trial.suggest_categorical("epochs", [1]), "learning_rate": trial.suggest_uniform("learning_rate", 2, 8), "patience": trial.suggest_categorical("patience", [5]), } return params if model_name == "p1": # -batch_size = 16 # -epochs = 5 # =====seed = 42 # ===target_size = 28 # -learning_rate = 0.002 params = { "batch_size": trial.suggest_categorical( "batch_size", [16, 32, 128, 512] ), # ,32,64, 128,256, 512]), "epochs": trial.suggest_int( "epochs", 20, 55, step=10, log=False ), # 55, step=5, log=False), # 5,55 # "epochs": trial.suggest_categorical("epochs", [1]), "learning_rate": trial.suggest_uniform("learning_rate", 1, 8), "patience": trial.suggest_categorical("patience", [3, 5]), "momentum": trial.suggest_uniform("momentum", 0.2, 0.9), } # Demo # params = { # "batch_size": trial.suggest_categorical( # "batch_size", [16, 32, 128, 512] # ), # ,32,64, 128,256, 512]), # "epochs": trial.suggest_int( # "epochs", 1,3, step=1, log=False # ), # 55, step=5, log=False), # 5,55 # # "epochs": trial.suggest_categorical("epochs", [1]), # "learning_rate": trial.suggest_uniform("learning_rate", 1, 8), # "patience": trial.suggest_categorical("patience", [3, 5]), # "momentum": trial.suggest_uniform("momentum", 0.2, 0.9), # } return params if model_name == "pretrained": # -batch_size = 16 # -epochs = 5 # =====seed = 42 # ===target_size = 28 # -learning_rate = 0.002 # params = { # "batch_size": trial.suggest_categorical( # "batch_size", [16, 32, 128, 512] # ), # ,32,64, 128,256, 512]), # "epochs": trial.suggest_int( # "epochs", 12,25, step=5, log=False # ), # 55, step=5, log=False), # 5,55 # #"epochs": trial.suggest_categorical("epochs", [1]), # "learning_rate": trial.suggest_uniform("learning_rate", 1, 8), # "patience": trial.suggest_categorical("patience", [3,5]), # "momentum": trial.suggest_uniform("momentum", 0.2, 0.9) # } # Demo params = { "batch_size": trial.suggest_categorical( "batch_size", [16, 32, 128, 512] ), # ,32,64, 128,256, 512]), "epochs": trial.suggest_int( "epochs", 1, 2, step=1, log=False ), # 55, step=5, log=False), # 5,55 # "epochs": trial.suggest_categorical("epochs", [1]), "learning_rate": trial.suggest_uniform("learning_rate", 1, 8), "patience": trial.suggest_categorical("patience", [3, 5]), "momentum": trial.suggest_uniform("momentum", 0.2, 0.9), } print("finding params") print(params) return params if model_name == "keras": # demo self.Table = pd.DataFrame( columns=[ "val_score", "lr_modified", "learning_rate", "epochs", "batch_size", "no_hidden_layers", "dropout_placeholder", "units_placeholder", "batch_norm_placeholder", " activation_placeholder", ] ) return params def get_model(self, params): # ["lgr","lir","xgb","xgbc","xgbr"] model_name = self.model_name self._random_state = self.generate_random_no() if model_name == "lgr": return LogisticRegression(**params, random_state=self._random_state) if model_name == "lir": return LinearRegression() #**params, random_state=self._random_state) if model_name == "xgb": return "No Model Yet" if model_name == "xgbc": return XGBClassifier(**params, random_state=self._random_state) if model_name == "xgbr": return XGBRegressor(**params, random_state=self._random_state) if model_name == "mlpc": return MLPClassifier(**params, random_state=self._random_state) if model_name == "mlpr": return MLPRegressor(**params, random_state=self._random_state) if model_name == "rg": return Ridge(**params, random_state=self._random_state) if model_name == "ls": return Lasso(**params, random_state=self._random_state) if model_name == "knnc": return KNeighborsClassifier(**params) if model_name == "cbc": # User defined loss functions, metrics and callbacks are not supported for GPU return CatBoostClassifier(**params, random_state=self._random_state) #, eval_metric = CustomMetric_cbc()) if model_name == "cbr": # User defined loss functions, metrics and callbacks are not supported for GPU return CatBoostRegressor(**params, random_state=self._random_state) #, eval_metric = CustomMetric_cbc()) if model_name == "dtc": return DecisionTreeClassifier(**params, random_state=self._random_state) if model_name == "adbc": return AdaBoostClassifier(**params, random_state=self._random_state) if model_name == "gbmc": #return HistGradientBoostingClassifier(**params, random_state=self._random_state) return GradientBoostingClassifier(**params, random_state=self._random_state) if model_name == "gbmr": #return HistGradientBoostingRegressor(**params, random_state=self._random_state) return GradientBoostingRegressor(**params, random_state=self._random_state) if model_name == "hgbc": return HistGradientBoostingClassifier( **params, random_state=self._random_state ) if model_name == "lgb": return "No model yet" if model_name == "lgbmc": return LGBMClassifier(**params, random_state=self._random_state) if model_name == "lgbmr": return LGBMRegressor(**params, random_state=self._random_state) if model_name == "rfc": return RandomForestClassifier(**params, random_state=self._random_state) if model_name == "rfr": return RandomForestRegressor(**params, random_state=self._random_state) if model_name == "tabnetc": return TabNetClassifier(**params) if model_name == "tabnetr": return TabNetRegressor(**params) if model_name == "k1": return self._k1(params, random_state=self._random_state) if model_name == "k2": return self._k2(params, random_state=self._random_state) if model_name == "k3": return self._k3(params, random_state=self._random_state) if model_name == "k4": return self._k4(params, random_state=self._random_state) if model_name == "tez1": return self._tez1(params, random_state=self._random_state) if model_name == "tez2": return self._tez2(params, random_state=self._random_state) if model_name == "p1": # pytorch1 # basic pytorch model return self._p1(params=params) if model_name == "pretrained": # pytorch return self._pretrained(params=params) else: raise Exception(f"{model_name} is invalid!") def _pretrained(self, params): self.learning_rate = 10 ** (-1 * params["learning_rate"]) # model = pretrained_models(len(self.filtered_features)) model = MODEL_DISPATCHER["resnet34"]( pretrained=False ) # supports all image size model.to("cuda") # train_loader self.train_loader = DataLoader( self.train_dataset, shuffle=True, num_workers=4, batch_size=params["batch_size"], ) self.valid_loader = DataLoader( self.valid_dataset, shuffle=False, num_workers=4, batch_size=params["batch_size"], ) self.test_loader = DataLoader( self.test_dataset, shuffle=False, num_workers=4, batch_size=params["batch_size"], ) optimizer = torch.optim.SGD( model.parameters(), lr=10 ** (-1 * params["learning_rate"]), momentum=params["momentum"], # 0.9, ) # base_opt = torch.optim.Adam(model.parameters(), lr=0.001) # optimizer = SWA(base_opt, swa_start=10, swa_freq=2, swa_lr=0.0005) # in torch some scheduler step after every epoch, # some after every batch scheduler = torch.optim.lr_scheduler.ReduceLROnPlateau( optimizer, factor=0.5, patience=params["patience"], verbose=True, mode="max", threshold=1e-4, ) if torch.cuda.device_count() > 1: model = nn.DataParallel(model) return trainer_p1( model, self.train_loader, self.valid_loader, optimizer, scheduler, self.use_cutmix, ) def _p1(self, params=0, random_state=0): self.learning_rate = 10 ** (-1 * params["learning_rate"]) model = p1_model() model.to("cuda") # train_loader self.train_loader = DataLoader( self.train_dataset, shuffle=True, num_workers=4, batch_size=params["batch_size"], ) self.valid_loader = DataLoader( self.valid_dataset, shuffle=False, num_workers=4, batch_size=params["batch_size"], ) self.test_loader = DataLoader( self.test_dataset, shuffle=False, num_workers=4, batch_size=params["batch_size"], ) optimizer = torch.optim.SGD( model.parameters(), lr=10 ** (-1 * params["learning_rate"]), momentum=params["momentum"], # 0.9, ) # base_opt = torch.optim.Adam(model.parameters(), lr=0.001) # optimizer = SWA(base_opt, swa_start=10, swa_freq=2, swa_lr=0.0005) scheduler = torch.optim.lr_scheduler.ReduceLROnPlateau( optimizer, factor=0.5, patience=params["patience"], verbose=True, mode="max", threshold=1e-4, ) return trainer_p1( model, self.train_loader, self.valid_loader, optimizer, scheduler, self.use_cutmix, ) def _tez1(self, params, random_state): """ self.train_image_paths self.valid_image_paths self.train_dataset selt.valid_dataset """ print("params of tez1") print(params) print("=" * 40) batch_size = params["batch_size"] epochs = params["epochs"] learning_rate = 10 ** ( -1 * params["learning_rate"] ) # params["learning_rate"] # img_size = 256 # nothing to do with model used for naming output files model_name = "resnet50" seed = random_state target_size = len(set(self.ytrain)) n_train_steps = int(len(self.train_dataset) / batch_size * epochs) model = UModel( model_name=model_name, num_classes=target_size, learning_rate=learning_rate, n_train_steps=n_train_steps, ) return model def _tez2(self, params, random_state): """ self.train_image_paths self.valid_image_paths self.train_dataset selt.valid_dataset """ print("params of tez2") print(params) print("=" * 40) batch_size = params["batch_size"] epochs = params["epochs"] learning_rate = 10 ** ( -1 * params["learning_rate"] ) # params["learning_rate"] # img_size = 256 # nothing to do with model used for naming output files model_name = "resnet50" seed = random_state target_size = len(set(self.ytrain)) # n_train_steps = int(len(self.train_image_paths) / batch_size * epochs) n_train_steps = int(len(self.train_dataset) / batch_size / 1 * epochs) model = DigitRecognizerModel( model_name="resnet50", num_classes=target_size, learning_rate=learning_rate, n_train_steps=n_train_steps, ) model = Tez(model) return model def _k1(self, params, random_state): # simple model model = keras.Sequential() model.add(BatchNormalization()) model.add(Dense(132, activation="relu")) model.add(BatchNormalization()) model.add(Dense(32, activation="relu")) model.add(BatchNormalization()) model.add(Dense(32, activation="relu")) model.add(BatchNormalization()) model.add(Dense(32, activation="relu")) model.add(BatchNormalization()) model.add(Dense(32, activation="relu")) # model.add(Dense(32, activation="relu")) # #model.add(Dropout(p=0.2)) # model.add(Dense(32, activation="relu")) # model.add(BatchNormalization()) # model.add(Dense(32, activation="relu")) # #model.add(Dropout(p=0.2)) # model.add(BatchNormalization()) # model.add(Dense(32, activation="relu")) # model.add(BatchNormalization()) # model.add(Dense(16, activation="relu")) model.add(BatchNormalization()) """ model = keras.Sequential() model.add(BatchNormalization()) model.add(Dense(32, activation="relu")) model.add(Dense(32, activation="relu")) model.add(Dense(32, activation="relu")) model.add(BatchNormalization()) model.add(Dense(16, activation="relu")) model.add(BatchNormalization()) """ # adam is used when we don't have custom lr_scheduler # any(x in ['b', 'd', 'foo', 'bar'] for x in ['a', 'b']): True # all(x in ['b', 'd', 'foo', 'bar'] for x in ['a', 'b']): False if any( x in self.callbacks_list for x in ["simple_decay", "cosine_decay", "exponential_decay"] ): # time for custom lr lr_start = 1e-2 # 0.01 lr_start = 10 ** ( -1 * params["learning_rate"] ) # optimize starting point using optuna global_variables.lr_start = lr_start opt = Adamax(learning_rate=lr_start) else: adam = tf.keras.optimizers.Adam( learning_rate=10 ** (-1 * params["learning_rate"]) ) opt = adam # PREDICT: gives probability always so in case of metrics which takes hard class do (argmax) # For #class more than 2 output label has multiple node: # confusion remains with 2class problem as it can have both one node or 2 node in end if self.comp_type == "regression": model.add(Dense(1, activation="linear")) # /None linear tanh # model.compile( # loss=self.metrics_name, # optimizer=Adamax(learning_rate=lr_start), # adam, # metrics=[tf.keras.metrics.MeanSquaredError()], # ) model.compile(optimizer=opt, loss = 'mae', metrics=['mean_squared_error']) elif self.comp_type == "2class": if len(self.ytrain.shape) == 1: model.add(Dense(1, activation="sigmoid")) #: binary_crossentropy #--> https://www.kaggle.com/code/cdeotte/tensorflow-gru-starter-0-790 #opt = tf.keras.optimizers.Adam(learning_rate=0.001) loss = tf.keras.losses.BinaryCrossentropy() model.compile(loss=loss, optimizer = opt) # model.compile( # optimizer=opt, metrics= [amex_metric_tensorflow], #["accuracy"],["accuracy"] # loss=tf.keras.losses.BinaryCrossentropy(), # ) #loss="binary_crossentropy", print("New metrics implemented1") else: # binary with one hot y no more binary problem so it is like multi class := don't use this case use above one instead model.add(Dense(self.ytrain.shape[1], activation="softmax")) model.compile( loss="categorical_crossentropy", optimizer=opt, metrics= [amex_metric], #["accuracy"], ) print("New metrics implemented") elif self.comp_type == "multi_class": # https://medium.com/deep-learning-with-keras/which-activation-loss-functions-in-multi-class-clasification-4cd599e4e61f if len(self.ytrain.shape) == 1: # sparse since true prediction is 1D # op1> # act:None # loss:keras.losses.SparseCategoricalCrossentropy(from_logits=True) # metrics:metrics=[keras.metrics.SparseCategoricalAccuracy()] # op2> # act: softmax # loss: sparse_categorical_crossentropy # metrics: keras.metrics.SparseCategoricalAccuracy() if params["o"]: loss = keras.losses.SparseCategoricalCrossentropy(from_logits=True) metrics = [keras.metrics.SparseCategoricalAccuracy()] act = None else: loss = keras.losses.SparseCategoricalCrossentropy() metrics = [keras.metrics.SparseCategoricalAccuracy()] act = "softmax" model.add(Dense(self.ytrain.shape[1], activation=act)) model.compile(loss=loss, optimizer=opt, metrics=metrics) else: # ytrain is not 1D # op1> # act:None # loss:keras.losses.CategoricalCrossentropy(from_logits=True) # metrics:metrics=[keras.metrics.CategoricalAccuracy()] # op2> # act: softmax # loss: categorical_crossentropy # metrics: keras.metrics.CategoricalAccuracy() if params["o"]: loss = keras.losses.CategoricalCrossentropy(from_logits=True) metrics = [keras.metrics.CategoricalAccuracy()] act = None else: loss = keras.losses.CategoricalCrossentropy() metrics = [keras.metrics.CategoricalAccuracy()] act = "softmax" model.add(Dense(self.ytrain.shape[1], activation="softmax")) model.compile(loss=loss, optimizer=opt, metrics=metrics) elif self.comp_type == "multi_label": model.add(Dense(self.ytrain.shape[1], activation="sigmoid")) model.compile( loss="categorical_crossentropy", optimizer=opt, metrics=["accuracy"] ) return model def _k2(self, params, random_state): # cone model model = Sequential() model.add(BatchNormalization()) no_cols = self.xtrain.shape[1] model.add(Dense(2 * no_cols, activation="relu")) while no_cols > 2 * 10: model.add(Dropout(params["drop_val"])) model.add(Dense(no_cols, activation="relu")) model.add(Dense(no_cols, activation="relu")) model.add(BatchNormalization()) no_cols = int(no_cols // params["prime"]) adam = tf.keras.optimizers.Adam( learning_rate=10 ** (-1 * params["learning_rate"]) ) # PREDICT: gives probability always so in case of metrics which takes hard class do (argmax) # For #class more than 2 output label has multiple node: # confusion remains with 2class problem as it can have both one node or 2 node in end if self.comp_type == "regression": model.add(Dense(1, activation="relu")) # /None linear tanh model.compile( loss=self.metrics_name, optimizer=adam, metrics=[tf.keras.metrics.MeanSquaredError()], ) elif self.comp_type == "2class": if len(self.ytrain.shape) == 1: model.add(Dense(1, activation="sigmoid")) #: binary_crossentropy #--> https://www.kaggle.com/code/cdeotte/tensorflow-gru-starter-0-790 #opt = tf.keras.optimizers.Adam(learning_rate=0.001) loss = tf.keras.losses.BinaryCrossentropy() model.compile(loss=loss, optimizer = opt) # model.compile( # optimizer=opt, metrics= [amex_metric_tensorflow], #["accuracy"],["accuracy"] # loss=tf.keras.losses.BinaryCrossentropy(), # ) #loss="binary_crossentropy", print("New metrics implemented1") else: # binary with one hot y no more binary problem so it is like multi class := don't use this case use above one instead model.add(Dense(self.ytrain.shape[1], activation="softmax")) model.compile( loss="categorical_crossentropy", optimizer=opt, metrics= [amex_metric], #["accuracy"], ) print("New metrics implemented") elif self.comp_type == "multi_class": # https://medium.com/deep-learning-with-keras/which-activation-loss-functions-in-multi-class-clasification-4cd599e4e61f if len(self.ytrain.shape) == 1: # sparse since true prediction is 1D # op1> # act:None # loss:keras.losses.SparseCategoricalCrossentropy(from_logits=True) # metrics:metrics=[keras.metrics.SparseCategoricalAccuracy()] # op2> # act: softmax # loss: sparse_categorical_crossentropy # metrics: keras.metrics.SparseCategoricalAccuracy() if params["o"]: loss = keras.losses.SparseCategoricalCrossentropy(from_logits=True) metrics = [keras.metrics.SparseCategoricalAccuracy()] act = None else: loss = keras.losses.SparseCategoricalCrossentropy() metrics = [keras.metrics.SparseCategoricalAccuracy()] act = "softmax" model.add(Dense(self.ytrain.shape[1], activation=act)) model.compile(loss=loss, optimizer=opt, metrics=metrics) else: # ytrain is not 1D # op1> # act:None # loss:keras.losses.CategoricalCrossentropy(from_logits=True) # metrics:metrics=[keras.metrics.CategoricalAccuracy()] # op2> # act: softmax # loss: categorical_crossentropy # metrics: keras.metrics.CategoricalAccuracy() if params["o"]: loss = keras.losses.CategoricalCrossentropy(from_logits=True) metrics = [keras.metrics.CategoricalAccuracy()] act = None else: loss = keras.losses.CategoricalCrossentropy() metrics = [keras.metrics.CategoricalAccuracy()] act = "softmax" model.add(Dense(self.ytrain.shape[1], activation="softmax")) model.compile(loss=loss, optimizer=opt, metrics=metrics) elif self.comp_type == "multi_label": model.add(Dense(self.ytrain.shape[1], activation="sigmoid")) model.compile( loss="categorical_crossentropy", optimizer=opt, metrics=["accuracy"] ) return model def _k3(self, params, random_state): # cone model model = Sequential() model.add(BatchNormalization()) for i in range(params["no_hidden_layers"]): if params["batch_norm_placeholder"][i] == 1: model.add(BatchNormalization()) model.add( Dense( units=params["units_placeholder"][i], activation=params["activation_placeholder"][i], ) ) model.add(Dropout(params["dropout_placeholder"][i])) gc.collect() adam = tf.keras.optimizers.Adam( learning_rate=10 ** (-1 * params["learning_rate"]) ) # PREDICT: gives probability always so in case of metrics which takes hard class do (argmax) # For #class more than 2 output label has multiple node: # confusion remains with 2class problem as it can have both one node or 2 node in end if self.comp_type == "regression": model.add(Dense(1, activation="relu")) # /None linear tanh model.compile( loss=self.metrics_name, optimizer=adam, metrics=[tf.keras.metrics.MeanSquaredError()], ) elif self.comp_type == "2class": if len(self.ytrain.shape) == 1: model.add(Dense(1, activation="sigmoid")) #: binary_crossentropy #--> https://www.kaggle.com/code/cdeotte/tensorflow-gru-starter-0-790 #opt = tf.keras.optimizers.Adam(learning_rate=0.001) loss = tf.keras.losses.BinaryCrossentropy() model.compile(loss=loss, optimizer = opt) # model.compile( # optimizer=opt, metrics= [amex_metric_tensorflow], #["accuracy"],["accuracy"] # loss=tf.keras.losses.BinaryCrossentropy(), # ) #loss="binary_crossentropy", print("New metrics implemented1") else: # binary with one hot y no more binary problem so it is like multi class := don't use this case use above one instead model.add(Dense(self.ytrain.shape[1], activation="softmax")) model.compile( loss="categorical_crossentropy", optimizer=opt, metrics= [amex_metric], #["accuracy"], ) print("New metrics implemented") elif self.comp_type == "multi_class": # https://medium.com/deep-learning-with-keras/which-activation-loss-functions-in-multi-class-clasification-4cd599e4e61f if len(self.ytrain.shape) == 1: # sparse since true prediction is 1D # op1> # act:None # loss:keras.losses.SparseCategoricalCrossentropy(from_logits=True) # metrics:metrics=[keras.metrics.SparseCategoricalAccuracy()] # op2> # act: softmax # loss: sparse_categorical_crossentropy # metrics: keras.metrics.SparseCategoricalAccuracy() if params["o"]: loss = keras.losses.SparseCategoricalCrossentropy(from_logits=True) metrics = [keras.metrics.SparseCategoricalAccuracy()] act = None else: loss = keras.losses.SparseCategoricalCrossentropy() metrics = [keras.metrics.SparseCategoricalAccuracy()] act = "softmax" model.add(Dense(self.ytrain.shape[1], activation=act)) model.compile(loss=loss, optimizer=opt, metrics=metrics) else: # ytrain is not 1D # op1> # act:None # loss:keras.losses.CategoricalCrossentropy(from_logits=True) # metrics:metrics=[keras.metrics.CategoricalAccuracy()] # op2> # act: softmax # loss: categorical_crossentropy # metrics: keras.metrics.CategoricalAccuracy() if params["o"]: loss = keras.losses.CategoricalCrossentropy(from_logits=True) metrics = [keras.metrics.CategoricalAccuracy()] act = None else: loss = keras.losses.CategoricalCrossentropy() metrics = [keras.metrics.CategoricalAccuracy()] act = "softmax" model.add(Dense(self.ytrain.shape[1], activation="softmax")) model.compile(loss=loss, optimizer=opt, metrics=metrics) elif self.comp_type == "multi_label": model.add(Dense(self.ytrain.shape[1], activation="sigmoid")) model.compile( loss="categorical_crossentropy", optimizer=opt, metrics=["accuracy"] ) return model # DLastStark # https://www.kaggle.com/code/dlaststark/tps-may22-what-tf-again def _k4(self, params, random_state): x_input = Input(shape=(len(self.useful_features),)) xi = Dense(units=384, activation="swish", kernel_initializer="lecun_normal")( x_input ) xi = BatchNormalization()(xi) xi = Dropout(rate=0.25)(xi) x = Reshape((16, 24))(xi) x = Conv1D( filters=48, activation="swish", kernel_size=3, strides=2, padding="same", kernel_initializer="lecun_normal", )(x) x = BatchNormalization()(x) x1 = Conv1D( filters=96, activation="swish", kernel_size=3, strides=1, padding="same", kernel_initializer="lecun_normal", )(x) x1 = BatchNormalization()(x1) x2 = Conv1D( filters=96, activation="swish", kernel_size=3, strides=1, padding="same", kernel_initializer="lecun_normal", )(x1) x2 = BatchNormalization()(x2) x2 = Conv1D( filters=96, activation="swish", kernel_size=3, strides=1, padding="same", kernel_initializer="lecun_normal", )(x2) x2 = BatchNormalization()(x2) x = Add()([x1, x2]) x = Conv1D( filters=96, activation="swish", kernel_size=3, strides=2, padding="same", kernel_initializer="lecun_normal", )(x) x = BatchNormalization()(x) x = Flatten()(x) x = Add()([x, xi]) x = Dense(units=192, activation="swish", kernel_initializer="lecun_normal")(x) x = BatchNormalization()(x) x = Dropout(rate=0.3)(x) x = Dense(units=96, activation="swish", kernel_initializer="lecun_normal")(x) x = BatchNormalization()(x) x = Dropout(rate=0.2)(x) x_output = Dense( units=1, activation="sigmoid", kernel_initializer="lecun_normal" )(x) model = Model(inputs=x_input, outputs=x_output, name="TPS_May22_TF_Model") model.compile( optimizer=Adamax(learning_rate=lr_start), loss="binary_crossentropy", metrics=["AUC"], ) return model def save_logs(self, params): print("Saving Log Table") if self._log_table is None: # not initialized self._log_table = pd.DataFrame( columns=["trial_score"] + list(params.keys()) + ["keras_history"] ) self._log_table.loc[self._log_table.shape[0], :] = ( [self._trial_score] + list(params.values()) + [self._history] ) def get_callbacks(self, params, verbose): ############################################################################### # Tree based models ############################################################################ # lgb/lgbmc # https://lightgbm.readthedocs.io/en/latest/Python-API.html#callbacks """ early_stopping(stopping_rounds[, ...]) Create a callback that activates early stopping. log_evaluation([period, show_stdv]) Create a callback that logs the evaluation results. record_evaluation(eval_result) Create a callback that records the evaluation history into eval_result. reset_parameter(**kwargs) Create a callback that resets the parameter after the first iteration. """ ############################################################################### # KERAS ############################################################################ # DLastStark # https://www.kaggle.com/code/dlaststark/tps-may22-what-tf-again # ambrosm # https://www.kaggle.com/code/ambrosm/amex-keras-quickstart-1-training/notebook # lr_start = 1e-2 set equal to lr # It is set while defining model K1 global_variables.lr_end = 1e-5 # 1e-4 global_variables.epochs = params["epochs"] callbacks = [TerminateOnNaN()] # always keep TerminateOnNan() if "chk_pt" in self.callbacks_list: # https://keras.io/api/callbacks/model_checkpoint/ # chk_point = ModelCheckpoint( # filepath=f"../models/models-{self.locker['comp_name']}/", # "./", # to work on this part # save_weights_only=True, # monitor="val_accuracy", # mode="max", # save_best_only=True, # ) # https://www.kaggle.com/code/dlaststark/tps-may22-what-tf-again chk_point = ModelCheckpoint( f"../models/models-{self.locker['comp_name']}/model_exp_{self.current_dict['current_exp_no']}.h5", monitor="val_auc", verbose=verbose, save_best_only=True, mode="max", ) callbacks.append(chk_pt) if "ReduceLROnPlateau" in self.callbacks_list: reduce_lr = ReduceLROnPlateau( monitor="val_accuracy", factor=0.5, patience=5, min_lr=0.00001, verbose=verbose, ) callbacks.append(reduce_lr) if "early_stopping" in self.callbacks_list: stop = EarlyStopping( monitor="accuracy", mode="max", patience=50 ) # , verbose=1) callbacks.append(stop) if "cosine_decay" in self.callbacks_list: lr = LearningRateScheduler(cosine_decay, verbose=verbose) callbacks.append(lr) if "exponential_decay" in self.callbacks_list: print("entered exponential_decay") lr = LearningRateScheduler(exponential_decay, verbose=verbose) callbacks.append(lr) if "simple_decay" in self.callbacks_list: lr = LearningRateScheduler(simple_decay, verbose=verbose) callbacks.append(lr) if "swa" in self.callbacks_list: # https://www.kaggle.com/competitions/google-quest-challenge/discussion/119371 # https://pypi.org/project/keras-swa/ """ # 'manual' , 'constant' or 'cyclic' The default schedule is 'manual', allowing the learning rate to be controlled by an external learning rate scheduler or the optimizer. start_epoch - Starting epoch for SWA. lr_schedule - Learning rate schedule. 'manual' , 'constant' or 'cyclic'. swa_lr - Learning rate used when averaging weights. swa_lr2 - Upper bound of learning rate for the cyclic schedule. swa_freq - Frequency of weight averagining. Used with cyclic schedules. batch_size - Batch size model is being trained with (only when using batch normalization). verbose - Verbosity mode, 0 or 1. """ from swa.keras import SWA #Define when to start SWA start_epoch = 5 # define swa callback swa = SWA(start_epoch=start_epoch, lr_schedule='constant', #cyclic 'manual' , 'constant' or 'cyclic' swa_lr=1e-5, #batch_size = 256 , #swa_lr2=9e-5, # swa_freq = 10, verbose=1) return callbacks def obj(self, trial): if self._state == "seed" or self._state == "fold": params = self.params else: params = self.get_params(trial) print("Current params:") print(params) model = self.get_model(params) if self._state == "seed": # There must be some other better ways self.xvalid = self.xtrain self.yvalid = self.ytrain # fit xtrain # ---------------------------------------------------------------------------- # ---------------------------------------------------------------------------- # lgb/lgbmc # https://lightgbm.readthedocs.io/en/latest/Python-API.html#callbacks """ early_stopping(stopping_rounds[, ...]) Create a callback that activates early stopping. log_evaluation([period, show_stdv]) Create a callback that logs the evaluation results. record_evaluation(eval_result) Create a callback that records the evaluation history into eval_result. reset_parameter(**kwargs) Create a callback that resets the parameter after the first iteration. """ if self.model_name == "lgb": # done but add callback # dart lgb_train = lgb.Dataset(self.xtrain, self.ytrain ) #, categorical_feature = cat_features) lgb_valid = lgb.Dataset(self.xvalid, self.yvalid ) #, categorical_feature = cat_features) """ model = lgb.train( params = params, train_set = lgb_train, num_boost_round = 10500, valid_sets = [lgb_train, lgb_valid], early_stopping_rounds = 100, verbose_eval = 500, feval = lgb_amex_metric ) # Save best model joblib.dump(model, f"../models/models-{self.locker['comp_name']}/model_exp_{self.current_dict['current_exp_no']}.pkl") """ # https://www.kaggle.com/competitions/amex-default-prediction/discussion/332575 global_variables.fold = self.optimize_on global_variables._state = self._state # sometimes we may want to predict an old experiment so don't use current exp no, set self.exp_no # counter stores no of times objective function is run path = f"../models/models-{self.comp_name}/callback_logs/lgb_models_e_{self.exp_no}_f_{global_variables.counter}_{global_variables._state}/" mkdir_from_path(path) n_rounds = 5000#5000 model = lgb.train(params, train_set = lgb_train, num_boost_round= n_rounds, valid_sets = [lgb_train,lgb_valid], feval=feval_RMSPE, verbose_eval= 250, early_stopping_rounds=500 ) # model = lgb.train( # params = params, # train_set = lgb_train, # num_boost_round = 105, #10500, # 0, #10500 # valid_sets = [lgb_train,lgb_valid], # #early_stopping_rounds = 1500, #100 # verbose_eval = 50, # #feval = amzcomp1_metrics, # #callbacks=[save_model1()], # #callbacks=[save_model2(models_folder=pathlib.Path(path), fold_id=global_variables.counter, min_score_to_save=0.78, every_k=50)] # ) elif self.model_name in ["lgbmr"]: # , "lgbmc"]: model.fit( self.xtrain, self.ytrain, eval_set=[(self.xvalid, self.yvalid)], eval_metric="auc", early_stopping_rounds=1000, callbacks=[ LightGBMPruningCallback(trial, "auc") ], # there is trial which creates issue when called from seed_it verbose=0, ) elif self.model_name in ["lgbmc"]: # done # https://www.kaggle.com/code/ambrosm/amex-lightgbm-quickstart model.fit( self.xtrain, self.ytrain, eval_set = [(self.xvalid, self.yvalid)], # custom metrics: https://lightgbm.readthedocs.io/en/latest/pythonapi/lightgbm.LGBMClassifier.html eval_metric=[lgbmc_amex_metric], callbacks= [log_evaluation(100)] # save_model() can't be called from lgbmc but can be from lgb ) elif self.model_name == "xgb": # not working # https://www.kaggle.com/competitions/amex-default-prediction/discussion/332575 # global_variables.fold = self.optimize_on # global_variables._state = self._state # global_variables.exp_no = self.current_dict['current_exp_no'] # path = f"../models/models-{self.comp_name}/lgb_models_e_{global_variables.exp_no}_f_{global_variables.counter}_{global_variables._state}/" # mkdir_from_path(path) # https://www.kaggle.com/code/cdeotte/xgboost-starter-0-793 # https://www.kaggle.com/code/sietseschrder/xgboost-starter-0-793 # of chris deotte and one other person but not worked yet # it is a low level xgboost # TRAIN, VALID, TEST FOR FOLD K # pass xtrain, ytrain as df # Xy_train = IterLoadForDMatrix(np.concatenate((self.xtrain, self.ytrain.reshape(-1,1)), axis=1)) # dtrain = xgb.DeviceQuantileDMatrix(Xy_train, max_bin=256) # dvalid = xgb.DMatrix(data=self.xvalid, label=self.yvalid) # if we are using feature importance it is better to convert it to dataframe if self.calculate_feature_importance: self.xtrain = pd.DataFrame(self.xtrain, columns = self.useful_features) self.xvalid = pd.DataFrame(self.xvalid, columns = self.useful_features) self.ytrain = pd.DataFrame(self.ytrain, columns = [self.locker["target_name"]]) self.yvalid = pd.DataFrame(self.yvalid, columns = [self.locker["target_name"]]) # https://www.kaggle.com/code/thedevastator/ensemble-lightgbm-catboost-xgboost dtrain = xgb.DMatrix(data = self.xtrain, label = self.ytrain) dvalid = xgb.DMatrix(data = self.xvalid, label = self.yvalid) # TRAIN MODEL FOLD K watchlist = [(dtrain, 'train'), (dvalid, 'eval')] model = xgb.train(params, dtrain=dtrain, evals= watchlist, # it is same [(dtrain,'train'),(dvalid,'valid')], custom_metric= xgboost_amex_metric_mod1, #getaroom_metrics maximize = True, # be very careful of this maximizes amex_metric # num_boost_round= 9999, #3000, #9999, #9999, # early_stopping_rounds= 5000, # 1000, #5000, #1000, # verbose_eval= 500, #100, num_boost_round= 6000, #3000, #9999, #9999, early_stopping_rounds= 1000, # 1000, #5000, #1000, verbose_eval= 500, #100, #callbacks=[save_model2(models_folder=pathlib.Path(path), fold_id=global_variables.counter, min_score_to_save=0.78, every_k=50)] #callbacks = [save_model()] ) #model.save_model(f"../models/models-{self.locker['comp_name']}/model_exp_{self.current_dict['current_exp_no']}.xgb") # https://stackoverflow.com/questions/37627923/how-to-get-feature-importance-in-xgboost # print('best ntree_limit:', model.best_ntree_limit) # print('best score:', model.best_score) # self.best_ntree_limit_value = model.best_ntree_limit # GET FEATURE IMPORTANCE FOR FOLD K # will work only when we pass a dataframe if self.calculate_feature_importance: dd = model.get_score(importance_type='weight') temp = pd.DataFrame({'feature': list(dd.keys()) ,f'importance_{global_variables.counter}': list(dd.values())}) # dd.keys() replace by self.ordered_list_test if self.feature_importance_table is None: # first time self.feature_importance_table = pd.DataFrame({'feature':dd.keys(),f'importance_{global_variables.counter}':dd.values()}) else: self.feature_importance_table = pd.merge(self.feature_importance_table, temp, on="feature",how="left") del dd , temp gc.collect() print(self.feature_importance_table) elif self.model_name == "cbc": # for catboost params,eval_metric are set while creating model actually it is done for every wrapper function. # for low level like lgb we call it from .train() model.fit( self.xtrain, self.ytrain, eval_set = [(self.xvalid, self.yvalid)], verbose=0, #eval_metric= [lgb_amex_metric], no eval metric for catboost, actually below true # we can call it when instantiating # https://stackoverflow.com/questions/65462220/how-to-create-custom-eval-metric-for-catboost # https://www.kaggle.com/code/thedevastator/ensemble-lightgbm-catboost-xgboost ) elif self.model_name == "cbr": # for catboost params,eval_metric are set while creating model actually it is done for every wrapper function. # for low level like lgb we call it from .train() model.fit( self.xtrain, self.ytrain, eval_set = [(self.xvalid, self.yvalid)], verbose=0, ) elif self.model_name in ["tabnetr", "tabnetc", "k1", "k2", "k3", "k4"]: # keras # ------------------------- general for all keras model # lr ranges from 1--> 0.001 # in cosine_decay : start 0.01 --> end 0.0001 # in exponential_decay : start 0.01 --> end 0.00001 # [ when we use lr scheduler] # -> we will use lr as the start while keeping end fixed to be either 0.0001 or 0.00001 # [ when we don't use lr scheduler] # -> we will use lr as constant , in this way we don't have to make much changes. # Althouh it is better to always use lr_scheduler verbose = 0 if self.model_name not in ["tabnetc", "tabnetr"]: callbacks = self.get_callbacks(params, verbose) # if self.model_name == "k4" or self.model_name == "k1": # for now we are passing "k1" as well later make it as param [callbacks] # # DLastStark model # callbacks = [lr, chk_point, TerminateOnNaN()] # else: # callbacks = [ checkpoint, reduce_lr], #[stop, checkpoint, reduce_lr], # ---------------------- if self.model_name in ["tabnetc", "tabnetr"]: model.fit( self.xtrain, self.ytrain, eval_set=[(self.xvalid, self.yvalid)], max_epochs = 30, # patience = 50, batch_size = 64, virtual_batch_size = 128, #128*20, num_workers = 4, drop_last = False, ) elif self.locker["data_type"] == "tabular": history = model.fit( x=self.xtrain, y=self.ytrain, validation_data=( self.xvalid, self.yvalid, ), # validation_data will override validation_split batch_size=params["batchsize"], epochs=params["epochs"], shuffle=True, validation_split=0.15, callbacks=callbacks, ) if self.model_name == "k4": model = load_model( f"../models/models-{self.locker['comp_name']}/model_exp_{self.current_dict['current_exp_no']}.h5", ) if self.locker["data_type"] == "image": history = model.fit( self.train_dataset, steps_per_epoch=np.ceil( len(self.xtrain) / self.params["batchsize"] ), epochs=self.params["epochs"], verbose=2, validatioin_data=self.valid_dataset, validation_step=8, callbacks=[stop, checkpoint, reduce_lr], ) model.evaluate_generator( generator=self.valid_dataset, steps=1 ) # 1 to make it perfectly divisible if self.model_name not in ["tabnetc", "tabnetr"]: self._history = history.history elif self.model_name in ["tez1", "tez2", "p1", "pretrained"]: # pytorch model_path_es = f"../models/models-{self.locker['comp_name']}/model_exp_{self.current_dict['current_exp_no'] + 1}_es" # 'model_es_s' + str(CFG.img_size) + '_f' +str(fold) + '.bin', model_path_s = f"../models/models-{self.locker['comp_name']}/model_exp_{self.current_dict['current_exp_no'] + 1}_s" if self._state == "seed": model_path_es = model_path_es + f"_seed_{self._random_state}" model_path_s = model_path_s + f"_seed_{self._random_state}" stop = EarlyStopping( monitor="valid_loss", model_path=model_path_es, patience=params["patience"], mode="min", ) es = EarlyStopping( monitor="valid_accuracy", model_path=model_path_es, patience=10, mode="max", save_weights_only=True, ) if self.model_name == "tez1": history = model.fit( self.train_dataset, # self.train_dataset valid_dataset=self.valid_dataset, # self.valid_dataset train_bs=params["batch_size"], valid_bs=16, device="cuda", epochs=params["epochs"], callbacks=[stop], fp16=True, ) # self._history = history.history model.save( model_path_s, ) elif self.model_name == "tez2": config = TezConfig( training_batch_size=params["batch_size"], validation_batch_size=2 * params["batch_size"], test_batch_size=2 * params["batch_size"], gradient_accumulation_steps=1, epochs=params["epochs"], step_scheduler_after="epoch", step_scheduler_metric="valid_accuracy", fp16=True, ) model.fit( self.train_dataset, valid_dataset=self.valid_dataset, callbacks=[es], config=config, ) elif self.model_name in ["p1", "pretrained"]: model.fit(n_iter=params["epochs"]) # self._history = history.history model.save( model_path_s, ) else: # tabular model.fit(self.xtrain, self.ytrain) # for now calculate here feature_permutation importance for xgb """ Can be modified to test only the new features, to make it fast """ # col1, col2, col3, col4 if self.calculate_permutation_feature_importance: prefix_name = "perm_importance" perm = {} #dvalid = xgb.DMatrix(data = self.xvalid, label = self.yvalid) #self.valid_preds = [model.predict(self.xvalid)] if self.model_name.startswith("k"): self.valid_preds = [model.predict(self.xvalid).flatten()] # NN else: self.valid_preds = [model.predict(self.xvalid)] #baseline= amex_metric_mod(self.yvalid, self.valid_preds[0][:]) # score valid predictions if self.metrics_name in [ "auc", "accuracy", "f1", "recall", "precision", "logloss", "auc_tf", "amex_metric", "amex_metric_mod", "amex_metric_lgb_base", ]: # Classification cl = ClassificationMetrics() if self.locker["comp_type"] == "multi_label": s1 = cl(self.metrics_name, self.yvalid[:, 0], self.valid_preds[0][:]) s2 = cl(self.metrics_name, self.yvalid[:, 1], self.valid_preds[1][:]) s3 = cl(self.metrics_name, self.yvalid[:, 2], self.valid_preds[2][:]) baseline = (s1 + s2 + s3) / 3 elif self.metrics_name in ["auc", "log_loss", "amex_metric"]: # then y proba can't be None # sanity check : convert it to numpy array baseline = cl( self.metrics_name, np.array(self.yvalid), "y_pred_dummy", np.array(self.valid_preds[0]), ) elif self.metrics_name == "amex_metric_mod": baseline= amex_metric_mod(self.yvalid, self.valid_preds[0][:]) elif self.metric_name == "amex_metric_lgb_base": baseline = amex_metric_lgb_base(self.yvalid, self.yvalid_preds[0][:]) else: baseline = cl(self.metrics_name, self.yvalid, self.valid_preds[0][:]) elif self.metrics_name in ["mae", "mse", "rmse", "msle", "rmsle", "r2"]: # Regression rg = RegressionMetrics() baseline = rg(self.metrics_name, self.yvalid, self.valid_preds) elif self.metrics_name == "getaroom_metrics": baseline = getaroom_metrics(self.yvalid, self.valid_preds[0]) elif self.metrics_name == "amzcomp1_metrics": baseline = amzcomp1_metrics(self.yvalid, self.valid_preds[0]) #care_feat = amex4_settings().feature_dict2["date"] # care_feat = getaroom_settings().feature_dict['base'] # care_feat += getaroom_settings().feature_dict['base_interact'] # care_feat = list(set(care_feat)) # don't know why it duplicated care_feat = list(set(self.useful_features)) print("Total no of features:", len(care_feat), len(set(care_feat))) print(f"Expected Time: {len(care_feat)*2/60} minutes" ) index_list = [self.useful_features.index(i) for i in care_feat] self.xvalid1 = self.xvalid.copy() for i,f_name in zip(index_list, care_feat): #range(self.xvalid.shape[1]): # no of features #print(f"perm: {i}") value = self.xvalid1[:,i].copy() # permute 10 times score = [] for j in range(3): self.xvalid1[:,i] = np.random.permutation(self.xvalid1[:,i].copy()) #dvalid = xgb.DMatrix(data = self.xvalid, label = self.yvalid) if self.model_name.startswith("k"): self.valid_preds = [model.predict(self.xvalid).flatten()] # NN else: self.valid_preds = [model.predict(self.xvalid1)] # score valid predictions if self.metrics_name in [ "auc", "accuracy", "f1", "recall", "precision", "logloss", "auc_tf", "amex_metric", "amex_metric_mod", "amex_metric_lgb_base", ]: # Classification cl = ClassificationMetrics() if self.locker["comp_type"] == "multi_label": s1 = cl(self.metrics_name, self.yvalid[:, 0], self.valid_preds[0][:]) s2 = cl(self.metrics_name, self.yvalid[:, 1], self.valid_preds[1][:]) s3 = cl(self.metrics_name, self.yvalid[:, 2], self.valid_preds[2][:]) baseline1 = (s1 + s2 + s3) / 3 elif self.metrics_name in ["auc", "log_loss", "amex_metric"]: # then y proba can't be None # sanity check : convert it to numpy array baseline1 = cl( self.metrics_name, np.array(self.yvalid), "y_pred_dummy", np.array(self.valid_preds[0]), ) elif self.metrics_name == "amex_metric_mod": baseline1= amex_metric_mod(self.yvalid, self.valid_preds[0][:]) elif self.metric_name == "amex_metric_lgb_base": baseline1 = amex_metric_lgb_base(self.yvalid, self.yvalid_preds[0][:]) else: baseline1 = cl(self.metrics_name, self.yvalid, self.valid_preds[0][:]) elif self.metrics_name in ["mae", "mse", "rmse", "msle", "rmsle", "r2"]: # Regression rg = RegressionMetrics() baseline1 = rg(self.metrics_name, self.yvalid, self.valid_preds) elif self.metrics_name == "getaroom_metrics": baseline1 = getaroom_metrics(self.yvalid, self.valid_preds[0]) elif self.metrics_name == "amzcomp1_metrics": baseline1 = amzcomp1_metrics(self.yvalid, self.valid_preds[0]) score.append(baseline1) #score.append( amex_metric_mod(self.yvalid, self.valid_preds[0][:]) ) #perm[self.useful_features[i]] = np.mean(score) - baseline perm[f_name] = np.mean(score) - baseline # reset back self.xvalid1[:,i] = value gc.collect() temp = pd.DataFrame({'feature': list(perm.keys()) ,f'{prefix_name}_{global_variables.counter}': list(perm.values())}) # dd.keys() replace by self.ordered_list_test if self.feature_importance_table is None: # first time self.feature_importance_table = pd.DataFrame({'feature':perm.keys(),f'{prefix_name}_{global_variables.counter}':perm.values()}) else: self.feature_importance_table = pd.merge(self.feature_importance_table, temp, on="feature",how="left") del perm , temp , self.xvalid1 gc.collect() print(self.feature_importance_table) """ Make prediction [keras datagen pytorch dataset ] tabular xvalid yvalid # because of multi-class evearything is a list even for 1d it is list of single element i.e. 1d array """ metrics_name = self.metrics_name if self.locker["data_type"] in ["image_path", "image_df", "image_folder"]: # storage for oof and submission # produce predictions - oof if self.model_name in ["tabnetr", "tabnetc", "k1", "k2", "k3"]: # keras image self.valid_dataset.reset() temp_preds = model.predict_generator( self.valid_dataset, steps=STEP_SIZE_TEST, verbose=1 ) elif self.model_name in ["tez1", "tez2"]: valid_preds = model.predict( self.valid_dataset, batch_size=16, n_jobs=-1 ) temp_preds = None for p in valid_preds: if temp_preds is None: temp_preds = p else: temp_preds = np.vstack((temp_preds, p)) gc.collect() elif self.model_name in ["p1", "pretrained"]: valid_preds = model.predict(self.valid_loader) # valid_preds = valid_preds.to("cpu") if self.locker["comp_type"] == "multi_label": temp_preds = [None, None, None] else: temp_preds = [None] for i, n in enumerate(temp_preds): valid_preds[i] = valid_preds[i].to("cpu") for p in valid_preds[i]: if temp_preds[i] is None: temp_preds[i] = p else: temp_preds[i] = np.vstack((temp_preds[i], p)) gc.collect() gc.collect() # for now done only for pretrained part self.valid_preds = [ np.argmax(temp_pred, axis=1) for temp_pred in temp_preds ] if self.locker["comp_type"] == "multi_label": print("Cal valid preds") print(self.valid_preds[0][:3]) print(self.valid_preds[1][:3]) print(self.valid_preds[2][:3]) if ( self._state == "seed" or self._state == "fold" ): # so create test prediction # produce predictions - test data if self.model_name in ["tabnetr", "tabnetc", "k1", "k2", "k3"]: self.valid_dataset = model.predict_generator( self.test_dataset, steps=STEP_SIZE_TEST, verbose=1 ) elif self.model_name in ["tez1", "tez2"]: test_preds = model.predict( self.test_dataset, batch_size=params["batch_size"], n_jobs=-1 ) temp_preds = None for p in test_preds: if temp_preds is None: temp_preds = p else: temp_preds = np.vstack((temp_preds, p)) gc.collect() elif self.model_name in ["p1", "pretrained"]: test_preds = model.predict(self.test_loader) # test_preds = test_preds.to("cpu") if self.locker["comp_type"] == "multi_label": temp_preds = [None, None, None] else: temp_preds = [None] for i, n in enumerate(temp_preds): test_preds[i] = test_preds[i].to("cpu") for p in test_preds[i]: if temp_preds[i] is None: temp_preds[i] = p else: temp_preds[i] = np.vstack((temp_preds[i], p)) gc.collect() gc.collect() # temp_preds = None # for p in test_preds: # if temp_preds is None: # temp_preds = p # else: # temp_preds = np.vstack((temp_preds, p)) # self.test_preds = temp_preds.argmax(axis=1) self.test_preds = [temp_pred.argmax(axis=1) for temp_pred in temp_preds] if self.locker["comp_type"] == "multi_label": print("Cal test preds") print(self.test_preds[0][:3]) print(self.test_preds[1][:3]) print(self.test_preds[2][:3]) elif self.locker["data_type"] == "tabular": if self.comp_type in [ "2class", "multi_class", "multi_label", ] and self.model_name in [ "xgb", # let's say we use it as a classifier "xgbc", "cbc", "mlpc", "knnc", "dtc", "adbc", "gbmc", "hgbc", "lgbmc", "rfc", ]: # self.model_name not in ["xgbr","lgr","lir", "lgbmr"]: if self.model_name == "lgbmc": #self.valid_preds = model.predict_proba(self.xvalid, raw_score=True) #[:, 1] self.valid_preds = model.predict_proba(self.xvalid)[:, 1] elif self.model_name in ["xgb"]: # lgb normal self.valid_preds = model.predict(dvalid ) #, iteration_range = (0, self.best_ntree_limit_value)) else: self.valid_preds = model.predict_proba(self.xvalid)[:, 1] elif self.model_name.startswith("k")or self.model_name in ["tabnetr", "tabnetc"]: self.valid_preds = model.predict(self.xvalid).flatten() # NN print("k") print(self.xvalid.shape, self.valid_preds.shape) print(self.valid_preds) else: self.valid_preds = model.predict(self.xvalid) # ML self.valid_preds = [ self.valid_preds ] # list of predictions maintain to sink with multilabel if ( self._state == "seed" or self._state == "fold" ): # so create test prediction # produce predictions - test data if self.locker["comp_type"] == "multi_label": temp_preds = [None, None, None] else: temp_preds = [None] # special case if self.comp_type in [ "2class", "multi_class", "multi_label", ] and self.model_name in [ "xgbc", "cbc", "mlpc", "knnc", "dtc", "adbc", "gbmc", "hgbc", "lgbmc", "rfc", ]: # self.model_name not in ["xgbr","lgr","lir", "lgbmr"]: # shape should be 1D (15232,) if self.model_name == "xgb": temp_preds[0] = model.predict(xgb.DMatrix(data=self.xtest) ) # , iteration_range = (0, self.best_ntree_limit_value)) # Yes this was causing issue else: temp_preds[0] = model.predict_proba(self.xtest)[:, 1] else: temp_preds[0] = model.predict(self.xtest) # else: # temp_preds[0] = model.predict(self.xtest) self.test_preds = temp_preds del temp_preds gc.collect() else: raise Exception(f"metrics not set yet of type {self.locker['data_type']}") # score valid predictions if self.metrics_name in [ "auc", "accuracy", "f1", "recall", "precision", "logloss", "auc_tf", "amex_metric", "amex_metric_mod", "amex_metric_lgb_base", ]: # Classification cl = ClassificationMetrics() if self.locker["comp_type"] == "multi_label": s1 = cl(self.metrics_name, self.yvalid[:, 0], self.valid_preds[0][:]) s2 = cl(self.metrics_name, self.yvalid[:, 1], self.valid_preds[1][:]) s3 = cl(self.metrics_name, self.yvalid[:, 2], self.valid_preds[2][:]) score = (s1 + s2 + s3) / 3 elif self.metrics_name in ["auc", "log_loss", "amex_metric"]: # then y proba can't be None # sanity check : convert it to numpy array score = cl( self.metrics_name, np.array(self.yvalid), "y_pred_dummy", np.array(self.valid_preds[0]), ) elif self.metrics_name == "amex_metric_mod": score= amex_metric_mod(self.yvalid, self.valid_preds[0][:]) elif self.metric_name == "amex_metric_lgb_base": score = amex_metric_lgb_base(self.yvalid, self.yvalid_preds[0][:]) else: print(self.metrics_name) print(self.yvalid[:5]) print(self.valid_preds[:5]) print() score = cl(self.metrics_name, self.yvalid, self.valid_preds[0][:]) elif self.metrics_name in ["mae", "mse", "rmse", "msle", "rmsle", "r2"]: # Regression rg = RegressionMetrics() score = rg(self.metrics_name, self.yvalid, self.valid_preds) elif self.metrics_name == "getaroom_metrics": #print(self.yvalid.shape, len(self.valid_preds[0]), "this si sit") print(self.yvalid[:4], self.valid_preds[0][:5]) score = getaroom_metrics(self.yvalid, self.valid_preds[0]) elif self.metrics_name == "amzcomp1_metrics": #print(self.yvalid.shape, len(self.valid_preds[0]), "this si sit") print(self.yvalid[:4], self.valid_preds[0][:5]) score = amzcomp1_metrics(self.yvalid, self.valid_preds[0]) if self._state == "opt": # Let's save these values self._trial_score = score # save it to save in log_table because params don't contain our metrics score self.save_logs(params) check_memory_usage("Obj", self, 0) #trial no, It records no of times objective function is called global_variables.counter += 1 return score def run( self, useful_features, with_gpu="--|--", prep_list="--|--", optimize_on="--|--", ): """ Run is used to call Optuna trials Run is also used to initialize variables while making prediction, so we call run --> then we call obj while Predicting """ if with_gpu != "--|--": self.with_gpu = with_gpu if optimize_on != "--|--": self.optimize_on = optimize_on if prep_list != "--|--": self.prep_list = prep_list self.useful_features = useful_features # ["pixel"] """ ###################################### # Memory uage # ###################################### """ print(f"Optimize on fold name {self.fold_name} and fold no: {self.optimize_on}") # BOTTLENECK return_type = "numpy_array" # "numpy_array" # "tensor" # xtest is not needed in optimiztion # xtest is needed in predict but only once so called from outside # slow # for i,f in enumerate(self.optimize_on): # if i==0: # # first time # self.val_idx, self.xtrain, self.xvalid, self.ytrain, self.yvalid, self.ordered_list_train = bottleneck(self.locker['comp_name'],self.useful_features, self.fold_name, f, self._state, return_type) # else: # # second time # val_idx, xtrain, xvalid, ytrain, yvalid, self.ordered_list_train = bottleneck(self.locker['comp_name'],self.useful_features, self.fold_name, f, self._state, return_type) # if val_idx is not None: # self.val_idx += val_idx # else: # self.valid_idx = None # if xtrain is not None: # self.xtrain = np.concatenate([self.xtrain, xtrain], axis=0) # else: # self.xtrain = None # if xvalid is not None: # self.xvalid = np.concatenate([self.xvalid, xvalid], axis=0) # else: # self.xvalid = None # if ytrain is not None: # self.ytrain = np.concatenate([self.ytrain, ytrain], axis=0) # else: # self.ytrain = None # if yvalid is not None: # self.yvalid = np.concatenate([self.yvalid, yvalid], axis=0) # else: # self.yvalid = None # del val_idx, xtrain, xvalid, ytrain, yvalid # gc.collect() # optimize on fold no [2] mean optimizing on [0,1,3,4] self.val_idx, self.xtrain, self.xvalid, self.ytrain, self.yvalid, self.ordered_list_train = bottleneck(self.locker['comp_name'],self.useful_features, self.fold_name, self.optimize_on, self._state, return_type) if self.model_name == "tabnetr": self.ytrain = self.ytrain.reshape(-1,1) self.yvalid = self.yvalid.reshape(-1,1) print("printing xtrain") print(self.xtrain) print() print("printing xvalid") print(self.xvalid) print("-"*40) if self.model_name.startswith("k") or self.model_name in ["tabnetr", "tabnetc", 'gbmr','gbmc']: if self._state == "fold": # has train , valid , test # fill with na in case of NN self.xtrain[np.isnan(self.xtrain)] = 0 self.xvalid[np.isnan(self.xvalid)] = 0 self.xtest[np.isnan(self.xtest)] = 0 #print("self.xtrain.shape, self.ytrain.shape, self.xvalid.shape, self.yvalid.shape, len(self.val_idx), self.xtest.shape") #print(self.xtrain.shape, self.ytrain.shape, self.xvalid.shape, self.yvalid.shape, len(self.val_idx), self.xtest.shape) pass elif self._state == "opt": self.xtrain[np.isnan(self.xtrain)] = 0 self.xvalid[np.isnan(self.xvalid)] = 0 #print("self.xtrain.shape, self.ytrain.shape, self.xvalid.shape, self.yvalid.shape, len(self.val_idx)") #print(self.xtrain.shape, self.ytrain.shape, self.xvalid.shape, self.yvalid.shape, len(self.val_idx)) pass else: raise Exception("Can't enter run function if _state != opt/fold") if self._state != 'opt': # "fold", "_seed" then we would have xtest and corresponding self.ordered_list_test # sanity check: for c,(i,j) in enumerate(zip(self.ordered_list_test, self.ordered_list_train)): if i != j: print() print("--+"*40) print(self.ordered_list_test) print() print(self.ordered_list_train) raise Exception(f"Feature no {c} don't correspond in test - train {i},{j}") # be sure self.useful_features = self.ordered_list_train print("No of Features:",len(self.useful_features)) if self.model_name in ["lgr"]: # fill missing values for item in [self.xtrain, self.xvalid]: if item is not None: item[ np.isnan(item)] = -999 #item.fillna(-999, inplace=True) #self.val_idx, self.xtrain, self.xvalid, self.ytrain, self.yvalid, self.xtest = bottleneck(self.locker['comp_name'],self.useful_features, self.fold_name, self.optimize_on, self._state, return_type) # print(len(self.val_idx)) # print(self.xtrain.shape) # print(self.xvalid.shape) # print(self.ytrain.shape) # print(self.yvalid.shape) #print(self.xtest.shape) """ image_df : image is stored in dataframe image_path: image path is there in dataframe image_folder: there are image folders returns self.valid_dataset self.train_dataset """ # => albumations augmentations # tez1 if self.aug_type == "aug1": self.train_aug = A.Compose( [ A.Normalize( mean=[0.5, 0.5, 0.5], std=[0.5, 0.5, 0.5], max_pixel_value=255.0, p=1.0, ) ], p=1.0, ) self.valid_aug = A.Compose( [ A.Normalize( mean=[0.5, 0.5, 0.5], std=[0.5, 0.5, 0.5], max_pixel_value=255.0, p=1.0, ) ], p=1.0, ) # tez2 elif self.aug_type == "aug2": self.train_aug = A.Compose( [ albumentations.Normalize( mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225], max_pixel_value=255.0, p=1.0, ), ], p=1.0, ) self.valid_aug = A.Compose( [ albumentations.Normalize( mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225], max_pixel_value=255.0, p=1.0, ), ], p=1.0, ) # kaggle tv elif self.aug_type == "aug3": self.train_aug = A.Compose([Rotate(20), ToTensor()]) self.valid_aug = A.Compose([ToTensor()]) # abhishek bengaliai video elif self.aug_type == "aug4": # valid self.valid_aug = albumentations.Compose( [ albumentations.Resize(128, 128, always_apply=True), albumentations.Normalize( (0.485, 0.456, 0.406), (9, 0.224, 0.225), always_apply=True ), ] ) # train self.train_aug = albumentations.Compose( [ albumentations.Resize(128, 128, always_apply=True), albumentations.ShiftScaleRotate( shift_limit=0.0625, scale_limit=5, p=0.9 ), albumentations.Normalize( (0.485, 0.456, 0.406), (9, 0.224, 0.225), always_apply=True ), ] ) # self.sample = pd.read_csv( # f"../input/input-{self.locker['comp_name']}/" + "sample.csv" # ) # self.test = pd.read_csv(f"../configs/configs-{self.locker['comp_name']}/" + "test.csv") # Do we need self.test Now because we are not mapping to id using whole putting whole as array # we definately not need it in optimization # self.test = pd.read_parquet( # f"../input/input-{self.locker['comp_name']}/" + "test.parquet" # ) # self.test[self.locker["target_name"]] = 0.0 # self.sample = self.test.copy() # temp No need now It only increases memory usage use inside "image_df" # => datasets if self.locker["data_type"] == "image_path": image_path = f"../input/input-{self.locker['comp_name']}/" + "train_images/" test_path = f"../input/input-{self.locker['comp_name']}/" + "test_images/" self.sample = self.test.copy()[ [self.locker["id_name"], self.locker["target_name"]] ] if self.model_name in ["tez1", "tez2", "pretrained", "p1"]: # now implemented for pytorch # use pytorch self.train_image_paths = [ os.path.join(image_path, str(x)) for x in self.xtrain[self.locker["id_name"]].values ] self.valid_image_paths = [ os.path.join(image_path, str(x)) for x in self.xvalid[self.locker["id_name"]].values ] # new # ------------------ prep test dataset # self.test_image_paths = [ # os.path.join( # test_path, str(x) # ) # f"../input/input-{self.locker['comp_name']}/" + "test_img/" + x # for x in self.sample[self.locker["id_name"]].values # ] # fake targets # correctly defince sample new_list = [] # do this to maintain order for i in self.sample[self.locker["id_name"]]: if i not in new_list: new_list.append(i) gc.collect() self.sample = pd.DataFrame(new_list, columns=[self.locker["id_name"]]) self.sample[self.locker["target_name"]] = 0 self.test_image_paths = [ os.path.join( test_path, str(x) ) # f"../input/input-{self.locker['comp_name']}/" + "test_img/" + x for x in self.sample[self.locker["id_name"]].values ] self.test_targets = self.sample[ self.locker["target_name"] ].values # dfx_te.digit_sum.values # ==========================================> if self._dataset in [ "BengaliDataset", ]: print("Entered here", self._dataset) # BengaliDataset self.train_dataset = BengaliDataset( # train_dataset image_paths=self.train_image_paths, targets=self.ytrain, img_height=128, img_width=128, transform=self.train_aug, ) self.valid_dataset = BengaliDataset( # valid_dataset image_paths=self.valid_image_paths, targets=self.yvalid, img_height=128, img_width=128, transform=self.valid_aug, ) self.test_dataset = BengaliDataset( image_paths=self.test_image_paths, targets=self.test_targets, img_height=128, img_width=128, transform=self.valid_aug, ) print(self.train_dataset) print(self.valid_dataset) print(self.test_dataset) else: # imageDataset self.train_dataset = ImageDataset( # train_dataset image_paths=self.train_image_paths, targets=self.ytrain, augmentations=self.train_aug, ) self.valid_dataset = ImageDataset( # valid_dataset image_paths=self.valid_image_paths, targets=self.yvalid, augmentations=self.valid_aug, ) self.test_dataset = ImageDataset( image_paths=self.test_image_paths, targets=self.test_targets, augmentations=self.valid_aug, ) elif self.model_name in ["k1", "k2", "k3"]: # now implemented for keras # use keras flow_from_dataframe train_datagen = ImageDataGenerator(rescale=1.0 / 255) valid_datagen = ImageDataGenerator(rescale=1.0 / 255) if self.use_cutmix != True: self.train_dataset = train_datagen.flow_from_dataframe( dataframe=self.xtrain, directory=image_path, target_size=(28, 28), # images are resized to (28,28) x_col=self.locker["id_name"], y_col=self.locker["target_name"], batch_size=32, seed=42, shuffle=True, class_mode="categorical", # "binary" ) elif self.use_cutmix == True: train_datagen1 = train_datagen.flow_from_dataframe( dataframe=self.xtrain, directory=image_path, target_size=(28, 28), # images are resized to (28,28) x_col=self.locker["id_name"], y_col=self.locker["target_name"], batch_size=32, seed=42, shuffle=True, # Required for cutmix class_mode="categorical", # "binary" ) train_datagen2 = train_datagen.flow_from_dataframe( dataframe=self.xtrain, directory=image_path, target_size=(28, 28), # images are resized to (28,28) x_col=self.locker["id_name"], y_col=self.locker["target_name"], batch_size=32, seed=42, shuffle=True, # Required for cutmix class_mode="categorical", # "binary" ) self.train_dataset = CutMixImageDataGenerator( generator1=train_generator1, generator2=train_generator2, img_size=(28, 28), batch_size=32, ) self.valid_dataset = valid_datagen.flow_from_dataframe( dataframe=self.xvalid, directory=image_path, target_size=(28, 28), # images are resized to (28,28) x_col=self.locker["id_name"], y_col=self.locker["target_name"], batch_size=32, seed=42, shuffle=True, class_mode="categorical", # "binary" ) elif self.locker["data_type"] == "image_df": # # it is not good to use whole image everytime # # create a seperate test_df and sample_df aka test to store test set # self.test = pd.read_csv(f"../configs/configs-{self.locker['comp_name']}/" + "test_df.csv") t = [] for n in self.useful_features: t += filter(lambda x: x.startswith(n), list(self.xtrain.columns)) gc.collect() self.filtered_features = t if self._dataset in [ "BengaliDataset", ]: # now implemented for pytorch # Can make our own custom dataset.. Note tez has dataloader inside the model so don't make self.train_dataset = BengaliDataset( # train_dataset csv=self.xtrain[ self.filtered_features + [self.locker["target_name"]] ], img_height=28, img_width=28, transform=self.train_aug, ) self.valid_dataset = BengaliDataset( # valid_dataset csv=self.xvalid[ self.filtered_features + [self.locker["target_name"]] ], img_height=28, img_width=28, transform=self.valid_aug, ) self.test_dataset = BengaliDataset( df=self.test[self.filtered_features + [self.locker["target_name"]]], img_height=28, img_width=28, augmentations=self.valid_aug, ) elif self._dataset in [ "DigitRecognizerDataset", ]: # DigitRecognizerDataset self.train_dataset = DigitRecognizerDataset( df=self.xtrain[ self.filtered_features + [self.locker["target_name"]] ], augmentations=self.train_aug, model_name=self.model_name, ) self.valid_dataset = DigitRecognizerDataset( df=self.xvalid[ self.filtered_features + [self.locker["target_name"]] ], augmentations=self.valid_aug, model_name=self.model_name, ) self.test_dataset = DigitRecognizerDataset( df=self.test[self.filtered_features + [self.locker["target_name"]]], augmentations=self.valid_aug, model_name=self.model_name, ) # nn.Crossentropy requires target to be single not from interval [0, #classes] # if self.model_name.startswith("p") and self.comp_type != "2class": # self.ytrain = np_utils.to_categorical(self.ytrain) # self.yvalid = np_utils.to_categorical(self.yvalid) elif self.locker["data_type"] == "image_folder": # folders of train test pass # use keras flow_from_directory don't use for now because it looks for subfolders with folder name as different targets like horses/humans elif self.locker["data_type"] == "tabular": # concept of useful feature don't make sense for image problem # self.xtrain = self.xtrain[self.useful_features] # self.xvalid = self.xvalid[self.useful_features] # self.xtest = self.test[self.useful_features] # del self.test # gc.collect() prep_dict = { "SiMe": SimpleImputer(strategy="mean"), "SiMd": SimpleImputer(strategy="median"), "SiMo": SimpleImputer(strategy="mode"), "Ro": RobustScaler(), "Sd": StandardScaler(), "Mi": MinMaxScaler(), } for f in self.prep_list: if f in list(prep_dict.keys()): sc = prep_dict[f] self.xtrain = sc.fit_transform(self.xtrain) if self._state != "opt": self.xtest = sc.transform(self.xtest) elif f == "Lg": self.xtrain = pd.DataFrame( self.xtrain, columns=self.useful_features ) self.xvalid = pd.DataFrame( self.xvalid, columns=self.useful_features ) if self._state != "opt": self.xtest = pd.DataFrame(self.xtest, columns=self.useful_features) # xtest = pd.DataFrame(xtest, columns=useful_features) for col in self.useful_features: self.xtrain[col] = np.log1p(self.xtrain[col]) self.xvalid[col] = np.log1p(self.xvalid[col]) if self._state != "opt": self.xtest[col] = np.log1p(self.xtest[col]) # xtest[col] = np.log1p(xtest[col]) gc.collect() else: raise Exception(f"scaler {f} is invalid!") gc.collect() # create instances # enable below for multiclass problem # if self.model_name.startswith("k") and self.comp_type != "2class": # ## to one hot # self.ytrain = np_utils.to_categorical(self.ytrain) # self.yvalid = np_utils.to_categorical(self.yvalid) gc.collect() if self._state == "opt": # optimization specific work do here # only looking at feature importance while optimizing self.calculate_feature_importance = True self.calculate_permutation_feature_importance = False global_variables.counter = 0 # since we can't get trial no from optuna we are maintaining our own # run() can be called for each new exp so we initialize here rather than at init self.feature_importance_table = None # store the feature importances each trial wise # create optuna study study = optuna.create_study(direction=self._aim, study_name=self.model_name) study.optimize( lambda trial: self.obj(trial), n_trials=self.n_trials, ) # it tries 50 different values to find optimal hyperparameter if self.save_models == True: # let's save logs c = self.current_dict[ "current_exp_no" ] # optuna is called once in each exp so c will be correct save_pickle( f"../configs/configs-{self.locker['comp_name']}/logs/log_exp_{c}.pkl", self._log_table, ) self._log_table = None # save feature importance if self.calculate_feature_importance or self.calculate_permutation_feature_importance: # need to calculate feature importance save_pickle(f"../configs/configs-{self.locker['comp_name']}/feature_importance/feature_importance_e_{c}_opt.pkl",self.feature_importance_table) del self.feature_importance_table gc.collect() print("=" * 40) print("Best parameters found:") print(study.best_trial.value) self.params = study.best_trial.params # crete params to be used in seed print(study.best_trial.params) print("=" * 40) # later put conditions on whether to put seed or not if self.model_name == "lgr": del self.params["c"] # seed_mean, seed_std = self._seed_it() # generate seeds seed is now generate seperately gc.collect() check_memory_usage("run", self, 0) return study, self._random_state # , seed_mean, seed_std check_memory_usage("run", self, 0) if __name__ == "__main__": import optuna a = OptunaOptimizer() del a """ {'objective': 'binary', 'metric': 'binary_logloss', 'boosting': 'dart', 'learning_rate': 0.009238354429187228, 'seed': 241, 'num_leaves': 105, 'feature_fraction': 0.16728169509013685, 'bagging_freq': 9, 'bagging_fraction': 0.500294582036411, 'n_jobs': -1, 'lambda_l2': 3, 'min_data_in_leaf': 45} """

File no 24: /src-framework3/output.py
import os import sys from utils import * import pandas as pd import numpy as np class out: def __init__(self, fold_name, exp_no=-1,file_type="parquet"): self.exp_no = exp_no self.file_type = file_type # initialize rest with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: self.comp_name = i x.close() self.Table = load_pickle(f"../configs/configs-{self.comp_name}/Table.pkl") self.locker = load_pickle(f"../configs/configs-{self.comp_name}/locker.pkl") assert fold_name != "" self.fold_name = fold_name # self.my_folds = pd.read_csv(f"../configs/configs-{self.comp_name}/my_folds.csv") self.my_folds = pd.read_parquet( f"../input/input-{self.comp_name}/my_folds.parquet" ) # self.test = pd.read_csv(f"../configs/configs-{self.comp_name}/test.csv") self.test = pd.read_parquet(f"../input/input-{self.comp_name}/test.parquet") # keep sample to input # self.sample = pd.read_csv(f"../input/input-{self.comp_name}/sample.csv") self.sample = pd.read_parquet(f"../input/input-{self.comp_name}/sample.parquet") def dump(self, exp_no="--|--", file_type="--|--"): if exp_no != "--|--": self.exp_no = exp_no if file_type != "--|--": self.file_type = file_type if not self.fold_name.startswith("e"): if self.exp_no == -1: row_e = self.Table[self.Table.exp_no == list(self.Table.exp_no.values)[-1]] self.exp_no = row_e.exp_no.values[0] else: row_e = self.Table[self.Table.exp_no == self.exp_no] assert self.exp_no == row_e.exp_no.values[0] # --> assert self.bv = row_e.bv.values[0] # confirming we are predcting correct experiment: print(f"Output of Exp No {self.exp_no}, whoose bv is {self.bv}") self.exp_no = row_e.exp_no.values[0] self.level_no = row_e.level_no.values[0] # found the row # BOTTLENECK # which oof_fold_name to pull if self.fold_name not in list(row_e.oof_fold_name.values[0]): raise Exception(f"This experiment has no prediction of type {self.fold_name}!!") self.useful_features = [f"pred_e_{self.exp_no}_{self.fold_name}"] return_type = "numpy_array" self.optimize_on = None # just to make sure it is not called xtest, ordered_list_test = bottleneck_test(self.comp_name, self.useful_features, return_type) #val_idx, xtrain, xvalid, ytrain, yvalid, xtest = bottleneck_test(self.locker['comp_name'],self.useful_features, fold_name, self.optimize_on, self._state, return_type) #xtest.shape : (234522,1) #xtrain.shape: (224224,1) print(xtest.shape) print(xtest[:4,:]) try: # fold if self.locker["comp_name"] == "twistmnist": # special case self.sample[self.locker["target_name"]] = ( self.test[f"pred_l_{self.level_no}_e_{self.exp_no}"].values.astype( int ) + 10 ) else: # self.sample[self.locker["target_name"]] = self.test[ # f"pred_l_{self.level_no}_e_{self.exp_no}" # ].values self.sample[self.locker["target_name"]] = xtest # else: # use it when want hard class # self.sample[self.locker["target_name"]] = self.test[f"pred_l_{self.level_no}_e_{self.exp_no}"].values.astype(int) print("Done here") if self.comp_name == 'amzcomp1': self.sample = self.sample.rename(columns= {self.locker['target_name']: 'Time_taken (min)'}) if self.file_type == "parquet": self.sample.to_parquet( f"../working/{self.locker['comp_name']}_sub_e_{int(self.exp_no)}_{self.fold_name}.parquet", index=False ) else: self.sample.to_csv( f"../working/{self.locker['comp_name']}_sub_e_{int(self.exp_no)}_{self.fold_name}.csv", index=False ) #################### Below files are already dumped in the WORKING directory # # seed all # #d1 = pd.read_csv(f"../configs/configs-{self.comp_name}/sub_seed_exp_{self.exp_no}_l_{self.level_no}_all.csv") # d1 = pd.read_parquet(f"../configs/configs-{self.comp_name}/sub_seed_exp_{self.exp_no}_l_{self.level_no}_all.parquet") # if self.locker["comp_name"] == "twistmnist": # d1[self.locker["target_name"]] = d1[self.locker["target_name"]] + 10 # else: # d1[self.locker["target_name"]] = d1[self.locker["target_name"]] # if self.file_type == "parquet": # d1.to_parquet(f"../working/sub_seed_exp_{self.exp_no}_l_{self.level_no}_all.parquet", index=False) # else: # d1.to_csv(f"../working/sub_seed_exp_{self.exp_no}_l_{self.level_no}_all.csv", index=False) # # seed single # #d1 = pd.read_csv(f"../configs/configs-{self.comp_name}/sub_seed_exp_{self.exp_no}_l_{self.level_no}_single.csv") # d1 = pd.read_parquet(f"../configs/configs-{self.comp_name}/sub_seed_exp_{self.exp_no}_l_{self.level_no}_single.parquet") # if self.locker["comp_name"] == "twistmnist": # d1[self.locker["target_name"]] = d1[self.locker["target_name"]] + 10 # twistmnist # else: # d1[self.locker["target_name"]] = d1[self.locker["target_name"]] # if self.file_type == "parquet": # d1.to_parquet(f"../working/sub_seed_exp_{self.exp_no}_l_{self.level_no}_single.parquet", index=False) # else: # d1.to_csv(f"../working/sub_seed_exp_{self.exp_no}_l_{self.level_no}_single.csv", index=False) ############################################################################################## print() print(self.sample.head(2)) except: raise Exception(f"exp_no {self.exp_no} not found with fold name : {self.fold_name}!") else: # starts with e so ensemble self.useful_features = [f"{self.comp_name}_ens_{self.exp_no}"] # this file should be in working directory val = pd.read_parquet(f"../working/{self.useful_features[0]}.parquet") self.sample[self.locker["target_name"]] = val[self.locker["target_name"]] if self.comp_name == 'amzcomp1': self.sample = self.sample.rename(columns= {self.locker['target_name']: 'Time_taken (min)'}) try: if self.file_type == "parquet": self.sample.to_parquet( f"../working/{self.useful_features[0]}.parquet", index=False ) else: self.sample.to_csv( f"../working/{self.useful_features[0]}.csv", index=False ) except: raise Exception("ensemble not created!!") if __name__ == "__main__": # creates fold submission from a predicted experiment """ file_type: parquet:- when working on remote ssh so that it is easy to version it csv:- when working on notebook so that it is easy to make submission as csv """ for exp_no in [70]: # exp_no = ( # 7 # ) # -1 for last prediction i.e. last experiment so you must predict last experiment before doing output.py # need to add which fold prediction to output file_type = "csv" # "csv" fold_name = "fold5" # need to pass some fold name can't keep it empty o = out( fold_name, exp_no, file_type) o.dump() # for exp_no in [0,2,5,11,19,43]: # o= out(exp_no, file_type) # o.dump()

File no 25: /src-framework3/predict.py
from optuna_search import OptunaOptimizer from utils import * from custom_models import * from custom_classes import * from utils import * import os import gc import sys import pandas as pd import numpy as np from scipy import stats import ast # for literal #pd.set_option("display.max_columns", None) # for time """ Inference file """ import global_variables class predictor(OptunaOptimizer): def __init__(self, exp_no): self.exp_no = exp_no # initialize rest with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: self.comp_name = i x.close() self.Table = load_pickle(f"../configs/configs-{self.comp_name}/Table.pkl") self.locker = load_pickle(f"../configs/configs-{self.comp_name}/locker.pkl") if self.exp_no == -1: row_e = self.Table[self.Table.exp_no == list(self.Table.exp_no.values)[-1]] self.exp_no = row_e.exp_no.values[0] else: row_e = self.Table[self.Table.exp_no == self.exp_no] global_variables.exp_no = self.exp_no # setting for making dir in lgb self.model_name = row_e.model_name.values[0] self.params = row_e.bp.values[0] self.bv = row_e.bv.values[0] # confirming we are predcting correct experiment: print(f"Predicting Exp No {self.exp_no}, whoose bv is {self.bv}") if self.model_name == "lgr": del self.params["c"] self._random_state = row_e.random_state.values[0] self.with_gpu = row_e.with_gpu.values[0] self.features_list = row_e.features_list.values[0] self.prep_list = row_e.prep_list.values[0] self.metrics_name = row_e.metrics_name.values[0] self.level_no = row_e.level_no.values[0] self.useful_features = row_e.features_list.values[0] self.aug_type = row_e.aug_type.values[0] self._dataset = row_e._dataset.values[0] self.use_cutmix = row_e.use_cutmix.values[0] super().__init__( model_name=self.model_name, comp_type=self.locker["comp_type"], metrics_name=self.metrics_name, prep_list=self.prep_list, with_gpu=self.with_gpu, aug_type=self.aug_type, _dataset=self._dataset, use_cutmix=self.use_cutmix, ) # When we call super() It is like calling their init # so all the default initialization of parent class is made here # So we must manually change it here after doing super() # if we did it before calling super() it will be overwritten by parent init # Overrite exp_no of OptunaOptimizer since it takes exp_no from current_dict self.exp_no = exp_no if self.exp_no == -1: row_e = self.Table[self.Table.exp_no == list(self.Table.exp_no.values)[-1]] self.exp_no = row_e.exp_no.values[0] # fold specific work do here # only looking at feature importance while optimizing self.calculate_feature_importance = False self.calculate_permutation_feature_importance = False global_variables.counter = 0 # since we can't get trial no from optuna we are maintaining our own # run() can be called for each new exp so we initialize here rather than at init self.feature_importance_table = None # store the feature importances each trial wise # We can set manually on which fold_name to create oof predictions self.fold_name = row_e.opt_fold_name.values[0] # 'fold3' # --- sanity check [new_feat, old_feat, feat_title] # --------------- self.feat_dict = load_pickle( f"../configs/configs-{self.locker['comp_name']}/features_dict.pkl" ) #new_features = [f"pred_e_{self.exp_no}_{self.exp_no}"] #useful_features = self.useful_features def run_folds(self, fold_name="--|--" ): check_memory_usage("run folds started", self, 0) ###################################### # Memory uage # ###################################### tracemalloc.start() if fold_name not in ["", "--|--"]: # empty self.fold_name = fold_name self._state = "fold" """ IF WE DON'T DO SANITY CHECK THEN OLD PREDICTION WILL BE REPLACED WITH NEW PREDICTION FOR THE FEATURE_DICT, It will not create new key but replace old key and the value Use it not in init because new fold_name is made in run_folds function """ self.isRepetition() # image_path = f'../input/input-{self.locker["comp_name"]}/' + "train_img/" # my_folds = pd.read_csv(f"../configs/configs-{self.comp_name}/my_folds.csv") # # my_folds = pd.read_parquet( # f"../input/input-{self.comp_name}/my_folds.parquet" # ) # test = pd.read_csv(f"../configs/configs-{self.comp_name}/test.csv") scores = [] oof_prediction = {} test_predictions = [] print("Running folds:") # BOTTLENECK return_type = "numpy_array" # "numpy_array" # "tensor" # don't delete ordered_list test because it is used later by obj function for the sanity check print("Before Bottleneck:", len(self.useful_features)) self.xtest , self.ordered_list_test = bottleneck_test(self.locker['comp_name'], self.useful_features, return_type) print("After Bottleneck:", len(self.ordered_list_test)) if self.model_name.startswith("k"): self.xtest[np.isnan(self.xtest)] = 0 if self.model_name == "xgb": # for lgb no need # if we are using feature importance it is better to convert it to dataframe if self.calculate_feature_importance: self.xtest = pd.DataFrame(self.xtest, columns = self.ordered_list_test) self.xtest = xgb.DMatrix(self.xtest) for fold in range(self.locker['fold_dict'][self.fold_name]): #self.locker["no_folds"]): self.optimize_on = [fold] # setting on which to optimize #set it also as list It is much more flexible like this # select data: xtrain xvalid etc self.run( self.useful_features ) # don't delete variables of self here # since used here scores.append(self.obj("--|--")) if self.locker["comp_type"] == "multi_label": # 3 to 1 so elongate self.test_preds = coln_3_1(self.test_preds) self.valid_preds = coln_3_1(self.valid_preds) else: self.valid_preds = self.valid_preds[0] self.test_preds = self.test_preds[0] oof_prediction.update(dict(zip(self.val_idx, self.valid_preds))) # oof test_predictions.append(self.test_preds) ###################################### # gc collect # ###################################### del self.xtrain, self.xvalid, self.val_idx, self.ytrain, self.yvalid #, self.test don't delete xtest since called only once # just see the importance of deleting self.test # one thing we can try is instead of reading multiple times just read once from outside _ = gc.collect() check_memory_usage(f"fold #{fold}", self, 0) print() #------------------------------ # save feature importance if self.calculate_feature_importance or self.calculate_permutation_feature_importance: # need to calculate feature importance save_pickle(f"../configs/configs-{self.locker['comp_name']}/feature_importance/feature_importance_e_{self.exp_no}_fold.pkl",self.feature_importance_table) del self.feature_importance_table gc.collect() del self.xtest gc.collect() # delete xtest now # CHECK MEMORY USAGE JUST AFTER ALL FOLDS check_memory_usage("AFTER_ALL_FOLDS", self, 1) """ Note: for multi_label we can't save oof in my_folds.csv since multiple target columns are flattened to create submission file. """ # save oof predictions temp_valid_predictions = pd.DataFrame.from_dict( oof_prediction, orient="index" ).reset_index() temp_valid_predictions.columns = [ f"{self.locker['id_name']}", f"{self.locker['target_name']}" ] # if regression problem then rank it if self.locker["comp_type"] in [ "regression", "2class", ] and self.metrics_name in [ "auc", "auc_tf", ]: # auc takes rank s #print("checking") # quite sensitive point temp_valid_predictions[f"{self.locker['target_name']}"]= stats.rankdata(temp_valid_predictions.loc[:,f"{self.locker['target_name']}"]) final_test_predictions = [stats.rankdata(f) for f in test_predictions] del test_predictions gc.collect() else: # temp_valid_predictions already defined final_test_predictions = test_predictions.copy() del test_predictions gc.collect() # save oof predictions if self.locker["comp_type"] != "multi_label": # SPLIT SUBMISSIONS #-> a = a.sort_values(by=['customer_ID']) #temp_valid_predictions = np.array(temp_valid_predictions.sort_values(by=[self.locker['id_name']])["prediction"].values) temp_valid_predictions = np.array(temp_valid_predictions.sort_values(by=[self.locker['id_name']])[f"{self.locker['target_name']}"].values) # temp_valid_predictions = temp_valid_predictions.set_index('customer_ID') # temp_valid_predictions = temp_valid_predictions.sort_index().reset_index().values # pkl # it is 1D array save_pickle(f"../configs/configs-{self.locker['comp_name']}/oof_preds/oof_pred_e_{self.exp_no}_{self.fold_name}.pkl", temp_valid_predictions) # clear memory del temp_valid_predictions gc.collect() else: input("We have not found way to save multi-label problem yet!!") # SPLIT PREDICTIONS # save test predictions # mode is good for classification problem but not for regression problem if self.locker["comp_type"] in ["regression", "2class"]: # so we will use regression methods [ for now using 0.2] final_test_predictions = [ np.sum([0.2 * i for i in f], axis=0) for f in [final_test_predictions] ][0] #final_test_predictions = [np.mean(f, axis=0) for f in [final_test_predictions]][0] else: final_test_predictions = stats.mode(np.column_stack(final_test_predictions), axis=1)[0] print("Test preds") print(final_test_predictions) save_pickle(f"../configs/configs-{self.locker['comp_name']}/test_preds/test_pred_e_{self.exp_no}_{self.fold_name}.pkl", np.array(final_test_predictions)) del final_test_predictions gc.collect() # --------------- # feature name should be unique enough not to match with base features #new_features = [f"pred_e_{self.exp_no}_{self.fold_name}"] #useful_features = self.useful_features # -----------------------------update current dict self.current_dict["current_feature_no"] = ( self.current_dict["current_feature_no"] + 1 ) feat_no = self.current_dict["current_feature_no"] level_no = self.current_dict["current_level"] save_pickle( f"../configs/configs-{self.locker['comp_name']}/current_dict.pkl", self.current_dict, ) # -----------------------------dump feature dictionary feat_dict = load_pickle( f"../configs/configs-{self.locker['comp_name']}/features_dict.pkl" ) #-- # sanity check is already done that's why we are dumping is_it_repetition = False if f"exp_{self.exp_no}" in list(feat_dict.keys()): # experiment already predicted so append feature if f"pred_e_{self.exp_no}_{self.fold_name}" in list(feat_dict[f"exp_{self.exp_no}"][0]): #this feature already present no need to put again either raise error or let it overwrite print(f"This feature pred_e_{self.exp_no}_{self.fold_name} is already present no need to put again either raise error or let it overwrite") s = input("Type Y/y to overwrite or Type N/n to raise error.") if s.upper() == "N": raise Exception("Repeating feture") is_it_repetition = True print("Overwritting") else: feat_dict[f"exp_{self.exp_no}"][0] += [f"pred_e_{self.exp_no}_{self.fold_name}"] else: # first time so add feat_dict[f"exp_{self.exp_no}"] = [ [f"pred_e_{self.exp_no}_{self.fold_name}"], self.useful_features ] #--- # feat_dict[f"l_{level_no}_f_{feat_no}"] = [ # new_features, # useful_features, # f"exp_{self.exp_no}", # ] save_pickle( f"../configs/configs-{self.locker['comp_name']}/features_dict.pkl", feat_dict, ) # ----------------------- print("New features create:- ") print([f"pred_e_{self.exp_no}_{self.fold_name}"]) # ----------------------------- print("scores: ") print(scores) # ---- update table if not is_it_repetition: self.Table.loc[self.Table.exp_no == self.exp_no, "fold_mean"].values[0] += [np.mean(scores)] self.Table.loc[self.Table.exp_no == self.exp_no, "fold_std"].values[0] += [np.std(scores)] self.Table.loc[self.Table.exp_no == self.exp_no, "oof_fold_name"].values[0] += [self.fold_name] # pblb to be updated mannually # ---------------- dump table save_pickle( f"../configs/configs-{self.locker['comp_name']}/Table.pkl", self.Table ) gc.collect() check_memory_usage("run folds stop", self) tracemalloc.stop() def isRepetition(self): title_new = f"exp_{self.exp_no}" if title_new in list(self.feat_dict.keys()): # So this experiment is done but is that fold_name is used if f"pred_e_{self.exp_no}_{self.fold_name}" in self.feat_dict[title_new][0]: # pred_e_10_fold10, pred_e_10_fold5 raise Exception(f"This feature : pred_e_{self.exp_no}_{self.fold_name}, with title : {title_new} is already present in my_folds!") gc.collect() if __name__ == "__main__": #p = predictor(exp_no=-1) # last exp #p = predictor(exp_no=236) # last exp # more the no of folds bigger training size in each fold # fold_name = "fold5" #fold5" #"fold5" # "fold3" , "fold5", "fold10" , "fold20", "" # p.run_folds(fold_name) # del p # p = predictor(exp_no=3) # exp_4 #p.run_folds() for exp_no in [-1]: fold_name = "fold5" p = predictor(exp_no = exp_no) p.run_folds(fold_name) del p gc.collect()

File no 26: /src-framework3/preprocess.py
import pandas as pd import numpy as np import matplotlib.pyplot as plt import joblib from tqdm import tqdm import os def prep(): data_dir = "../input/input-bengali/" files_train = [f"train_image_data_{fid}.parquet" for fid in range(4)] for fname in files_train: F = os.path.join(data_dir, fname) df_train = pd.read_parquet(F) img_ids = df_train["image_id"].values img_array = df_train.iloc[:, 1:].values for idx in tqdm(range(len(df_train))): img_id = img_ids[idx] img = img_array[idx] joblib.dump(img, f"../input/input-bengali/train_images/{img_id}.pkl") if __name__ == "__main__": prep()

File no 27: /src-framework3/pull.py
import os import sys import pandas as pd import json def sync_(configs, models, src, input_): framework_name = "framework3" with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() print("comp name:", comp_name) # download data if configs: # configs #!kaggle datasets list try: os.mkdir(f"../configs/configs-{comp_name}/") print(f"configs-{comp_name} folder created.") except: print(f"configs-{comp_name} already exists.") os.system( f"kaggle datasets download raj401/configs-{comp_name} -p ../configs/configs-{comp_name}/ --unzip" ) print(f"configs-{comp_name} downloaded") if models: try: os.mkdir(f"../models/models-{comp_name}/") print(f"models-{comp_name} folder created.") except: print(f"models-{comp_name} already exists.") # models #!kaggle datasets download raj401/models-tmay -p ../models/models-tmay/ --unzip os.system( f"kaggle datasets download raj401/models-{comp_name} -p ../models/models-{comp_name}/ --unzip" ) print(f"models-{comp_name} downloaded") if src: try: os.mkdir(f"../src-{framework_name}/") print(f"src-{framework_name} folder created.") except: print(f"src-{framework_name} already exists.") # src # !kaggle datasets download raj401/src-{framework_name} -p ../src-{framework_name}/ --unzip os.system( f"kaggle datasets download raj401/src-{framework_name} -p ../src-{framework_name}/ --unzip" ) print(f"src-{framework_name} downloaded") if input_: try: os.mkdir(f"../input/input-{comp_name}/") print(f"input-{comp_name} folder created.") except: print(f"input-{comp_name} already exists.") # input #!kaggle datasets download raj401/input-tmay -p ../input/input-tmay/ --unzip os.system( f"kaggle datasets download raj401/input-{comp_name} -p ../input/input-{comp_name}/ --unzip" ) print(f"input-{comp_name} downloaded") if __name__ == "__main__": configs = True # configs models = False # models src = False # src_framework3 input_ = False sync_(configs, models, src, input_) print("Done")

File no 28: /src-framework3/push.py
import os import sys import pandas as pd import json from datetime import datetime def sync_(configs, models, src, working, input_, comment=""): framework_name = "framework3" with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() print("comp name:", comp_name) version_name = datetime.now().strftime("%Y%m%d-%H%M%S") if comment != "": version_name += "-" + comment print(f"Versioning at {version_name}") print("=" * 40) # upload data if configs: # configs #!kaggle datasets list try: os.system( f"kaggle datasets version -m {version_name} -p ../configs/configs-{comp_name}/ -r zip" ) print(f"configs-{comp_name} uploaded") except: print(f"configs-{comp_name} doesn't exists.") if models: # models try: os.system( f"kaggle datasets version -m {version_name} -p ../models/models-{comp_name}/ -r zip -q" ) print(f"models-{comp_name} uploaded") except: print(f"models-{comp_name} doesn't exists.") if src: # src try: os.system( f"kaggle datasets version -m {version_name} -p ../src-{framework_name}/" ) print(f"src-{framework_name} uploaded") except: print(f"src-{framework_name} doesn't exists.") if working: # src try: os.system(f"kaggle datasets version -m {version_name} -p ../working/") print(f"working uploaded") except: print(f"working doesn't exists.") if input_: try: os.system( f"kaggle datasets version -m {version_name} -p ../input/input-{comp_name}/ -r zip -q" ) print(f"input-{comp_name} uploaded") except: print(f"input-{comp_name} doesn't exists.") if __name__ == "__main__": configs = False # configs models = False # models src = True # src_framework3 working = False # working input_ = False # we never push input_ twice [already pushed once] comment = "amz_reg_tabnet_src" # don't keep space sync_(configs, models, src, working, input_, comment) print("Done")

File no 29: /src-framework3/ref.txt
amzcomp1

File no 30: /src-framework3/removed_dup_in_dict.py
from settings import * if __name__ == "__main__": a = amzcomp1_settings() b = list(a.auto_filtered_features.keys()) print(b[::-1])

File no 31: /src-framework3/requirements.txt
numpy scipy pandas matplotlib scikit-learn

File no 32: /src-framework3/run.sh
# /home/pramit_mazumdar/anaconda3/envs/AKR_env/bin/pip uninstall optuna # /home/pramit_mazumdar/anaconda3/envs/AKR_env/bin/pip uninstall tensorflow # /home/pramit_mazumdar/anaconda3/envs/AKR_env/bin/pip uninstall catboost # /home/pramit_mazumdar/anaconda3/envs/AKR_env/bin/pip uninstall timm # /home/pramit_mazumdar/anaconda3/envs/AKR_env/bin/pip uninstall pretrainedmodels # /home/pramit_mazumdar/anaconda3/envs/AKR_env/bin/pip uninstall -Iv tez==0.6.0 # /home/pramit_mazumdar/anaconda3/envs/AKR_env/bin/pip uninstall torchcontrib # /home/pramit_mazumdar/anaconda3/envs/AKR_env/bin/pip uninstall iterative-stratification /home/pramit_mazumdar/anaconda3/envs/AKR_env/bin/pip install tensorflow /home/pramit_mazumdar/anaconda3/envs/AKR_env/bin/pip install --upgrade pip /home/pramit_mazumdar/anaconda3/envs/AKR_env/bin/pip install optuna /home/pramit_mazumdar/anaconda3/envs/AKR_env/bin/pip install catboost /home/pramit_mazumdar/anaconda3/envs/AKR_env/bin/pip install timm /home/pramit_mazumdar/anaconda3/envs/AKR_env/bin/pip install pretrainedmodels /home/pramit_mazumdar/anaconda3/envs/AKR_env/bin/pip install -Iv tez==0.6.0 /home/pramit_mazumdar/anaconda3/envs/AKR_env/bin/pip install torchcontrib /home/pramit_mazumdar/anaconda3/envs/AKR_env/bin/pip install iterative-stratification #/home/pramit_mazumdar/anaconda3/envs/AKR_env3/bin/pip install iterative-stratification # /home/pramit_mazumdar/anaconda3/envs/AKR_env/bin/pip uninstall lightgbm --install-option=--cuda #/home/pramit_mazumdar/anaconda3/envs/AKR_env2/bin/pip install pytorch-tabnet """ what worked for tensorflow issue: pip uninstall tensorflow pip install tensorflow-gpu pip uninstall tensorflow-gpu pip uninstall tensorflow-gpu --upgrade """ # # /home/pramit_mazumdar/anaconda3/envs/AKR_env2/bin/pip install optuna # # /home/pramit_mazumdar/anaconda3/envs/AKR_env2/bin/pip install kaggle --upgrade # # conda install -c conda-forge py-xgboost-gpu # # /home/pramit_mazumdar/anaconda3/envs/AKR_env/bin/pip install https://s3-us-west-2.amazonaws.com/xgboost-nightly-builds/xgboost-1.4.0_SNAPSHOT%2B4224c08cacceba3f83f90e387c07aa6205a83bfa-py3-none-manylinux2010_x86_64.whl # # /home/pramit_mazumdar/anaconda3/envs/AKR_env/bin/pip install xgboost-0.81-py2.py3-none-manylinux1_x86_64.zip

File no 33: /src-framework3/seed_it.py
from optuna_search import OptunaOptimizer from utils import * from custom_models import * from custom_classes import * from utils import * import os import gc import sys import pandas as pd import numpy as np from scipy import stats from sklearn.impute import SimpleImputer from sklearn.preprocessing import StandardScaler, Normalizer, MinMaxScaler from sklearn.preprocessing import RobustScaler """ Seed file Trains of full dataset for n different seeds and Outputs two files Single seed ( output based on one of the seed) all seed (ensemble of all the seeds) """ class seeds(OptunaOptimizer): def __init__(self, exp_no): self.exp_no = exp_no # initialize rest with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: self.comp_name = i x.close() self.Table = load_pickle(f"../configs/configs-{self.comp_name}/Table.pkl") self.locker = load_pickle(f"../configs/configs-{self.comp_name}/locker.pkl") if self.exp_no == -1: row_e = self.Table[self.Table.exp_no == list(self.Table.exp_no.values)[-1]] self.exp_no = row_e.exp_no.values[0] else: row_e = self.Table[self.Table.exp_no == self.exp_no] self.model_name = row_e.model_name.values[0] self.params = row_e.bp.values[0] self.bv = row_e.bv.values[0] # confirming we are predcting correct experiment: print(f"Predicting Exp No {self.exp_no}, whoose bv is {self.bv}") if self.model_name == "lgr": del self.params["c"] self._random_state = row_e.random_state.values[0] # This value will be changed self.with_gpu = row_e.with_gpu.values[0] self.features_list = row_e.features_list.values[0] self.prep_list = row_e.prep_list.values[0] self.metrics_name = row_e.metrics_name.values[0] self.level_no = row_e.level_no.values[0] self.useful_features = row_e.features_list.values[0] self.aug_type = row_e.aug_type.values[0] self._dataset = row_e._dataset.values[0] self.use_cutmix = row_e.use_cutmix.values[0] super().__init__( model_name=self.model_name, comp_type=self.locker["comp_type"], metrics_name=self.metrics_name, prep_list=self.prep_list, with_gpu=self.with_gpu, aug_type=self.aug_type, _dataset=self._dataset, use_cutmix=self.use_cutmix, ) # When we call super() It is like calling their init # so all the default initialization of parent class is made here # So we must manually change it here after doing super() # if we did it before calling super() it will be overwritten by parent init # Overrite exp_no of OptunaOptimizer since it takes exp_no from current_dict self.exp_no = exp_no if self.exp_no == -1: row_e = self.Table[self.Table.exp_no == list(self.Table.exp_no.values)[-1]] self.exp_no = row_e.exp_no.values[0] # --- sanity check [new_feat, old_feat, feat_title] # --------------- self.feat_dict = load_pickle( f"../configs/configs-{self.locker['comp_name']}/features_dict.pkl" ) useful_features = self.useful_features # It's ok to run seed any no of time but it's not ok to run predict # so sanity check in predict but not in seed_it def run_seeds(self): check_memory_usage("run seeds started", self, 0) ###################################### # Memory uage # ###################################### tracemalloc.start() # --------------------------------------> print("SEEDING") self._state = "seed" self.generate_random_no() no_seeds = 5 # 20 #3 random_list = np.random.randint(1, 1000, no_seeds) # 100 print(f"Running {no_seeds} seeds!") """ Use full train set and test set. call it train and valid """ # --> test set # read only what is necessary # self.test = pd.read_csv(f"../configs/configs-{self.locker['comp_name']}/" + "test.csv")[self.useful_features + [ self.locker["id_name"]] ] # self.test = pd.read_parquet( # f"../input/input-{self.locker['comp_name']}/" + "test.parquet", # columns=self.useful_features + [self.locker["id_name"]], # ) # [self.useful_features + [ self.locker["id_name"]] ] # self.test[self.locker["target_name"]] = 0.0 # # Create Folds since deleted in run # # self.my_folds = pd.read_csv(f"../configs/configs-{self.locker['comp_name']}/my_folds.csv")[ [ self.locker["id_name"], self.locker["target_name"]] + self.useful_features ] # self.my_folds = pd.read_parquet( # f"../input/input-{self.locker['comp_name']}/my_folds.parquet", # columns=[self.locker["id_name"], self.locker["target_name"]] # + self.useful_features, # ) # [ [ self.locker["id_name"], self.locker["target_name"]] + self.useful_features ] # if not multi_label # keep sample to input # self.sample = pd.read_csv( # f"../input/input-{self.locker['comp_name']}/" + "sample.csv" # ) # # self.sample = pd.read_parquet( # f"../input/input-{self.locker['comp_name']}/" + "sample.parquet" # ) # if self.locker["comp_type"] == "multi_label": # self.sample = self.test.copy() # temp # else: # self.sample = pd.read_csv( # f"../input/input-{self.locker['comp_name']}/" + "sample.csv" # ) # BOTTLENECK return_type = "numpy_array" self.optimize_on = None # just to make sure it is not called fold_name = "fold_check" self.val_idx, self.xtrain, self.xvalid, self.ytrain, self.yvalid, self.ordered_list_train = bottleneck(self.locker['comp_name'],self.useful_features, fold_name, self.optimize_on, self._state, return_type) self.xvalid = None self.yvalid = None self.val_idx = None self.xtest, self.ordered_list_test = bottleneck_test(self.locker['comp_name'], self.useful_features, return_type) # sanity check: for i,j in zip(self.ordered_list_test, self.ordered_list_train): if i != j: raise Exception(f"Features don't correspond in test - train {i},{j}") self.ordered_list_test = None self.ordered_list_train = None # print("self.xtrain.shape, self.ytrain.shape, self.xtest.shape") # print(self.xtrain.shape, self.ytrain.shape, self.xtest.shape) if self.locker["data_type"] == "image_path": image_path = f"../input/input-{self.locker['comp_name']}/" + "train_img/" # test_path = f"../input/input-{self.locker['comp_name']}/" + "test_img/" if self.model_name in ["tez1", "tez2", "pretrained"]: # now implemented for pytorch print("one") # use pytorch self.train_image_paths = [ os.path.join(image_path, str(x)) for x in self.my_folds[self.locker["id_name"]].values # => ] print("two") self.valid_image_paths = [ os.path.join(image_path, str(x)) for x in self.my_folds[self.locker["id_name"]].values # => ] print("three") self.ytrain = self.my_folds[self.locker["target_name"]].values # => self.yvalid = self.my_folds[self.locker["target_name"]].values # => # ------------------ prep test dataset # self.test_image_paths = [ # os.path.join( # test_path, str(x) # ) # f"../input/input-{self.locker['comp_name']}/" + "test_img/" + x # for x in self.sample[self.locker["id_name"]].values # ] print("four") # fake targets # self.test_targets = self.sample[ # self.locker["target_name"] # ].values # dfx_te.digit_sum.values print("five") if self._dataset in [ "BengaliDataset", ]: self.train_dataset = BengaliDataset( # train_dataset image_paths=self.train_image_paths, targets=self.ytrain, img_height=128, img_width=128, transform=self.train_aug, ) print("six") self.valid_dataset = BengaliDataset( # train_dataset image_paths=self.valid_image_paths, targets=self.yvalid, img_height=128, img_width=128, transform=self.valid_aug, ) print("seven") # already defined # self.test_dataset = BengaliDataset( # train_dataset # image_paths=self.test_image_paths, # targets=self.test_targets, # img_height = 128, # img_width = 128, # transform=self.valid_aug, # ) print("eight") # now implemented for pytorch # Can make our own custom dataset.. Note tez has dataloader inside the model so don't make else: # imageDataset self.train_dataset = ImageDataset( # train_dataset image_paths=self.train_image_paths, targets=self.ytrain, augmentations=self.aug, ) self.valid_dataset = ImageDataset( # valid_dataset image_paths=self.valid_image_paths, targets=self.yvalid, augmentations=self.aug, ) # self.test_dataset = ImageDataset( # image_paths=self.test_image_paths, # targets=self.test_targets, # augmentations=self.aug, # ) elif self.model_name in ["k1", "k2", "k3"]: # now implemented for keras # use keras flow_from_dataframe train_datagen = ImageDataGenerator(rescale=1.0 / 255) valid_datagen = ImageDataGenerator(rescale=1.0 / 255) if self.use_cutmix != True: self.train_dataset = train_datagen.flow_from_dataframe( dataframe=self.my_folds, directory=image_path, target_size=(28, 28), # images are resized to (28,28) x_col=self.locker["id_name"], y_col=self.locker["target_name"], batch_size=32, seed=42, shuffle=True, class_mode="categorical", # "binary" ) elif self.use_cutmix == True: train_datagen1 = train_datagen.flow_from_dataframe( dataframe=self.my_folds, directory=image_path, target_size=(28, 28), # images are resized to (28,28) x_col=self.locker["id_name"], y_col=self.locker["target_name"], batch_size=32, seed=42, shuffle=True, # Required for cutmix class_mode="categorical", # "binary" ) train_datagen2 = train_datagen.flow_from_dataframe( dataframe=self.my_folds, directory=image_path, target_size=(28, 28), # images are resized to (28,28) x_col=self.locker["id_name"], y_col=self.locker["target_name"], batch_size=32, seed=42, shuffle=True, # Required for cutmix class_mode="categorical", # "binary" ) self.train_dataset = CutMixImageDataGenerator( generator1=train_generator1, generator2=train_generator2, img_size=(28, 28), batch_size=32, ) self.valid_dataset = valid_datagen.flow_from_dataframe( dataframe=self.my_folds, directory=image_path, target_size=(28, 28), # images are resized to (28,28) x_col=self.locker["id_name"], y_col=self.locker["target_name"], batch_size=32, seed=42, shuffle=True, class_mode="categorical", # "binary" ) test_datagen = ImageDataGenerator(rescale=1.0 / 255.0) test_generator = test_datagen.flow_from_dataframe( dataframe=self.test, directory=test_path, target_size=(28, 28), # images are resized to (28,28) x_col=self.locker["id_name"], y_col=None, batch_size=32, seed=42, shuffle=True, class_mode="None", # "binary" ) elif self.locker["data_type"] == "image_df": # here we create filtered_features from useful_features # self.test = pd.read_csv( # f"../configs/configs-{self.locker['comp_name']}/" + "test.csv" # ) self.test = pd.read_parquet( f"../input/input-{self.locker['comp_name']}/" + "test.parquet" ) self.yvalid = self.my_folds[self.locker["target_name"]] self.ytrain = self.my_folds[self.locker["target_name"]] # create fake labels self.test[self.locker["target_name"]] = 0.0 if self._dataset == "DigitRecognizerDataset": # DigitRecognizerDataset self.train_dataset = DigitRecognizerDataset( df=self.my_folds[ self.filtered_features + [self.locker["target_name"]] ], augmentations=self.train_aug, model_name=self.model_name, ) self.valid_dataset = DigitRecognizerDataset( df=self.my_folds[ self.filtered_features + [self.locker["target_name"]] ], augmentations=self.valid_aug, model_name=self.model_name, ) self.test_dataset = DigitRecognizerDataset( df=self.test[self.filtered_features + [self.locker["target_name"]]], augmentations=self.valid_aug, model_name=self.model_name, ) elif self._dataset == "BengaliDataset": # now implemented for pytorch # Can make our own custom dataset.. Note tez has dataloader inside the model so don't make self.train_dataset = BengaliDataset( # train_dataset csv=self.my_folds[ self.filtered_features + [self.locker["target_name"]] ], img_height=28, img_width=28, transform=self.train_aug, ) self.valid_dataset = BengaliDataset( # valid_dataset csv=self.my_folds[ self.filtered_features + [self.locker["target_name"]] ], img_height=28, img_width=28, transform=self.valid_aug, ) self.test_dataset = BengaliDataset( df=self.test[self.filtered_features + [self.locker["target_name"]]], img_height=28, img_width=28, augmentations=self.valid_aug, ) elif self.locker["data_type"] == "image_folder": # folders of train test pass # use keras flow_from_directory don't use for now because it looks for subfolders with folder name as different targets like horses/humans elif self.locker["data_type"] == "tabular": # concept of useful feature don't make sense for image problem # self.xtrain = self.my_folds[self.useful_features] # self.xvalid = self.my_folds[self.useful_features] # self.yvalid = self.my_folds[self.locker["target_name"]] # self.ytrain = self.my_folds[self.locker["target_name"]] # self.xtest = self.test[self.useful_features] # del self.test # del self.my_folds # gc.collect() prep_dict = { "SiMe": SimpleImputer(strategy="mean"), "SiMd": SimpleImputer(strategy="median"), "SiMo": SimpleImputer(strategy="mode"), "Ro": RobustScaler(), "Sd": StandardScaler(), "Mi": MinMaxScaler(), } for f in self.prep_list: if f in list(prep_dict.keys()): sc = prep_dict[f] self.xtrain = sc.fit_transform(self.xtrain) if self._state != "seed": # understand carefully it is correct self.xvalid = sc.transform(self.xvalid) if self._state != "opt": self.xtest = sc.transform(self.xtest) elif f == "Lg": self.xtrain = pd.DataFrame( self.xtrain, columns=self.useful_features ) self.xvalid = pd.DataFrame( self.xvalid, columns=self.useful_features ) self.xtest = pd.DataFrame(self.xtest, columns=self.useful_features) # xtest = pd.DataFrame(xtest, columns=useful_features) for col in self.useful_features: self.xtrain[col] = np.log1p(self.xtrain[col]) self.xvalid[col] = np.log1p(self.xvalid[col]) self.xtest[col] = np.log1p(self.xtest[col]) # xtest[col] = np.log1p(xtest[col]) gc.collect() else: raise Exception(f"scaler {f} is invalid!") gc.collect() # create instances if self.model_name.startswith("k") and self.comp_type != "2class": ## to one hot self.ytrain = np_utils.to_categorical(self.ytrain) self.yvalid = np_utils.to_categorical(self.yvalid) scores = [] if self.locker["comp_type"] == "multi_label": final_test_predictions = [[], [], []] else: final_test_predictions = [[]] for i, rn in enumerate(random_list): print() print(f"Seed no: {i}, seed: {rn}") self._random_state = rn # run an algorithm for 100 times scores.append(self.obj("--no-trial--")) for i, f in enumerate(final_test_predictions): final_test_predictions[i].append(self.test_preds[i]) gc.collect() gc.collect() # if regression problem then rank it if self.locker["comp_type"] in [ "regression", "2class", ] and self.metrics_name in [ "auc", "auc_tf", ]: # auc takes rank s # no oof while creating seed submissions # temp_valid_prediction[f"pred_l_{self.current_dict['current_level']}_e_{self.exp_no}"] = [stats.rankdata(f) for f in temp_valid_prediction[f"pred_l_{self.current_dict['current_level']}_e_{self.exp_no}"]] # [[p1, p2, p3]] for i, f in enumerate(final_test_predictions): final_test_predictions[i] = [ stats.rankdata(f) for f in final_test_predictions[i] ] gc.collect() if self.locker["comp_type"] == "multi_label": # convert multi column target to single column # input=> 3 columns , output=> 1 column single_column = [np.array(f[0]) for f in final_test_predictions] multiple_columns = [ stats.mode(np.column_stack(f), axis=1)[0] for f in final_test_predictions ] # keep sample to input # sample_real = pd.read_csv(f"../input/input-{self.locker['comp_name']}/sample.csv") sample_real = pd.read_parquet( f"../input/input-{self.locker['comp_name']}/sample.parquet" ) sample_real["target"] = coln_3_1(single_column) # sample_real.to_csv( # f"../configs/configs-{self.locker['comp_name']}/sub_seed_exp_{self.current_dict['current_exp_no']}_l_{self.current_dict['current_level']}_single.csv", # index=False, # ) sample_real.to_parquet( f"../working/{self.locker['comp_name']}_sub_e_{int(self.exp_no)}_single.parquet", index=False, ) sample_real["target"] = coln_3_1(multiple_columns) # sample_real.to_csv( # f"../configs/configs-{self.locker['comp_name']}/sub_seed_exp_{self.current_dict['current_exp_no']}_l_{self.current_dict['current_level']}_all.csv", # index=False, # ) sample_real.to_parquet( f"../working/{self.locker['comp_name']}_sub_e_{int(self.exp_no)}_all.parquet", index=False, ) else: self.sample = pd.read_parquet(f"../input/input-{self.locker['comp_name']}/" + "sample.parquet") self.sample[self.locker["target_name"]] = [ np.array(f[0]) for f in final_test_predictions ][0] # self.sample.to_csv( # f"../configs/configs-{self.locker['comp_name']}/sub_seed_exp_{self.current_dict['current_exp_no']}_l_{self.current_dict['current_level']}_single.csv", # index=False, # ) self.sample.to_parquet( f"../working/{self.locker['comp_name']}_sub_e_{int(self.exp_no)}_single.parquet", index=False, ) # mode is good for classification proble but not for regression problem if self.locker["comp_type"] in ["regression", "2class"]: # so we will use regression methods for i, f in enumerate(final_test_predictions): final_test_predictions[i] = [ 0.2 * f for f in final_test_predictions[i] ] gc.collect() self.sample[self.locker["target_name"]] = np.sum( np.array(final_test_predictions[0]), axis=0 ) else: self.sample[self.locker["target_name"]] = [ stats.mode(np.column_stack(f), axis=1)[0] for f in final_test_predictions ][0] # self.sample.to_csv( # f"../configs/configs-{self.locker['comp_name']}/sub_seed_exp_{self.current_dict['current_exp_no']}_l_{self.current_dict['current_level']}_all.csv", # index=False, # ) self.sample.to_parquet( f"../working/{self.locker['comp_name']}_sub_e_{int(self.exp_no)}_all.parquet", index=False, ) check_memory_usage("seed_it", self, 0) # ---- update table # self.Table.loc[self.Table.exp_no == self.exp_no, "fold_mean"] = np.mean(scores) # self.Table.loc[self.Table.exp_no == self.exp_no, "fold_std"] = np.std(scores) self.Table.loc[self.Table.exp_no == self.exp_no, "seed_mean"] = np.mean(scores) self.Table.loc[self.Table.exp_no == self.exp_no, "seed_std"] = np.std(scores) # pblb to be updated mannually # ---------------- dump table save_pickle( f"../configs/configs-{self.locker['comp_name']}/Table.pkl", self.Table ) gc.collect() check_memory_usage("run seed stop", self) tracemalloc.stop() def isRepetition(self, gen_features, old_features, feat_title): # self.curr for key, value in self.feat_dict.items(): f1, f2, ft = value if f1 == gen_features and f2 == old_features and ft == feat_title: raise Exception("This feature is already present in my_folds!") gen_features_modified = gen_features old_features_modified = old_features f1_modified = f1 f2_modified = f2 if f2 == 0: # from base pass elif len(f1[0].split("_")[0]) < 5 or ( f1[0].split("_")[0][0] == "l" and f1[0].split("_")[0][2] == "f" ): # originate from base so f2 can't be split f1_modified = ["_".join(f.split("_")[2:]) for f in f1_modified] gen_features_modified = [ "_".join(f.split("_")[2:]) for f in gen_features_modified ] else: f2_modified = ["_".join(f.split("_")[2:]) for f in f2_modified] old_features_modified = [ "_".join(f.split("_")[2:]) for f in old_features_modified ] f1_modified = ["_".join(f.split("_")[2:]) for f in f1_modified] gen_features_modified = [ "_".join(f.split("_")[2:]) for f in gen_features_modified ] if ( f1_modified == gen_features_modified and f2_modified == old_features_modified and ft == feat_title ): raise Exception("This feature is already present in my_folds!") gc.collect() if __name__ == "__main__": #s = seeds(exp_no=-1) # last exp s = seeds(exp_no=44) s.run_seeds() del s # p = predictor(exp_no=3) # exp_4 # p.run_folds()

File no 34: /src-framework3/settings.py
Framework3/src-framework3/settings.py at master · ar8372/Framework3 · GitHub Skip to content Toggle navigation Sign up In this repository All GitHub ↵ Jump to ↵ No suggested jump to results In this repository All GitHub ↵ Jump to ↵ In this user All GitHub ↵ Jump to ↵ In this repository All GitHub ↵ Jump to ↵ Sign in Sign up You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session. You switched accounts on another tab or window. Reload to refresh your session. ar8372 / Framework3 Public Notifications Fork 0 Star 0 Permalink master Switch branches/tags Branches Tags Name already in use A tag already exists with the provided branch name. Many Git commands accept both tag and branch names, so creating this branch may cause unexpected behavior. Are you sure you want to create this branch? Framework3/src-framework3/settings.py Go to file Go to file T Go to line L Copy path Copy permalink This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository. Cannot retrieve contributors at this time 1.87 MB Download Open with Desktop Download Delete file View raw (Sorry about that, but we can’t show files that are this big right now.) Go You can’t perform that action at this time.

File no 35: /src-framework3/show_importance.py
from utils import * import os pd.set_option("display.max_rows", None) import matplotlib.pyplot as plt import seaborn as sns class Importance: def __init__(self, exp_no): with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() self.comp_name = comp_name self.feature_importance_table = None self.log_table = None assert exp_no >= 0 # pull data try: self.feature_importance_table = load_pickle(f"../configs/configs-{self.comp_name}/feature_importance/feature_importance_e_{exp_no}.pkl") except: try: self.feature_importance_table = load_pickle(f"../configs/configs-{self.comp_name}/feature_importance/feature_importance_e_{exp_no}_fold.pkl") print(self.feature_importance_table.head(3)) print("got") except: raise Exception("Feature importance is not saved!!") # fill nan self.feature_importance_table.fillna(0,inplace=True) try: self.log_table = load_pickle(f"../configs/configs-{self.comp_name}/logs/log_exp_{exp_no}.pkl") except: raise Exception("Log is not saved!!") self.scores = list(self.log_table.trial_score.astype(float)) print("Trial Scores:- ") print(self.scores) print("---+"*30) print("Log Table") print(self.log_table) print("---+"*30) print("Feature Importance") print(self.feature_importance_table.head(2)) def show(self,technique = "weighted_mean", top= 20, threshold=100, direction="maximize", pick = None, type_importance="opt", base_features=[]): filtered_trials = list(self.log_table.sort_values(by=['trial_score'], axis=0, ascending = False).index.values) # if pick is not none if pick is not None: if technique == "weighted_mean": # time to pick trials filtered_trials = list(self.log_table.sort_values(by=['trial_score'], axis=0, ascending = False).head(pick).index.values) # remove extra trials self.log_table = self.log_table.loc[filtered_trials] self.scores = list(self.log_table.trial_score.astype(float)) self.feature_importance_table = self.feature_importance_table.iloc[:,[0]+ [i+1 for i in filtered_trials]] elif type_importance=="fold" and technique == "mean": filtered_trials = [0,1,2,3,4] self.feature_importance_table = self.feature_importance_table.iloc[:,[0]+ [i+1 for i in filtered_trials]] if technique == "mean": self.feature_importance_table[technique]= self.feature_importance_table.drop("feature", axis=1).mean(axis=1) if direction == "minimize": self.feature_importance_table= self.feature_importance_table.sort_values(by=[technique], axis=0, ascending = True) else: self.feature_importance_table= self.feature_importance_table.sort_values(by=[technique], axis=0, ascending = False) print() print(self.feature_importance_table.head(10)) if technique == "bagging": L = self.feature_importance_table.drop("feature", axis=1) L = L<0 L = L.sum(axis=1) self.feature_importance_table[technique] = L self.feature_importance_table= self.feature_importance_table.sort_values(by=[technique], axis=0, ascending = False) print(self.feature_importance_table.head(3)) #self.feature_importance_table[technique] = self.feature_importance_table[L>= 1] if technique == "weighted_mean": val = [] for col,w in zip(self.feature_importance_table.drop("feature", axis=1).columns, self.scores): val.append(self.feature_importance_table[col]*w/sum(self.scores) ) self.feature_importance_table[technique] = np.sum(np.array(val), axis=0) if direction == "minimize": self.feature_importance_table= self.feature_importance_table.sort_values(by=[technique], axis=0, ascending = True) else: self.feature_importance_table= self.feature_importance_table.sort_values(by=[technique], axis=0, ascending = False) if technique == "best": ind = self.scores.index(max(self.scores)) useful_cols = self.feature_importance_table.drop("feature", axis=1).columns.values best_col = useful_cols[ind] print("best feature:", best_col) val = self.feature_importance_table[best_col] self.feature_importance_table[technique] = val if direction == "minimize": self.feature_importance_table= self.feature_importance_table.sort_values(by=[technique], axis=0, ascending = True) else: self.feature_importance_table= self.feature_importance_table.sort_values(by=[technique], axis=0, ascending = False) try: val= self.feature_importance_table[["feature", technique]] except: print("couldn't") val= self.feature_importance_table[["feature", technique]] print("---+"*30) print("VALUE") #print(val) print() print([i.round(2) for i in val[technique].values]) print(f"originally {val.shape[0]} features.") print("---+"*30) if top is not None: print(f"Top {top} features") print() if base_features is not None: filtered_feat = list(set(list(val.iloc[:top,:].feature))- set(base_features)) print("Original length:", len(list(set(list(val.iloc[:top,:].feature))))) print("After filter:", len(filtered_feat)) print(filtered_feat ) else: print(list(val.iloc[:top,:].feature)) elif threshold is not None: # threshold print(f"Threshold of {threshold} features") if technique == "bagging": l = list(val.feature) val = val[val[technique] >= threshold] print([i.round(4) for i in val[technique].values]) print(f"after filter: {val.shape[0]} features.") print(f"left features:", list(set(l)- set(val.feature))) elif direction == "maximize": val = val[val[technique]>= threshold] print([i.round(4) for i in val[technique].values]) print(f"after filter: {val.shape[0]} features.") else: # minimize val = val[val[technique]<= threshold] print([i.round(4) for i in val[technique].values]) print(f"after filter {val.shape[0]} features.") if base_features is not None: filtered_feat = list(set(val.feature)- set(base_features)) print("Original length:", len(val.feature)) print("After filter:", len(filtered_feat)) print(filtered_feat ) else: print(list(val.feature)) else: if base_features is not None: filtered_feat = list(set(val.feature)- set(base_features)) print("Original length:", len(val.feature)) print("After filter:", len(filtered_feat)) print(filtered_feat ) else: print(list(val.feature)) print("---+"*30) def give(self,technique = "weighted_mean", top= 20, threshold=100, direction="maximize", pick = None, type_importance="opt", base_features=[]): filtered_trials = list(self.log_table.sort_values(by=['trial_score'], axis=0, ascending = False).index.values) # if pick is not none if pick is not None: if technique == "weighted_mean": # time to pick trials filtered_trials = list(self.log_table.sort_values(by=['trial_score'], axis=0, ascending = False).head(pick).index.values) # remove extra trials self.log_table = self.log_table.loc[filtered_trials] self.scores = list(self.log_table.trial_score.astype(float)) self.feature_importance_table = self.feature_importance_table.iloc[:,[0]+ [i+1 for i in filtered_trials]] elif type_importance=="fold" and technique == "mean": filtered_trials = [0,1,2,3,4] self.feature_importance_table = self.feature_importance_table.iloc[:,[0]+ [i+1 for i in filtered_trials]] if technique == "mean": self.feature_importance_table[technique]= self.feature_importance_table.drop("feature", axis=1).mean(axis=1) if direction == "minimize": self.feature_importance_table= self.feature_importance_table.sort_values(by=[technique], axis=0, ascending = True) else: self.feature_importance_table= self.feature_importance_table.sort_values(by=[technique], axis=0, ascending = False) print() print(self.feature_importance_table.head(10)) if technique == "bagging": L = self.feature_importance_table.drop("feature", axis=1) L = L<0 L = L.sum(axis=1) self.feature_importance_table[technique] = L self.feature_importance_table= self.feature_importance_table.sort_values(by=[technique], axis=0, ascending = False) print(self.feature_importance_table.head(3)) #self.feature_importance_table[technique] = self.feature_importance_table[L>= 1] if technique == "weighted_mean": val = [] for col,w in zip(self.feature_importance_table.drop("feature", axis=1).columns, self.scores): val.append(self.feature_importance_table[col]*w/sum(self.scores) ) self.feature_importance_table[technique] = np.sum(np.array(val), axis=0) if direction == "minimize": self.feature_importance_table= self.feature_importance_table.sort_values(by=[technique], axis=0, ascending = True) else: self.feature_importance_table= self.feature_importance_table.sort_values(by=[technique], axis=0, ascending = False) if technique == "best": ind = self.scores.index(max(self.scores)) useful_cols = self.feature_importance_table.drop("feature", axis=1).columns.values best_col = useful_cols[ind] print("best feature:", best_col) val = self.feature_importance_table[best_col] self.feature_importance_table[technique] = val if direction == "minimize": self.feature_importance_table= self.feature_importance_table.sort_values(by=[technique], axis=0, ascending = True) else: self.feature_importance_table= self.feature_importance_table.sort_values(by=[technique], axis=0, ascending = False) try: val= self.feature_importance_table[["feature", technique]] except: print("couldn't") val= self.feature_importance_table[["feature", technique]] print("---+"*30) print("VALUE") #print(val) print() print([i.round(2) for i in val[technique].values]) print(f"originally {val.shape[0]} features.") print("---+"*30) if top is not None: print(f"Top {top} features") print() if base_features is not None: filtered_feat = list(set(list(val.iloc[:top,:].feature))- set(base_features)) print("Original length:", len(list(set(list(val.iloc[:top,:].feature))))) print("After filter:", len(filtered_feat)) print(filtered_feat ) return filtered_feat else: print(list(val.iloc[:top,:].feature)) return list(val.iloc[:top,:].feature) elif threshold is not None: # threshold print(f"Threshold of {threshold} features") if technique == "bagging": l = list(val.feature) val = val[val[technique] >= threshold] print([i.round(4) for i in val[technique].values]) print(f"after filter: {val.shape[0]} features.") print(f"left features:", list(set(l)- set(val.feature))) elif direction == "maximize": val = val[val[technique]>= threshold] print([i.round(4) for i in val[technique].values]) print(f"after filter: {val.shape[0]} features.") else: # minimize val = val[val[technique]<= threshold] print([i.round(4) for i in val[technique].values]) print(f"after filter {val.shape[0]} features.") if base_features is not None: filtered_feat = list(set(val.feature)- set(base_features)) print("Original length:", len(val.feature)) print("After filter:", len(filtered_feat)) print(filtered_feat ) return filtered_feat else: print(list(val.feature)) return list(val.feature) else: if base_features is not None: filtered_feat = list(set(val.feature)- set(base_features)) print("Original length:", len(val.feature)) print("After filter:", len(filtered_feat)) print(filtered_feat ) return filtered_feat else: print(list(val.feature)) return list(val.feature) print("---+"*30) from settings import * if __name__ == "__main__": """ best: picke features from beast trial mean: take simple mean of all the trials weighted mean: take weighted mean based on the score top: 20 filters top 20 threshold: 121 removes all whoose value is less than 121 """ exp_no = 142 #-1 120, 122, 127 direction = "minimize" technique = "bagging" # "weighted_mean" , "best" , "mean", "top50", "bagging" f = Importance(exp_no=exp_no) # helps when doing weighted mean base_features = None type_importance = "fold" #"fold", "opt" pick = None # pick top 2 trials out of 5 top = None threshold = 1 f.show(technique= technique, top=top, threshold=threshold, direction=direction, pick = pick, type_importance= type_importance, base_features=base_features) """ # mean ['D_39_last', 'P_2_last', 'P_2_last_2round2', 'S_3_mean', 'B_4_last_mean_diff', 'D_39_last_mean_diff', 'D_41_last_mean_diff', 'B_1_last', 'S_3_last', 'B_4_last', 'D_43_last', 'D_42_mean', 'D_39_std', 'B_4_std', 'D_39_max', 'B_3_last', 'B_5_last', 'D_42_min', 'D_43_mean', 'D_43_last_2round2'] # best ['D_39_last_mean_diff', 'P_2_last', 'D_39_last', 'B_1_last', 'B_4_last', 'D_43_last', 'D_43_last_2round2', 'S_3_last', 'D_39_std', 'S_3_mean', 'P_2_last_2round2', 'D_42_mean', 'P_2_mean', 'D_43_mean', 'D_41_last_mean_diff', 'S_3_min', 'S_8_mean', 'D_39_max', 'B_3_last', 'B_3_last_2round2'] # weighted ['D_39_last', 'P_2_last', 'P_2_last_2round2', 'S_3_mean', 'B_4_last_mean_diff', 'D_39_last_mean_diff', 'D_41_last_mean_diff', 'B_1_last', 'S_3_last', 'B_4_last', 'D_43_last', 'D_42_mean', 'D_39_std', 'B_4_std', 'D_39_max', 'B_3_last', 'B_5_last', 'D_42_min', 'D_43_mean', 'D_43_last_2round2'] """

File no 36: /src-framework3/show_input.py
import pandas as pd import numpy as np import os import sys import gc from utils import * def show_input_folders(): with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() try: print("my_folds: ") my_folds = pd.read_parquet(f"../input/input-{comp_name}/my_folds.parquet") for col in my_folds.columns: print(col) #my_folds = my_folds[["0","1"]] print(my_folds.head(3)) print() print(my_folds.columns) print() print(my_folds.info()) print() # for f in list(zip(my_folds.columns, my_folds.dtypes, my_folds.nunique())): # print(f) # print() print(my_folds.shape) del my_folds gc.collect() print("="*40) print() except: print("Train not found") try: print("Train: ") train = pd.read_parquet(f"../input/input-{comp_name}/train.parquet") #train = train[["0","1"]] print(train.head(3)) print() print(train.columns) print() print(train.info()) print() print(train.shape) del train gc.collect() print("="*40) print() except: print("Train not found") try: print("Test: ") test = pd.read_parquet(f"../input/input-{comp_name}/test.parquet") # for col in test.columns: # print(col) # #test = test[["0","1"]] print(test.head(3)) print() print(test.columns) print() print(test.info()) print() print(test.shape) del test gc.collect() print("="*40) print() except: print("Test not found") try: print("Sample: ") sample = pd.read_parquet(f"../input/input-{comp_name}/sample.parquet") print(sample.head(3)) print() print(sample.columns) print() print(sample.info()) print() print(sample.shape) print("="*40) print() except: print("Sample not found") try: import glob # All files and directories ending with .txt and that don't begin with a dot: names = glob.glob(f"../configs/configs-{comp_name}/train_feats/*.pkl") for n in names: print(f"{n}: ") sample = load_pickle(n) print(sample) #input() if len(list(set(sample))) == 1: print("same value") # nan_count, num_missing_std, medianad, median, min, skew, print() # print(sample.head(3)) # print() # print(sample.columns) # print() # print(sample.info()) # print() # print(sample.shape) # print("="*40) # print() except: print(f"../configs/configs-{comp_name}/train_feats/train_feat_l_1_f_10_std.pkl not found") if __name__ == "__main__": show_input_folders()

File no 37: /src-framework3/show_table.py
import os import sys from utils import * import pandas as pd #pd.set_option("display.max_columns", None) pd.set_option("display.max_rows", None) def update_table_function( Table, exp_no, pblb_single_seed=None, pblb_all_seed=None, pblb_all_fold=None ): # pblb_single_seed pblb_all_seed pblb_all_fold Table.loc[exp_no, "pblb_single_seed"] = pblb_single_seed Table.loc[exp_no, "pblb_all_seed"] = pblb_all_seed Table.loc[exp_no, "pblb_all_fold"] = pblb_all_fold return Table def show_table(exp_list,col, is_sorted, which_table= ["base_table"]): with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() bv_t = load_pickle(f"../configs/configs-{comp_name}/Table.pkl") # load for t in which_table: print() print("*--"*40) if t.split("_")[0] == "base": Table = load_pickle(f"../configs/configs-{comp_name}/Table.pkl") if exp_list != []: Table= Table[Table.exp_no.isin(exp_list)] if is_sorted: Table = Table.sort_values(by=["bv"], axis=0, ascending=False) #Table = Table[Table.fold_mean is list] #Table = Table.head(5) #print(Table) Table = Table.sort_values(by= ["fold_mean"], axis=0, ascending=False) # to compress if col == []: Table.rename(columns={'pblb_single_seed': 'single', 'pblb_all_seed': 'all', 'pblb_all_fold': 'fold', "no_iterations": "#iter"}, inplace=True) print(Table.set_index('exp_no')) else: if len(col) == 1: # asking for single value print(Table[col[0]].values[0]) else: Table= Table[Table.bv > 0.75][col] #Table.rename(columns={'pblb_single_seed': 'single', 'pblb_all_seed': 'all', 'pblb_all_fold': 'fold', "no_iterations": "#iter"}, inplace=True) print(Table) #print(self.Table[]) else: submissions = ["seed_mean", "fold_mean","pblb_single_seed","pblb_all_seed","pblb_all_fold"] Table = pd.read_csv(f"../configs/configs-{comp_name}/auto_exp_tables/auto_exp_table_{t.split('_')[0]}.csv") Table = pd.merge(Table, bv_t[["exp_no","bv"]+ submissions], on="exp_no",how="left") if exp_list != []: Table= Table[Table.exp_no.isin(exp_list)] if False: #is_sorted: Table = Table.sort_values(by=["bv"], axis=0, ascending=False) #print(tabulate(Table[Table.bv > 0.75].set_index('exp_no'))) #print(Table[Table.bv > 0.75].set_index('exp_no').to_markdown()) Table.rename(columns={'pblb_single_seed': 'single',"seed_mean":"s_mean", "fold_mean":"f_mean", "feature_names":"f_names", 'pblb_all_seed': 'all', 'pblb_all_fold': 'fold', "no_iterations": "#iter","optimize_on":"opt_on"}, inplace=True) print(Table[Table.bv > 0.75].set_index('exp_no')) #print(self.Table[]) def change_name(old_name, new_name): with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() # load Table = load_pickle(f"../configs/configs-{comp_name}/Table.pkl") Table = Table.rename(columns = {old_name : new_name}) print(Table.head(2)) save_pickle(f"../configs/configs-{comp_name}/Table.pkl", Table) if __name__ == "__main__": col = [ "exp_no", "model_name", "bv", "bp", "random_state", "with_gpu", "aug_type", "_dataset", "use_cutmix", "features_list", "level_no", "oof_fold_name", "opt_fold_name", "fold_no", "no_iterations", "prep_list", # 'metrics_name', # 'seed_mean', # 'seed_std', # 'fold_mean', # 'fold_std', # 'pblb_single_seed', # 'pblb_all_seed', # 'pblb_all_fold', # 'notes', ] submissions = ["seed_mean", "seed_std","fold_mean","fold_std","pblb_single_seed","pblb_all_seed","pblb_all_fold"] general = ["prep_list","opt_fold_name","oof_fold_name", "fold_no","no_iterations"] base = ['exp_no',"bv"] explore_range = ["pblb_all_fold", "pblb_single_seed","pblb_all_seed"] pblb_cols = ["pblb_all_fold","pblb_single_seed","pblb_all_seed"] cv_cols = ["oof_fold_name", "fold_mean","fold_std", "seed_mean", "seed_std"] opt_cols = ["bv","no_iterations","prep_list","opt_fold_name","fold_no", "with_gpu"] #, "bp", "random_state", "metrics_name", "feaures_list" # things to reproduce prediction from an experiment exp_list = [17] #[435, 416] exp_list = [240] exp_list = [] which_table = [ "base_table", #"xgbr_table", #"xgb_table", #"cbc_table", #"lgbmc_table", #"lgb_table", ] # don't change col col = ["exp_no","model_name","no_iterations","bv"] + explore_range + ["fold_mean", "oof_fold_name", "opt_fold_name", "fold_no", "seed_mean", "fold_std", "seed_std"] #col = ['bp'] #col = ['features_list'] #col = [] is_sorted = True show_table(exp_list, col, is_sorted, which_table) # old_name = 'callbacks_listfeatures_list' # new_name = 'features_list' # change_name(old_name, new_name)

File no 38: /src-framework3/split_input.py
import pandas as pd import numpy as np from auto_exp import * from collections import defaultdict def split_base(): with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() locker = load_pickle(f"../configs/configs-{comp_name}/locker.pkl") target_name = locker['target_name'] id_name = locker['id_name'] fold_list = ['fold3', 'fold5', 'fold10', 'fold20'] my_folds = pd.read_parquet(f"../input/input-{comp_name}/my_folds.parquet") print("my_folds shape is:", my_folds.shape) test = pd.read_parquet(f"../input/input-{comp_name}/test.parquet") all_columns = list(test.drop(id_name, axis=1).columns) my_dict = defaultdict() demo_set = set(all_columns) # step 1 feat = [id_name] + fold_list + [target_name] d = my_folds[feat] d.to_parquet(f"../input/input-{comp_name}/id_folds_target.parquet") my_dict['id_folds_target'] = feat # step 2 feat = all_columns d1 = my_folds[feat] d2 = test[feat] d1.to_parquet(f"../input/input-{comp_name}/train_original.parquet", index=False) d2.to_parquet(f"../input/input-{comp_name}/test_original.parquet", index=False) my_dict['original'] = feat demo_set = demo_set - set(feat) assert demo_set == set() save_pickle(f"../input/input-{comp_name}/input_dict.pkl", my_dict) def split(): comp_name = "amexdummy" target_name = "prediction" id_name = "customer_ID" fold_list = ["fold3", "fold5", "fold10", "fold20"] my_folds = pd.read_parquet(f"../input/input-{comp_name}/my_folds.parquet") print("my_folds shape is:", my_folds.shape) test = pd.read_parquet(f"../input/input-{comp_name}/test.parquet") #print(my_folds.columns) # cat_features = [ # "B_30", # "B_38", # "D_114", # "D_116", # "D_117", # "D_120", # "D_126", # "D_63", # "D_64", # "D_66", # "D_68" # ] # num_columns = ['P_2', 'D_39', 'B_1', 'B_2', 'R_1', 'S_3', 'D_41', 'B_3', 'D_42', 'D_43', 'D_44', 'B_4', 'D_45', 'B_5', 'R_2', 'D_46', 'D_47', 'D_48', 'D_49', 'B_6', 'B_7', 'B_8', 'D_50', 'D_51', 'B_9', 'R_3', 'D_52', 'P_3', 'B_10', 'D_53', 'S_5', 'B_11', 'S_6', 'D_54', 'R_4', 'S_7', 'B_12', 'S_8', 'D_55', 'D_56', 'B_13', 'R_5', 'D_58', 'S_9', 'B_14', 'D_59', 'D_60', 'D_61', 'B_15', 'S_11', 'D_62', 'D_65', 'B_16', 'B_17', 'B_18', 'B_19', 'B_20', 'S_12', 'R_6', 'S_13', 'B_21', 'D_69', 'B_22', 'D_70', 'D_71', 'D_72', 'S_15', 'B_23', 'D_73', 'P_4', 'D_74', 'D_75', 'D_76', 'B_24', 'R_7', 'D_77', 'B_25', 'B_26', 'D_78', 'D_79', 'R_8', 'R_9', 'S_16', 'D_80', 'R_10', 'R_11', 'B_27', 'D_81', 'D_82', 'S_17', 'R_12', 'B_28', 'R_13', 'D_83', 'R_14', 'R_15', 'D_84', 'R_16', 'B_29', 'S_18', 'D_86', 'D_87', 'R_17', 'R_18', 'D_88', 'B_31', 'S_19', 'R_19', 'B_32', 'S_20', 'R_20', 'R_21', 'B_33', 'D_89', 'R_22', 'R_23', 'D_91', 'D_92', 'D_93', 'D_94', 'R_24', 'R_25', 'D_96', 'S_22', 'S_23', 'S_24', 'S_25', 'S_26', 'D_102', 'D_103', 'D_104', 'D_105', 'D_106', 'D_107', 'B_36', 'B_37', 'R_26', 'R_27', 'D_108', 'D_109', 'D_110', 'D_111', 'B_39', 'D_112', 'B_40', 'S_27', 'D_113', 'D_115', 'D_118', 'D_119', 'D_121', 'D_122', 'D_123', 'D_124', 'D_125', 'D_127', 'D_128', 'D_129', 'B_41', 'B_42', 'D_130', 'D_131', 'D_132', 'D_133', 'R_28', 'D_134', 'D_135', 'D_136', 'D_137', 'D_138', 'D_139', 'D_140', 'D_141', 'D_142', 'D_143', 'D_144', 'D_145'] # # 11 + 177 = 188 all_columns = list(test.drop('customer_ID', axis=1).columns) # #base_columns =[i[:-6] for i in list(filter(lambda x:x.endswith("_first"), all_columns))] # base_columns = cat_features + num_columns # #num_columns = [c for c in base_columns if c not in cat_features] # print(base_columns) # print(cat_features) # print(num_columns) # print(len(cat_features)) # print(len(num_columns)) # print(len(base_columns)) demo_set = set(all_columns) print("all columns", len(all_columns), len(list(demo_set))) #print(all_columns) print() my_dict = defaultdict() # fold+target : id_fold_target feat = [id_name] + fold_list + [target_name] d = my_folds[feat] d.to_parquet(f"../input/input-{comp_name}/id_folds_target.parquet") my_dict['id_folds_target'] = feat # print(d.head(2)) # print(d.shape) # first : train_first, test_first feat = ['year_first', 'year_mean', 'year_std', 'year_min', 'year_max', 'year_last', 'year_nunique', 'year_count', 'month_first', 'month_mean', 'month_std', 'month_min', 'month_max', 'month_last', 'month_nunique', 'month_count', 'day_first', 'day_mean', 'day_std', 'day_min', 'day_max', 'day_last', 'day_nunique', 'day_count', 'dayofweek_first', 'dayofweek_mean', 'dayofweek_std', 'dayofweek_min', 'dayofweek_max', 'dayofweek_last', 'dayofweek_nunique', 'dayofweek_count'] d1 = my_folds[feat] d2 = test[feat] d1.to_parquet(f"../input/input-{comp_name}/train_date.parquet", index=False) d2.to_parquet(f"../input/input-{comp_name}/test_date.parquet", index=False) my_dict['date'] = feat print( len(feat)) #print(feat) print() demo_set = demo_set - set(feat) """ feat = [i+"_first" for i in base_columns] d1 = my_folds[feat] d2 = test[feat] d1.to_parquet(f"../input/input-{comp_name}/train_first.parquet", index=False) d2.to_parquet(f"../input/input-{comp_name}/test_first.parquet", index=False) my_dict['first'] = feat print( len(feat)) #print(feat) print() demo_set = demo_set - set(feat) # last : train_last, test_last feat = [i+"_last" for i in base_columns] d1 = my_folds[feat] d2 = test[feat] d1.to_parquet(f"../input/input-{comp_name}/train_last.parquet", index=False) d2.to_parquet(f"../input/input-{comp_name}/test_last.parquet", index=False) my_dict['last'] = feat print( len(feat)) #print(feat) print() demo_set = demo_set - set(feat) # min feat = [i+"_min" for i in num_columns] d1 = my_folds[feat] d2 = test[[i+"_min" for i in num_columns]] d1.to_parquet(f"../input/input-{comp_name}/train_min.parquet", index=False) d2.to_parquet(f"../input/input-{comp_name}/test_min.parquet", index=False) my_dict['min'] = feat print( len(feat)) #print(feat) print() demo_set = demo_set - set(feat) # max feat = [i+"_max" for i in num_columns] d1 = my_folds[feat] d2 = test[feat] d1.to_parquet(f"../input/input-{comp_name}/train_max.parquet", index=False) d2.to_parquet(f"../input/input-{comp_name}/test_max.parquet", index=False) my_dict['max'] = feat print( len(feat)) #print(feat) print() demo_set = demo_set - set(feat) # mean feat = [i+"_mean" for i in num_columns] d1 = my_folds[feat] d2 = test[feat] d1.to_parquet(f"../input/input-{comp_name}/train_mean.parquet", index=False) d2.to_parquet(f"../input/input-{comp_name}/test_mean.parquet", index=False) my_dict['mean'] = feat print( len(feat)) #print(feat) print() demo_set = demo_set - set(feat) # std feat = [i+"_std" for i in num_columns] d1 = my_folds[feat] d2 = test[feat] d1.to_parquet(f"../input/input-{comp_name}/train_std.parquet", index=False) d2.to_parquet(f"../input/input-{comp_name}/test_std.parquet", index=False) my_dict['std'] = feat print( len(feat)) #print(feat) print() demo_set = demo_set - set(feat) # count feat = [i+"_count" for i in cat_features] d1 = my_folds[feat] d2 = test[feat] d1.to_parquet(f"../input/input-{comp_name}/train_count.parquet", index=False) d2.to_parquet(f"../input/input-{comp_name}/test_count.parquet", index=False) my_dict['count'] = feat print( len(feat)) #print(feat) print() demo_set = demo_set - set(feat) # nunique feat = [i+"_nunique" for i in cat_features] d1 = my_folds[feat] d2 = test[feat] d1.to_parquet(f"../input/input-{comp_name}/train_nunique.parquet", index=False) d2.to_parquet(f"../input/input-{comp_name}/test_nunique.parquet", index=False) my_dict['nunique'] = feat print( len(feat)) #print(feat) print() demo_set = demo_set - set(feat) # lag_sq feat = [i+"_last_lag_sq" for i in num_columns] d1 = my_folds[feat] d2 = test[feat] d1.to_parquet(f"../input/input-{comp_name}/train_lag_sq.parquet", index=False) d2.to_parquet(f"../input/input-{comp_name}/test_lag_sq.parquet", index=False) my_dict['lag_sq'] = feat print( len(feat)) #print(feat) print() demo_set = demo_set - set(feat) # lag_cb feat = [i+"_last_lag_cb" for i in num_columns] d1 = my_folds[feat] d2 = test[feat] d1.to_parquet(f"../input/input-{comp_name}/train_lag_cb.parquet", index=False) d2.to_parquet(f"../input/input-{comp_name}/test_lag_cb.parquet", index=False) my_dict['lag_cb'] = feat print( len(feat)) #print(feat) print() demo_set = demo_set - set(feat) # lag_div feat = [i+"_last_lag_div" for i in num_columns] d1 = my_folds[feat] d2 = test[feat] d1.to_parquet(f"../input/input-{comp_name}/train_lag_div.parquet", index=False) d2.to_parquet(f"../input/input-{comp_name}/test_lag_div.parquet", index=False) my_dict['lag_div'] = feat print( len(feat)) #print(feat) print() demo_set = demo_set - set(feat) # lag_sub feat = [i+"_last_lag_sub" for i in num_columns] d1 = my_folds[feat] d2 = test[feat] d1.to_parquet(f"../input/input-{comp_name}/train_lag_sub.parquet", index=False) d2.to_parquet(f"../input/input-{comp_name}/test_lag_sub.parquet", index=False) my_dict['lag_sub'] = feat print( len(feat)) #print(feat) print() demo_set = demo_set - set(feat) # round2 Round lall ast float features to 2 decimal place # This is the one which keeps changing feat = list(filter(lambda x:x.endswith("_2round2"), all_columns)) d1 = my_folds[feat] d2 = test[feat] d1.to_parquet(f"../input/input-{comp_name}/train_2round2.parquet", index=False) d2.to_parquet(f"../input/input-{comp_name}/test_2round2.parquet", index=False) my_dict['2round2'] = feat print( len(feat)) #print(feat) print() demo_set = demo_set - set(feat) # lag_mmsub max-min feat = [i+"_max_lag_mmsub" for i in num_columns] d1 = my_folds[feat] d2 = test[feat] d1.to_parquet(f"../input/input-{comp_name}/train_lag_mmsub.parquet", index=False) d2.to_parquet(f"../input/input-{comp_name}/test_lag_mmsub.parquet", index=False) my_dict['lag_mmsub'] = feat print( len(feat)) #print(feat) print() demo_set = demo_set - set(feat) # lag_mmsub max-min feat = [i+"_max_lag_mmsq" for i in num_columns] d1 = my_folds[feat] d2 = test[feat] d1.to_parquet(f"../input/input-{comp_name}/train_lag_mmsq.parquet", index=False) d2.to_parquet(f"../input/input-{comp_name}/test_lag_mmsq.parquet", index=False) my_dict['lag_mmsq'] = feat print( len(feat)) #print(feat) print() demo_set = demo_set - set(feat) # lag_mmcb max-min feat = [i+"_max_lag_mmcb" for i in num_columns] d1 = my_folds[feat] d2 = test[feat] d1.to_parquet(f"../input/input-{comp_name}/train_lag_mmcb.parquet", index=False) d2.to_parquet(f"../input/input-{comp_name}/test_lag_mmcb.parquet", index=False) my_dict['lag_mmcb'] = feat print( len(feat)) #print(feat) print() demo_set = demo_set - set(feat) # last_mean_diff feat = [i+"_last_mean_diff" for i in num_columns] d1 = my_folds[feat] d2 = test[feat] d1.to_parquet(f"../input/input-{comp_name}/train_last_mean_diff.parquet", index=False) d2.to_parquet(f"../input/input-{comp_name}/test_last_mean_diff.parquet", index=False) my_dict['last_mean_diff'] = feat print( len(feat)) #print(feat) print() demo_set = demo_set - set(feat) # _diff1 feat = [i+"_diff1" for i in num_columns] d1 = my_folds[feat] d2 = test[feat] d1.to_parquet(f"../input/input-{comp_name}/train_diff1.parquet", index=False) d2.to_parquet(f"../input/input-{comp_name}/test_diff1.parquet", index=False) my_dict['diff1'] = feat print( len(feat)) #print(feat) print() demo_set = demo_set - set(feat) # count_nunique_diff feat = [i+"_count_nunique_diff" for i in cat_features] d1 = my_folds[feat] d2 = test[feat] d1.to_parquet(f"../input/input-{comp_name}/train_count_nunique_diff.parquet", index=False) d2.to_parquet(f"../input/input-{comp_name}/test_count_nunique_diff.parquet", index=False) my_dict['count_nunique_diff'] = feat print( len(feat)) #print(feat) print() demo_set = demo_set - set(feat) print("Done") print(demo_set) print(len(list(demo_set))) """ save_pickle(f"../input/input-{comp_name}/input_dict.pkl", my_dict) #split_base() #split() #print(11*3+177*13+188*2+642) d = load_pickle(f"../input/input-amzcomp1/input_dict.pkl") print(d) # 2633 # s = [188, # 188, # 177, # 177, # 177, # 177, # 11, # 11, # 177, # 177, # 177, # 177, # 642, # 177] # print(s) # print(sum(s)) # verified # amex = amex3_settings() # feature_keys = ['first','last','min', 'max' , 'mean', 'std', 'count', 'nunique', 'lag_sq', 'lag_cb','lag_div', 'lag_sub', 'round2', 'lag_mmsub'] # feature_keys2 = ['all_cat', 'all_num'] # all_cols = [] # for f in feature_keys: # all_cols += amex.feature_dict[f] # print(len(all_cols)) # assert len(all_cols) == len(set(all_cols)) # all_cols2 = [] # for r in feature_keys2: # all_cols2 += amex.feature_dict[r] # print(len(all_cols2)) # assert len(all_cols2) == len(set(all_cols2))

File no 39: /src-framework3/submit.py
import pandas as pd import numpy as np import os import sys import pickle from utils import * from output import * from predict import * from seed_it import * import time # for animation import itertools import threading import time import sys import global_variables import warnings warnings.filterwarnings("ignore") def update_it( comp_name, exp_no, sub_type, pb_score): # to update a table that is all we need # comp_name , exp_no, sub_table Table = load_pickle(f"../configs/configs-{comp_name}/Table.pkl") updated = False col_name = { "all" : "pblb_all_seed", "single" : "pblb_single_seed" } if sub_type.startswith("e"): # ensemble raise Exception("Ensemble should not try to update Table!!") elif sub_type.startswith("f"): # public fold submission # so first find index of fold full_row = Table.loc[Table.exp_no == exp_no] try: oof_fold_name_list = Table.loc[Table.exp_no == exp_no, "oof_fold_name"].values[0] # sanity check if oof_fold_name_list == []: # our oof_fold_name is empty : No prediction is done yet # that is not possible because we entered here only after some prediction has been done as "fold5/fold10/..." raise Exception("Already made prediction but Table is showing oof_fold_name empty!!") index_no= Table.loc[Table.exp_no == exp_no, "oof_fold_name"].values[0].index(sub_type) pblb_all_fold_list = Table.loc[Table.exp_no == exp_no, "pblb_all_fold"].values[0] # first correct it if pblb_all_fold_list == []: # it is first time pblb_all_fold_list = [None for i in range(len(oof_fold_name_list))] if pblb_all_fold_list[index_no] is None: # so this is a new submission so update print("Before updating") print(Table.loc[Table.exp_no == exp_no, ["exp_no","oof_fold_name", "pblb_all_fold"]]) pblb_all_fold_list[index_no] = pb_score full_row.pblb_all_fold = [[i for i in pblb_all_fold_list]] print("updating...") Table.loc[Table.exp_no == exp_no, :] = full_row.copy() print("After updating") print(Table.loc[Table.exp_no == exp_no, ["exp_no","oof_fold_name", "pblb_all_fold"]]) print("="*40) print() updated = True else: # already updated print("Already updated") print() pass except: raise Exception(f"Fold name {sub_type} is not found in Table") elif sub_type in ["single", "all"]: # all seeds if Table.loc[Table.exp_no == exp_no, col_name[sub_type]].values[0] is None: # first time print("Before updating") print(Table.loc[Table.exp_no == exp_no, ["exp_no","pblb_single_seed", "pblb_all_seed"]]) print("updating...") Table.loc[Table.exp_no == exp_no, col_name[sub_type]] = pb_score print("After updating") print(Table.loc[Table.exp_no == exp_no, ["exp_no","pblb_single_seed", "pblb_all_seed"]]) print("="*40) print() updated = True else: # no need to rename it already updated print("Already updated") print() pass else: raise Exception(f"sub_type {sub_type} is not valid name!") if updated: # since Table is updated save_pickle(f"../configs/configs-{comp_name}/Table.pkl", Table) def update_table_with_submission_log(comp_full_name, current_update_only = False): with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() comp_full_name = "amex-default-prediction" log = pd.read_csv(f"../working/{comp_full_name}_submission_logs.csv") print(log) log = log[log.fileName == "submission.csv"] # ignore old if current_update_only is True: # it is asking to update only the current submission no need to go through the whole logs log = log.iloc[[0]] print("Only update single row!!") print() print(log) print() for row in log.iterrows(): items = row[1] if items[3] != "complete": # score is not updated yet continue pb_score = float(items[4]) # items[2] :=> message # f"{comp_name}_exp_{exp_no}_{pred_type}" # f"{comp_name}_ens_{exp_no}" comp_name = items[2].split("_")[0] marker = items[2].split("_")[1] exp_no = int(items[2].split("_")[2]) if marker != "exp": # ensemble case update_log_ens(comp_name, exp_no, pb_score) else: sub_type = items[2].split("_")[3] # fold5, all, single print(comp_name, marker, exp_no, sub_type, pb_score) update_it( comp_name, exp_no, sub_type, pb_score) def update_log_ens(comp_name, exp_no, pb_score): # update the public score ensemble_dict = load_json(f"../configs/configs-{comp_name}/ensemble_logs/ens_{exp_no}.json") ensemble_dict["pb_score"] = pb_score print(ensemble_dict) save_json(f"../configs/configs-{comp_name}/ensemble_logs/ens_{exp_no}.json", ensemble_dict) """ submit.py kaggle competitions list kaggle competitions leaderboard amex-default-prediction --show | --download kaggle competitions submissions amex-default-prediction kaggle competitions submit ventilator-pressure-prediction -f submission.csv -m "exp_{}_fold/single/all" #submit your submission.csv kaggle competitions submit -c [COMPETITION] -f [FILE] -m [MESSAGE] """ def submit_pred(comp_full_name, exp_no, pred_type, mode): with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() locker = load_pickle(f"../configs/configs-{comp_name}/locker.pkl") Table = load_pickle(f"../configs/configs-{comp_name}/Table.pkl") if exp_no == -1: row_e = Table[Table.exp_no == list(Table.exp_no.values)[-1]] exp_no = row_e.exp_no.values[0] if pred_type == "ens": # pred type is good for exp as can be multiple fold but here each ensemble is unique so keep minimalistic name message = f"{comp_name}_ens_{exp_no}" else: message = f"{comp_name}_exp_{exp_no}_{pred_type}" ########################################## # Sanity check # ########################################## # checks whether it is already submitted log = pd.read_csv(f"../working/{comp_full_name}_submission_logs.csv") log = log[log.fileName == "submission.csv"] # ignore old if message in list(log.description.values): raise Exception(f"{message} already submitted!!!") ######################################### if pred_type == "ens": # it's an ensemble prediction try: sample = pd.read_parquet(f"../working/{comp_name}_ens_{exp_no}.parquet") except: raise Exception(f"Not created ensemble of ens no: {exp_no}") sample.to_csv(f"../working/submission.csv",index=False) print(sample.head(3)) if mode == "manual": val = input(f"""You are about to make submission to {comp_name} with: \nFile named: {comp_name}_sub_e_{exp_no}_single.parquet Press Y/y to continue or press N/n to prevent submission!: """) if val.upper() == "Y": os.system(f"kaggle competitions submit {comp_full_name} -f ../working/submission.csv -m {message}") # #submit your submission.csv") else: time.sleep(1) os.system(f"kaggle competitions submit {comp_full_name} -f ../working/submission.csv -m {message}") # #submit your submission.csv") if pred_type == "single": try: sample= pd.read_parquet(f"../working/{comp_name}_sub_e_{exp_no}_single.parquet") except: # It is not predicted yet # run seed_it script s = seeds(exp_no=exp_no) # last exp s.run_seeds() del s # It must be true now sample= pd.read_parquet(f"../working/{comp_name}_sub_e_{exp_no}_single.parquet") sample.to_csv(f"../working/submission.csv",index=False) # {comp_name}_sub_e_{exp_no}_single.csv") # we print(sample.head(3)) if mode == "manual": val = input(f"""You are about to make submission to {comp_name} with: \nFile named: {comp_name}_sub_e_{exp_no}_single.parquet Press Y/y to continue or press N/n to prevent submission!: """) if val.upper() == "Y": os.system(f"kaggle competitions submit {comp_full_name} -f ../working/submission.csv -m {message}") # #submit your submission.csv") else: time.sleep(1) os.system(f"kaggle competitions submit {comp_full_name} -f ../working/submission.csv -m {message}") # #submit your submission.csv") if pred_type == "all": try: sample= pd.read_parquet(f"../working/{comp_name}_sub_e_{exp_no}_all.parquet") except: # It is not predicted yet # run seed_it script s = seeds(exp_no=exp_no) # last exp s.run_seeds() del s # It must be true now sample= pd.read_parquet(f"../working/{comp_name}_sub_e_{exp_no}_all.parquet") sample.to_csv(f"../working/submission.csv",index=False) # {comp_name}_sub_e_{exp_no}_all.csv") # we print(sample.head(3)) if mode == "manual": val = input(f"""You are about to make submission to {comp_name} with: \nFile named: {comp_name}_sub_e_{exp_no}_all.parquet Press Y/y to continue or press N/n to prevent submission!: """) if val.upper() == "Y": os.system(f"kaggle competitions submit {comp_full_name} -f ../working/submission.csv -m {message}") # #submit your submission.csv") else: time.sleep(1) os.system(f"kaggle competitions submit {comp_full_name} -f ../working/submission.csv -m {message}") # #submit your submission.csv") if pred_type.startswith("f"): #"fold3", "fold5" try: sample= pd.read_parquet(f"../working/{comp_name}_sub_e_{exp_no}_{pred_type}.parquet") except: # It is not output yet yet try: dummy = load_pickle(f"../configs/configs-{comp_name}/test_preds/test_pred_e_{exp_no}_{pred_type}.pkl") del dummy gc.collect() except: # It is also not predicted yet # predict it p = predictor(exp_no=exp_no) # last exp fold_name = pred_type #fold5" #"fold5" # "fold3" , "fold5", "fold10" , "fold20", "" p.run_folds(fold_name) del p # output it # need to add which fold prediction to output file_type = "parquet" # "csv" o = out( pred_type , exp_no, file_type) o.dump() del o # It must be true now sample= pd.read_parquet(f"../working/{comp_name}_sub_e_{exp_no}_{pred_type}.parquet") sample.to_csv(f"../working/submission.csv",index=False) # {comp_name}_sub_e_{exp_no}_ingle.csv") # we print(sample.head(3)) if mode == "manual": val = input(f"""You are about to make submission to {comp_name} with: \nFile named: {comp_name}_sub_e_{exp_no}_{pred_type}.parquet Press Y/y to continue or press N/n to prevent submission!: """) if val.upper() == "Y": score= os.system(f"kaggle competitions submit {comp_full_name} -f ../working/submission.csv -m {message}") # #submit your submission.csv") else: time.sleep(1) os.system(f"kaggle competitions submit {comp_full_name} -f ../working/submission.csv -m {message}") # #submit your submission.csv") ###################################################### # Makes sure submission score is out # ###################################################### global_variables.done = False t = threading.Thread(target=animate) t.start() #long process here time.sleep(5) # save logs # update submission_log # https://askubuntu.com/questions/420981/how-do-i-save-terminal-output-to-a-file#:~:text=the%20shortcut%20is%20Ctrl%20%2B%20Shift,or%20as%20HTML%20including%20colors! #!kaggle competitions submissions amex-default-prediction --csv > ../working/amex-default-prediction_submission_logs.csv os.system(f"kaggle competitions submissions {comp_full_name} --csv > ../working/{comp_full_name}_submission_logs.csv") log = pd.read_csv(f"../working/{comp_full_name}_submission_logs.csv") latest_message = log.loc[0, 'description'] status = log.loc[0, "status"] while latest_message != message or status != "complete": time.sleep(3) os.system(f"kaggle competitions submissions {comp_full_name} --csv > ../working/{comp_full_name}_submission_logs.csv") log = pd.read_csv(f"../working/{comp_full_name}_submission_logs.csv") latest_message = log.loc[0, 'description'] status = log.loc[0, "status"] global_variables.done = True # display submission_log os.system(f"kaggle competitions submissions {comp_full_name}") # update the table #update_table_with_submission_log(comp_full_name) current_update_only = True update_table_with_submission_log(comp_full_name, current_update_only) if __name__ == "__main__": with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() comp_full_name = "amex-default-prediction" #exp_no = -1 #0,1,2 exp_no = 44 pred_type = "single" #"fold10" #"fold5" # "all" "fold" "fold3", "ens" mode = "auto" # "manual" # manual asks for a prompt just before submitting # auto don't asks for a prompt # both can make prediction file if already not created submit_pred(comp_full_name, exp_no, pred_type, mode) # if calling from here update, itterate through whole log file current_update_only = False #update_table_with_submission_log(comp_full_name, current_update_only) #e138 #[0.7984387250317737, 0.794395022818941, 0.7928167917014163, 0.797858209410043, 0.7950284894125992] # # [0.7978218889227393, 0.7940426440210139, 0.7932858172582967, 0.7982026580647962, 0.7945527414758347] --> 0.97

File no 40: /src-framework3/submit_one.py
""" This does nothing but submits one prediction. """ from utils import * #pd.set_option("display.max_columns", None) pd.set_option("display.max_rows", None) class Moderator: def __init__(self, comp_full_name, explore_range= ["pblb_all_fold"], sort_by_col = "bv", mode="auto"): with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() self.locker = load_pickle(f"../configs/configs-{comp_name}/locker.pkl") self.Table = load_pickle(f"../configs/configs-{comp_name}/Table.pkl") self.comp_full_name = comp_full_name self.explore_range = explore_range self.sort_by_col = sort_by_col self.mode = mode self.ascending = False if sort_by_col in ["fold_std", "seed_std"]: self.ascending = True # filter by THRESHOLD # bv self.Table = self.Table[self.Table.bv > 0.75] # no_iterations #self.Table = self.Table[self.Table.no_iterations > 5] # fold_mean #self.Table = self.Table[self.Table.fold_mean > 0.75] # fold_std #self.Table = self.Table[self.Table.fold_std < 0.001] # seed_mean #self.Table = self.Table[self.Table.seed_mean > 0.79] # seed_std #self.Table = self.Table[self.Table.seed_std < 0.005] # Sort by: self.Table = self.Table.sort_values(by=[sort_by_col], ascending=self.ascending) self.show() def query(self): print("Type:") print("sub: to submit in this exp") print("down: to move to next row") text = input() if text.lower() == "down": print() return 0 elif text.lower() == "sub": print("+.."*40) # submit this print("Type prediction type for which you want to make submission!: ") print("single, all, fold3, fold5, fold10, fold20") fold_type = input() # fold_type : "all", "single", "fold3", "fold10" from submit import submit_pred submit_pred(self.comp_full_name, self.target_exp_no, fold_type, self.mode) self.submitted = True return 1 raise Exception("Should never reach here, Not a valid input") def submit(self): self.submitted = False pos = 0 size = self.Table.shape[0] while self.submitted is False and pos< size : self.target_exp_no = self.Table.iloc[pos,0] oof_fold_name_list = self.Table.loc[self.target_exp_no, "oof_fold_name"] # ["fold5", "fold3", "fold10"] print("="*40) print("Experiment no:",self.target_exp_no) explore_range = ["pblb_all_fold", "pblb_single_seed","pblb_all_seed"] cv_cols = ["oof_fold_name", "fold_mean","fold_std", "seed_mean", "seed_std"] print(self.Table[self.Table.exp_no== self.target_exp_no][["bv"] +explore_range+ cv_cols]) if self.mode == "manual": no= self.query() if no == 0: pos += 1 continue elif no == 1: break #submitted = True for feat in self.explore_range: # "pblb_all_fold", "pblb_single_seed","pblb_all_seed" val= self.Table.loc[self.target_exp_no, feat] if isinstance(val, list) and None in val: # so we need to repeat it for that # [ 0.23, None, None, 0.22,0.56,None] for i in range(len(val)): if val[i] is None: # automatically submit this as not submitted before from submit import submit_pred submit_pred(self.comp_full_name, self.target_exp_no, fold_type, self.mode) # stopping execution since submitted return if val in [None, []]: # at present it deals with only [] oof_fold_name .i.e no prediction is made yet [None, 0.9, None] won't work for now # None, [] if feat.split("_")[-1] == "fold": # no prediction is made yet print("Type prediction fold_name for which you want to make submission!: ") print("fold3, fold5, fold10, fold20") fold_type = input() # fold_type : "all", "single", "fold3", "fold10" from submit import submit_pred submit_pred(self.comp_full_name, self.target_exp_no, fold_type, self.mode) self.submitted = True break fold_type = feat.split("_")[1] # "single", "all" :-> seed # automatically submit this as not submitted before from submit import submit_pred submit_pred(self.comp_full_name, self.target_exp_no, fold_type, self.mode) # stopping execution since submitted return pos += 1 def show(self): # anything extra added will cause it to move below: "seed_std", "fold_std" print(self.Table[["exp_no","model_name","no_iterations",self.sort_by_col] + self.explore_range + ["fold_mean", "oof_fold_name", "seed_mean"]].set_index('exp_no')) submissions = ["seed_mean", "seed_std","fold_mean","fold_std","pblb_single_seed","pblb_all_seed","pblb_all_fold"] general = ["prep_list","opt_fold_name","oof_fold_name", "fold_no","no_iterations"] base = ['exp_no',"bv"] pblb_cols = ["pblb_all_fold","pblb_single_seed","pblb_all_seed"] cv_cols = ["oof_fold_name", "fold_mean","fold_std", "seed_mean", "seed_std"] opt_cols = ["bv","no_iterations","prep_list","opt_fold_name","fold_no", "with_gpu"] #, "bp", "random_state", "metrics_name", "feaures_list" # things to reproduce prediction from an experiment if __name__ == "__main__": comp_full_name = "amex-default-prediction" # explore range searches for what we have to submit # if set only "fold" It will look if fold public score is there or not # If not it will prompt/auto submit. explore_range = ["pblb_all_fold", "pblb_single_seed","pblb_all_seed"] #["fold", "seed_single", "seed_all"] sort_by_col = "bv" # "bv", "", "fold_mean", "fold_std", "seed_mean", "seed_std" # if it is sort by "bv" then no issue # but if is is by fold/seed then we may have not done "predict.py"/"seed_it.py" mode = "auto" # "auto", "manual" # auto: looks for the first None and sends it for submission , It asks only once when we encounter [], which fold_name to predict # manual: asks at each step what to select m = Moderator(comp_full_name, explore_range, sort_by_col, mode) m.submit()

File no 41: /src-framework3/update_table.py
import os import sys from utils import * import pandas as pd import ast pd.set_option("display.max_columns", None) pd.set_option("display.max_rows", None) def update_table_function( Table, exp_no, pblb_single_seed=None, pblb_all_seed=None, pblb_all_fold=None ): # pblb_single_seed pblb_all_seed pblb_all_fold Table.loc[exp_no, "pblb_single_seed"] = pblb_single_seed Table.loc[exp_no, "pblb_all_seed"] = pblb_all_seed Table.loc[exp_no, "pblb_all_fold"] = [[i for i in pblb_all_fold]] return Table def update_score( exp_no=-1, pblb_single_seed=None, pblb_all_seed=None, pblb_all_fold=None ): with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() # load Table = load_pickle(f"../configs/configs-{comp_name}/Table.pkl") if exp_no == -1: # pick the last one exp_no = Table.iloc[-1, :].exp_no # before print( Table[Table.exp_no == exp_no][ ["exp_no", "pblb_single_seed", "pblb_all_seed", "pblb_all_fold"] ] ) print() # -> Sanity check: if pblb_single_seed != None: assert Table.loc[exp_no, "pblb_single_seed"] == None if pblb_all_seed != None: assert Table.loc[exp_no, "pblb_all_seed"] == None if pblb_all_fold != None: assert Table.loc[exp_no, "pblb_all_fold"] == [] # None # update Table = update_table_function( Table, exp_no, pblb_single_seed, pblb_all_seed, pblb_all_fold ) # after print( Table[Table.exp_no == exp_no][ ["exp_no", "pblb_single_seed", "pblb_all_seed", "pblb_all_fold"] ] ) print("=" * 40) print("Type Y/y to update, N/n to reject") text = input() if text.upper() == "Y": # Dump back save_pickle(f"../configs/configs-{comp_name}/Table.pkl", Table) print("Updated!") else: print("Cancelled Update!") def change_table(exp_no, feature_name, value): with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() # load Table = load_pickle(f"../configs/configs-{comp_name}/Table.pkl") old_value= Table.loc[exp_no, feature_name] print(f"Do you want to replace \n{old_value} \n\nwith: \n{value} \nfor:") print(f"Exp no: {exp_no} and col: {feature_name}") print("=" * 40) print("Type Y/y to update, N/n to reject:") text = input() if text.upper() == "Y": # Dump back # old : Table.loc[exp_no, feature_name] = value Table = get_table(Table, exp_no, feature_name, value) save_pickle(f"../configs/configs-{comp_name}/Table.pkl", Table) print("Updated!") else: print("Cancelled Update!") def get_table(Table, exp_no, feature_name, value): raw_row = Table.loc[exp_no, :].copy() raw_row[feature_name] = value Table.loc[exp_no, :] = raw_row.values return Table def change_table_custom(): with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() # load Table = load_pickle(f"../configs/configs-{comp_name}/Table.pkl") Table.exp_no = Table.exp_no.astype(int) Table.level_no = Table.level_no.astype(int) Table.no_iterations = Table.no_iterations.astype(int) Table.random_state = Table.random_state.astype(int) print(Table.head(2)) print("=" * 40) print("Type Y/y to update, N/n to reject:") text = input() if text.upper() == "Y": # Dump back save_pickle(f"../configs/configs-{comp_name}/Table.pkl", Table) print("Updated!") else: print("Cancelled Update!") if __name__ == "__main__": # exp_no = -1 # keep it as default exp_no = 70 pblb_single_seed = None pblb_all_seed = None pblb_all_fold = [83.00393] #83.22706 update_score(exp_no, pblb_single_seed, pblb_all_seed, pblb_all_fold) # exp_no = 269 # feature_name = "no_iterations" # value = 30 # change_table(exp_no, feature_name, value) # exp_no = 18 # feature_name = "bp" # value = {'objective': 'binary', 'metric': 'binary_logloss', 'boosting': 'dart', 'learning_rate': 0.010230005490999927, 'seed': 241, 'num_leaves': 105, 'feature_fraction': 0.18956831457766554, 'bagging_freq': 12, 'bagging_fraction': 0.5115517394581794, 'n_jobs': -1, 'lambda_l2': 1, 'min_data_in_leaf': 35} # change_table(exp_no, feature_name, value) #change_table_custom() # {'n_estimators': 500, 'learning_rate': 0.27981914604335584, 'max_depth': 7, 'loss': 'squared_error', 'criterion': 'mse', 'max_features': 'auto', 'min_sample_split': 0.11249062083311395, 'subsample': 0.95} # exp_no = 17 # feature_name = "bp" # value = {'n_estimators': 500, 'learning_rate': 0.27981914604335584, 'max_depth': 7, 'loss': 'squared_error', 'criterion': 'mse', 'max_features': 'auto', 'min_samples_split': 0.11249062083311395, 'subsample': 0.95} # change_table(exp_no, feature_name, value)

File no 42: /src-framework3/utils.py
import pickle import json import os import numpy as np import pandas as pd import math import random import tensorflow as tf import sys import gc import tracemalloc import global_variables import gzip from datetime import datetime # for animation import itertools import threading import time import sys import global_variables # https://stackoverflow.com/questions/47152610/what-is-the-difference-between-xgb-train-and-xgb-xgbregressor-or-xgb-xgbclassif import xgboost as xgb # when calling the low level api # dart callback import joblib def save_pickle(path, to_dump): with open(path, "wb") as f: pickle.dump(to_dump, f) def load_pickle(path): with open(path, "rb") as f: o = pickle.load(f) return o def save_gzip(path, to_dump): with gzip.open(path, "wb") as f: f.write(to_dump) def load_gzip(path): with gzip.open(path, "rb") as f: o = f.read(f) return o def save_json(path, to_dump): json.dump( to_dump, open( path, 'w' ) ) def load_json(path): return json.load( open( path) ) def coln_3_1(arr): # array with three columns return np.array(arr).reshape(-1) def fix_random(seed): os.environ["PYTHONHASHSEED"] = str(seed) np.random.seed(seed) random.seed(seed) tf.random.set_seed( seed ) # f"The truth value of a {type(self).__name__} is ambiguous. " return seed # np.random.randint(3, 1000) # it should return 5 def true_random(size): val = os.urandom(100) val = str(val) total = 0 for i,v in enumerate(val): total += (i+1)*ord(v) return int(total) # sanity check # https://www.kaggle.com/code/sietseschrder/xgboost-starter-0-793/notebook # NEEDED WITH DeviceQuantileDMatrix BELOW class IterLoadForDMatrix(xgb.core.DataIter): def __init__(self, df=None, batch_size=256*1024): #self, df=None, features=None, target=None, batch_size=256*1024): # self.features = features # self.target = target self.df = df # is a numpy 2D array (no_of_data_pts, [features,target]) self.it = 0 # set iterator to 0 self.batch_size = batch_size self.batches = int( np.ceil( df.shape[0] / self.batch_size ) ) super().__init__() def reset(self): '''Reset the iterator''' self.it = 0 def next(self, input_data): '''Yield next batch of data.''' if self.it == self.batches: return 0 # Return 0 when there's no more batch. a = self.it * self.batch_size b = min( (self.it + 1) * self.batch_size, self.df.shape[0] ) dt = cudf.DataFrame(self.df[a:b]) # can use it without cudf input_data(data=dt[:,:-1], label=dt[:, -1]) #, weight=dt['weight']) # may need to reset few self.it += 1 return 1 # generte random no time based but not good, repeats in fractions of seconds def generate_random_no(adder="--|--"): # makes sure each time we are at differnet random state # random_state should only be used for reproducibility and should not give a better model seed = int(datetime.now().strftime("%H%M%S")) # seed selected based on current time if adder != "--|--": seed += adder # datetime can't give new no in vicinity of fraction of seconds so introducing this adder os.environ["PYTHONHASHSEED"] = str(seed) np.random.seed(seed) random.seed(seed) tf.random.set_seed( seed ) # f"The truth value of a {type(self).__name__} is ambiguous. " return seed # np.random.randint(3, 1000) # it should return 5 # https://stackoverflow.com/questions/24455615/python-how-to-display-size-of-all-variables # https://stackoverflow.com/questions/633127/viewing-all-defined-variables def sizeof_fmt(num, suffix="B"): """by Fred Cirera, https://stackoverflow.com/a/1094933/1870254, modified""" for unit in ["", "Ki", "Mi", "Gi", "Ti", "Pi", "Ei", "Zi"]: if abs(num) < 1024.0: return "%3.1f %s%s" % (num, unit, suffix) num /= 1024.0 return "%.1f %s%s" % (num, "Yi", suffix) # https://stackoverflow.com/questions/22029562/python-how-to-make-simple-animated-loading-while-process-is-running #here is the animation def animate(): for c in itertools.cycle(['|', '/', '-', '\\']): if global_variables.done: break sys.stdout.write('\rRefreshing ' + c) sys.stdout.flush() time.sleep(0.1) sys.stdout.write('\rDone! ') sys.stdout.write('\n') def check_memory_usage(title, object_name, verbose=1): # https://stackoverflow.com/questions/24455615/python-how-to-display-size-of-all-variables # https://stackoverflow.com/questions/633127/viewing-all-defined-variables if verbose > 0: print() print("*" * 40) print("{:>30}".format(title)) print("*" * 40) mem = tracemalloc.get_traced_memory() print( "current, peak: {:>8} : {:>8}".format( sizeof_fmt(mem[0]), sizeof_fmt(mem[1]) ) ) else: mem = tracemalloc.get_traced_memory() print( "{}=> current usage, peak usage: {:>8} : {:>8}".format( title, sizeof_fmt(mem[0]), sizeof_fmt(mem[1]) ) ) if verbose > 0: print() # # Locals # print("Local Variables") # for name, size in sorted(((name, sys.getsizeof(value)) for name, value in locals().items()), # key= lambda x: -x[1])[:10]: # print("{:>20}: {:>8}".format(name, sizeof_fmt(size))) # # globals # print("Global Variables") # for name, size in sorted(((name, sys.getsizeof(value)) for name, value in globals().items()), # key= lambda x: -x[1])[:10]: # print("{:>30}: {:>8}".format(name, sizeof_fmt(size))) if object_name != "--|--": # object print("object variables") for name, size in sorted( ( (name, sys.getsizeof(value)) for name, value in object_name.__dict__.items() ), key=lambda x: -x[1], )[:10]: print("{:>30}: {:>8}".format(name, sizeof_fmt(size))) # #==> # print("List of object") # [o for o in gc.get_objects() if isinstance(o, Foo)] # for all_objects in gc.get_objects(): # for o in all_object # name = o # size = sys.getsizeof(o) # print("{:>30}: {:>8}".format(name, sizeof_fmt(size))) print("-" * 40) print() def cosine_decay(epoch): if global_variables.epochs > 1: w = (1 + math.cos(epoch / (global_variables.epochs - 1) * math.pi)) / 2 else: w = 1 return w * global_variables.lr_start + (1 - w) * global_variables.lr_end def exponential_decay(epoch): # v decays from e^a to 1 in every cycle # w decays from 1 to 0 in every cycle # epoch == 0 -> w = 1 (first epoch of cycle) # epoch == epochs_per_cycle-1 -> w = 0 (last epoch of cycle) # higher a -> decay starts with a steeper decline a = 3 CYCLES = global_variables.epochs //5 # 5 epochs in one cycle assert CYCLES < global_variables.epochs epochs_per_cycle = global_variables.epochs // CYCLES epoch_in_cycle = epoch % epochs_per_cycle if epochs_per_cycle > 1: v = math.exp(a * (1 - epoch_in_cycle / (epochs_per_cycle - 1))) w = (v - 1) / (math.exp(a) - 1) else: w = 1 n = w * global_variables.lr_start + (1 - w) * global_variables.lr_end print("lr-->", n) return n def get_test(input_dict,comp_name, useful_features, no_rows): # optimize_on : [3,1] features_in = [] new_array = np.array([], dtype=np.int8).reshape(no_rows,0) for key,feat_list in input_dict.items(): if key == "id_folds_target": continue if all(x in useful_features for x in feat_list): # pull whole set features_in += feat_list d1 = pd.read_parquet(f"../input/input-{comp_name}/test_{key}.parquet") new_array=np.concatenate((new_array, np.array(d1.values)), axis=1) # xtrain = np.array(my_folds[values].values) # xtrain= np.concatenate((xtrain, np.array(rest_train)), axis=1) elif any(x in useful_features for x in feat_list): # partial set present = list(set(feat_list) & set(useful_features)) features_in += present d1 = pd.read_parquet(f"../input/input-{comp_name}/test_{key}.parquet")[present] new_array=np.concatenate((new_array, np.array(d1.values)), axis=1) else: # none of values present pass # it is asking for full dataset return new_array, features_in def bottleneck_test(comp_name, useful_features, return_type, verbose=0): ordered_list = [] # There is a risk that we may not have same order of items in test vs train/valid # RETURNS TEST # base is a list base = load_pickle(f"../configs/configs-{comp_name}/useful_features_l_1.pkl") input_dict = load_pickle(f"../input/input-{comp_name}/input_dict.pkl") # just picking a random set no_rows = pd.read_parquet(f"../input/input-{comp_name}/test_{list(input_dict.keys())[1]}.parquet").shape[0] if all(x in base for x in useful_features): # all the features are in my_folds # we need xtest preprocessed xtest = None #xtest = pd.read_parquet(f"../input/input-{comp_name}/test.parquet") xtest, ordered_list = get_test(input_dict,comp_name, useful_features, no_rows) xtest= pd.DataFrame(xtest, columns= ordered_list)[useful_features] #print(xtest.iloc[:5,:7]) xtest = np.array(xtest.values) return xtest , useful_features elif any(x in base for x in useful_features): # part in my_folds part outside # we need xtest preprocessed xtest = None #xtest = pd.read_parquet(f"../input/input-{comp_name}/test.parquet") #features_in = list(set(input_dict['base']) & set(useful_features)) features_in = list(set(base) & set(useful_features)) #features_in = list(set(xtest.columns) & set(useful_features)) features_out = list(set(useful_features) - set(base)) xtest, features_in = get_test(input_dict,comp_name, features_in, no_rows) #xtest = np.array(xtest[features_in].values) rest_test = [] ###################################################################################################### """ is it in oof or in features useful_features: pred_e_121_fold5.pkl # experiment no is the unique identifier # one experiment can have multiple preds feat_l_1_f_12_std # feature no is the unique identifier # level no is good since we can have std feature # at two levels and it is good to seperate our features based on at which leve we are working # for predictions the TABLE has a level column for identifying level feat_l_1_f_12_mean """ # first filter features based on where they come from. useful_features_pred = [item for item in features_out if item.split("_")[0]=="pred"] useful_features_feat = [item for item in features_out if item.split("_")[0]=="feat"] # sanity check assert len(useful_features_pred) + len(useful_features_feat) == len(features_out) # collecting preds for f in useful_features_pred: try: rest_test.append(load_pickle(f"../configs/configs-{comp_name}/test_preds/test_{f}.pkl")) ordered_list.append(f) except: raise Exception(f"Feature: {f} not found") # collecting feats for f in useful_features_feat: try: rest_test.append(load_pickle(f"../configs/configs-{comp_name}/test_feats/test_{f}.pkl")) ordered_list.append(f) except: raise Exception(f"Feature: {f} not found") if rest_test == []: raise Exception("Error in bottleneck") rest_test = np.array(rest_test).T #rest_test = np.array(rest_test).reshape(-1,len(features_out)) del useful_features_feat, useful_features_pred gc.collect() ################################################################################################### xtest = np.concatenate((xtest, rest_test), axis=1) ordered_list = features_in + ordered_list xtest= pd.DataFrame(xtest, columns= ordered_list)[useful_features] xtest = np.array(xtest.values) return xtest, useful_features else: # all the features are present outside xtest = None # we need xtest preprocessed rest_test = [] ###################################################################################################### """ is it in oof or in features useful_features: pred_e_121_fold5.pkl # experiment no is the unique identifier # one experiment can have multiple preds feat_l_1_f_12_std # feature no is the unique identifier # level no is good since we can have std feature # at two levels and it is good to seperate our features based on at which leve we are working # for predictions the TABLE has a level column for identifying level feat_l_1_f_12_mean """ # first filter features based on where they come from. useful_features_pred = [item for item in useful_features if item.split("_")[0]=="pred"] useful_features_feat = [item for item in useful_features if item.split("_")[0]=="feat"] # sanity check assert len(useful_features_pred) + len(useful_features_feat) == len(useful_features) # collecting preds for f in useful_features_pred: try: rest_test.append(load_pickle(f"../configs/configs-{comp_name}/test_preds/test_{f}.pkl")) ordered_list.append(f) except: raise Exception(f"Feature: {f} not found") # collecting feats for f in useful_features_feat: try: rest_test.append(load_pickle(f"../configs/configs-{comp_name}/test_feats/test_{f}.pkl")) ordered_list.append(f) except: raise Exception(f"Feature: {f} not found") if rest_test == []: raise Exception("Error in bottleneck") xtest = np.array(rest_test).T #xtest = np.array(rest_test).reshape(-1,len(useful_features)) del useful_features_feat, useful_features_pred gc.collect() ################################################################################################### xtest= pd.DataFrame(xtest, columns= ordered_list)[useful_features] xtest = np.array(xtest.values) return xtest, useful_features def get_train(input_dict,id_folds_target, comp_name, useful_features, fold_name, istrain,optimize_on=[]): # optimize_on : [3,1] no_cols = id_folds_target.shape[1] features_base = list(id_folds_target.columns) features_in = [] for key,feat_list in input_dict.items(): if key == "id_folds_target": continue # if all(x in useful_features for x in feat_list): # pull whole set features_in += feat_list d1 = pd.read_parquet(f"../input/input-{comp_name}/train_{key}.parquet") id_folds_target=np.concatenate((id_folds_target, np.array(d1.values)), axis=1) # xtrain = np.array(my_folds[values].values) # xtrain= np.concatenate((xtrain, np.array(rest_train)), axis=1) elif any(x in useful_features for x in feat_list): # partial set present = list(set(feat_list) & set(useful_features)) features_in += present d1 = pd.read_parquet(f"../input/input-{comp_name}/train_{key}.parquet")[present] id_folds_target=np.concatenate((id_folds_target, np.array(d1.values)), axis=1) else: # none of values present pass d1 = None if fold_name is not None: # we are taking partial fold id_folds_target = pd.DataFrame(id_folds_target, columns=features_base+features_in) if istrain: # so train set everythign except id_folds_target = np.array(id_folds_target[~id_folds_target[fold_name].isin(optimize_on) ].values) else: # valid set id_folds_target = np.array(id_folds_target[id_folds_target[fold_name].isin(optimize_on) ].values) return id_folds_target[:,no_cols:],id_folds_target[:,no_cols-1], features_in else: # it is asking for full dataset return id_folds_target[:,no_cols:], id_folds_target[:,no_cols-1],features_in # xtrain, ytrain, features_in def bottleneck(comp_name,useful_features, fold_name, optimize_on, _state, return_type, verbose=0): ordered_list=[] # RETURNS XTRAIN, XVALID, YTRAIN, YVLID, XVALID_IDX locker = load_pickle(f"../configs/configs-{comp_name}/locker.pkl") #my_folds = pd.read_parquet(f"../input/input-{comp_name}/my_folds.parquet") #test = pd.read_parquet(f"../input/input-{comp_name}/test.parquet") # base is a list # base is the combined input_dict is splitted base = load_pickle(f"../configs/configs-{comp_name}/useful_features_l_1.pkl") id_folds_target = pd.read_parquet(f"../input/input-{comp_name}/id_folds_target.parquet") input_dict = load_pickle(f"../input/input-{comp_name}/input_dict.pkl") """ # NO NEED OF THIS CAME # it is a dictonary for each set of features created # each set has a unique name as key "l_1_f_0": ['column names generate', 'columns used to generate', 'title give to the process'] "e_30" : [column_names_generated, columns_name_used_to_generate] "nan_count": [['nan_f34','nan_32'], ['f_1', 'f_2']] "base" : [['f_1', 'f_4'], 0] : column names generate pred_l_1_e_0, mean_f_24 etc : columns used to generate : title given nan_count, exp_2 etc """ # First aim is to find where we have to search for the features is it in # my_folds or it is not # base is the list of all the column of my_folds a = load_pickle(f"../configs/configs-{comp_name}/features_dict.pkl") if all(x in base for x in useful_features): # all the features are in my_folds if verbose != 0: print("all the features are in my_folds") #my_folds = pd.read_parquet(f"../input/input-{comp_name}/my_folds.parquet") input_dict = load_pickle(f"../input/input-{comp_name}/input_dict.pkl") val_idx = None if _state in ["fold", "opt"]: # for seed we don't need to find val_idx val_idx = id_folds_target[id_folds_target[fold_name].isin(optimize_on)][locker["id_name"]].values.tolist() #val_idx = my_folds[my_folds[fold_name] == optimize_on][locker["id_name"]].values.tolist() if _state == "seed": xtrain, ytrain, temp_features = get_train(input_dict,id_folds_target.copy(), comp_name, useful_features, None, True,optimize_on) xtrain = pd.DataFrame(xtrain, columns=temp_features)[useful_features] xtrain = np.array(xtrain.values) #xtrain = np.array(my_folds[useful_features].values) #ytrain = np.array(my_folds[locker["target_name"]].values) xvalid = None yvalid = None val_idx = None return val_idx, xtrain, xvalid, ytrain, yvalid, useful_features # xvalid [2] xtrain [0,1,2,3,4] #fold5 # # # fold_nos = [i for i in range(int(fold_name.split("d")[1]))] # train_fold_nos = list(set(fold_nos) - set(optimize_on)) # print("This is train fold nos") # print(train_fold_nos) # print(optimize_on) # print("done") xtrain, ytrain, temp_features= get_train(input_dict,id_folds_target.copy(), comp_name, useful_features, fold_name, True,optimize_on) xtrain = pd.DataFrame(xtrain, columns=temp_features)[useful_features] xtrain = np.array(xtrain.values) #xtrain = np.array(my_folds[my_folds[fold_name] != optimize_on][useful_features].values) #ytrain = np.array(my_folds[my_folds[fold_name] != optimize_on][locker["target_name"]].values) xvalid, yvalid, temp_features= get_train(input_dict,id_folds_target.copy(), comp_name, temp_features, fold_name, False,optimize_on) xvalid = pd.DataFrame(xvalid, columns=temp_features)[useful_features] xvalid = np.array(xvalid.values) #xvalid = np.array(my_folds[my_folds[fold_name] == optimize_on][useful_features].values) #yvalid = np.array(my_folds[my_folds[fold_name] == optimize_on][locker["target_name"]].values) return val_idx, xtrain, xvalid, ytrain, yvalid, useful_features elif any(x in base for x in useful_features): # part in my_folds part outside if verbose != 0: print("part in my_folds part outside") #my_folds = pd.read_parquet(f"../input/input-{comp_name}/my_folds.parquet") features_in = list(set(base) & set(useful_features)) features_out = list(set(useful_features) - set(base)) rest_train = [] ###################################################################################################### """ is it in oof or in features useful_features: pred_e_121_fold5.pkl # experiment no is the unique identifier # one experiment can have multiple preds feat_l_1_f_12_std # feature no is the unique identifier # level no is good since we can have std feature # at two levels and it is good to seperate our features based on at which leve we are working # for predictions the TABLE has a level column for identifying level feat_l_1_f_12_mean """ # first filter features based on where they come from. useful_features_pred = [item for item in features_out if item.split("_")[0]=="pred"] useful_features_feat = [item for item in features_out if item.split("_")[0]=="feat"] # sanity check assert len(useful_features_pred) + len(useful_features_feat) == len(features_out) # This is the order they are accessed #ordered_list = features_in + useful_features_pred + useful_features_feat # collecting preds for f in useful_features_pred: try: rest_train.append(load_pickle(f"../configs/configs-{comp_name}/oof_preds/oof_{f}.pkl")) except: raise Exception(f"Feature: {f} not found") ordered_list += useful_features_pred # collecting feats for f in useful_features_feat: try: rest_train.append(load_pickle(f"../configs/configs-{comp_name}/train_feats/train_{f}.pkl")) except: raise Exception(f"Feature: {f} not found") ordered_list += useful_features_feat if rest_train == []: raise Exception("Error in bottleneck") rest_train = np.array(rest_train).T #rest_train = np.array(rest_train).reshape(-1,len(features_out)) #del useful_features_feat, useful_features_pred gc.collect() ################################################################################################### if _state == "seed": xtrain, ytrain, features_in= get_train(input_dict,id_folds_target.copy(), comp_name, features_in, None, True,optimize_on) #xtrain = np.array(my_folds[features_in].values) xtrain= np.concatenate((xtrain, np.array(rest_train)), axis=1) #ytrain = np.array(my_folds[locker["target_name"]].values) xvalid = None yvalid = None val_idx = None ordered_list += features_in xtrain= pd.DataFrame(xtrain, columns= ordered_list)[useful_features].values return val_idx, xtrain, xvalid, ytrain, yvalid, useful_features #xtrain, ytrain, features_in= get_train(input_dict,id_folds_target.copy(), comp_name, features_in, fold_name, True,optimize_on) #xtrain = np.array(my_folds[my_folds[fold_name] != optimize_on][features_in].values) #ytrain = np.array(my_folds[my_folds[fold_name] != optimize_on][locker["target_name"]].values) #xvalid, yvalid, features_in= get_train(input_dict,id_folds_target.copy(), comp_name, features_in, fold_name, False,optimize_on) #xvalid = np.array(my_folds[my_folds[fold_name] == optimize_on][features_in].values) #yvalid = np.array(my_folds[my_folds[fold_name] == optimize_on][locker["target_name"]].values) #mask = np.array((my_folds[fold_name] != optimize_on).values, dtype=bool) mask = np.array(~id_folds_target[fold_name].isin(optimize_on).values, dtype=bool) xtrain, ytrain, features_in= get_train(input_dict,id_folds_target.copy(), comp_name, features_in, fold_name, True,optimize_on) #xtrain= np.concatenate((xtrain, rest_train[mask].values), axis=1) xtrain= np.concatenate((xtrain, rest_train[mask]), axis=1) ordered_list = features_in + ordered_list #xtrain= np.concatenate((xtrain, np.array(rest_train[(my_folds[fold_name] != optimize_on).values])), axis=1) #ytrain = np.array(my_folds[my_folds[fold_name] != optimize_on][locker["target_name"]].values) mask = np.array(id_folds_target[fold_name].isin(optimize_on).values, dtype=bool) xvalid, yvalid, features_in= get_train(input_dict,id_folds_target.copy(), comp_name, features_in, fold_name, False,optimize_on) xvalid = np.concatenate((xvalid, rest_train[mask]), axis=1) #xvalid = np.array(my_folds[my_folds[fold_name] == optimize_on][features_in].values) #xvalid = np.concatenate((xvalid, np.array(rest_train[(my_folds[fold_name] == optimize_on).values])), axis=1) #yvalid = np.array(my_folds[my_folds[fold_name] == optimize_on][locker["target_name"]].values) val_idx = None if _state in ["fold", "opt"]: # for seed we don't need to find val_idx val_idx= id_folds_target[id_folds_target[fold_name].isin(optimize_on)][locker["id_name"]].values.tolist() #val_idx = my_folds[my_folds[fold_name] == optimize_on][locker["id_name"]].values.tolist() xtrain= pd.DataFrame(xtrain, columns= ordered_list)[useful_features].values xvalid= pd.DataFrame(xvalid, columns= ordered_list)[useful_features].values return val_idx, xtrain, xvalid, ytrain, yvalid, useful_features else: # all the features are present outside #my_folds = pd.read_parquet(f"../input/input-{comp_name}/my_folds.parquet") if verbose != 0: print("all the features are present outside") rest_train = [] # append 1D arrays ###################################################################################################### """ is it in oof or in features useful_features: pred_e_121_fold5.pkl # experiment no is the unique identifier # one experiment can have multiple preds feat_l_1_f_12_std # feature no is the unique identifier # level no is good since we can have std feature # at two levels and it is good to seperate our features based on at which leve we are working # for predictions the TABLE has a level column for identifying level feat_l_1_f_12_mean """ # first filter features based on where they come from. useful_features_pred = [item for item in useful_features if item.split("_")[0]=="pred"] useful_features_feat = [item for item in useful_features if item.split("_")[0]=="feat"] # sanity check assert len(useful_features_pred) + len(useful_features_feat) == len(useful_features) #ordered_list = useful_features_pred + useful_features_feat # collecting preds for f in useful_features_pred: try: rest_train.append(load_pickle(f"../configs/configs-{comp_name}/oof_preds/oof_{f}.pkl")) except: raise Exception(f"Feature: {f} not found") ordered_list += useful_features_pred # collecting feats for f in useful_features_feat: try: rest_train.append(load_pickle(f"../configs/configs-{comp_name}/train_feats/train_{f}.pkl")) except: raise Exception(f"Feature: {f} not found") ordered_list += useful_features_feat if rest_train == []: raise Exception("Error in bottleneck") # print(np.array(rest_train)[:3,:]) # print("check") # print(np.array(rest_train).T[:3,:]) # print("check2") # rest_train = np.array(rest_train).reshape(-1,len(useful_features)) # print(rest_train[:3,:]) rest_train = np.array(rest_train).T #del useful_features_feat, useful_features_pred #del useful_features gc.collect() ################################################################################################### if _state == "seed": xtrain= rest_train xtrain= pd.DataFrame(xtrain, columns= ordered_list)[useful_features].values ytrain = np.array(my_folds[locker["target_name"]].values) xvalid = None yvalid = None val_idx = None return val_idx, xtrain, xvalid, ytrain, yvalid , useful_features mask = np.array(~id_folds_target[fold_name].isin(optimize_on).values, dtype=bool) #mask = np.array((my_folds[fold_name] != optimize_on).values, dtype=bool) xtrain= rest_train[mask] ytrain = np.array(id_folds_target[mask][locker["target_name"]].values) mask = np.array(id_folds_target[fold_name].isin(optimize_on).values, dtype=bool) xvalid = rest_train[mask] yvalid = np.array(id_folds_target[mask][locker["target_name"]].values) val_idx = None if _state in ["fold", "opt"]: # for seed we don't need to find val_idx val_idx= id_folds_target[id_folds_target[fold_name].isin(optimize_on)][locker["id_name"]].values.tolist() #val_idx = my_folds[my_folds[fold_name] == optimize_on][locker["id_name"]].values.tolist() xtrain= pd.DataFrame(xtrain, columns= ordered_list)[useful_features].values xvalid= pd.DataFrame(xvalid, columns= ordered_list)[useful_features].values return val_idx, xtrain, xvalid, ytrain, yvalid , useful_features # def bottleneck_test(comp_name, useful_features, return_type, verbose=0): # ordered_list = [] # # There is a risk that we may not have same order of items in test vs train/valid # # RETURNS TEST # # base is a list # base = load_pickle(f"../configs/configs-{comp_name}/useful_features_l_1.pkl") # if all(x in base for x in useful_features): # # all the features are in my_folds # # we need xtest preprocessed # xtest = None # xtest = pd.read_parquet(f"../input/input-{comp_name}/test.parquet") # xtest = np.array(xtest[useful_features].values) # return xtest , useful_features # elif any(x in base for x in useful_features): # # part in my_folds part outside # # we need xtest preprocessed # xtest = None # xtest = pd.read_parquet(f"../input/input-{comp_name}/test.parquet") # features_in = list(set(xtest.columns) & set(useful_features)) # features_out = list(set(useful_features) - set(xtest.columns)) # xtest = np.array(xtest[features_in].values) # rest_test = [] # ###################################################################################################### # """ # is it in oof or in features # useful_features: # pred_e_121_fold5.pkl # experiment no is the unique identifier # one experiment can have multiple preds # feat_l_1_f_12_std # # feature no is the unique identifier # level no is good since we can have std feature # # at two levels and it is good to seperate our features based on at which leve we are working # # for predictions the TABLE has a level column for identifying level # feat_l_1_f_12_mean # """ # # first filter features based on where they come from. # useful_features_pred = [item for item in features_out if item.split("_")[0]=="pred"] # useful_features_feat = [item for item in features_out if item.split("_")[0]=="feat"] # # sanity check # assert len(useful_features_pred) + len(useful_features_feat) == len(features_out) # # collecting preds # for f in useful_features_pred: # try: # rest_test.append(load_pickle(f"../configs/configs-{comp_name}/test_preds/test_{f}.pkl")) # ordered_list.append(f) # except: # raise Exception(f"Feature: {f} not found") # # collecting feats # for f in useful_features_feat: # try: # rest_test.append(load_pickle(f"../configs/configs-{comp_name}/test_feats/test_{f}.pkl")) # ordered_list.append(f) # except: # raise Exception(f"Feature: {f} not found") # if rest_test == []: # raise Exception("Error in bottleneck") # rest_test = np.array(rest_test).reshape(-1,len(features_out)) # del useful_features_feat, useful_features_pred # gc.collect() # ################################################################################################### # xtest = np.concatenate((xtest, rest_test), axis=1) # ordered_list = features_in + ordered_list # xtest= pd.DataFrame(xtest, columns= ordered_list)[useful_features].values # return xtest, useful_features # else: # # all the features are present outside # xtest = None # # we need xtest preprocessed # rest_test = [] # ###################################################################################################### # """ # is it in oof or in features # useful_features: # pred_e_121_fold5.pkl # experiment no is the unique identifier # one experiment can have multiple preds # feat_l_1_f_12_std # # feature no is the unique identifier # level no is good since we can have std feature # # at two levels and it is good to seperate our features based on at which leve we are working # # for predictions the TABLE has a level column for identifying level # feat_l_1_f_12_mean # """ # # first filter features based on where they come from. # useful_features_pred = [item for item in useful_features if item.split("_")[0]=="pred"] # useful_features_feat = [item for item in useful_features if item.split("_")[0]=="feat"] # # sanity check # assert len(useful_features_pred) + len(useful_features_feat) == len(useful_features) # # collecting preds # for f in useful_features_pred: # print(f,"got it") # try: # rest_test.append(load_pickle(f"../configs/configs-{comp_name}/test_preds/test_{f}.pkl")) # ordered_list.append(f) # except: # raise Exception(f"Feature: {f} not found") # # collecting feats # for f in useful_features_feat: # try: # rest_test.append(load_pickle(f"../configs/configs-{comp_name}/test_feats/test_{f}.pkl")) # ordered_list.append(f) # except: # raise Exception(f"Feature: {f} not found") # if rest_test == []: # raise Exception("Error in bottleneck") # xtest = np.array(rest_test).reshape(-1,len(useful_features)) # del useful_features_feat, useful_features_pred # gc.collect() # ################################################################################################### # xtest= pd.DataFrame(xtest, columns= ordered_list)[useful_features].values # return xtest, useful_features # def bottleneck(comp_name,useful_features, fold_name, optimize_on, _state, return_type, verbose=0): # ordered_list=[] # # RETURNS XTRAIN, XVALID, YTRAIN, YVLID, XVALID_IDX # locker = load_pickle(f"../configs/configs-{comp_name}/locker.pkl") # #my_folds = pd.read_parquet(f"../input/input-{comp_name}/my_folds.parquet") # #test = pd.read_parquet(f"../input/input-{comp_name}/test.parquet") # # base is a list # base = load_pickle(f"../configs/configs-{comp_name}/useful_features_l_1.pkl") # """ # # NO NEED OF THIS CAME # # it is a dictonary for each set of features created # # each set has a unique name as key # "l_1_f_0": ['column names generate', 'columns used to generate', 'title give to the process'] # "e_30" : [column_names_generated, columns_name_used_to_generate] # "nan_count": [['nan_f34','nan_32'], ['f_1', 'f_2']] # "base" : [['f_1', 'f_4'], 0] # : column names generate pred_l_1_e_0, mean_f_24 etc # : columns used to generate # : title given nan_count, exp_2 etc # """ # # First aim is to find where we have to search for the features is it in # # my_folds or it is not # # base is the list of all the column of my_folds # a = load_pickle(f"../configs/configs-{comp_name}/features_dict.pkl") # if all(x in base for x in useful_features): # # all the features are in my_folds # if verbose != 0: # print("all the features are in my_folds") # my_folds = pd.read_parquet(f"../input/input-{comp_name}/my_folds.parquet") # val_idx = None # if _state in ["fold", "opt"]: # # for seed we don't need to find val_idx # val_idx = my_folds[my_folds[fold_name] == optimize_on][locker["id_name"]].values.tolist() # if _state == "seed": # xtrain = np.array(my_folds[useful_features].values) # ytrain = np.array(my_folds[locker["target_name"]].values) # xvalid = None # yvalid = None # val_idx = None # return val_idx, xtrain, xvalid, ytrain, yvalid, useful_features # xtrain = np.array(my_folds[my_folds[fold_name] != optimize_on][useful_features].values) # ytrain = np.array(my_folds[my_folds[fold_name] != optimize_on][locker["target_name"]].values) # xvalid = np.array(my_folds[my_folds[fold_name] == optimize_on][useful_features].values) # yvalid = np.array(my_folds[my_folds[fold_name] == optimize_on][locker["target_name"]].values) # return val_idx, xtrain, xvalid, ytrain, yvalid, useful_features # elif any(x in base for x in useful_features): # # part in my_folds part outside # if verbose != 0: # print("part in my_folds part outside") # my_folds = pd.read_parquet(f"../input/input-{comp_name}/my_folds.parquet") # features_in = list(set(my_folds.columns) & set(useful_features)) # features_out = list(set(useful_features) - set(my_folds.columns)) # rest_train = [] # ###################################################################################################### # """ # is it in oof or in features # useful_features: # pred_e_121_fold5.pkl # experiment no is the unique identifier # one experiment can have multiple preds # feat_l_1_f_12_std # # feature no is the unique identifier # level no is good since we can have std feature # # at two levels and it is good to seperate our features based on at which leve we are working # # for predictions the TABLE has a level column for identifying level # feat_l_1_f_12_mean # """ # # first filter features based on where they come from. # useful_features_pred = [item for item in features_out if item.split("_")[0]=="pred"] # useful_features_feat = [item for item in features_out if item.split("_")[0]=="feat"] # # sanity check # assert len(useful_features_pred) + len(useful_features_feat) == len(features_out) # # This is the order they are accessed # ordered_list = features_in + useful_features_pred + useful_features_feat # # collecting preds # for f in useful_features_pred: # try: # rest_train.append(load_pickle(f"../configs/configs-{comp_name}/oof_preds/oof_{f}.pkl")) # except: # raise Exception(f"Feature: {f} not found") # # collecting feats # for f in useful_features_feat: # try: # rest_train.append(load_pickle(f"../configs/configs-{comp_name}/train_feats/train_{f}.pkl")) # except: # raise Exception(f"Feature: {f} not found") # if rest_train == []: # raise Exception("Error in bottleneck") # rest_train = np.array(rest_train).reshape(-1,len(features_out)) # del useful_features_feat, useful_features_pred # gc.collect() # ################################################################################################### # if rest_train == []: # raise Exception("Error in bottleneck") # rest_train = np.array(rest_train).reshape(-1,len(features_out)) # if _state == "seed": # xtrain = np.array(my_folds[features_in].values) # xtrain= np.concatenate((xtrain, np.array(rest_train)), axis=1) # ytrain = np.array(my_folds[locker["target_name"]].values) # xvalid = None # yvalid = None # val_idx = None # xtrain= pd.DataFrame(xtrain, columns= ordered_list)[useful_features].values # return val_idx, xtrain, xvalid, ytrain, yvalid, useful_features # xtrain = np.array(my_folds[my_folds[fold_name] != optimize_on][features_in].values) # ytrain = np.array(my_folds[my_folds[fold_name] != optimize_on][locker["target_name"]].values) # xvalid = np.array(my_folds[my_folds[fold_name] == optimize_on][features_in].values) # yvalid = np.array(my_folds[my_folds[fold_name] == optimize_on][locker["target_name"]].values) # mask = np.array((my_folds[fold_name] != optimize_on).values, dtype=bool) # xtrain= np.concatenate((xtrain, np.array(rest_train[(my_folds[fold_name] != optimize_on).values])), axis=1) # ytrain = np.array(my_folds[my_folds[fold_name] != optimize_on][locker["target_name"]].values) # xvalid = np.array(my_folds[my_folds[fold_name] == optimize_on][features_in].values) # xvalid = np.concatenate((xvalid, np.array(rest_train[(my_folds[fold_name] == optimize_on).values])), axis=1) # yvalid = np.array(my_folds[my_folds[fold_name] == optimize_on][locker["target_name"]].values) # val_idx = None # if _state in ["fold", "opt"]: # # for seed we don't need to find val_idx # val_idx = my_folds[my_folds[fold_name] == optimize_on][locker["id_name"]].values.tolist() # xtrain= pd.DataFrame(xtrain, columns= ordered_list)[useful_features].values # xvalid= pd.DataFrame(xvalid, columns= ordered_list)[useful_features].values # return val_idx, xtrain, xvalid, ytrain, yvalid, useful_features # else: # # all the features are present outside # my_folds = pd.read_parquet(f"../input/input-{comp_name}/my_folds.parquet") # if verbose != 0: # print("all the features are present outside") # rest_train = [] # append 1D arrays # ###################################################################################################### # """ # is it in oof or in features # useful_features: # pred_e_121_fold5.pkl # experiment no is the unique identifier # one experiment can have multiple preds # feat_l_1_f_12_std # # feature no is the unique identifier # level no is good since we can have std feature # # at two levels and it is good to seperate our features based on at which leve we are working # # for predictions the TABLE has a level column for identifying level # feat_l_1_f_12_mean # """ # # first filter features based on where they come from. # useful_features_pred = [item for item in useful_features if item.split("_")[0]=="pred"] # useful_features_feat = [item for item in useful_features if item.split("_")[0]=="feat"] # # sanity check # assert len(useful_features_pred) + len(useful_features_feat) == len(useful_features) # ordered_list = useful_features_pred + useful_features_feat # # collecting preds # for f in useful_features_pred: # try: # rest_train.append(load_pickle(f"../configs/configs-{comp_name}/oof_preds/oof_{f}.pkl")) # except: # raise Exception(f"Feature: {f} not found") # # collecting feats # for f in useful_features_feat: # try: # rest_train.append(load_pickle(f"../configs/configs-{comp_name}/train_feats/train_{f}.pkl")) # except: # raise Exception(f"Feature: {f} not found") # if rest_train == []: # raise Exception("Error in bottleneck") # rest_train = np.array(rest_train).reshape(-1,len(useful_features)) # del useful_features_feat, useful_features_pred # del useful_features # gc.collect() # ################################################################################################### # if _state == "seed": # xtrain= rest_train # xtrain= pd.DataFrame(xtrain, columns= ordered_list)[useful_features].values # ytrain = np.array(my_folds[locker["target_name"]].values) # xvalid = None # yvalid = None # val_idx = None # return val_idx, xtrain, xvalid, ytrain, yvalid , useful_features # mask = np.array((my_folds[fold_name] != optimize_on).values, dtype=bool) # xtrain= rest_train[(my_folds[fold_name] != optimize_on).values] # ytrain = np.array(my_folds[my_folds[fold_name] != optimize_on][locker["target_name"]].values) # xvalid = rest_train[(my_folds[fold_name] == optimize_on).values] # yvalid = np.array(my_folds[my_folds[fold_name] == optimize_on][locker["target_name"]].values) # val_idx = None # if _state in ["fold", "opt"]: # # for seed we don't need to find val_idx # val_idx = my_folds[my_folds[fold_name] == optimize_on][locker["id_name"]].values.tolist() # xtrain= pd.DataFrame(xtrain, columns= ordered_list)[useful_features].values # xvalid= pd.DataFrame(xvalid, columns= ordered_list)[useful_features].values # return val_idx, xtrain, xvalid, ytrain, yvalid , useful_features # https://www.kaggle.com/competitions/amex-default-prediction/discussion/332575#1829172 import pathlib class SaveModelCallback: def __init__(self, models_folder: pathlib.Path, fold_id: int, min_score_to_save: float, every_k: int, order: int = 0): self.min_score_to_save: float = min_score_to_save self.every_k: int = every_k self.current_score = min_score_to_save self.order: int = order self.models_folder: pathlib.Path = models_folder self.fold_id: int = fold_id def __call__(self, env): iteration = env.iteration score = env.evaluation_result_list[3][2] if iteration % self.every_k == 0: print(f'iteration {iteration}, score={score:.05f}') if score > self.current_score: self.current_score = score for fname in self.models_folder.glob(f'fold_id_{self.fold_id}*'): fname.unlink() print(f'High Score: iteration {iteration}, score={score:.05f}') joblib.dump(env.model, self.models_folder / f'fold_id_{self.fold_id}_{score:.05f}.pkl') def save_model2(models_folder: pathlib.Path, fold_id: int, min_score_to_save: float = 0.78, every_k: int = 50): return SaveModelCallback(models_folder=models_folder, fold_id=fold_id, min_score_to_save=min_score_to_save, every_k=every_k) def save_model1(): def callback(env): with open(os.path.join(sys.path[0], "ref.txt"), "r") as x: for i in x: comp_name = i x.close() max_score = global_variables.max_score iteration = env.iteration score = env.evaluation_result_list[0][2] if iteration % 100 == 0: print('iteration {}, score= {:.05f}'.format(iteration,score)) if score > max_score: max_score = score path = f"../models/models-{comp_name}/callback_logs/lgb_models_e_{global_variables.exp_no}_f_{global_variables.counter}_{global_variables._state}/" #'Models/' # if path don't exists create one # if exists throw error or delete it first for fname in os.listdir(path): if fname.startswith("fold_{}".format(global_variables.fold)): os.remove(os.path.join(path, fname)) print('High Score: iteration {}, score={:.05f}'.format(iteration, score)) joblib.dump(env.model, f"../models/models-{comp_name}/callback_logs/lgb_models_e_{global_variables.exp_no}_f_{global_variables.counter}_{global_variables._state}/"+'{:.05f}.pkl'.format(score)) global_variables.max_score = max_score callback.order = 0 return callback def mkdir_from_path(path): if not os.path.exists(path): os.mkdir(path) else: print(f"Folder: {path} already exists, do you want to overwrite?") print("Enter Y/y for overwrite or any other button to terminate") print(": ",end="") a = input() if a.upper() == "Y": # overrite print("Overwritting...") else: raise Exception("Folder already exists so process Terminated!!!") return path if __name__ == "__main__": comp_name= 'amex3' useful_features=['B_1_last', 'B_11_last', 'B_12_last','pred_e_5_fold5'] fold_name = "fold3" optimize_on= [2] _state = "seed" # opt: idx, train, valid, [test] # fold: idx, train, valid, test # seed: train, test return_type = "numpy_array" # self.val_idx, self.xtrain, self.xvalid, self.ytrain, self.yvalid, self.ordered_list_train val_idx, xtrain, xvalid, ytrain, yvalid, my_list = bottleneck(comp_name,useful_features, fold_name, optimize_on, _state, return_type,0) print(val_idx) print() print(xtrain) print() print(xvalid) print() print(ytrain) print() print(yvalid) print() print(my_list)

File no 43: /README.md
[Framework3] Machine Learning Pipeline The Pipeline is quite modular in nature following py37 guidelines. It uses OOPs concepts which makes it quite robust and easy to debug. I have tried to make this pipeline not too abstract, so that the user can have full control over it. The main goal of it is to help keep track of all the experiements in an organized way and automate repetitive tasks like creating folds, creating OOF and TEST predictions from an experiment. Models Supported lgr,lir, xgb,xgbc, xgbr, cbc, cbr, mlpc, rg, ls, knnc, dtc, adbc, gbmc , gbmr, hgbc, lgb, lgbmc, lgbmr, rfc , rfr, tabnetr, tabnetc, k1, k2, k3, tez1, tez2, p1, pretrained Key Features Of The Pipeline 1.Visualize Experimentations Visualize effect of various feature groups and and preprocessing techniques on the score. Visualize how various algorithms [here optuna] does hyperparameter tuning through various trials. Demo: https://www.kaggle.com/code/raj401/eda-experiments-tmay 2.Automates Hyperparameter tuning, experimentation, OOF and TEST predictions. Demo: https://www.kaggle.com/code/raj401/inference-mnist !python experiment.py # finds optimal hyperparameters !python predict.py # creates OOF and TEST predictions !python output.py # creates submission.csv file 3.Maintains a table of all the experiments. Demo: https://www.kaggle.com/code/raj401/eda-experiments-tmay How to use it Environment setup Folder Structure It allows working on different competitions together. Here example: tmay and amex Framework3/ | ├── configs/ | |__ configs-tmay/ | |__ configs-amex/ | ├── input/ | |__ input-tmay/ | |__ input-amex/ | ├── models/ | |__ models-tmay/ | |__ models-amex/ | ├── src_framework3/ | └── working/ Change your working directory to src_framework3. src_framework3 ├── create_folds.py ├── custoom_classes.sh ├── custom_models.py ├── experiment.py ├── feature_generator.py ├── feature_picker.py ├── grab.py ├── info.txt ├── keys.py ├── metrics.py ├── model_dispatcher.py ├── optuna_search.py ├── output.py ├── predict.sh ├── ref.txt ├── run.sh └── utils.py Dependencies Install below libraries manually or run command sh run.sh. Note: to run the sh script make sure your current working directory is src_framework3 pip install optuna pip install catboost pip install timm pip install pretrainedmodels pip install -Iv tez==0.6.0 pip install torchcontrib pip install iterative-stratification TABULAR COMPETITION (classification/regression) [STEPS] STEP-->1 : First set ref STEP-->2 : run init_folders.py --> create_datasets.py STEP-->3 : put train.parquet, test.parquet, sample.parquet in input folder [requirement] train:- id_col, features, target ( train may or may not have id column but test must have id column) [if not in parquet then convert using csv_to_parquet.py] [Now see once input content train, sample, test using show_input.py] test:- id_col, features sample:- id_col, target STEP-->4 : run keys.py STEP-->5 : run create_folds.py [ Create New id columns for train] [ No need to sort test as test will always have submission with id column just never RESHUFFLE] [ Sort train by id column, if not create one by reshuffling since when we get folds we will also sort them] [No need to sort test, we just predict on them, no training] train--------[ converted to ]------------->my_folds After this what should we have these files in input folder # what we did is train------------------->my_folds my_folds:- id_col, features, target , fold_cols test:- id_col, features sample:- id_col, target_col [You may now remove train folder] check once everything is as it should be using show_input.py STEP-->6 : run experiment.py / auto_exp.py we should pass list of optimize_on in run() We won't be predicting for all the experiments we do. So keep log_exp_22.pkl file in a subfolder also make seperate folder for preds: oof_preds, test_preds After 5-6 hr do plot the auto table to see which set performs well and you can limit the search in that direction Like "f_base", "f_max" performs quite well STEP-->7 : run predict.py or run seed_it.py # calls opt() function but not run() so keep it that way as obj() don't require optimize_on Note : run() takes list optimize_on : obj() takes single integer optimize_on for each fold : both takes fold_name STEP-->8 : run output.py after running predict.py STEP-->9 : make submission submit.py kaggle competitions list kaggle competitions leaderboard amex-default-prediction --show | --download kaggle competitions submisssions amex-default-prediction kaggle competitions submit ventilator-pressure-prediction -f submission.csv -m "exp_{}_fold/single/all" #submit your submission.csv Note: all parquet file contains id and target , all pkl files contain 1d prediction STEP-->10 : auto_exp , It automatically does experimentations by selecting different subsets of feature groups and preprocessing techniques. IMAGE COMPETITION (classification) [STEPS] [Case1] Image stored as dataframe STEP-->1 : First set ref [note: image_df: image pixels are stored as dataframe ] STEP-->2 : move train.csv ,test.csv, sample.csv to models_ [make name train,test,sample] STEP-->3 :decide: id_name : as that of train id columns target_name : as that of sample target column -----------Make format like below exactly ---------------------- train: ImageId, Label, pixel0, pixel1, pixel2, ... , pixel200, test: ImageId, pixel0, pixel1, pixel2, ... , pixel200 sample: ImageId, Label STEP-->4 :run keys.py after setting appropriate name of variables STEP-->5 :run create_folds.py to create [my_folds.csv] [Case1] Image path stored in dataframe image_path: there is train.csv and sample.csv folder which contains image name and there are image folders initially> (before putting image ID column do sample(frac=1)) train.csv: image_id, target sample.csv: image_id, fake_target target_name >> sample target name id_name >> sample id name STEP-->1 : move train.csv to models_ by first rename id_name to image1.jpeg STEP-->2 : move sample.csv to models_ as test.csv by first renaming id_name to image2.jpeg STEP-->3 : move sample to models_ [image_id, target] STEP-->4 : run keys.py after setting appropriate name of variables STEP-->5 : run create_folds.py to create [my_folds.csv] [Case3] Image Folder ..[work in progress..] Go You can’t perform that action at this time.

4: Project Name : CutMix-Regularization-Strategy-to-Train-Strong-Classifiers-with-Localizable-Features
This project contains 1 main files, namely /README.md
Below we will get details about each of these files one by one:
	
File no 1: /README.md
CutMix-Regularization Through this project we will try to understand CutMix Augmentation by implementing it on a simple problem of cat-vs-dog classification. Implementation I have used keras to implement the cutmix augmentation. Dataset used: https://www.kaggle.com/competitions/dogs-vs-cats/data. In CutMix we mix two images and their labels respectively in order to generate new data point. To implement this, I have created a custom datagenerator. This custom datagenerator takes batches from two seperate keras datagenerator and returns one batch by applying cutmix on it. train datagenerator (custom) train_dataset = CutMixImageDataGenerator( generator1= train_datagen1, #train_generator1, generator2= train_datagen2, #train_generator2, img_size=128, batch_size=32, ) valid datagenerator (default) valid_dataset = valid_datagen.flow_from_dataframe( dataframe=validate_df, directory=image_path, target_size=(128, 128), x_col='filename', y_col='category', batch_size=32, seed=42, shuffle=True, class_mode="categorical", ) Results Type Without CutMix With CutMix Output Training and Validation Accuracy plot Score loss: 0.7671 - acc: 0.6406 val_loss: 0.9630 - val_acc: 0.6445 loss: 0.1226 - acc: 0.9538 val_loss: 0.4688 - val_acc: 0.8438 #epochs 50 50 Early Stop at 28 15 Conclusion We have two notebooks 1. Without CutMix and 2. With CutMix. Both notebooks have everything exactly same(seed, batchsize, #epochs, rescaling etc) only except the training datagenerator. And we notice that using CutMix augmentation has really improved the validation score making the model more regularized and robust in comparision to model which is trained without using CutMix augmentation. Reference original paper: https://arxiv.org/abs/1905.04899 Go You can’t perform that action at this time.

5: Project Name : ar8372
This project contains 1 main files, namely /README.md
Below we will get details about each of these files one by one:
	
File no 1: /README.md
Hi there 👋 🔭 I am currently working on : Winning Medal in Kaggle Competition tier 🌱 I’m currently learning Reinforcement Learning 🥅 2022 Goals: Research in ML+RL domain ⚡ Fun fact: I love to read thriller and mystery novels 🤔 I’m looking for help with Julia Language 💬 Ask me about TensorFlow2.x, PyTorch 😄 Pronouns: He/him. 🛠 Tech Stack Programming Languages Machine Learning Frameworks Operating Systems: Miscellaneous Kaggle Stats Go You can’t perform that action at this time.

6: Project Name : Optimization-SteepestDescent-vs-GradientDescent
This project contains 5 main files, namely /README.md, /gradient_descent.py, /main.py, /steepest_descent.py, /utils.py
Below we will get details about each of these files one by one:
	
File no 1: /README.md
Optimization-SteepestDescent vs GradientDescent Understand working of Steepest-Descent and Gradient-Descent methods We will work with Quadratic function. Because any higher dimension problem will be harder to plot and visualize. Problem Statement :- cost_func_f(x) = (1/2)*x.T*Q*x + b.T*x + c or (5/2)* (X2**2)+(Y2**2)+X2*Y2-2*X2+3*Y2+10 where x = [[X1], [Y1]] Q = np.array([[5,1], [1, 2]]) b = np.array([[-2], [3]]) c = 10 x = np.array([[10], [10]]) Find point x s.t. cost_func_f(x) is minimum. Different Approaches: Steepest Descent Gradient Descent 1.Steepest Descent: In this learning rate or step size is determined based on algorithm and is not a heuristic value. a) Base problem Steepest Descent Method also known as saddle method. In this we move in a direction untill the cost function stops decreasing [i.e. ∇f(dx1)=0, where dx1 is that direction. Cost function may still decrease in other direction]. Then we pick another direction let say dx2. In this each next direction is perpendicular to last direction ( dx1 ⊥ dx2 ). The saddle point is point of contact to the contour line where that direction is tangent. #iterations: 13 b) Steepest Descent with Newton's Method In newton's method we approximate our cost function with a similar quadratic equation which behaves similar to our original function in some small neigbourhood. It then tries to find the optiamal pt of that quadratic function. It repeats this process untill stopping criteria is met. [Note: here since our original function is quadratic function itself so the approximation is same function and thus we reach it's optimal point in one iteration.] #iterations: 1 2.Gradient Descent: In this learning rate or step size is a heuristic value. So we must be very carefull about what we choose as step size. A big step size may create problem and we may never converge to optimal point. [ In general learning rate < 2/ λmax (Hf(x)) , for quadratic cost Hf(x) is Q. so in our problem 2/ λmax(Q) is 0.3771609692315777] a) Gradient Descent with learning rate `0.1` Since leanring rate is much less than the 0.3771609692315777, it will converge nicely. #iterations: 86 b) Gradient Descent with learning rate `0.3771609692315777 - 0.00002` Since leanring rate is smaller but very close to 0.3771609692315777 it will converge after much oscillation, thus will take much more iterations. #iterations: 163093 c) Gradient Descent with learning rate `0.3771609692315777 + 0.00002` Since leanring rate is larger than 0.3771609692315777 it will keep oscillating and will never converge. Let's put all our findings in one table no algorithm #iterations 1.a Steepest Descent (base method) 13 1.b Steepest Descent (newton's method) 1 2.a Gradient Descent (lr=0.1) 86 2.b Gradient Descent (lr=0.3771609692315777 - 0.00002) 163093 2.c Gradient Descent (lr=0.3771609692315777 + 0.00002) NA Go You can’t perform that action at this time.

File no 2: /gradient_descent.py
from utils import * def gd(Q,b,c, x,alpha, verbose=0): store_x = [x] val = (1/2)*(x.T@Q@x + b.T@x + c) # calculate gradient Qinv b x_ = -1 *np.linalg.inv(Q) @ b # print("x*") # print(x_) grad = Q@x + b #print("grad") #print(grad) dk = -1*grad #alpha = dk.T @ dk / (dk.T @ Q @ dk) #print("alpha shape", alpha.shape) xnew = x + alpha*dk store_x += [xnew] counter = 0 while np.linalg.norm(grad) > 0.000002: counter += 1 #print(counter) x = xnew #print(x_) grad = Q@x + b #print("grad") #print(grad) dk = -1*grad #alpha = dk.T @ dk / (dk.T @ Q @ dk) xnew = x + alpha*dk store_x += [xnew] if verbose > 10: print("Reached: ", (xnew[0,0], xnew[1,0])) print() print(f"Finished in {counter} steps") final_x, cost, x_star, store_x = xnew, np.linalg.norm(xnew - x), x_, store_x if verbose >= 1: print("#"*40) print("OUTPUT".center(40)) print("#"*40) print("Final pos:") print(final_x) print() if verbose >= 2: print("x*:") print(x_star) print() if verbose >= 3: #plt.scatter(store_x) # print("store_x:") x = [] y = [] for i in store_x: x.append(i[0,0]) y.append(i[1,0]) plt.plot(x,y, marker="o",ls="--",markersize=3,markeredgewidth=6, markeredgecolor="y", markerfacecolor="b") plt.title('gradient descent with learning rate 0.3771609692315777 - 0.00002') plt.show() print() return xnew, np.linalg.norm(xnew - x), x_, store_x

File no 3: /main.py
from utils import * from steepest_descent import sd , sd_with_newtons_method from gradient_descent import gd ########################################## # INITIALIZE # ########################################## Q = np.array([[5,1], [1, 2]]) thresh= 2/5.30277564 # 0.3771609692315777 b = np.array([[-2], [3]]) c = 10 x = np.array([[1], [0]]) x = np.array([[10], [10]]) alpha = 0.002 alpha = 0.1 alpha = 0.3771609692315777 - 0.00002 no_of_pts = 10 if __name__ == "__main__": final_x, cost, x_star, store_x= gd(Q, b, c, x, alpha, verbose=3) #final_x, cost, x_star, store_x= sd(Q, b, c, x, verbose=3) #final_x, cost, x_star, store_x= sd_with_newtons_method(Q, b, c, x, verbose=3) # Draws 3D plot of descent plot_descent(10,final_x, cost, x_star, store_x)

File no 4: /steepest_descent.py
from utils import * def sd(Q,b,c, x, verbose=0): store_x = [x] val = (1/2)*(x.T@Q@x + b.T@x + c) # calculate gradient Qinv b x_ = -1 *np.linalg.inv(Q) @ b # print("x*") # print(x_) grad = Q@x + b #print("grad") #print(grad) dk = -1*grad alpha = dk.T @ dk / (dk.T @ Q @ dk) #print("alpha shape", alpha.shape) xnew = x + alpha*dk store_x += [xnew] counter = 0 while np.linalg.norm(grad) > 0.000002: # np.linalg.norm(xnew-x) > 0.000002: counter += 1 x = xnew #print(x_) grad = Q@x + b #print("grad") #print(grad) dk = -1*grad alpha = dk.T @ dk / (dk.T @ Q @ dk) xnew = x + alpha*dk store_x += [xnew] if verbose > 10: print("Reached: ", (xnew[0,0], xnew[1,0])) print() print(f"Finished in {counter} steps") final_x, cost, x_star, store_x = xnew, np.linalg.norm(xnew - x), x_, store_x if verbose >= 1: print("#"*40) print("OUTPUT".center(40)) print("#"*40) print("Final pos:") print(final_x) print() if verbose >= 2: print("x*:") print(x_star) print() # if verbose >= 3: # plt.scatter(store_x) # print("store_x:") # for i in store_x: # print(i) # print('-'*40) if verbose >= 3: #plt.scatter(store_x) # print("store_x:") x = [] y = [] for i in store_x: x.append(i[0,0]) y.append(i[1,0]) plt.plot(x,y, marker="o",ls="--",markersize=3,markeredgewidth=6, markeredgecolor="y", markerfacecolor="b") plt.title('steepest descent') plt.ylabel('y', rotation=0) plt.xlabel('x') plt.show() print() return xnew, np.linalg.norm(xnew - x), x_, store_x def sd_with_newtons_method(Q,b,c, x, verbose=0): store_x = [x] val = (1/2)*(x.T@Q@x + b.T@x + c) # calculate gradient Qinv b x_ = -1 *np.linalg.inv(Q) @ b # print("x*") # print(x_) grad = Q@x + b grad2 = np.linalg.inv(Q) #print("grad") #print(grad) dk = -1*grad alpha = dk.T @ dk / (dk.T @ Q @ dk) #print("alpha shape", alpha.shape) f1f2 = -1* (grad2@grad) xnew = x + f1f2 #alpha*dk store_x += [xnew] counter = 0 while np.linalg.norm(grad) > 0.000002: counter += 1 x = xnew #print(x_) grad = Q@x + b #print("grad") #print(grad) dk = -1*grad alpha = dk.T @ dk / (dk.T @ Q @ dk) f1f2 = -1* (grad2@grad) xnew = x + f1f2 #alpha*dk store_x += [xnew] if verbose > 10: print("Reached: ", (xnew[0,0], xnew[1,0])) print() print(f"Finished in {counter} steps") final_x, cost, x_star, store_x = xnew, np.linalg.norm(xnew - x), x_, store_x if verbose >= 1: print("#"*40) print("OUTPUT".center(40)) print("#"*40) print("Final pos:") print(final_x) print() if verbose >= 2: print("x*:") print(x_star) print() # if verbose >= 3: # plt.scatter(store_x) # print("store_x:") # for i in store_x: # print(i) # print('-'*40) if verbose >= 3: #plt.scatter(store_x) # print("store_x:") x = [] y = [] for i in store_x: x.append(i[0,0]) y.append(i[1,0]) plt.plot(x,y, marker="o",ls="--",markersize=3,markeredgewidth=6, markeredgecolor="y", markerfacecolor="b") plt.title("steepest descent with newton's method") plt.ylabel('y', rotation=0) plt.xlabel('x') plt.show() print() return xnew, np.linalg.norm(xnew - x), x_, store_x

File no 5: /utils.py
import numpy as np import pandas as pd import matplotlib.pyplot as plt from mpl_toolkits import mplot3d def cost_func(X2, Y2): return (5/2)* (X2**2)+(Y2**2)+X2*Y2-2*X2+3*Y2+10 def n_pts(px, py, i, j, n=10): # px = 1 # py = 1.2 # i = 11 # j = 1.2 X = [] Y = [] slope = (j-py)/(i-px) step = (px-i)/(n+1) for c in range(0,n): current_x = i + c*step current_y = j + slope*(current_x-i) X.append(current_x) Y.append(current_y) return X, Y def plot_descent(no_of_pts, final_x, cost, x_star, store_x): ax = plt.axes(projection = "3d") X1 = [] Y1 = [] for i,j in store_x: X1.append(i[0]) Y1.append(j[0]) # x1 -.2 0.3 # y1 0.1 0.02 # pts in between if no_of_pts != 0: X2 = [] Y2 = [] for i,j in zip(X1, Y1): # if X2 == []: # first time X2.append(i) Y2.append(j) px = i py = j else: # find distance from last to current l,m= n_pts(px, py, i,j,n=no_of_pts) X2 += l Y2 += m px = i py = j X2 = np.array(X2) Y2 = np.array(Y2) Z2 = cost_func(X2, Y2) X1 = np.array(X1) Y1 = np.array(Y1) Z1 = cost_func(X1, Y1) x = np.arange(-10,10,0.1) y = np.arange(-10,10,0.1) X,Y = np.meshgrid(x,y) # Z = (5/2)* (X**2)+(Y**2)+X*Y-2*X+3*Y+10 Z = cost_func(X, Y) #ax.scatter(X, Y, Z, marker="v", alpha=0.008, c='blue') ax.contour3D(X, Y, Z, 50, cmap='binary') ax.scatter(X1, Y1, Z1, marker=".", c='green') if no_of_pts != 0: ax.scatter(X2, Y2, Z2 , c='red', alpha=0.8, marker='.') # Starting Point a = X1[0] b = Y1[0] z_star = (5/2)* (a**2)+(b**2)+a*b-2*a+3*b+10 ax.scatter(a, b, z_star, marker='s', c='Red' ) # Final Point a = x_star[0,0] b = x_star[1,0] z_star = (5/2)* (a**2)+(b**2)+a*b-2*a+3*b+10 ax.scatter(a, b, z_star, marker='s', c='black' ) plt.show()

7: Project Name : Image-Feature-extraction-using-Reinforcement-Learning
This project contains 2 main files, namely /resources/temp.py, /README.md
Below we will get details about each of these files one by one:
	
File no 1: /resources/temp.py


File no 2: /README.md
Image Feature Extraction Image-Feature-extraction-using-Reinforcement-Learning. Our algorithm converts an image dataset into tabular dataset by extracting features of an image. This algorithm is tested on simple problems like handwritten-digit recognition, hand-sign recognition etc and is able to extract features. For complex problems like extracting features from a human face image, we have not tested it yet and it probably won't work due to complexity of the problem. Demo :- Input: Output: -169.0 , -148.0, -153.0, -171.0 Algorithm [approach]: Preprocess image to reduce computation Calculate transition matrix of the preprocessed Image Assign pixels to grids Assign reward to each state Find optimal point of the figure Calculate return Use it to extract features At the end we get a set of 4 features corresponding to each image Inference Notebook link: https://www.kaggle.com/raj401/image-feature-extraction-using-rl Theory rewards returns Theory Notebook link: https://colab.research.google.com/drive/1ttKeYIf_TUjrm9HPu8U5_PRI2A7Vi6s9?usp=sharing Go You can’t perform that action at this time.

8: Project Name : N-Armed-Bandit
This project contains 9 main files, namely /Agent.py, /Environment.py, /Problem1.py, /Problem2.py, /Problem3.py, /Report.pdf, /main.py, /plot_epsilons.py, /utils.py
Below we will get details about each of these files one by one:
	
File no 1: /Agent.py
import numpy as np import random from utils import * # define environment """ Agent: input:=> environment, decides which actions to take and based on the reward it get's from env it updates it's policy. [updated idea about what is the ExpectedReward] returns:=> Optimal policty """ class Agents: def __init__(self, name_agent, epsilon, discount_factor, env): #==> Types of Agent # Epsilon-Greedy Agent # Optimistic Initial Start # Upper Confidence Bound # Gradient Bandit Agent self.name_agent = name_agent self.epsilon = epsilon self.discount_factor = discount_factor self.env = env self.no_arms = self.env.no_arms self.actions = self.env.actions # initialize expectedReward self.initialize_() def train(self, n_iterations, verbose=0, seed=2023): # seed it for reproducibility of result seedBasic(self,seed) avg_rewards = [] for iter_no in range(n_iterations): action = self.take_action() reward = self.get_reward(action) if verbose >= 1: print(f"iteration no {iter_no}") print(f"action: {action}") print(f"reward: {reward}") print() # update self.update_expectedReward(action, reward) print(f"iter no {iter_no}: {[np.round(x,3) for x in self.expectedReward]}") avg_rewards.append(np.mean(self.expectedReward)) return avg_rewards def initialize_(self): # initialize initial expected reward of each arm self.expectedReward = [0]*self.no_arms print(f"Initial expectedRewards: ") print(self.expectedReward) print() def best_action(self): action = self.actions[np.argmax(self.expectedReward)] return action def take_action(self): # 1-epsilon times exploit # so epsilon tells how many times explore prob = random.uniform(0,1) #[low,high) if prob > self.epsilon: # argmax action = self.actions[np.argmax(self.expectedReward)] else: # random choice action = np.random.choice(self.actions) return action def get_reward(self, action): # environment will provide reward reward_received = self.env.reward(action) return reward_received def update_expectedReward(self, action_taken, reward_received): index_ = self.actions.index(action_taken) self.expectedReward[index_] += self.discount_factor*(reward_received -self.expectedReward[index_] )

File no 2: /Environment.py
import numpy as np import random from utils import * # define environment """ Environment: [Stationary Environment but non-deterministic] input:=> action returns:=> reward """ class N_Armed_Bandit: def __init__(self,n, random_state,_mean, _std, manual_reward="--|--"): self.no_arms = n self._mean = _mean self._std = _std self.manual_reward = manual_reward self.actions = [i for i in range(1, self.no_arms+1)] print(f"Actions: ") print(self.actions) # seed everything seedBasic(self,random_state) # initialize self.initialize_() def initialize_(self): # initialize reward of each arm actual reward associated with each action if self.manual_reward != "--|--": self.rewards = self.manual_reward else: self.rewards = [np.random.randint(1,100) for i in range(self.no_arms)] print(f"Means of Reward Distributions") print(self.rewards) def reward(self, action): # returns reward on taking a given action prob_dist = random.gauss(self._mean,self._std) return self.rewards[self.actions.index(action)] + prob_dist

File no 3: /Problem1.py
""" Problem1:- Consider a binary bandit with two rewards {1-success, 0-failure}. The bandit returns 1 or 0 for the action that you select, i.e. 1 or 2. The rewards are stochastic (but stationary). Use an epsilon-greedy algorithm discussed in class and decide upon the action to take for maximizing the expected reward. There are two binary bandits named binaryBanditA.m and binaryBanditB.m are waiting for you. """ from Environment import N_Armed_Bandit from Agent import Agents if __name__ == "__main__": no_arms = 2 agent_name = "epsilon_greedy" epsilon = 0.5 discount_factor = 0.7 # future reward importance random_state = 100 _mean = 0 _std = 1 no_iterations = 5 verbose = 0 manual_reward = [1, 0] # will override random reward assignment print() # create env e = N_Armed_Bandit(no_arms, random_state, _mean, _std,manual_reward = manual_reward) print() # create agent a = Agents(agent_name, epsilon, discount_factor, e) a.train(no_iterations,verbose) print() print("True Reward is:") print(e.rewards) print("Expected Reward is:") print(a.expectedReward) print() print("Best action is: ",a.best_action()) print()

File no 4: /Problem2.py
""" Problem2:- # Non-Stationary Reward: Develop a 10-armed bandit in which all ten mean-rewards start out equal and then take independent random walks (by adding a normally distributed increment with mean zero and standard deviation 0.01 to all mean-rewards on each time step). {function [value] = bandit_nonstat(action)} """ from Environment import N_Armed_Bandit from Agent import Agents if __name__ == "__main__": no_arms = 10 agent_name = "epsilon_greedy" epsilon = .4 # How many times to explore discount_factor = 0.7 # future reward importance random_state = 101 _mean = 0 _std = 0.01 no_iterations = 5 verbose = 0 manual_reward = "--|--" #[1, 0] # will override random reward assignment print() # create env e = N_Armed_Bandit(no_arms, random_state,_mean, _std, manual_reward = manual_reward) print() # create agent a = Agents(agent_name, epsilon, discount_factor, e) a.train(no_iterations,verbose) print() print("True Reward is:") print(e.rewards) print("Expected Reward is:") print(a.expectedReward) print() print("Best action is: ",a.best_action()) print()

File no 5: /Problem3.py
""" Problem3:- Develop a 10-armed bandit in which all ten mean-rewards start out equal and then take independent random walks (by adding a normally distributed increment with mean zero and standard deviation 0.01 to all mean-rewards on each time step). {function [value] = bandit_nonstat(action)} """ from Environment import N_Armed_Bandit from Agent import Agents if __name__ == "__main__": no_arms = 10 agent_name = "epsilon_greedy" epsilon = .4 # How many times to explore discount_factor = 0.7 # future reward importance random_state = 101 _mean = 0 _std = 0.01 no_iterations = 1000 verbose = 0 manual_reward = "--|--" #[1, 0] # will override random reward assignment print() # create env e = N_Armed_Bandit(no_arms, random_state,_mean, _std, manual_reward = manual_reward) print() # create agent a = Agents(agent_name, epsilon, discount_factor, e) a.train(no_iterations,verbose) print() print("True Reward is:") print(e.rewards) print("Expected Reward is:") print(a.expectedReward) print() print("Best action is: ",a.best_action()) print()

File no 6: /Report.pdf
N-Armed-Bandit/Report.pdf at main · ar8372/N-Armed-Bandit · GitHub Skip to content Toggle navigation Sign up In this repository All GitHub ↵ Jump to ↵ No suggested jump to results In this repository All GitHub ↵ Jump to ↵ In this user All GitHub ↵ Jump to ↵ In this repository All GitHub ↵ Jump to ↵ Sign in Sign up You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session. You switched accounts on another tab or window. Reload to refresh your session. ar8372 / N-Armed-Bandit Public Notifications Fork 0 Star 0 Permalink main Switch branches/tags Branches Tags Name already in use A tag already exists with the provided branch name. Many Git commands accept both tag and branch names, so creating this branch may cause unexpected behavior. Are you sure you want to create this branch? N-Armed-Bandit/Report.pdf Go to file Go to file T Go to line L Copy path Copy permalink This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository. Cannot retrieve contributors at this time 396 KB Download Open with Desktop Download Delete file Sorry, something went wrong. Reload? Sorry, we cannot display this file. Sorry, this file is invalid so it cannot be displayed. Viewer requires iframe. Go You can’t perform that action at this time.

File no 7: /main.py
from Environment import N_Armed_Bandit from Agent import Agents if __name__ == "__main__": no_arms = 3 agent_name = "epsilon_greedy" epsilon = 0.2 discount_factor = 0.5 # future reward importance random_state = 100 _mean = 0 _std = 1 no_iterations = 500 verbose = 0 print() # create env e = N_Armed_Bandit(no_arms, random_state, _mean, _std,) print() # create agent a = Agents(agent_name, epsilon, discount_factor, e) print("="*40) print("For actions 3 actual reward is:") print(a.get_reward(3)) print("and Agent Expected reward is:") print(a.expectedReward[2]) print("="*40) a.train(no_iterations,verbose) print("="*40) print("For actions 3 actual reward is:") print(a.get_reward(3)) print("and Agent Expected reward is:") print(a.expectedReward[2]) print("="*40) print() print("Best action is: ",a.best_action())

File no 8: /plot_epsilons.py
# Run this on Spyder """ Problem3:- Develop a 10-armed bandit in which all ten mean-rewards start out equal and then take independent random walks (by adding a normally distributed increment with mean zero and standard deviation 0.01 to all mean-rewards on each time step). {function [value] = bandit_nonstat(action)} """ from Environment import N_Armed_Bandit from Agent import Agents import matplotlib.pyplot as plt if __name__ == "__main__": no_arms = 10 agent_name = "epsilon_greedy" epsilon = .4 # How many times to explore discount_factor = 0.7 # future reward importance random_state = 100 _mean = 0 _std = 0.01 no_iterations = 1000 verbose = 0 manual_reward = "--|--" #[1, 0] # will override random reward assignment avg_rewards = [] for epsilon in [0,0.01,0.1,0.5,0.9]: e = N_Armed_Bandit(no_arms, random_state,_mean, _std, manual_reward = manual_reward) # create agent a = Agents(agent_name, epsilon, discount_factor, e) avg_rewards.append(a.train(no_iterations,verbose)) print("This is avg_rewards") plt.plot(avg_rewards[0],label="epsilon:0") plt.plot(avg_rewards[1],label="epsilon:0.01") plt.plot(avg_rewards[2],label="epsilon:0.1") plt.plot(avg_rewards[3],label="epsilon:0.5") plt.plot(avg_rewards[4],label="epsilon:0.9") plt.ylabel("avg reward") plt.xlabel("epochs") plt.legend(loc="upper right") plt.show()

File no 9: /utils.py
import os import numpy as np import random def seedBasic(self,random_state): random.seed(random_state) os.environ['PYTHONHASHSEED'] = str(random_state) np.random.seed(random_state) if __name__ == "__main__": seedBasic(100) print(random.gauss(0,1))

9: Project Name : uninformed_search
This project contains 3 main files, namely /Missionary_and_Cannibal.py, /Rabbit_leap.py, /Report.pdf
Below we will get details about each of these files one by one:
	
File no 1: /Missionary_and_Cannibal.py
# -*- coding: utf-8 -*- """ Created on Mon Feb 28 12:59:31 2022 @author: aman raj """ import numpy as np # ----------------M C side initial_state = [3, 3, 0] goal_state = [0, 0, 1] def pick_R1(current_state, i): temp = current_state.copy() temp[i + 1] = 0 temp[i] = 2 return temp def pick_R2(current_state, i): temp = current_state.copy() temp[i + 2] = 0 temp[i] = 2 return temp def pick_L1(current_state, i): temp = current_state.copy() temp[i - 1] = 0 temp[i] = 1 return temp def pick_L2(current_state, i): temp = current_state.copy() temp[i - 2] = 0 temp[i] = 1 return temp def actions(current_state): a = current_state[0] b = current_state[1] int_states = [] in_arr = np.array([[a, b] for i in range(5)]).reshape(5, 2) move = np.array([[-1, 0], [0, -1], [-2, 0], [0, -2], [-1, -1]]) bb = in_arr + move cc = np.sum(bb >= 0, axis=1) == 2 for row in bb[cc]: int_states.append(row) clean_states = [] for ro in int_states: if list(ro) == [0, 0]: # reached print("current_state:", (ro[0], ro[1], 1)) return "Found" for r in [ [3, 0], [3, 1], [3, 2], [3, 3], [2, 2], [1, 1], [0, 3], [0, 2], [0, 1], ]: if r[0] == ro[0] and r[1] == ro[1]: clean_states.append(ro) if clean_states == []: # not possible to reach return [] # --------------------------------------- final_states = [] for st in clean_states: a = st[0] b = st[1] in_arr = np.array([[a, b] for i in range(5)]).reshape(5, 2) move = np.array([[+1, 0], [0, +1], [+2, 0], [0, +2], [+1, +1]]) bb = in_arr + move cc = np.sum(bb <= 3, axis=1) == 2 for row in bb[cc]: final_states.append(row) clean_final_states = [] for ro in final_states: if list(ro) == [0, 0]: # reached print("reached") return [] for r in [ [3, 0], [3, 1], [3, 2], [3, 3], [2, 2], [1, 1], [0, 3], [0, 2], [0, 1], ]: if r[0] == ro[0] and r[1] == ro[1]: clean_final_states.append(tuple(ro)) # print("clean",clean_final_states) if clean_final_states == []: # not possible to reach return [] return list(set(clean_final_states)) class node: def __init__(self, state, parent, path_cost): self.state = state self.parent = parent self.path_cost = path_cost class Frontier: # priority que def __init__(self, root_node): self.list_nodes = [root_node] def pop(self): # remove first element if len(self.list_nodes) == 0: return "NotFound" first = self.list_nodes[0] self.list_nodes = self.list_nodes[1:].copy() return first def remove(self, nod): if nod not in self.list_nodes: return "NotFound" del self.list_nodes[self.list_nodes.index(nod)] def isbetter(self, nod): list_same_state = [] for no in self.list_nodes: if nod.state == no.state: list_same_state.append(no) for no in list_same_state: if no.path_cost <= nod.path_cost: return False return True def top(self): # return node with minimum cost if len(self.list_nodes) == 0: return "NotFound" my_node = self.list_nodes[0] cost = my_node.path_cost for nod in self.list_nodes: s = nod.state p = nod.parent pt = nod.path_cost if pt < cost: my_node = nod return my_node def is_empty(self): if len(self.list_nodes) == 0: return True return False def add(self, nod): self.list_nodes.append(nod) class Visited: def __init__(self): self.visited_list = [] def add(self, nod): self.visited_list.append(nod) def isin(self, st): for no in self.visited_list: if list(st) == list(no.state): return True return False def backtrack(my_frontier, my_visited, top_node, home_state): # top node is where we reached current_node = top_node print(current_node.state) while current_node.state != home_state: # find next node p = current_node.parent for no in my_visited.visited_list: # got node if no.state == p: current_node = no print(current_node.state) print("=" * 79) # BestFirstsearch Agent def BestFirstSearch_Agent(initial_state, goal_state, verbose): ## home_state = initial_state.copy() # (initial state, None,0) parent_node = node(initial_state, None, 0) my_frontier = Frontier(parent_node) my_visited = Visited() if initial_state == goal_state: # we got return initial_state while my_frontier.is_empty() != True: if verbose >= 1: print("visited:",[t.state for t in my_visited.visited_list]) # while my frontier is not empty # Best First search top_node = my_frontier.top() my_frontier.remove(top_node) if top_node.state == goal_state: backtrack(my_frontier, my_visited, top_node, home_state) return top_node.state # not goal so move it to Visited state and expand it # check whether it is in visited or not if my_visited.isin(top_node.state): # so we already visited it continue my_visited.add(top_node) # expanded print("current_state:", top_node.state) print() #print("frontier:", ) all_possible_actions = actions(top_node.state) # print("these are all valid actions",all_possible_actions) if all_possible_actions == []: print("Not possible") return if all_possible_actions == "Found": print() print("BackTracking: ") print((0, 0, 1)) backtrack(my_frontier, my_visited, top_node, home_state) return all_possible_actions = [(a, b, 0) for a, b in all_possible_actions] c = top_node.path_cost all_possible_nodes = [ node(st, top_node.state, c + 1) for st in all_possible_actions ] clean_nodes = [] for no in all_possible_nodes: if my_frontier.isbetter(no) and not my_visited.isin(no.state): clean_nodes.append(no) if my_frontier.isbetter(no): # it is better so replace my_frontier.remove(no) for no in clean_nodes: my_frontier.add(no) initial_state = top_node.state print("Not found") if __name__ == "__main__": """ We have considered state as : (no of Missionaries on left, no of Cannibal on left , side of boat ) where side of boat is 0 if it is in left and 1 if it is in right. initial state:- (3, 3, 0) goal state:- (0, 0, 1) Note:- set verbose 0 for min display set verbose 1 for max display """ # ----------------M C side initial_state = [3, 3, 0] goal_state = [0, 0, 1] verbose = 0 print("="*79) print("="*30, end="") print("Missionary&Cannibal",end="") print("="*30, end="\n\n") #run:- BestFirstSearch_Agent(initial_state, goal_state, verbose) print("="*36, end="") print("End",end="") print("="*40, end="\n\n")

File no 2: /Rabbit_leap.py
# -*- coding: utf-8 -*- """ Created on Mon Feb 28 12:59:31 2022 @author: aman raj """ initial_state = [1, 1, 1, 0, 2, 2, 2] goal_state = [2, 2, 2, 0, 1, 1, 1] def pick_R1(current_state, i): temp = current_state.copy() temp[i + 1] = 0 temp[i] = 2 return temp def pick_R2(current_state, i): temp = current_state.copy() temp[i + 2] = 0 temp[i] = 2 return temp def pick_L1(current_state, i): temp = current_state.copy() temp[i - 1] = 0 temp[i] = 1 return temp def pick_L2(current_state, i): temp = current_state.copy() temp[i - 2] = 0 temp[i] = 1 return temp def actions(current_state): # agent asked for all next possible states possible_states = [] i = current_state.index(0) if i == 0: # first positon if current_state[i + 1] == 2: # 2 0 ---- possible_states.append(pick_R1(current_state, i)) if current_state[i + 2] == 2: # 2 - 0 --- possible_states.append(pick_R2(current_state, i)) elif i == 1: if current_state[i - 1] == 1: # 0 1 -- - possible_states.append(pick_L1(current_state, i)) # first positon if current_state[i + 1] == 2: # 2 0 ---- possible_states.append(pick_R1(current_state, i)) if current_state[i + 2] == 2: # 2 - 0 --- possible_states.append(pick_R2(current_state, i)) elif i >= 2 and i < len(current_state) - 2: # has both left and right full if current_state[i - 2] == 1: # possible_states.append(pick_L2(current_state, i)) if current_state[i - 1] == 1: # 0 1 -- - possible_states.append(pick_L1(current_state, i)) # first positon if current_state[i + 1] == 2: # 2 0 ---- possible_states.append(pick_R1(current_state, i)) if current_state[i + 2] == 2: # 2 - 0 --- possible_states.append(pick_R2(current_state, i)) elif i == len(current_state) - 2: if current_state[i + 1] == 2: # 0 1 -- - possible_states.append(pick_R1(current_state, i)) # first positon if current_state[i - 1] == 1: # 2 0 ---- possible_states.append(pick_L1(current_state, i)) if current_state[i - 2] == 1: # 2 - 0 --- possible_states.append(pick_L2(current_state, i)) elif i == len(current_state) - 1: # last positon if current_state[i - 1] == 1: # 2 0 ---- possible_states.append(pick_L1(current_state, i)) if current_state[i - 2] == 1: # 2 - 0 --- possible_states.append(pick_L2(current_state, i)) return possible_states class node: def __init__(self, state, parent, path_cost): self.state = state self.parent = parent self.path_cost = path_cost class Frontier: # priority que def __init__(self, root_node): self.list_nodes = [root_node] def pop(self): # remove first element if len(self.list_nodes) == 0: return "NotFound" first = self.list_nodes[0] self.list_nodes = self.list_nodes[1:].copy() return first def remove(self, nod): if nod not in self.list_nodes: return "NotFound" del self.list_nodes[self.list_nodes.index(nod)] def isbetter(self, nod): list_same_state = [] for no in self.list_nodes: if nod.state == no.state: list_same_state.append(no) for no in list_same_state: if no.path_cost <= nod.path_cost: return False return True def top(self): # return node with minimum cost if len(self.list_nodes) == 0: return "NotFound" my_node = self.list_nodes[0] cost = my_node.path_cost for nod in self.list_nodes: s = nod.state p = nod.parent pt = nod.path_cost if pt < cost: my_node = nod return my_node def is_empty(self): if len(self.list_nodes) == 0: return True return False def add(self, nod): self.list_nodes.append(nod) class Visited: def __init__(self): self.visited_list = [] def add(self, nod): self.visited_list.append(nod) def isin(self, st): for no in self.visited_list: if st == no.state: return True return False def backtrack(my_frontier, my_visited, top_node, home_state): # top node is where we reached print() print("BackTrackig:-") current_node = top_node print(current_node.state) while current_node.state != home_state: # find next node p = current_node.parent for no in my_visited.visited_list: # got node if no.state == p: current_node = no print(current_node.state) print("=" * 79) # BestFirstsearch Agent def BestFirstSearch_Agent(initial_state, goal_state,verbose): ## home_state = initial_state.copy() # (initial state, None,0) parent_node = node(initial_state, None, 0) my_frontier = Frontier(parent_node) my_visited = Visited() if initial_state == goal_state: # we got return initial_state while my_frontier.is_empty() != True: if verbose >= 1: print("visited:",[t.state for t in my_visited.visited_list]) # while my frontier is not empty # Best First search top_node = my_frontier.top() my_frontier.remove(top_node) if top_node.state == goal_state: backtrack(my_frontier, my_visited, top_node, home_state) return top_node.state # not goal so move it to Visited state and expand it # check whether it is in visited or not if my_visited.isin(top_node.state): # so we already visited it continue my_visited.add(top_node) # expanded print("current_state:", top_node.state) if verbose >= 1: print("frontier:", [(t.state, t.parent, t.path_cost) for t in my_frontier.list_nodes]) print() all_possible_actions = actions(top_node.state) c = top_node.path_cost all_possible_nodes = [ node(st, top_node.state, c + 1) for st in all_possible_actions ] clean_nodes = [] for no in all_possible_nodes: if my_frontier.isbetter(no) and not my_visited.isin(no.state): clean_nodes.append(no) if my_frontier.isbetter(no): # it is better so replace my_frontier.remove(no) for no in clean_nodes: my_frontier.add(no) initial_state = top_node.state if __name__ == "__main__": """ In this problem we have consdered state as: array of lenght 6 where each position contains values as 2/1/0 2:- there is a rabbit and it can move only right 1:- there is a rabbit and it can move only left 0:- there is no rabbit initial state:- [2, 2, 2, 0, 1, 1, 1] goal state:- [1, 1, 1, 0, 2, 2, 2] Note:- set verbose 0 for min display set verbose 1 for max display """ initial_state = [1, 1, 1, 0, 2, 2, 2] goal_state = [2, 2, 2, 0, 1, 1, 1] verbose = 1 print("="*79) print("="*30, end="") print("Rabbit Leap",end="") print("="*35, end="\n\n") BestFirstSearch_Agent(initial_state, goal_state, verbose) print("="*36, end="") print("End",end="") print("="*40, end="\n\n")

File no 3: /Report.pdf
uninformed_search/Report.pdf at master · ar8372/uninformed_search · GitHub Skip to content Toggle navigation Sign up In this repository All GitHub ↵ Jump to ↵ No suggested jump to results In this repository All GitHub ↵ Jump to ↵ In this user All GitHub ↵ Jump to ↵ In this repository All GitHub ↵ Jump to ↵ Sign in Sign up You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session. You switched accounts on another tab or window. Reload to refresh your session. ar8372 / uninformed_search Public Notifications Fork 0 Star 0 Permalink master Switch branches/tags Branches Tags Name already in use A tag already exists with the provided branch name. Many Git commands accept both tag and branch names, so creating this branch may cause unexpected behavior. Are you sure you want to create this branch? uninformed_search/Report.pdf Go to file Go to file T Go to line L Copy path Copy permalink This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository. Cannot retrieve contributors at this time 166 KB Download Open with Desktop Download Delete file Sorry, something went wrong. Reload? Sorry, we cannot display this file. Sorry, this file is invalid so it cannot be displayed. Viewer requires iframe. Go You can’t perform that action at this time.

10: Project Name : Bit_Mesra_ML_Hackathon-2nd-place-Soln-
This project contains 2 main files, namely /Final_Report/StillLearning_final_report.pdf, /README.md
Below we will get details about each of these files one by one:
	
File no 1: /Final_Report/StillLearning_final_report.pdf
Bit_Mesra_ML_Hackathon-2nd-place-Soln-/Final_Report/StillLearning_final_report.pdf at main · ar8372/Bit_Mesra_ML_Hackathon-2nd-place-Soln- · GitHub Skip to content Toggle navigation Sign up In this repository All GitHub ↵ Jump to ↵ No suggested jump to results In this repository All GitHub ↵ Jump to ↵ In this user All GitHub ↵ Jump to ↵ In this repository All GitHub ↵ Jump to ↵ Sign in Sign up You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session. You switched accounts on another tab or window. Reload to refresh your session. ar8372 / Bit_Mesra_ML_Hackathon-2nd-place-Soln- Public Notifications Fork 1 Star 3 Permalink main Switch branches/tags Branches Tags Name already in use A tag already exists with the provided branch name. Many Git commands accept both tag and branch names, so creating this branch may cause unexpected behavior. Are you sure you want to create this branch? Bit_Mesra_ML_Hackathon-2nd-place-Soln-/Final_Report/StillLearning_final_report.pdf Go to file Go to file T Go to line L Copy path Copy permalink This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository. Cannot retrieve contributors at this time 1.01 MB Download Open with Desktop Download Delete file Sorry, something went wrong. Reload? Sorry, we cannot display this file. Sorry, this file is invalid so it cannot be displayed. Viewer requires iframe. Go You can’t perform that action at this time.

File no 2: /README.md
SDS BIT Mesra - ML Contest on Liver Disease Prediction(2nd Place Solution) Link of hackathon is :- https://dphi.tech/challenges/sds-bit-mesra-ml-contest-on-liver-disease-prediction/192/leaderboard/practice/ Team Name :- Still Learning This repository contain our solution(2nd place) to the Machine Learning Contest organized by BIT Mesra in which we have to create predictive models to predict the stage of liver Cirrhosis using 18 clinical features as Cirrhosis damages the liver from a variety of causes leading to scarring and liver failure. Motivation Behind The Problem Statement Hepatitis and chronic alcohol abuse are frequent causes of the disease. Liver damage caused by cirrhosis can't be undone, but further damage can be limited. Treatments focus on the underlying cause. In advanced cases, a liver transplant may be required. Predicting the stage of cirrhosis and beginning the treatment before it's too late can prevent the fatal consequences of the disease. The full solution is described in the final report :- https://github.com/Jatin-Goyal-552/Bit_Mesra_ML_Hackathon-2nd-place-Soln-/blob/main/Final_Report/StillLearning_final_report.pdf EDA of dataset can be found at :- https://www.kaggle.com/code/raj401/liver-disease-eda Code to generate folds of dataset is at :- https://www.kaggle.com/code/raj401/liverdisease-create-folds Final notebook to train model is at :- https://www.kaggle.com/code/raj401/liver-disease-complete-ensemble-2nd-place/notebook Go You can’t perform that action at this time.

11: Project Name : Framework1
This project contains 22 main files, namely /src/__init__.py, /src/bayesian_search.py, /src/categorical.py, /src/create_folds.py, /src/cross_validation.py, /src/dataset-metadata.json, /src/dataset.py, /src/dd.py, /src/dispatcher.py, /src/engine.py, /src/feature_generator.py, /src/grid_search.py, /src/hyperopt_search.py, /src/loss.py, /src/metrics.py, /src/optuna_search.py, /src/predict.py, /src/random_search.py, /src/test.py, /src/train.py, /src/utils.py, /run.sh
Below we will get details about each of these files one by one:
	
File no 1: /src/__init__.py


File no 2: /src/bayesian_search.py
import pandas as pd import numpy as np from sklearn import ensemble from sklearn import metrics from sklearn import decomposition from sklearn import preprocessing from sklearn import pipeline # for cross validation use cv from sklearn import model_selection from functools import partial from skopt import space, gp_minimize def optimize(params, param_names, x,y): # note here we can also define params which are not of mmodel but make sure you take them out.. # just like we did in NN model we had no_levels , no_units etc... # x is our features # y is target params = dict(zip(param_names, params)) model = ensemble.RandomForestClassifier(**params) kf = model_selection.StratifiedKFold(n_splits=5) accuracies = [] for i,(train_idx, test_idx) in enumerate(kf.split(X=x, y=y)): xtrain= x[train_idx] ytrain = y[train_idx] xtest = x[test_idx] ytest = y[test_idx] model.fit(xtrain, ytrain) preds = model.predict(xtest) fold_acc = metrics.accuracy_score(ytest, preds) accuracies.append(fold_acc) return -1.0 * np.mean(accuracies) # since minimize it (gp_mimimize) if __name__ == "__main__": df = pd.read_csv("../input/Mobile_train.csv") X = df.drop("price_range", axis=1).values Y = df.price_range.values param_space = [ space.Integer(3, 15, name="max_depth"), space.Integer(100,600, name="n_estimators"), space.Categorical(["gini", "entropy"], name="criterion"), space.Real(0.01, 1, prior="uniform", name="max_features") ] param_names = [ "max_depth", "n_estimators", "criterion", "max_features" ] optimization_function = partial( optimize, # takes list of params as argument param_names=param_names, x= X, y= Y ) result = gp_minimize( optimization_function, dimensions = param_space, n_calls = 15, n_random_starts = 10, verbose= 10 ) print( dict( zip(param_names, result.x) ) )

File no 3: /src/categorical.py
from sklearn import preprocessing """ - Label Encoding - One hot encoding - binarization """ class CategoricalFeatures: def __init__(self, df, categorical_features, encoding_type, handle_na = False): """ df: pandas dataframe categorical_features: list of column names, e.g. ["ord_1","nom_0"] encoding_type: label, binary, ohe handle_na: True/False """ self.df =df self.cat_feats = categorical_features self.enc_type = encoding_type self.label_encoders = dict() self.binary_encoders = dict() self.ohe = None self.handle_na = handle_na if self.handle_na: for c in self.cat_feats: self.df.loc[:,c] = self.df.loc[:, c].astype(str).fillna("-9999999") self.output_df = self.df.copy(deep=True) # creates deep copy def _label_encoding(self): for c in self.cat_feats: lbl = preprocessing.LabelEncoder() lbl.fit(self.df[c].values) self.output_df.loc[:, c] = lbl.transform(self.df[c].values) self.label_encoders[c] = lbl # to do some transformation later return self.output_df def _label_binarization(self): old_names = [] new_names = [] store_df = None for c in self.cat_feats: lbl = preprocessing.LabelBinarizer() lbl.fit(self.df[c].values) val = lbl.transform(self.df[c].values) # array old_names.append(c) new_names+= [c+ f"__bin_{j}" for j in range(val.shape[1])] if store_df is None: store_df = pd.DataFrame(val) else: store_df = pd.concat([store_df, pd.DataFrame(val)], axis=1) self.binary_encoders[c] = lbl self.output_df = self.output_df.drop(old_names, axis=1) temp_col = self.output_df.columns.tolist() self.output_df= pd.concat([self.output_df, store_df],axis=1) self.output_df.columns = temp_col+ new_names return self.output_df def _one_hot(self): # all columns at once ohe = preprocessing.OneHotEncoder() ohe.fit(self.df[self.cat_feats].values) self.ohe = ohe # sanity check --\ transform in same order as fit return ohe.transform(self.df[self.cat_feats].values) def fit_transform(self): if self.enc_type == "label": return self._label_encoding() elif self.enc_type == "binary": return self._label_binarization() elif self.enc_type == "ohe": return self._one_hot() else: raise Exception("Encoding type not understood") def transform(self, dataframe): if self.handle_na: for c in self.cat_feats: dataframe.loc[:,c] = dataframe.loc[:, c].astype(str).fillna("-999999") if self.enc_type == "label": old_names = [] new_names = [] store_df = [] for c,lbl in self.label_encoders.items(): val = lbl.transform(dataframe[c].values) # array old_names.append(c) store_df.append(list(val)) dataframe[old_names] = pd.DataFrame(store_df).T return dataframe elif self.enc_type == "binary": old_names = [] new_names = [] store_df = None for c,lbl in self.binary_encoders.items(): val = lbl.transform(dataframe[c].values) # array old_names.append(c) new_names += [c+ f"__bin_{j}" for j in range(val.shape[1])] if store_df is None: store_df = pd.DataFrame(val) else: store_df = pd.concat([store_df, pd.DataFrame(val)], axis=1) dataframe = dataframe.drop(old_names, axis=1) temp_col = dataframe.columns.tolist() dataframe = pd.concat([dataframe, store_df], axis=1) dataframe.columns = temp_col + new_names return dataframe elif self.enc_type == "ohe": # No need since both train and test are converted to one hot together dataframe = self.ohe.transform(dataframe[self.cat_feats]) return dataframe else: raise Exception(f"Not valid encoding type: {self.env_type}") if __name__ == "__main__": """ # for LabelEncoding and BinaryEncoding few class of test may not be in train then it will cause error sol:- combine tran-test and fit it on label encoder #- to maintain train test separable # M1 df_test["isTrain"] = 0 df["isTrain"] = 1 full_data[full_data['isTrain'== 1]] #=> to extract # M2 train_idx = df["id"].values test_idx = df_test["id"].values full_data[full_data["id"].isin(train_idx)] #=> to extract # M3 train_len = df.shape[0] full_data_transformed[:train_len] df_test['target'] = -1 full_data = pd.concat([df, df_test]) """ import pandas as pd import numpy as np from sklearn import linear_model df = pd.read_csv("../input/train_cat2.csv")#.head(500) df_test =pd.read_csv("../input/test_cat2.csv")#.head(500) sample = pd.read_csv("../input/sample_cat2.csv") # M1 # df_test["isTrain"] = 0 # df["isTrain"] = 1 # M2 train_idx = df["id"].values test_idx = df_test["id"].values # M3 train_len = df.shape[0] df_test['target'] = -1 full_data = pd.concat([df, df_test]) cols = [c for c in df.columns if c not in ["id","target"]] print(cols) cat_feats = CategoricalFeatures(full_data, categorical_features= cols, encoding_type="ohe", handle_na=True) cat_feats = cat_feats.fit_transform() X = cat_feats[:train_len, :] X_test = cat_feats[train_len:, :] print(X.shape) print() print(X_test.shape) model = linear_model.LogisticRegression() model.fit(X, df["target"]) pred = model.predict_proba(X_test)[:,1] sample["target"] = pred sample.to_csv("../models/sub1_cat2.csv", index=False)

File no 4: /src/create_folds.py
import pandas as pd from sklearn import model_selection if __name__ == "__main__": df = pd.read_csv("input/train_cat2.csv") df['fold'] = -1 df = df.sample(frac=1).reset_index(drop=True) kf = model_selection.StratifiedKFold(n_splits=5, shuffle=True, random_state=23) for fold, (train_idx, val_idx) in enumerate(kf.split(X=df, y=df.target.values)): print(len(train_idx),len(val_idx)) df.loc[val_idx,"fold"] = fold df.to_csv("input/train_folds.csv", index=False)

File no 5: /src/cross_validation.py
import pandas as pd from sklearn import model_selection import matplotlib.pyplot as plt import seaborn as sns import argparse from collections import defaultdict, Counter import random import pandas as pd import tqdm """ --- binary classification --- multiclass classification --- multilabel classification --- single column regression --- multi column regression --- holdout """ class CrossValidation: def __init__( self, df, target_cols, shuffle, problem_type = "binary_classification", multilabel_delimiter=",", num_folds = 5, random_state=42, ): self.dataframe = df self.target_cols = target_cols self.num_targets = len(target_cols) self.shuffle = shuffle self.problem_type = problem_type self.multilabel_delimiter = multilabel_delimiter self.num_folds = num_folds self.random_state = random_state assert type(self.dataframe) is pd.DataFrame, "Not a dataframe" if self.shuffle == True: self.dataframe = self.dataframe.sample(frac=1).reset_index(drop=True) #frac=1 mean frac of item to be returned is all items self.dataframe['fold'] = -1 def split(self): problem_name = self.problem_type if problem_name in ("biniary_classification", "multiclass_classification"): if self.num_targets != 1: raise Exception("num_targets != 1") target = self.target_cols[0] unique_values = self.dataframe[target].nunique() # all classes if unique_values == 1: raise Exception("Only one unique value found") elif unique_values > 1: # use StratifiedKFold for both balanced and unbalanced targets skf = model_selection.StratifiedKFold(n_splits= self.num_folds,shuffle=False) # we shuffle separately for fold, (train_idx, val_idx) in enumerate(skf.split(X=self.dataframe, y= self.dataframe[target].values)): self.dataframe.loc[val_idx, 'fold'] = fold self.dataframe.fold = self.dataframe.fold.astype(int) # Display distribution> for i in range(self.num_folds): t = self.dataframe.loc[self.dataframe['fold']==i, target].value_counts() t = (t/t.sum()).tolist() print(f"For fold {i} class ratio is: ",end="") for j in range(unique_values): print(f"{t[j]},",end="") print() elif problem_name in ("single_col_regression", "multi_col_regression"): # since it is continuous value we can't stratify on target # M1 -> KFold # M2 -> split such that each fold has same distribution # M1 if self.num_targets != 1 and problem_name == "single_col_regression": raise Exception(f"{self.num_targets} != 1 for {problem_name}") if self.num_targets <2 and problem_name == "multi_col_regression": raise Exception(f"{self.num_targets} <2 for {problem_name}") kf = model_selection.KFold(n_splits=self.num_folds) for fold, (train_idx, val_idx) in enumerate(kf.split(X=self.dataframe)): self.dataframe.loc[val_idx,'fold'] = fold # Display distribution> target = self.target_cols[0] sns.kdeplot(data=self.dataframe, x=target,hue='fold',fill=True) plt.show() elif problem_name.startswith("holdout_"): # use for time series Note: don't shuffle data # when huge dataset in classification or regression like 10M so take 100,000 only holdout_percentage = int(self.problem_type.split("_")[1]) #picked the no num_holdout_samples = int(len(self.dataframe) * holdout_percentage / 100) # hold -->0 , use -->1 self.dataframe.loc[:len(self.dataframe) - num_holdout_samples, 'fold'] = 0 self.dataframe.loc[(len(self.dataframe) - num_holdout_samples) :, 'fold'] = 1 elif problem_name.startswith("multilabel_classification"): if problem_name == "multilabel_classification1": # M1 # Stratified KFold split based on number of classes present in a datapoint if self.num_targets != 1: raise Exception(f"{self.num_targets} != 1 for {problem_name}") targets = self.dataframe[self.target_cols[0]].apply(lambda x: len(str(x).split(self.multilabel_delimiter))) skf = model_selection.StratifiedKFold(n_splits= self.num_folds, shuffle=False) # we shuffle separately for fold, (train_idx, val_idx) in enumerate(skf.split(X=self.dataframe, y= targets)): self.dataframe.loc[val_idx, 'fold'] = fold self.dataframe.fold = self.dataframe.fold.astype(int) elif problem_name == "multilabel_classification2": # M2 :- https://github.com/lopuhin/kaggle-imet-2019/blob/master/imet/make_folds.py #The idea was to spread rare classes among folds first, and only then spread more #common classes, because rare classes are more affected by chance. df = self.dataframe n_folds = self.num_folds cls_counts = Counter(cls for classes in df['target'].str.split(self.multilabel_delimiter) for cls in classes) fold_cls_counts = defaultdict(int) print(cls_counts) folds = [-1] * len(df) tj = 0 for item in tqdm.tqdm(df.sample(frac=1, random_state=42).itertuples(), total=len(df)): # picking the rarest label in given row cls = min(item.target.split(self.multilabel_delimiter), key=lambda cls: cls_counts[cls]) print(cls, item.target.split(self.multilabel_delimiter),'this is rare') fold_counts = [(f, fold_cls_counts[f, cls]) for f in range(n_folds)] print(fold_counts,'this is fold count') min_count = min([count for _, count in fold_counts]) print(min_count) random.seed(item.Index) fold = random.choice([f for f, count in fold_counts if count == min_count]) folds[item.Index] = fold for cls in item.target.split(self.multilabel_delimiter): fold_cls_counts[fold, cls] += 1 if tj <15: tj += 1 else: break df['fold'] = folds self.dataframe = df else: # none raise Exception("Problem type not understood!") return self.dataframe if __name__ == "__main__": #- Binary and Multiclass classification problem # df = pd.read_csv("input/train_multiclass.csv") # target_cols = ['target'] # problem_type = 'multiclass_classification' # shuffle=True #- Single col Regression # df = pd.read_csv("../input/train_reg.csv") # target_cols = ['SalePrice'] # problem_type = 'single_col_regression' # shuffle=True #- Holdout # df = pd.read_csv("../input/train_reg.csv") # target_cols = ['SalePrice'] # problem_type = 'holdout_50' # shuffle=True #- multilabel M2 , multilabel M1 df = pd.read_csv("../input/train_multilabel.csv") for i,col in enumerate(df.columns[1:]): df[col] = df[col]*(i+1) df[df.columns[1:]]= df[df.columns[1:]].replace(0,"_") df['target'] = df[df.columns[1:]].apply(lambda x: "_".join(x.dropna().astype(str)), axis=1) df['target']= df['target'].apply(lambda x: x.replace("_"," ")) df['target']= df['target'].apply(lambda x: "_".join([str(i) for i in list(map(int, x.split())) ])) df = df[['id','target']] target_cols = ['target'] problem_type = 'multilabel_classification2' multilabel_delimiter = "_" shuffle=True cv = CrossValidation(df, shuffle=shuffle, target_cols=target_cols, problem_type=problem_type,multilabel_delimiter=multilabel_delimiter) df_split = cv.split() print(df_split.head()) print() print(df_split.fold.value_counts())

File no 6: /src/dataset-metadata.json
{ "title": "Framework1", "id": "raj401/Framework1", "licenses": [ { "name": "CC0-1.0" } ] }

File no 7: /src/dataset.py


File no 8: /src/dd.py
import matplotlib.pyplot as plt x = [1, 1] plt.plot(x) plt.show()

File no 9: /src/dispatcher.py
from sklearn import ensemble MODELS = { "rfc": ensemble.RandomForestClassifier(n_estimators=200,n_jobs=-1, verbose=2), "etc": ensemble.ExtraTreesClassifier(n_estimators=200, n_jobs=-1, verbose=2), }

File no 10: /src/engine.py


File no 11: /src/feature_generator.py


File no 12: /src/grid_search.py
import pandas as pd import numpy as np from sklearn import ensemble from sklearn import metrics from sklearn import decomposition from sklearn import preprocessing from sklearn import pipeline # for cross validation us cv from sklearn import model_selection if __name__ == "__main__": df = pd.read_csv("../input/Mobile_train.csv") X = df.drop("price_range", axis=1).values y = df.price_range.values scl = preprocessing.StandardScaler() pca = decomposition.PCA() rf = ensemble.RandomForestClassifier(n_jobs=-1) classifier = pipeline.Pipeline( [ ("scaling",scl), ("pca", pca), ("rf", rf) ] ) # pca__ : it is the key param_grid = { "pca__n_components": [5,6,7,8,9,10], "rf__n_estimators": [100, 200], "rf__max_depth": [1,3], "rf__criterion": ["gini", "entropy"], } #RandomizedSearchCV => n_iter = 10 model = model_selection.GridSearchCV(estimator=classifier, param_grid=param_grid, scoring="accuracy", verbose=10, n_jobs=1, cv=5, #by deafault 5 fold # if we have classification estimator then it will use stratified kfold for creating folds # for regression kfold ) model.fit(X,y) print(model.best_score_) print(model.best_estimator_.get_params())

File no 13: /src/hyperopt_search.py
import pandas as pd import numpy as np from sklearn import ensemble from sklearn import metrics from sklearn import decomposition from sklearn import preprocessing from sklearn import pipeline # for cross validation use cv from sklearn import model_selection from functools import partial from skopt import space, gp_minimize from hyperopt import hp, fmin, tpe, Trials from hyperopt.pyll.base import scope def optimize(params, x,y): # params is a dictionary # note here we can also define params which are not of mmodel but make sure you take them out.. # just like we did in NN model we had no_levels , no_units etc... # x is our features # y is target model = ensemble.RandomForestClassifier(**params) kf = model_selection.StratifiedKFold(n_splits=5) accuracies = [] for i,(train_idx, test_idx) in enumerate(kf.split(X=x, y=y)): xtrain= x[train_idx] ytrain = y[train_idx] xtest = x[test_idx] ytest = y[test_idx] model.fit(xtrain, ytrain) preds = model.predict(xtest) fold_acc = metrics.accuracy_score(ytest, preds) accuracies.append(fold_acc) return -1.0 * np.mean(accuracies) # since minimize it (gp_mimimize) if __name__ == "__main__": df = pd.read_csv("../input/Mobile_train.csv") X = df.drop("price_range", axis=1).values Y = df.price_range.values #space.Integer --> hp.quniform hp.choice('max_depth', np.arange(1, 13+1, dtype=int) #space.Categorical --> hp.choice #space.Real prior="uniform" --> hp.uniform # scope.int() to wrap it into int if giving float error param_space = { "max_depth": hp.quniform("max_depth", 3, 15, 1), "n_estimators": scope.int(hp.quniform("n_estimators", 100,600,1)), #hp.choice('n_estimators', np.arange(100,600, dtype=int)), "criterion": hp.choice("criterion", ["gini", "entropy"]), "max_features": hp.uniform("max_featurs",0.01, 1), } optimization_function = partial( optimize, x= X, y= Y ) trials = Trials() result = fmin( fn=optimization_function, algo=tpe.suggest, space=param_space, max_evals=15, trials=trials ) print(result)

File no 14: /src/loss.py


File no 15: /src/metrics.py
from sklearn import metrics as skmetrics import tensorflow as tf import numpy as np class RegressionMetrics: def __init__(self): self.metrics = { "mae": self._mae, "mse": self._mse, "rmse": self._rmse, "msle": self._msle, "rmsle": self._rmsle, "r2": self._r2, } def __call__(self, metric, y_true, y_pred): if metric not in self.metrics: raise Exception(f"{metrics}: Metric not implemented") if metric == "mae": return self._mae(y_true= y_true, y_pred=y_pred) if metric == "mse": return self._mse(y_true= y_true, y_pred=y_pred) if metric == "rmse": return self._rmse(y_true= y_true, y_pred=y_pred) if metric == "msle": return self._msle(y_true= y_true, y_pred=y_pred) if metric == "rmsle": return self._rmsle(y_true= y_true, y_pred=y_pred) if metric == "r2": return self._r2(y_true= y_true, y_pred=y_pred) @staticmethod def _mae( y_true, y_pred): return skmetrics.mean_absolute_error(y_true=y_true, y_pred = y_pred) @staticmethod def _mse( y_true, y_pred): return skmetrics.mean_squared_error(y_true=y_true, y_pred = y_pred) def _rmse(self, y_true, y_pred): return np.sqrt(self._mse(y_true, y_pred)) @staticmethod def _msle( y_true, y_pred): return skmetrics.mean_squared_log_error(y_true=y_true, y_pred = y_pred) def _rmsle( self,y_true, y_pred): return np.sqrt(self._msle(y_true, y_pred)) @staticmethod def _r2( y_true, y_pred): return skmetrics.r2_score(y_true=y_true, y_pred = y_pred) class ClassificationMetrics: def __init__(self): self.metrics = { "accuracy": self._accuracy, "f1": self._f1, "recall": self._recall, "precisison": self._precision, "auc": self._auc, "logloss": self._logloss, "auc_tf": self._auc_tf, } # it allows to use an instance of this class as a function # a= Class..ics() then a("auc",y_true,y_pred) def __call__(self, metric, y_true, y_pred, y_proba=None): if metric not in self.metrics: raise Exception(f"{metric}: Metric not implemented") if metric == "auc": if y_proba is None: raise Exception(f"y_proba can't be None for {metric}") return self._auc(y_true=y_true, y_pred = y_proba) if metric == "logloss": if y_proba is None: raise Exception(f"y_proba can't be None for {metric}") return self._auc(y_true=y_true, y_pred = y_proba) if metric == "auc_tf": if y_proba is None: raise Exception(f"y_proba can't be None for {metric}") return self._auc_tf(y_true= y_true, y_pred= y_proba) else: return self.metrics[metric](y_true=y_true, y_pred=y_pred) @staticmethod def _accuracy( y_true, y_pred): return skmetrics.accuracy_score(y_true=y_true, y_pred = y_pred) @staticmethod def _f1( y_true, y_pred): return skmetrics.f1_score(y_true=y_true, y_pred = y_pred) @staticmethod def _recall( y_true, y_pred): return skmetrics.recall_score(y_true=y_true, y_pred = y_pred) @staticmethod def _precision( y_true, y_pred): return skmetrics.precision_score(y_true=y_true, y_pred = y_pred) @staticmethod def _auc( y_true, y_pred): # auc expects probability so we need y_proba return skmetrics.roc_auc_score(y_true=y_true, y_score= y_pred) @staticmethod def _logloss(y_true, y_pred): return skmetrics.log_loss(y_true= y_true, y_pred= y_pred) @staticmethod def _auc_tf(y_true, y_pred): # should have cuda enabled def fallback_auc(y_true, y_pred): try: return metrics.roc_auc_score(y_true, y_pred) except: return 0.5 return tf.py_function(fallback_auc, (y_true, y_pred), tf.double)

File no 16: /src/optuna_search.py
import pandas as pd import numpy as np from sklearn import ensemble from sklearn import metrics from sklearn import decomposition from sklearn import preprocessing from sklearn import pipeline # for cross validation use cv from sklearn import model_selection from functools import partial from skopt import space, gp_minimize from hyperopt import hp, fmin, tpe, Trials from hyperopt.pyll.base import scope import optuna def optimize(trial, x,y): criterion= trial.suggest_categorical("criterion", ['gini','entropy']) n_estimators = trial.suggest_int("n_estimators",100,1500) max_depth= trial.suggest_int("max_depht", 3,15) max_features = trial.suggest_uniform("max_features", 0.01,1.0) model = ensemble.RandomForestClassifier( n_estimators= n_estimators, max_depth=max_depth, max_features=max_features, criterion=criterion ) kf = model_selection.StratifiedKFold(n_splits=5) accuracies = [] for i,(train_idx, test_idx) in enumerate(kf.split(X=x, y=y)): xtrain= x[train_idx] ytrain = y[train_idx] xtest = x[test_idx] ytest = y[test_idx] model.fit(xtrain, ytrain) preds = model.predict(xtest) fold_acc = metrics.accuracy_score(ytest, preds) accuracies.append(fold_acc) return -1.0 * np.mean(accuracies) # since minimize it (gp_mimimize) if __name__ == "__main__": df = pd.read_csv("../input/Mobile_train.csv") X = df.drop("price_range", axis=1).values Y = df.price_range.values optimization_function = partial(optimize,x=X, y=Y) study = optuna.create_study(direction="minimize") study.optimize(optimization_function, n_trials=15)

File no 17: /src/predict.py
import os import pandas as pd import numpy as np from sklearn import ensemble from sklearn import preprocessing from sklearn import metrics import joblib from . import dispatcher # get as env variable # We remove it for making inference kernel # TEST_DATA = os.environ.get("TEST_DATA") #changed to test_data_path # MODEL = os.environ.get("MODEL") # changed to model_type def predict(test_data_path, model_type, model_path): # Fold 0 is validation fold here df_test = pd.read_csv(test_data_path) #- test test_idx = df_test.id.values predictions = None for FOLD in range(5): df = df_test.copy() #- to prevent changing original test set encoders = joblib.load(os.path.join(model_path,f"{model_type}_{FOLD}_label_encoder.pkl")) cols = joblib.load(os.path.join(model_path,f"{model_type}_{FOLD}_columns.pkl")) for c in cols: # encode each column lbl = encoders[c] df.loc[:,c] = lbl.transform(df[c].values.tolist()) #- test # data is ready to train clf = joblib.load(os.path.join(model_path,f"{model_type}_{FOLD}.pkl")) df = df[cols] preds = clf.predict_proba(df)[:,1] if FOLD == 0: predictions = preds else: predictions += preds predictions /= 5 sub = pd.DataFrame(np.column_stack((test_idx, predictions)), columns=["id","target"]) return sub if __name__ == "__main__": test_data_path="input/test_cat2.csv" model_type="rfc" model_path = "models" submission = predict(test_data_path, model_type, model_path) submission.loc[:, "id"] = submission.loc[:, "id"].astype(int) submission.to_csv(f"models/{model_type}_sub.csv",index=False)

File no 18: /src/random_search.py
import pandas as pd import numpy as np from sklearn import ensemble from sklearn import metrics from sklearn import decomposition from sklearn import preprocessing from sklearn import pipeline # for cross validation use cv from sklearn import model_selection if __name__ == "__main__": df = pd.read_csv("../input/Mobile_train.csv") X = df.drop("price_range", axis=1).values y = df.price_range.values scl = preprocessing.StandardScaler() pca = decomposition.PCA() rf = ensemble.RandomForestClassifier(n_jobs=-1) classifier = pipeline.Pipeline( [ ("scaling",scl), ("pca", pca), ("rf", rf) ] ) # pca__ : it is the key param_grid = { "pca__n_components": np.arange(5,10), "rf__n_estimators": np.arange(100,1500,100), "rf__max_depth": np.arange(1,20), "rf__criterion": ["gini", "entropy"], } #RandomizedSearchCV => n_iter = 10 model = model_selection.RandomizedSearchCV(estimator=classifier, param_distributions=param_grid, n_iter= 10, scoring="accuracy", verbose=10, n_jobs=1, cv=5, #by deafault 5 fold # if we have classification estimator then it will use stratified kfold for creating folds # for regression kfold ) model.fit(X,y) print(model.best_score_) print(model.best_estimator_.get_params())

File no 19: /src/test.py
from collections import defaultdict, Counter fold_cls_counts = defaultdict(int) t= [(i,fold_cls_counts[i,8]) for i in range(5)] print(t) t= [(i,fold_cls_counts[i,7]) for i in range(5)] print(t) t= [(i,fold_cls_counts[i,9]) for i in range(5)] print(t)

File no 20: /src/train.py
import os import pandas as pd from sklearn import ensemble from sklearn import preprocessing from sklearn import metrics import joblib from . import dispatcher TRAINING_DATA = os.environ.get("TRAINING_DATA") TEST_DATA = os.environ.get("TEST_DATA") FOLD = int(os.environ.get("FOLD")) MODEL = os.environ.get("MODEL") FOLD_MAPPPING = { 0: [1, 2, 3, 4], 1: [0, 2, 3, 4], 2: [0, 1, 3, 4], 3: [0, 1, 2, 4], 4: [0, 1, 2, 3] } if __name__ == "__main__": # Fold 0 is validation fold here df = pd.read_csv(TRAINING_DATA) df_test = pd.read_csv(TEST_DATA) #- test train_df = df[df.fold.isin(FOLD_MAPPPING.get(FOLD))].reset_index(drop=True) valid_df = df[df.fold==FOLD].reset_index(drop=True) ytrain = train_df.target.values yvalid = valid_df.target.values train_df = train_df.drop(["id",'target','fold'], axis=1) valid_df = valid_df.drop(['id','target','fold'], axis=1) valid_df = valid_df[train_df.columns] label_encoder = {} for c in train_df.columns: # encode each column lbl = preprocessing.LabelEncoder() lbl.fit(train_df[c].values.tolist()+valid_df[c].values.tolist()+df_test[c].values.tolist()) #- test labels added train_df.loc[:, c] = lbl.transform(train_df[c].values.tolist()) valid_df.loc[:,c] = lbl.transform(valid_df[c].values.tolist()) label_encoder[c] = lbl # data is ready to train clf = dispatcher.MODELS[MODEL] clf.fit(train_df, ytrain) preds = clf.predict_proba(valid_df)[:,1] print(metrics.roc_auc_score(yvalid, preds)) #- store everything joblib.dump(label_encoder, f"models/{MODEL}_{FOLD}_label_encoder.pkl") # trained model joblib.dump(clf, f"models/{MODEL}_{FOLD}.pkl") # part of training data on which model is trained joblib.dump(train_df.columns, f"models/{MODEL}_{FOLD}_columns.pkl")

File no 21: /src/utils.py


File no 22: /run.sh
export TRAINING_DATA=input/train_folds.csv export TEST_DATA=input/test_cat2.csv export SAMPLE_DATA=input/sample_submission.csv export MODEL=$1 # Train each fold # FOLD=0 python -m src.train # FOLD=1 python -m src.train # FOLD=2 python -m src.train # FOLD=3 python -m src.train # FOLD=4 python -m src.train # Test prediction python -m src.predict # sh run.sh # bash run.sh # ksh run.sh # csh run.sh # zsh run.sh

12: Project Name : Working-With-Different-File-Formats-
This project contains 0 main files, namely 
Below we will get details about each of these files one by one:
	
13: Project Name : ML_algos_from_scratch
This project contains 1 main files, namely /README.md
Below we will get details about each of these files one by one:
	
File no 1: /README.md
ML_algos_from_scratch This repository contains Machine Learning algorithms implementation from scratch. Algorithm 1:- TF-IDF 2:- Rocchio Classifier 3:- Naive-bayes Classifier 4:- KNN Classifier 5:- K-Means Clustering 6:- HAC single link , complete link Go You can’t perform that action at this time.

14: Project Name : 3DText
This project contains 0 main files, namely 
Below we will get details about each of these files one by one:
	
15: Project Name : TPS-Oct-2021
This project contains 1 main files, namely /README.md
Below we will get details about each of these files one by one:
	
File no 1: /README.md
TPS-Oct-2021 Tabular Playground Series-Oct 2021 Go You can’t perform that action at this time.

16: Project Name : TPS
This project contains 1 main files, namely /README.md
Below we will get details about each of these files one by one:
	
File no 1: /README.md
TPS Tabular Playground Series Kaggle Competitions Go You can’t perform that action at this time.

17: Project Name : FIRST_AID
This project contains 14 main files, namely /FIRST AID PROJECT/APPS/Build/APPS.json, /FIRST AID PROJECT/APPS/Build/UnityLoader.js, /FIRST AID PROJECT/APPS/TemplateData/UnityProgress.js, /FIRST AID PROJECT/APPS/TemplateData/style.css, /FIRST AID PROJECT/APPS/index.html, /FIRST AID PROJECT/Assets/assets/fonts/need-for-font/license.txt, /FIRST AID PROJECT/Assets/assets/fonts/perfect-dark-brk/perfectdark.txt, /FIRST AID PROJECT/Assets/scipts/TABsCIPT.cs, /FIRST AID PROJECT/Assets/scipts/appManager.cs, /FIRST AID PROJECT/Assets/scipts/uiManager.cs, /FIRST AID PROJECT/Assets/Manager.cs, /FIRST AID PROJECT/Packages/manifest.json, /FIRST AID PROJECT/ProjectSettings/ProjectVersion.txt, /README.md
Below we will get details about each of these files one by one:
	
File no 1: /FIRST AID PROJECT/APPS/Build/APPS.json
{ "companyName": "DefaultCompany", "productName": "FIRST AID PROJECT", "productVersion": "0.1", "dataUrl": "APPS.data.unityweb", "wasmCodeUrl": "APPS.wasm.code.unityweb", "wasmFrameworkUrl": "APPS.wasm.framework.unityweb", "graphicsAPI": ["WebGL 2.0","WebGL 1.0"], "webglContextAttributes": {"preserveDrawingBuffer": false}, "splashScreenStyle": "Dark", "backgroundColor": "#231F20", "cacheControl": {"default": "must-revalidate"}, "developmentBuild": false, "multithreading": false, "unityVersion": "2019.3.9f1" }

File no 2: /FIRST AID PROJECT/APPS/Build/UnityLoader.js
var UnityLoader=UnityLoader||{Compression:{identity:{require:function(){return{}},decompress:function(e){return e}},gzip:{require:function(e){var t={"inflate.js":function(e,t,r){"use strict";function n(e){if(!(this instanceof n))return new n(e);this.options=s.assign({chunkSize:16384,windowBits:0,to:""},e||{});var t=this.options;t.raw&&t.windowBits>=0&&t.windowBits<16&&(t.windowBits=-t.windowBits,0===t.windowBits&&(t.windowBits=-15)),!(t.windowBits>=0&&t.windowBits<16)||e&&e.windowBits||(t.windowBits+=32),t.windowBits>15&&t.windowBits<48&&0===(15&t.windowBits)&&(t.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new c,this.strm.avail_out=0;var r=a.inflateInit2(this.strm,t.windowBits);if(r!==l.Z_OK)throw new Error(u[r]);this.header=new f,a.inflateGetHeader(this.strm,this.header)}function o(e,t){var r=new n(t);if(r.push(e,!0),r.err)throw r.msg||u[r.err];return r.result}function i(e,t){return t=t||{},t.raw=!0,o(e,t)}var a=e("./zlib/inflate"),s=e("./utils/common"),d=e("./utils/strings"),l=e("./zlib/constants"),u=e("./zlib/messages"),c=e("./zlib/zstream"),f=e("./zlib/gzheader"),h=Object.prototype.toString;n.prototype.push=function(e,t){var r,n,o,i,u,c,f=this.strm,p=this.options.chunkSize,m=this.options.dictionary,w=!1;if(this.ended)return!1;n=t===~~t?t:t===!0?l.Z_FINISH:l.Z_NO_FLUSH,"string"==typeof e?f.input=d.binstring2buf(e):"[object ArrayBuffer]"===h.call(e)?f.input=new Uint8Array(e):f.input=e,f.next_in=0,f.avail_in=f.input.length;do{if(0===f.avail_out&&(f.output=new s.Buf8(p),f.next_out=0,f.avail_out=p),r=a.inflate(f,l.Z_NO_FLUSH),r===l.Z_NEED_DICT&&m&&(c="string"==typeof m?d.string2buf(m):"[object ArrayBuffer]"===h.call(m)?new Uint8Array(m):m,r=a.inflateSetDictionary(this.strm,c)),r===l.Z_BUF_ERROR&&w===!0&&(r=l.Z_OK,w=!1),r!==l.Z_STREAM_END&&r!==l.Z_OK)return this.onEnd(r),this.ended=!0,!1;f.next_out&&(0!==f.avail_out&&r!==l.Z_STREAM_END&&(0!==f.avail_in||n!==l.Z_FINISH&&n!==l.Z_SYNC_FLUSH)||("string"===this.options.to?(o=d.utf8border(f.output,f.next_out),i=f.next_out-o,u=d.buf2string(f.output,o),f.next_out=i,f.avail_out=p-i,i&&s.arraySet(f.output,f.output,o,i,0),this.onData(u)):this.onData(s.shrinkBuf(f.output,f.next_out)))),0===f.avail_in&&0===f.avail_out&&(w=!0)}while((f.avail_in>0||0===f.avail_out)&&r!==l.Z_STREAM_END);return r===l.Z_STREAM_END&&(n=l.Z_FINISH),n===l.Z_FINISH?(r=a.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===l.Z_OK):n!==l.Z_SYNC_FLUSH||(this.onEnd(l.Z_OK),f.avail_out=0,!0)},n.prototype.onData=function(e){this.chunks.push(e)},n.prototype.onEnd=function(e){e===l.Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=s.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg},r.Inflate=n,r.inflate=o,r.inflateRaw=i,r.ungzip=o},"utils/common.js":function(e,t,r){"use strict";var n="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;r.assign=function(e){for(var t=Array.prototype.slice.call(arguments,1);t.length;){var r=t.shift();if(r){if("object"!=typeof r)throw new TypeError(r+"must be non-object");for(var n in r)r.hasOwnProperty(n)&&(e[n]=r[n])}}return e},r.shrinkBuf=function(e,t){return e.length===t?e:e.subarray?e.subarray(0,t):(e.length=t,e)};var o={arraySet:function(e,t,r,n,o){if(t.subarray&&e.subarray)return void e.set(t.subarray(r,r+n),o);for(var i=0;i<n;i++)e[o+i]=t[r+i]},flattenChunks:function(e){var t,r,n,o,i,a;for(n=0,t=0,r=e.length;t<r;t++)n+=e[t].length;for(a=new Uint8Array(n),o=0,t=0,r=e.length;t<r;t++)i=e[t],a.set(i,o),o+=i.length;return a}},i={arraySet:function(e,t,r,n,o){for(var i=0;i<n;i++)e[o+i]=t[r+i]},flattenChunks:function(e){return[].concat.apply([],e)}};r.setTyped=function(e){e?(r.Buf8=Uint8Array,r.Buf16=Uint16Array,r.Buf32=Int32Array,r.assign(r,o)):(r.Buf8=Array,r.Buf16=Array,r.Buf32=Array,r.assign(r,i))},r.setTyped(n)},"utils/strings.js":function(e,t,r){"use strict";function n(e,t){if(t<65537&&(e.subarray&&a||!e.subarray&&i))return String.fromCharCode.apply(null,o.shrinkBuf(e,t));for(var r="",n=0;n<t;n++)r+=String.fromCharCode(e[n]);return r}var o=e("./common"),i=!0,a=!0;try{String.fromCharCode.apply(null,[0])}catch(e){i=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(e){a=!1}for(var s=new o.Buf8(256),d=0;d<256;d++)s[d]=d>=252?6:d>=248?5:d>=240?4:d>=224?3:d>=192?2:1;s[254]=s[254]=1,r.string2buf=function(e){var t,r,n,i,a,s=e.length,d=0;for(i=0;i<s;i++)r=e.charCodeAt(i),55296===(64512&r)&&i+1<s&&(n=e.charCodeAt(i+1),56320===(64512&n)&&(r=65536+(r-55296<<10)+(n-56320),i++)),d+=r<128?1:r<2048?2:r<65536?3:4;for(t=new o.Buf8(d),a=0,i=0;a<d;i++)r=e.charCodeAt(i),55296===(64512&r)&&i+1<s&&(n=e.charCodeAt(i+1),56320===(64512&n)&&(r=65536+(r-55296<<10)+(n-56320),i++)),r<128?t[a++]=r:r<2048?(t[a++]=192|r>>>6,t[a++]=128|63&r):r<65536?(t[a++]=224|r>>>12,t[a++]=128|r>>>6&63,t[a++]=128|63&r):(t[a++]=240|r>>>18,t[a++]=128|r>>>12&63,t[a++]=128|r>>>6&63,t[a++]=128|63&r);return t},r.buf2binstring=function(e){return n(e,e.length)},r.binstring2buf=function(e){for(var t=new o.Buf8(e.length),r=0,n=t.length;r<n;r++)t[r]=e.charCodeAt(r);return t},r.buf2string=function(e,t){var r,o,i,a,d=t||e.length,l=new Array(2*d);for(o=0,r=0;r<d;)if(i=e[r++],i<128)l[o++]=i;else if(a=s[i],a>4)l[o++]=65533,r+=a-1;else{for(i&=2===a?31:3===a?15:7;a>1&&r<d;)i=i<<6|63&e[r++],a--;a>1?l[o++]=65533:i<65536?l[o++]=i:(i-=65536,l[o++]=55296|i>>10&1023,l[o++]=56320|1023&i)}return n(l,o)},r.utf8border=function(e,t){var r;for(t=t||e.length,t>e.length&&(t=e.length),r=t-1;r>=0&&128===(192&e[r]);)r--;return r<0?t:0===r?t:r+s[e[r]]>t?r:t}},"zlib/inflate.js":function(e,t,r){"use strict";function n(e){return(e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24)}function o(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new y.Buf16(320),this.work=new y.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function i(e){var t;return e&&e.state?(t=e.state,e.total_in=e.total_out=t.total=0,e.msg="",t.wrap&&(e.adler=1&t.wrap),t.mode=P,t.last=0,t.havedict=0,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new y.Buf32(me),t.distcode=t.distdyn=new y.Buf32(we),t.sane=1,t.back=-1,M):R}function a(e){var t;return e&&e.state?(t=e.state,t.wsize=0,t.whave=0,t.wnext=0,i(e)):R}function s(e,t){var r,n;return e&&e.state?(n=e.state,t<0?(r=0,t=-t):(r=(t>>4)+1,t<48&&(t&=15)),t&&(t<8||t>15)?R:(null!==n.window&&n.wbits!==t&&(n.window=null),n.wrap=r,n.wbits=t,a(e))):R}function d(e,t){var r,n;return e?(n=new o,e.state=n,n.window=null,r=s(e,t),r!==M&&(e.state=null),r):R}function l(e){return d(e,ye)}function u(e){if(ge){var t;for(w=new y.Buf32(512),b=new y.Buf32(32),t=0;t<144;)e.lens[t++]=8;for(;t<256;)e.lens[t++]=9;for(;t<280;)e.lens[t++]=7;for(;t<288;)e.lens[t++]=8;for(U(E,e.lens,0,288,w,0,e.work,{bits:9}),t=0;t<32;)e.lens[t++]=5;U(k,e.lens,0,32,b,0,e.work,{bits:5}),ge=!1}e.lencode=w,e.lenbits=9,e.distcode=b,e.distbits=5}function c(e,t,r,n){var o,i=e.state;return null===i.window&&(i.wsize=1<<i.wbits,i.wnext=0,i.whave=0,i.window=new y.Buf8(i.wsize)),n>=i.wsize?(y.arraySet(i.window,t,r-i.wsize,i.wsize,0),i.wnext=0,i.whave=i.wsize):(o=i.wsize-i.wnext,o>n&&(o=n),y.arraySet(i.window,t,r-n,o,i.wnext),n-=o,n?(y.arraySet(i.window,t,r-n,n,0),i.wnext=n,i.whave=i.wsize):(i.wnext+=o,i.wnext===i.wsize&&(i.wnext=0),i.whave<i.wsize&&(i.whave+=o))),0}function f(e,t){var r,o,i,a,s,d,l,f,h,p,m,w,b,me,we,be,ye,ge,ve,Ae,Ue,xe,Ee,ke,Be=0,Le=new y.Buf8(4),We=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!e||!e.state||!e.output||!e.input&&0!==e.avail_in)return R;r=e.state,r.mode===j&&(r.mode=X),s=e.next_out,i=e.output,l=e.avail_out,a=e.next_in,o=e.input,d=e.avail_in,f=r.hold,h=r.bits,p=d,m=l,xe=M;e:for(;;)switch(r.mode){case P:if(0===r.wrap){r.mode=X;break}for(;h<16;){if(0===d)break e;d--,f+=o[a++]<<h,h+=8}if(2&r.wrap&&35615===f){r.check=0,Le[0]=255&f,Le[1]=f>>>8&255,r.check=v(r.check,Le,2,0),f=0,h=0,r.mode=T;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&f)<<8)+(f>>8))%31){e.msg="incorrect header check",r.mode=fe;break}if((15&f)!==S){e.msg="unknown compression method",r.mode=fe;break}if(f>>>=4,h-=4,Ue=(15&f)+8,0===r.wbits)r.wbits=Ue;else if(Ue>r.wbits){e.msg="invalid window size",r.mode=fe;break}r.dmax=1<<Ue,e.adler=r.check=1,r.mode=512&f?G:j,f=0,h=0;break;case T:for(;h<16;){if(0===d)break e;d--,f+=o[a++]<<h,h+=8}if(r.flags=f,(255&r.flags)!==S){e.msg="unknown compression method",r.mode=fe;break}if(57344&r.flags){e.msg="unknown header flags set",r.mode=fe;break}r.head&&(r.head.text=f>>8&1),512&r.flags&&(Le[0]=255&f,Le[1]=f>>>8&255,r.check=v(r.check,Le,2,0)),f=0,h=0,r.mode=D;case D:for(;h<32;){if(0===d)break e;d--,f+=o[a++]<<h,h+=8}r.head&&(r.head.time=f),512&r.flags&&(Le[0]=255&f,Le[1]=f>>>8&255,Le[2]=f>>>16&255,Le[3]=f>>>24&255,r.check=v(r.check,Le,4,0)),f=0,h=0,r.mode=F;case F:for(;h<16;){if(0===d)break e;d--,f+=o[a++]<<h,h+=8}r.head&&(r.head.xflags=255&f,r.head.os=f>>8),512&r.flags&&(Le[0]=255&f,Le[1]=f>>>8&255,r.check=v(r.check,Le,2,0)),f=0,h=0,r.mode=z;case z:if(1024&r.flags){for(;h<16;){if(0===d)break e;d--,f+=o[a++]<<h,h+=8}r.length=f,r.head&&(r.head.extra_len=f),512&r.flags&&(Le[0]=255&f,Le[1]=f>>>8&255,r.check=v(r.check,Le,2,0)),f=0,h=0}else r.head&&(r.head.extra=null);r.mode=V;case V:if(1024&r.flags&&(w=r.length,w>d&&(w=d),w&&(r.head&&(Ue=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Array(r.head.extra_len)),y.arraySet(r.head.extra,o,a,w,Ue)),512&r.flags&&(r.check=v(r.check,o,w,a)),d-=w,a+=w,r.length-=w),r.length))break e;r.length=0,r.mode=q;case q:if(2048&r.flags){if(0===d)break e;w=0;do Ue=o[a+w++],r.head&&Ue&&r.length<65536&&(r.head.name+=String.fromCharCode(Ue));while(Ue&&w<d);if(512&r.flags&&(r.check=v(r.check,o,w,a)),d-=w,a+=w,Ue)break e}else r.head&&(r.head.name=null);r.length=0,r.mode=Z;case Z:if(4096&r.flags){if(0===d)break e;w=0;do Ue=o[a+w++],r.head&&Ue&&r.length<65536&&(r.head.comment+=String.fromCharCode(Ue));while(Ue&&w<d);if(512&r.flags&&(r.check=v(r.check,o,w,a)),d-=w,a+=w,Ue)break e}else r.head&&(r.head.comment=null);r.mode=Y;case Y:if(512&r.flags){for(;h<16;){if(0===d)break e;d--,f+=o[a++]<<h,h+=8}if(f!==(65535&r.check)){e.msg="header crc mismatch",r.mode=fe;break}f=0,h=0}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),e.adler=r.check=0,r.mode=j;break;case G:for(;h<32;){if(0===d)break e;d--,f+=o[a++]<<h,h+=8}e.adler=r.check=n(f),f=0,h=0,r.mode=J;case J:if(0===r.havedict)return e.next_out=s,e.avail_out=l,e.next_in=a,e.avail_in=d,r.hold=f,r.bits=h,N;e.adler=r.check=1,r.mode=j;case j:if(t===L||t===W)break e;case X:if(r.last){f>>>=7&h,h-=7&h,r.mode=le;break}for(;h<3;){if(0===d)break e;d--,f+=o[a++]<<h,h+=8}switch(r.last=1&f,f>>>=1,h-=1,3&f){case 0:r.mode=K;break;case 1:if(u(r),r.mode=re,t===W){f>>>=2,h-=2;break e}break;case 2:r.mode=$;break;case 3:e.msg="invalid block type",r.mode=fe}f>>>=2,h-=2;break;case K:for(f>>>=7&h,h-=7&h;h<32;){if(0===d)break e;d--,f+=o[a++]<<h,h+=8}if((65535&f)!==(f>>>16^65535)){e.msg="invalid stored block lengths",r.mode=fe;break}if(r.length=65535&f,f=0,h=0,r.mode=Q,t===W)break e;case Q:r.mode=_;case _:if(w=r.length){if(w>d&&(w=d),w>l&&(w=l),0===w)break e;y.arraySet(i,o,a,w,s),d-=w,a+=w,l-=w,s+=w,r.length-=w;break}r.mode=j;break;case $:for(;h<14;){if(0===d)break e;d--,f+=o[a++]<<h,h+=8}if(r.nlen=(31&f)+257,f>>>=5,h-=5,r.ndist=(31&f)+1,f>>>=5,h-=5,r.ncode=(15&f)+4,f>>>=4,h-=4,r.nlen>286||r.ndist>30){e.msg="too many length or distance symbols",r.mode=fe;break}r.have=0,r.mode=ee;case ee:for(;r.have<r.ncode;){for(;h<3;){if(0===d)break e;d--,f+=o[a++]<<h,h+=8}r.lens[We[r.have++]]=7&f,f>>>=3,h-=3}for(;r.have<19;)r.lens[We[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,Ee={bits:r.lenbits},xe=U(x,r.lens,0,19,r.lencode,0,r.work,Ee),r.lenbits=Ee.bits,xe){e.msg="invalid code lengths set",r.mode=fe;break}r.have=0,r.mode=te;case te:for(;r.have<r.nlen+r.ndist;){for(;Be=r.lencode[f&(1<<r.lenbits)-1],we=Be>>>24,be=Be>>>16&255,ye=65535&Be,!(we<=h);){if(0===d)break e;d--,f+=o[a++]<<h,h+=8}if(ye<16)f>>>=we,h-=we,r.lens[r.have++]=ye;else{if(16===ye){for(ke=we+2;h<ke;){if(0===d)break e;d--,f+=o[a++]<<h,h+=8}if(f>>>=we,h-=we,0===r.have){e.msg="invalid bit length repeat",r.mode=fe;break}Ue=r.lens[r.have-1],w=3+(3&f),f>>>=2,h-=2}else if(17===ye){for(ke=we+3;h<ke;){if(0===d)break e;d--,f+=o[a++]<<h,h+=8}f>>>=we,h-=we,Ue=0,w=3+(7&f),f>>>=3,h-=3}else{for(ke=we+7;h<ke;){if(0===d)break e;d--,f+=o[a++]<<h,h+=8}f>>>=we,h-=we,Ue=0,w=11+(127&f),f>>>=7,h-=7}if(r.have+w>r.nlen+r.ndist){e.msg="invalid bit length repeat",r.mode=fe;break}for(;w--;)r.lens[r.have++]=Ue}}if(r.mode===fe)break;if(0===r.lens[256]){e.msg="invalid code -- missing end-of-block",r.mode=fe;break}if(r.lenbits=9,Ee={bits:r.lenbits},xe=U(E,r.lens,0,r.nlen,r.lencode,0,r.work,Ee),r.lenbits=Ee.bits,xe){e.msg="invalid literal/lengths set",r.mode=fe;break}if(r.distbits=6,r.distcode=r.distdyn,Ee={bits:r.distbits},xe=U(k,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,Ee),r.distbits=Ee.bits,xe){e.msg="invalid distances set",r.mode=fe;break}if(r.mode=re,t===W)break e;case re:r.mode=ne;case ne:if(d>=6&&l>=258){e.next_out=s,e.avail_out=l,e.next_in=a,e.avail_in=d,r.hold=f,r.bits=h,A(e,m),s=e.next_out,i=e.output,l=e.avail_out,a=e.next_in,o=e.input,d=e.avail_in,f=r.hold,h=r.bits,r.mode===j&&(r.back=-1);break}for(r.back=0;Be=r.lencode[f&(1<<r.lenbits)-1],we=Be>>>24,be=Be>>>16&255,ye=65535&Be,!(we<=h);){if(0===d)break e;d--,f+=o[a++]<<h,h+=8}if(be&&0===(240&be)){for(ge=we,ve=be,Ae=ye;Be=r.lencode[Ae+((f&(1<<ge+ve)-1)>>ge)],we=Be>>>24,be=Be>>>16&255,ye=65535&Be,!(ge+we<=h);){if(0===d)break e;d--,f+=o[a++]<<h,h+=8}f>>>=ge,h-=ge,r.back+=ge}if(f>>>=we,h-=we,r.back+=we,r.length=ye,0===be){r.mode=de;break}if(32&be){r.back=-1,r.mode=j;break}if(64&be){e.msg="invalid literal/length code",r.mode=fe;break}r.extra=15&be,r.mode=oe;case oe:if(r.extra){for(ke=r.extra;h<ke;){if(0===d)break e;d--,f+=o[a++]<<h,h+=8}r.length+=f&(1<<r.extra)-1,f>>>=r.extra,h-=r.extra,r.back+=r.extra}r.was=r.length,r.mode=ie;case ie:for(;Be=r.distcode[f&(1<<r.distbits)-1],we=Be>>>24,be=Be>>>16&255,ye=65535&Be,!(we<=h);){if(0===d)break e;d--,f+=o[a++]<<h,h+=8}if(0===(240&be)){for(ge=we,ve=be,Ae=ye;Be=r.distcode[Ae+((f&(1<<ge+ve)-1)>>ge)],we=Be>>>24,be=Be>>>16&255,ye=65535&Be,!(ge+we<=h);){if(0===d)break e;d--,f+=o[a++]<<h,h+=8}f>>>=ge,h-=ge,r.back+=ge}if(f>>>=we,h-=we,r.back+=we,64&be){e.msg="invalid distance code",r.mode=fe;break}r.offset=ye,r.extra=15&be,r.mode=ae;case ae:if(r.extra){for(ke=r.extra;h<ke;){if(0===d)break e;d--,f+=o[a++]<<h,h+=8}r.offset+=f&(1<<r.extra)-1,f>>>=r.extra,h-=r.extra,r.back+=r.extra}if(r.offset>r.dmax){e.msg="invalid distance too far back",r.mode=fe;break}r.mode=se;case se:if(0===l)break e;if(w=m-l,r.offset>w){if(w=r.offset-w,w>r.whave&&r.sane){e.msg="invalid distance too far back",r.mode=fe;break}w>r.wnext?(w-=r.wnext,b=r.wsize-w):b=r.wnext-w,w>r.length&&(w=r.length),me=r.window}else me=i,b=s-r.offset,w=r.length;w>l&&(w=l),l-=w,r.length-=w;do i[s++]=me[b++];while(--w);0===r.length&&(r.mode=ne);break;case de:if(0===l)break e;i[s++]=r.length,l--,r.mode=ne;break;case le:if(r.wrap){for(;h<32;){if(0===d)break e;d--,f|=o[a++]<<h,h+=8}if(m-=l,e.total_out+=m,r.total+=m,m&&(e.adler=r.check=r.flags?v(r.check,i,m,s-m):g(r.check,i,m,s-m)),m=l,(r.flags?f:n(f))!==r.check){e.msg="incorrect data check",r.mode=fe;break}f=0,h=0}r.mode=ue;case ue:if(r.wrap&&r.flags){for(;h<32;){if(0===d)break e;d--,f+=o[a++]<<h,h+=8}if(f!==(4294967295&r.total)){e.msg="incorrect length check",r.mode=fe;break}f=0,h=0}r.mode=ce;case ce:xe=O;break e;case fe:xe=C;break e;case he:return I;case pe:default:return R}return e.next_out=s,e.avail_out=l,e.next_in=a,e.avail_in=d,r.hold=f,r.bits=h,(r.wsize||m!==e.avail_out&&r.mode<fe&&(r.mode<le||t!==B))&&c(e,e.output,e.next_out,m-e.avail_out)?(r.mode=he,I):(p-=e.avail_in,m-=e.avail_out,e.total_in+=p,e.total_out+=m,r.total+=m,r.wrap&&m&&(e.adler=r.check=r.flags?v(r.check,i,m,e.next_out-m):g(r.check,i,m,e.next_out-m)),e.data_type=r.bits+(r.last?64:0)+(r.mode===j?128:0)+(r.mode===re||r.mode===Q?256:0),(0===p&&0===m||t===B)&&xe===M&&(xe=H),xe)}function h(e){if(!e||!e.state)return R;var t=e.state;return t.window&&(t.window=null),e.state=null,M}function p(e,t){var r;return e&&e.state?(r=e.state,0===(2&r.wrap)?R:(r.head=t,t.done=!1,M)):R}function m(e,t){var r,n,o,i=t.length;return e&&e.state?(r=e.state,0!==r.wrap&&r.mode!==J?R:r.mode===J&&(n=1,n=g(n,t,i,0),n!==r.check)?C:(o=c(e,t,i,i))?(r.mode=he,I):(r.havedict=1,M)):R}var w,b,y=e("../utils/common"),g=e("./adler32"),v=e("./crc32"),A=e("./inffast"),U=e("./inftrees"),x=0,E=1,k=2,B=4,L=5,W=6,M=0,O=1,N=2,R=-2,C=-3,I=-4,H=-5,S=8,P=1,T=2,D=3,F=4,z=5,V=6,q=7,Z=8,Y=9,G=10,J=11,j=12,X=13,K=14,Q=15,_=16,$=17,ee=18,te=19,re=20,ne=21,oe=22,ie=23,ae=24,se=25,de=26,le=27,ue=28,ce=29,fe=30,he=31,pe=32,me=852,we=592,be=15,ye=be,ge=!0;r.inflateReset=a,r.inflateReset2=s,r.inflateResetKeep=i,r.inflateInit=l,r.inflateInit2=d,r.inflate=f,r.inflateEnd=h,r.inflateGetHeader=p,r.inflateSetDictionary=m,r.inflateInfo="pako inflate (from Nodeca project)"},"zlib/constants.js":function(e,t,r){"use strict";t.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},"zlib/messages.js":function(e,t,r){"use strict";t.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},"zlib/zstream.js":function(e,t,r){"use strict";function n(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}t.exports=n},"zlib/gzheader.js":function(e,t,r){"use strict";function n(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}t.exports=n},"zlib/adler32.js":function(e,t,r){"use strict";function n(e,t,r,n){for(var o=65535&e|0,i=e>>>16&65535|0,a=0;0!==r;){a=r>2e3?2e3:r,r-=a;do o=o+t[n++]|0,i=i+o|0;while(--a);o%=65521,i%=65521}return o|i<<16|0}t.exports=n},"zlib/crc32.js":function(e,t,r){"use strict";function n(){for(var e,t=[],r=0;r<256;r++){e=r;for(var n=0;n<8;n++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e}return t}function o(e,t,r,n){var o=i,a=n+r;e^=-1;for(var s=n;s<a;s++)e=e>>>8^o[255&(e^t[s])];return e^-1}var i=n();t.exports=o},"zlib/inffast.js":function(e,t,r){"use strict";var n=30,o=12;t.exports=function(e,t){var r,i,a,s,d,l,u,c,f,h,p,m,w,b,y,g,v,A,U,x,E,k,B,L,W;r=e.state,i=e.next_in,L=e.input,a=i+(e.avail_in-5),s=e.next_out,W=e.output,d=s-(t-e.avail_out),l=s+(e.avail_out-257),u=r.dmax,c=r.wsize,f=r.whave,h=r.wnext,p=r.window,m=r.hold,w=r.bits,b=r.lencode,y=r.distcode,g=(1<<r.lenbits)-1,v=(1<<r.distbits)-1;e:do{w<15&&(m+=L[i++]<<w,w+=8,m+=L[i++]<<w,w+=8),A=b[m&g];t:for(;;){if(U=A>>>24,m>>>=U,w-=U,U=A>>>16&255,0===U)W[s++]=65535&A;else{if(!(16&U)){if(0===(64&U)){A=b[(65535&A)+(m&(1<<U)-1)];continue t}if(32&U){r.mode=o;break e}e.msg="invalid literal/length code",r.mode=n;break e}x=65535&A,U&=15,U&&(w<U&&(m+=L[i++]<<w,w+=8),x+=m&(1<<U)-1,m>>>=U,w-=U),w<15&&(m+=L[i++]<<w,w+=8,m+=L[i++]<<w,w+=8),A=y[m&v];r:for(;;){if(U=A>>>24,m>>>=U,w-=U,U=A>>>16&255,!(16&U)){if(0===(64&U)){A=y[(65535&A)+(m&(1<<U)-1)];continue r}e.msg="invalid distance code",r.mode=n;break e}if(E=65535&A,U&=15,w<U&&(m+=L[i++]<<w,w+=8,w<U&&(m+=L[i++]<<w,w+=8)),E+=m&(1<<U)-1,E>u){e.msg="invalid distance too far back",r.mode=n;break e}if(m>>>=U,w-=U,U=s-d,E>U){if(U=E-U,U>f&&r.sane){e.msg="invalid distance too far back",r.mode=n;break e}if(k=0,B=p,0===h){if(k+=c-U,U<x){x-=U;do W[s++]=p[k++];while(--U);k=s-E,B=W}}else if(h<U){if(k+=c+h-U,U-=h,U<x){x-=U;do W[s++]=p[k++];while(--U);if(k=0,h<x){U=h,x-=U;do W[s++]=p[k++];while(--U);k=s-E,B=W}}}else if(k+=h-U,U<x){x-=U;do W[s++]=p[k++];while(--U);k=s-E,B=W}for(;x>2;)W[s++]=B[k++],W[s++]=B[k++],W[s++]=B[k++],x-=3;x&&(W[s++]=B[k++],x>1&&(W[s++]=B[k++]))}else{k=s-E;do W[s++]=W[k++],W[s++]=W[k++],W[s++]=W[k++],x-=3;while(x>2);x&&(W[s++]=W[k++],x>1&&(W[s++]=W[k++]))}break}}break}}while(i<a&&s<l);x=w>>3,i-=x,w-=x<<3,m&=(1<<w)-1,e.next_in=i,e.next_out=s,e.avail_in=i<a?5+(a-i):5-(i-a),e.avail_out=s<l?257+(l-s):257-(s-l),r.hold=m,r.bits=w}},"zlib/inftrees.js":function(e,t,r){"use strict";var n=e("../utils/common"),o=15,i=852,a=592,s=0,d=1,l=2,u=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],c=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],f=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],h=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];t.exports=function(e,t,r,p,m,w,b,y){var g,v,A,U,x,E,k,B,L,W=y.bits,M=0,O=0,N=0,R=0,C=0,I=0,H=0,S=0,P=0,T=0,D=null,F=0,z=new n.Buf16(o+1),V=new n.Buf16(o+1),q=null,Z=0;for(M=0;M<=o;M++)z[M]=0;for(O=0;O<p;O++)z[t[r+O]]++;for(C=W,R=o;R>=1&&0===z[R];R--);if(C>R&&(C=R),0===R)return m[w++]=20971520,m[w++]=20971520,y.bits=1,0;for(N=1;N<R&&0===z[N];N++);for(C<N&&(C=N),S=1,M=1;M<=o;M++)if(S<<=1,S-=z[M],S<0)return-1;if(S>0&&(e===s||1!==R))return-1;for(V[1]=0,M=1;M<o;M++)V[M+1]=V[M]+z[M];for(O=0;O<p;O++)0!==t[r+O]&&(b[V[t[r+O]]++]=O);if(e===s?(D=q=b,E=19):e===d?(D=u,F-=257,q=c,Z-=257,E=256):(D=f,q=h,E=-1),T=0,O=0,M=N,x=w,I=C,H=0,A=-1,P=1<<C,U=P-1,e===d&&P>i||e===l&&P>a)return 1;for(;;){k=M-H,b[O]<E?(B=0,L=b[O]):b[O]>E?(B=q[Z+b[O]],L=D[F+b[O]]):(B=96,L=0),g=1<<M-H,v=1<<I,N=v;do v-=g,m[x+(T>>H)+v]=k<<24|B<<16|L|0;while(0!==v);for(g=1<<M-1;T&g;)g>>=1;if(0!==g?(T&=g-1,T+=g):T=0,O++,0===--z[M]){if(M===R)break;M=t[r+b[O]]}if(M>C&&(T&U)!==A){for(0===H&&(H=C),x+=N,I=M-H,S=1<<I;I+H<R&&(S-=z[I+H],!(S<=0));)I++,S<<=1;if(P+=1<<I,e===d&&P>i||e===l&&P>a)return 1;A=T&U,m[A]=C<<24|I<<16|x-w|0}}return 0!==T&&(m[x+T]=M-H<<24|64<<16|0),y.bits=C,0}}};for(var r in t)t[r].folder=r.substring(0,r.lastIndexOf("/")+1);var n=function(e){var r=[];return e=e.split("/").every(function(e){return".."==e?r.pop():"."==e||""==e||r.push(e)})?r.join("/"):null,e?t[e]||t[e+".js"]||t[e+"/index.js"]:null},o=function(e,t){return e?n(e.folder+"node_modules/"+t)||o(e.parent,t):null},i=function(e,t){var r=t.match(/^\//)?null:e?t.match(/^\.\.?\//)?n(e.folder+t):o(e,t):n(t);if(!r)throw"module not found: "+t;return r.exports||(r.parent=e,r(i.bind(null,r),r,r.exports={})),r.exports};return i(null,e)},decompress:function(e){this.exports||(this.exports=this.require("inflate.js"));try{return this.exports.inflate(e)}catch(e){}},hasUnityMarker:function(e){var t=10,r="UnityWeb Compressed Content (gzip)";if(t>e.length||31!=e[0]||139!=e[1])return!1;var n=e[3];if(4&n){if(t+2>e.length)return!1;if(t+=2+e[t]+(e[t+1]<<8),t>e.length)return!1}if(8&n){for(;t<e.length&&e[t];)t++;if(t+1>e.length)return!1;t++}return 16&n&&String.fromCharCode.apply(null,e.subarray(t,t+r.length+1))==r+"\0"}},brotli:{require:function(e){var t={"decompress.js":function(e,t,r){t.exports=e("./dec/decode").BrotliDecompressBuffer},"dec/bit_reader.js":function(e,t,r){function n(e){this.buf_=new Uint8Array(i),this.input_=e,this.reset()}const o=4096,i=8224,a=8191,s=new Uint32Array([0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,262143,524287,1048575,2097151,4194303,8388607,16777215]);n.READ_SIZE=o,n.IBUF_MASK=a,n.prototype.reset=function(){this.buf_ptr_=0,this.val_=0,this.pos_=0,this.bit_pos_=0,this.bit_end_pos_=0,this.eos_=0,this.readMoreInput();for(var e=0;e<4;e++)this.val_|=this.buf_[this.pos_]<<8*e,++this.pos_;return this.bit_end_pos_>0},n.prototype.readMoreInput=function(){if(!(this.bit_end_pos_>256))if(this.eos_){if(this.bit_pos_>this.bit_end_pos_)throw new Error("Unexpected end of input "+this.bit_pos_+" "+this.bit_end_pos_)}else{var e=this.buf_ptr_,t=this.input_.read(this.buf_,e,o);if(t<0)throw new Error("Unexpected end of input");if(t<o){this.eos_=1;for(var r=0;r<32;r++)this.buf_[e+t+r]=0}if(0===e){for(var r=0;r<32;r++)this.buf_[8192+r]=this.buf_[r];this.buf_ptr_=o}else this.buf_ptr_=0;this.bit_end_pos_+=t<<3}},n.prototype.fillBitWindow=function(){for(;this.bit_pos_>=8;)this.val_>>>=8,this.val_|=this.buf_[this.pos_&a]<<24,++this.pos_,this.bit_pos_=this.bit_pos_-8>>>0,this.bit_end_pos_=this.bit_end_pos_-8>>>0},n.prototype.readBits=function(e){32-this.bit_pos_<e&&this.fillBitWindow();var t=this.val_>>>this.bit_pos_&s[e];return this.bit_pos_+=e,t},t.exports=n},"dec/context.js":function(e,t,r){r.lookup=new Uint8Array([0,0,0,0,0,0,0,0,0,4,4,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,12,16,12,12,20,12,16,24,28,12,12,32,12,36,12,44,44,44,44,44,44,44,44,44,44,32,32,24,40,28,12,12,48,52,52,52,48,52,52,52,48,52,52,52,52,52,48,52,52,52,52,52,48,52,52,52,52,52,24,12,28,12,12,12,56,60,60,60,56,60,60,60,56,60,60,60,60,60,56,60,60,60,60,60,56,60,60,60,60,60,24,12,28,12,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,0,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,56,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,6,6,6,6,7,7,7,7,8,8,8,8,9,9,9,9,10,10,10,10,11,11,11,11,12,12,12,12,13,13,13,13,14,14,14,14,15,15,15,15,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,22,22,22,22,23,23,23,23,24,24,24,24,25,25,25,25,26,26,26,26,27,27,27,27,28,28,28,28,29,29,29,29,30,30,30,30,31,31,31,31,32,32,32,32,33,33,33,33,34,34,34,34,35,35,35,35,36,36,36,36,37,37,37,37,38,38,38,38,39,39,39,39,40,40,40,40,41,41,41,41,42,42,42,42,43,43,43,43,44,44,44,44,45,45,45,45,46,46,46,46,47,47,47,47,48,48,48,48,49,49,49,49,50,50,50,50,51,51,51,51,52,52,52,52,53,53,53,53,54,54,54,54,55,55,55,55,56,56,56,56,57,57,57,57,58,58,58,58,59,59,59,59,60,60,60,60,61,61,61,61,62,62,62,62,63,63,63,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),r.lookupOffsets=new Uint16Array([1024,1536,1280,1536,0,256,768,512])},"dec/decode.js":function(e,t,r){function n(e){var t;return 0===e.readBits(1)?16:(t=e.readBits(3),t>0?17+t:(t=e.readBits(3),t>0?8+t:17))}function o(e){if(e.readBits(1)){var t=e.readBits(3);return 0===t?1:e.readBits(t)+(1<<t)}return 0}function i(){this.meta_block_length=0,this.input_end=0,this.is_uncompressed=0,this.is_metadata=!1}function a(e){var t,r,n,o=new i;if(o.input_end=e.readBits(1),o.input_end&&e.readBits(1))return o;if(t=e.readBits(2)+4,7===t){if(o.is_metadata=!0,0!==e.readBits(1))throw new Error("Invalid reserved bit");if(r=e.readBits(2),0===r)return o;for(n=0;n<r;n++){var a=e.readBits(8);if(n+1===r&&r>1&&0===a)throw new Error("Invalid size byte");o.meta_block_length|=a<<8*n}}else for(n=0;n<t;++n){var s=e.readBits(4);if(n+1===t&&t>4&&0===s)throw new Error("Invalid size nibble");o.meta_block_length|=s<<4*n}return++o.meta_block_length,o.input_end||o.is_metadata||(o.is_uncompressed=e.readBits(1)),o}function s(e,t,r){var n;return r.fillBitWindow(),t+=r.val_>>>r.bit_pos_&D,n=e[t].bits-T,n>0&&(r.bit_pos_+=T,t+=e[t].value,t+=r.val_>>>r.bit_pos_&(1<<n)-1),r.bit_pos_+=e[t].bits,e[t].value}function d(e,t,r,n){for(var o=0,i=N,a=0,s=0,d=32768,l=[],u=0;u<32;u++)l.push(new B(0,0));for(L(l,0,5,e,z);o<t&&d>0;){var c,f=0;if(n.readMoreInput(),n.fillBitWindow(),f+=n.val_>>>n.bit_pos_&31,n.bit_pos_+=l[f].bits,c=255&l[f].value,c<R)a=0,r[o++]=c,0!==c&&(i=c,d-=32768>>c);else{var h,p,m=c-14,w=0;if(c===R&&(w=i),s!==w&&(a=0,s=w),h=a,a>0&&(a-=2,a<<=m),a+=n.readBits(m)+3,p=a-h,o+p>t)throw new Error("[ReadHuffmanCodeLengths] symbol + repeat_delta > num_symbols");for(var b=0;b<p;b++)r[o+b]=s;o+=p,0!==s&&(d-=p<<15-s)}}if(0!==d)throw new Error("[ReadHuffmanCodeLengths] space = "+d);for(;o<t;o++)r[o]=0}function l(e,t,r,n){var o,i=0,a=new Uint8Array(e);if(n.readMoreInput(),o=n.readBits(2),1===o){for(var s,l=e-1,u=0,c=new Int32Array(4),f=n.readBits(2)+1;l;)l>>=1,++u;for(s=0;s<f;++s)c[s]=n.readBits(u)%e,a[c[s]]=2;switch(a[c[0]]=1,f){case 1:break;case 3:if(c[0]===c[1]||c[0]===c[2]||c[1]===c[2])throw new Error("[ReadHuffmanCode] invalid symbols");break;case 2:if(c[0]===c[1])throw new Error("[ReadHuffmanCode] invalid symbols");a[c[1]]=1;break;case 4:if(c[0]===c[1]||c[0]===c[2]||c[0]===c[3]||c[1]===c[2]||c[1]===c[3]||c[2]===c[3])throw new Error("[ReadHuffmanCode] invalid symbols");n.readBits(1)?(a[c[2]]=3,a[c[3]]=3):a[c[0]]=2}}else{var s,h=new Uint8Array(z),p=32,m=0,w=[new B(2,0),new B(2,4),new B(2,3),new B(3,2),new B(2,0),new B(2,4),new B(2,3),new B(4,1),new B(2,0),new B(2,4),new B(2,3),new B(3,2),new B(2,0),new B(2,4),new B(2,3),new B(4,5)];for(s=o;s<z&&p>0;++s){var b,y=V[s],g=0;n.fillBitWindow(),g+=n.val_>>>n.bit_pos_&15, n.bit_pos_+=w[g].bits,b=w[g].value,h[y]=b,0!==b&&(p-=32>>b,++m)}if(1!==m&&0!==p)throw new Error("[ReadHuffmanCode] invalid num_codes or space");d(h,e,a,n)}if(i=L(t,r,T,a,e),0===i)throw new Error("[ReadHuffmanCode] BuildHuffmanTable failed: ");return i}function u(e,t,r){var n,o;return n=s(e,t,r),o=M.kBlockLengthPrefixCode[n].nbits,M.kBlockLengthPrefixCode[n].offset+r.readBits(o)}function c(e,t,r){var n;return e<q?(r+=Z[e],r&=3,n=t[r]+Y[e]):n=e-q+1,n}function f(e,t){for(var r=e[t],n=t;n;--n)e[n]=e[n-1];e[0]=r}function h(e,t){var r,n=new Uint8Array(256);for(r=0;r<256;++r)n[r]=r;for(r=0;r<t;++r){var o=e[r];e[r]=n[o],o&&f(n,o)}}function p(e,t){this.alphabet_size=e,this.num_htrees=t,this.codes=new Array(t+t*G[e+31>>>5]),this.htrees=new Uint32Array(t)}function m(e,t){var r,n,i,a={num_htrees:null,context_map:null},d=0;t.readMoreInput();var u=a.num_htrees=o(t)+1,c=a.context_map=new Uint8Array(e);if(u<=1)return a;for(r=t.readBits(1),r&&(d=t.readBits(4)+1),n=[],i=0;i<F;i++)n[i]=new B(0,0);for(l(u+d,n,0,t),i=0;i<e;){var f;if(t.readMoreInput(),f=s(n,0,t),0===f)c[i]=0,++i;else if(f<=d)for(var p=1+(1<<f)+t.readBits(f);--p;){if(i>=e)throw new Error("[DecodeContextMap] i >= context_map_size");c[i]=0,++i}else c[i]=f-d,++i}return t.readBits(1)&&h(c,e),a}function w(e,t,r,n,o,i,a){var d,l=2*r,u=r,c=s(t,r*F,a);d=0===c?o[l+(1&i[u])]:1===c?o[l+(i[u]-1&1)]+1:c-2,d>=e&&(d-=e),n[r]=d,o[l+(1&i[u])]=d,++i[u]}function b(e,t,r,n,o,i){var a,s=o+1,d=r&o,l=i.pos_&E.IBUF_MASK;if(t<8||i.bit_pos_+(t<<3)<i.bit_end_pos_)for(;t-- >0;)i.readMoreInput(),n[d++]=i.readBits(8),d===s&&(e.write(n,s),d=0);else{if(i.bit_end_pos_<32)throw new Error("[CopyUncompressedBlockToOutput] br.bit_end_pos_ < 32");for(;i.bit_pos_<32;)n[d]=i.val_>>>i.bit_pos_,i.bit_pos_+=8,++d,--t;if(a=i.bit_end_pos_-i.bit_pos_>>3,l+a>E.IBUF_MASK){for(var u=E.IBUF_MASK+1-l,c=0;c<u;c++)n[d+c]=i.buf_[l+c];a-=u,d+=u,t-=u,l=0}for(var c=0;c<a;c++)n[d+c]=i.buf_[l+c];if(d+=a,t-=a,d>=s){e.write(n,s),d-=s;for(var c=0;c<d;c++)n[c]=n[s+c]}for(;d+t>=s;){if(a=s-d,i.input_.read(n,d,a)<a)throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");e.write(n,s),t-=a,d=0}if(i.input_.read(n,d,t)<t)throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");i.reset()}}function y(e){var t=e.bit_pos_+7&-8,r=e.readBits(t-e.bit_pos_);return 0==r}function g(e){var t=new U(e),r=new E(t);n(r);var o=a(r);return o.meta_block_length}function v(e,t){var r=new U(e);null==t&&(t=g(e));var n=new Uint8Array(t),o=new x(n);return A(r,o),o.pos<o.buffer.length&&(o.buffer=o.buffer.subarray(0,o.pos)),o.buffer}function A(e,t){var r,i,d,f,h,g,v,A,U,x=0,L=0,N=0,R=0,T=[16,15,11,4],D=0,z=0,V=0,Z=[new p(0,0),new p(0,0),new p(0,0)];const Y=128+E.READ_SIZE;U=new E(e),N=n(U),i=(1<<N)-16,d=1<<N,f=d-1,h=new Uint8Array(d+Y+k.maxDictionaryWordLength),g=d,v=[],A=[];for(var G=0;G<3240;G++)v[G]=new B(0,0),A[G]=new B(0,0);for(;!L;){var J,j,X,K,Q,_,$,ee,te,re=0,ne=[1<<28,1<<28,1<<28],oe=[0],ie=[1,1,1],ae=[0,1,0,1,0,1],se=[0],de=null,le=null,ue=null,ce=0,fe=null,he=0,pe=0,me=null,we=0,be=0,ye=0;for(r=0;r<3;++r)Z[r].codes=null,Z[r].htrees=null;U.readMoreInput();var ge=a(U);if(re=ge.meta_block_length,x+re>t.buffer.length){var ve=new Uint8Array(x+re);ve.set(t.buffer),t.buffer=ve}if(L=ge.input_end,J=ge.is_uncompressed,ge.is_metadata)for(y(U);re>0;--re)U.readMoreInput(),U.readBits(8);else if(0!==re)if(J)U.bit_pos_=U.bit_pos_+7&-8,b(t,re,x,h,f,U),x+=re;else{for(r=0;r<3;++r)ie[r]=o(U)+1,ie[r]>=2&&(l(ie[r]+2,v,r*F,U),l(H,A,r*F,U),ne[r]=u(A,r*F,U),se[r]=1);for(U.readMoreInput(),j=U.readBits(2),X=q+(U.readBits(4)<<j),K=(1<<j)-1,Q=X+(48<<j),le=new Uint8Array(ie[0]),r=0;r<ie[0];++r)U.readMoreInput(),le[r]=U.readBits(2)<<1;var Ae=m(ie[0]<<S,U);_=Ae.num_htrees,de=Ae.context_map;var Ue=m(ie[2]<<P,U);for($=Ue.num_htrees,ue=Ue.context_map,Z[0]=new p(C,_),Z[1]=new p(I,ie[1]),Z[2]=new p(Q,$),r=0;r<3;++r)Z[r].decode(U);for(fe=0,me=0,ee=le[oe[0]],be=W.lookupOffsets[ee],ye=W.lookupOffsets[ee+1],te=Z[1].htrees[0];re>0;){var xe,Ee,ke,Be,Le,We,Me,Oe,Ne,Re,Ce;for(U.readMoreInput(),0===ne[1]&&(w(ie[1],v,1,oe,ae,se,U),ne[1]=u(A,F,U),te=Z[1].htrees[oe[1]]),--ne[1],xe=s(Z[1].codes,te,U),Ee=xe>>6,Ee>=2?(Ee-=2,Me=-1):Me=0,ke=M.kInsertRangeLut[Ee]+(xe>>3&7),Be=M.kCopyRangeLut[Ee]+(7&xe),Le=M.kInsertLengthPrefixCode[ke].offset+U.readBits(M.kInsertLengthPrefixCode[ke].nbits),We=M.kCopyLengthPrefixCode[Be].offset+U.readBits(M.kCopyLengthPrefixCode[Be].nbits),z=h[x-1&f],V=h[x-2&f],Re=0;Re<Le;++Re)U.readMoreInput(),0===ne[0]&&(w(ie[0],v,0,oe,ae,se,U),ne[0]=u(A,0,U),ce=oe[0]<<S,fe=ce,ee=le[oe[0]],be=W.lookupOffsets[ee],ye=W.lookupOffsets[ee+1]),Ne=W.lookup[be+z]|W.lookup[ye+V],he=de[fe+Ne],--ne[0],V=z,z=s(Z[0].codes,Z[0].htrees[he],U),h[x&f]=z,(x&f)===f&&t.write(h,d),++x;if(re-=Le,re<=0)break;if(Me<0){var Ne;if(U.readMoreInput(),0===ne[2]&&(w(ie[2],v,2,oe,ae,se,U),ne[2]=u(A,2160,U),pe=oe[2]<<P,me=pe),--ne[2],Ne=255&(We>4?3:We-2),we=ue[me+Ne],Me=s(Z[2].codes,Z[2].htrees[we],U),Me>=X){var Ie,He,Se;Me-=X,He=Me&K,Me>>=j,Ie=(Me>>1)+1,Se=(2+(1&Me)<<Ie)-4,Me=X+(Se+U.readBits(Ie)<<j)+He}}if(Oe=c(Me,T,D),Oe<0)throw new Error("[BrotliDecompress] invalid distance");if(R=x<i&&R!==i?x:i,Ce=x&f,Oe>R){if(!(We>=k.minDictionaryWordLength&&We<=k.maxDictionaryWordLength))throw new Error("Invalid backward reference. pos: "+x+" distance: "+Oe+" len: "+We+" bytes left: "+re);var Se=k.offsetsByLength[We],Pe=Oe-R-1,Te=k.sizeBitsByLength[We],De=(1<<Te)-1,Fe=Pe&De,ze=Pe>>Te;if(Se+=Fe*We,!(ze<O.kNumTransforms))throw new Error("Invalid backward reference. pos: "+x+" distance: "+Oe+" len: "+We+" bytes left: "+re);var Ve=O.transformDictionaryWord(h,Ce,Se,We,ze);if(Ce+=Ve,x+=Ve,re-=Ve,Ce>=g){t.write(h,d);for(var qe=0;qe<Ce-g;qe++)h[qe]=h[g+qe]}}else{if(Me>0&&(T[3&D]=Oe,++D),We>re)throw new Error("Invalid backward reference. pos: "+x+" distance: "+Oe+" len: "+We+" bytes left: "+re);for(Re=0;Re<We;++Re)h[x&f]=h[x-Oe&f],(x&f)===f&&t.write(h,d),++x,--re}z=h[x-1&f],V=h[x-2&f]}x&=1073741823}}t.write(h,x&f)}var U=e("./streams").BrotliInput,x=e("./streams").BrotliOutput,E=e("./bit_reader"),k=e("./dictionary"),B=e("./huffman").HuffmanCode,L=e("./huffman").BrotliBuildHuffmanTable,W=e("./context"),M=e("./prefix"),O=e("./transform");const N=8,R=16,C=256,I=704,H=26,S=6,P=2,T=8,D=255,F=1080,z=18,V=new Uint8Array([1,2,3,4,0,5,17,6,16,7,8,9,10,11,12,13,14,15]),q=16,Z=new Uint8Array([3,2,1,0,3,3,3,3,3,3,2,2,2,2,2,2]),Y=new Int8Array([0,0,0,0,-1,1,-2,2,-3,3,-1,1,-2,2,-3,3]),G=new Uint16Array([256,402,436,468,500,534,566,598,630,662,694,726,758,790,822,854,886,920,952,984,1016,1048,1080]);p.prototype.decode=function(e){var t,r,n=0;for(t=0;t<this.num_htrees;++t)this.htrees[t]=n,r=l(this.alphabet_size,this.codes,n,e),n+=r},r.BrotliDecompressedSize=g,r.BrotliDecompressBuffer=v,r.BrotliDecompress=A,k.init()},"dec/dictionary.js":function(e,t,r){var n=e("./dictionary-browser");r.init=function(){r.dictionary=n.init()},r.offsetsByLength=new Uint32Array([0,0,0,0,0,4096,9216,21504,35840,44032,53248,63488,74752,87040,93696,100864,104704,106752,108928,113536,115968,118528,119872,121280,122016]),r.sizeBitsByLength=new Uint8Array([0,0,0,0,10,10,11,11,10,10,10,10,10,9,9,8,7,7,8,7,7,6,6,5,5]),r.minDictionaryWordLength=4,r.maxDictionaryWordLength=24},"dec/dictionary.bin.js":function(e,t,r){t.exports="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"; },"dec/dictionary-browser.js":function(e,t,r){var n=e("base64-js");r.init=function(){var t=e("./decode").BrotliDecompressBuffer,r=n.toByteArray(e("./dictionary.bin.js"));return t(r)}},"dec/huffman.js":function(e,t,r){function n(e,t){this.bits=e,this.value=t}function o(e,t){for(var r=1<<t-1;e&r;)r>>=1;return(e&r-1)+r}function i(e,t,r,o,i){do o-=r,e[t+o]=new n(i.bits,i.value);while(o>0)}function a(e,t,r){for(var n=1<<t-r;t<s&&(n-=e[t],!(n<=0));)++t,n<<=1;return t-r}r.HuffmanCode=n;const s=15;r.BrotliBuildHuffmanTable=function(e,t,r,d,l){var u,c,f,h,p,m,w,b,y,g,v,A=t,U=new Int32Array(16),x=new Int32Array(16);for(v=new Int32Array(l),f=0;f<l;f++)U[d[f]]++;for(x[1]=0,c=1;c<s;c++)x[c+1]=x[c]+U[c];for(f=0;f<l;f++)0!==d[f]&&(v[x[d[f]]++]=f);if(b=r,y=1<<b,g=y,1===x[s]){for(h=0;h<g;++h)e[t+h]=new n(0,65535&v[0]);return g}for(h=0,f=0,c=1,p=2;c<=r;++c,p<<=1)for(;U[c]>0;--U[c])u=new n(255&c,65535&v[f++]),i(e,t+h,p,y,u),h=o(h,c);for(w=g-1,m=-1,c=r+1,p=2;c<=s;++c,p<<=1)for(;U[c]>0;--U[c])(h&w)!==m&&(t+=y,b=a(U,c,r),y=1<<b,g+=y,m=h&w,e[A+m]=new n(b+r&255,t-A-m&65535)),u=new n(c-r&255,65535&v[f++]),i(e,t+(h>>r),p,y,u),h=o(h,c);return g}},"dec/prefix.js":function(e,t,r){function n(e,t){this.offset=e,this.nbits=t}r.kBlockLengthPrefixCode=[new n(1,2),new n(5,2),new n(9,2),new n(13,2),new n(17,3),new n(25,3),new n(33,3),new n(41,3),new n(49,4),new n(65,4),new n(81,4),new n(97,4),new n(113,5),new n(145,5),new n(177,5),new n(209,5),new n(241,6),new n(305,6),new n(369,7),new n(497,8),new n(753,9),new n(1265,10),new n(2289,11),new n(4337,12),new n(8433,13),new n(16625,24)],r.kInsertLengthPrefixCode=[new n(0,0),new n(1,0),new n(2,0),new n(3,0),new n(4,0),new n(5,0),new n(6,1),new n(8,1),new n(10,2),new n(14,2),new n(18,3),new n(26,3),new n(34,4),new n(50,4),new n(66,5),new n(98,5),new n(130,6),new n(194,7),new n(322,8),new n(578,9),new n(1090,10),new n(2114,12),new n(6210,14),new n(22594,24)],r.kCopyLengthPrefixCode=[new n(2,0),new n(3,0),new n(4,0),new n(5,0),new n(6,0),new n(7,0),new n(8,0),new n(9,0),new n(10,1),new n(12,1),new n(14,2),new n(18,2),new n(22,3),new n(30,3),new n(38,4),new n(54,4),new n(70,5),new n(102,5),new n(134,6),new n(198,7),new n(326,8),new n(582,9),new n(1094,10),new n(2118,24)],r.kInsertRangeLut=[0,0,8,8,0,16,8,16,16],r.kCopyRangeLut=[0,8,0,8,16,0,16,8,16]},"dec/streams.js":function(e,t,r){function n(e){this.buffer=e,this.pos=0}function o(e){this.buffer=e,this.pos=0}n.prototype.read=function(e,t,r){this.pos+r>this.buffer.length&&(r=this.buffer.length-this.pos);for(var n=0;n<r;n++)e[t+n]=this.buffer[this.pos+n];return this.pos+=r,r},r.BrotliInput=n,o.prototype.write=function(e,t){if(this.pos+t>this.buffer.length)throw new Error("Output buffer is not large enough");return this.buffer.set(e.subarray(0,t),this.pos),this.pos+=t,t},r.BrotliOutput=o},"dec/transform.js":function(e,t,r){function n(e,t,r){this.prefix=new Uint8Array(e.length),this.transform=t,this.suffix=new Uint8Array(r.length);for(var n=0;n<e.length;n++)this.prefix[n]=e.charCodeAt(n);for(var n=0;n<r.length;n++)this.suffix[n]=r.charCodeAt(n)}function o(e,t){return e[t]<192?(e[t]>=97&&e[t]<=122&&(e[t]^=32),1):e[t]<224?(e[t+1]^=32,2):(e[t+2]^=5,3)}var i=e("./dictionary");const a=0,s=1,d=2,l=3,u=4,c=5,f=6,h=7,p=8,m=9,w=10,b=11,y=12,g=13,v=14,A=15,U=16,x=17,E=18,k=20;var B=[new n("",a,""),new n("",a," "),new n(" ",a," "),new n("",y,""),new n("",w," "),new n("",a," the "),new n(" ",a,""),new n("s ",a," "),new n("",a," of "),new n("",w,""),new n("",a," and "),new n("",g,""),new n("",s,""),new n(", ",a," "),new n("",a,", "),new n(" ",w," "),new n("",a," in "),new n("",a," to "),new n("e ",a," "),new n("",a,'"'),new n("",a,"."),new n("",a,'">'),new n("",a,"\n"),new n("",l,""),new n("",a,"]"),new n("",a," for "),new n("",v,""),new n("",d,""),new n("",a," a "),new n("",a," that "),new n(" ",w,""),new n("",a,". "),new n(".",a,""),new n(" ",a,", "),new n("",A,""),new n("",a," with "),new n("",a,"'"),new n("",a," from "),new n("",a," by "),new n("",U,""),new n("",x,""),new n(" the ",a,""),new n("",u,""),new n("",a,". The "),new n("",b,""),new n("",a," on "),new n("",a," as "),new n("",a," is "),new n("",h,""),new n("",s,"ing "),new n("",a,"\n\t"),new n("",a,":"),new n(" ",a,". "),new n("",a,"ed "),new n("",k,""),new n("",E,""),new n("",f,""),new n("",a,"("),new n("",w,", "),new n("",p,""),new n("",a," at "),new n("",a,"ly "),new n(" the ",a," of "),new n("",c,""),new n("",m,""),new n(" ",w,", "),new n("",w,'"'),new n(".",a,"("),new n("",b," "),new n("",w,'">'),new n("",a,'="'),new n(" ",a,"."),new n(".com/",a,""),new n(" the ",a," of the "),new n("",w,"'"),new n("",a,". This "),new n("",a,","),new n(".",a," "),new n("",w,"("),new n("",w,"."),new n("",a," not "),new n(" ",a,'="'),new n("",a,"er "),new n(" ",b," "),new n("",a,"al "),new n(" ",b,""),new n("",a,"='"),new n("",b,'"'),new n("",w,". "),new n(" ",a,"("),new n("",a,"ful "),new n(" ",w,". "),new n("",a,"ive "),new n("",a,"less "),new n("",b,"'"),new n("",a,"est "),new n(" ",w,"."),new n("",b,'">'),new n(" ",a,"='"),new n("",w,","),new n("",a,"ize "),new n("",b,"."),new n("\xc2\xa0",a,""),new n(" ",a,","),new n("",w,'="'),new n("",b,'="'),new n("",a,"ous "),new n("",b,", "),new n("",w,"='"),new n(" ",w,","),new n(" ",b,'="'),new n(" ",b,", "),new n("",b,","),new n("",b,"("),new n("",b,". "),new n(" ",b,"."),new n("",b,"='"),new n(" ",b,". "),new n(" ",w,'="'),new n(" ",b,"='"),new n(" ",w,"='")];r.kTransforms=B,r.kNumTransforms=B.length,r.transformDictionaryWord=function(e,t,r,n,a){var s,d=B[a].prefix,l=B[a].suffix,u=B[a].transform,c=u<y?0:u-11,f=0,h=t;c>n&&(c=n);for(var p=0;p<d.length;)e[t++]=d[p++];for(r+=c,n-=c,u<=m&&(n-=u),f=0;f<n;f++)e[t++]=i.dictionary[r+f];if(s=t-n,u===w)o(e,s);else if(u===b)for(;n>0;){var g=o(e,s);s+=g,n-=g}for(var v=0;v<l.length;)e[t++]=l[v++];return t-h}},"node_modules/base64-js/index.js":function(e,t,r){"use strict";function n(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");return"="===e[t-2]?2:"="===e[t-1]?1:0}function o(e){return 3*e.length/4-n(e)}function i(e){var t,r,o,i,a,s,d=e.length;a=n(e),s=new c(3*d/4-a),o=a>0?d-4:d;var l=0;for(t=0,r=0;t<o;t+=4,r+=3)i=u[e.charCodeAt(t)]<<18|u[e.charCodeAt(t+1)]<<12|u[e.charCodeAt(t+2)]<<6|u[e.charCodeAt(t+3)],s[l++]=i>>16&255,s[l++]=i>>8&255,s[l++]=255&i;return 2===a?(i=u[e.charCodeAt(t)]<<2|u[e.charCodeAt(t+1)]>>4,s[l++]=255&i):1===a&&(i=u[e.charCodeAt(t)]<<10|u[e.charCodeAt(t+1)]<<4|u[e.charCodeAt(t+2)]>>2,s[l++]=i>>8&255,s[l++]=255&i),s}function a(e){return l[e>>18&63]+l[e>>12&63]+l[e>>6&63]+l[63&e]}function s(e,t,r){for(var n,o=[],i=t;i<r;i+=3)n=(e[i]<<16)+(e[i+1]<<8)+e[i+2],o.push(a(n));return o.join("")}function d(e){for(var t,r=e.length,n=r%3,o="",i=[],a=16383,d=0,u=r-n;d<u;d+=a)i.push(s(e,d,d+a>u?u:d+a));return 1===n?(t=e[r-1],o+=l[t>>2],o+=l[t<<4&63],o+="=="):2===n&&(t=(e[r-2]<<8)+e[r-1],o+=l[t>>10],o+=l[t>>4&63],o+=l[t<<2&63],o+="="),i.push(o),i.join("")}r.byteLength=o,r.toByteArray=i,r.fromByteArray=d;for(var l=[],u=[],c="undefined"!=typeof Uint8Array?Uint8Array:Array,f="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",h=0,p=f.length;h<p;++h)l[h]=f[h],u[f.charCodeAt(h)]=h;u["-".charCodeAt(0)]=62,u["_".charCodeAt(0)]=63}};for(var r in t)t[r].folder=r.substring(0,r.lastIndexOf("/")+1);var n=function(e){var r=[];return e=e.split("/").every(function(e){return".."==e?r.pop():"."==e||""==e||r.push(e)})?r.join("/"):null,e?t[e]||t[e+".js"]||t[e+"/index.js"]:null},o=function(e,t){return e?n(e.folder+"node_modules/"+t)||o(e.parent,t):null},i=function(e,t){var r=t.match(/^\//)?null:e?t.match(/^\.\.?\//)?n(e.folder+t):o(e,t):n(t);if(!r)throw"module not found: "+t;return r.exports||(r.parent=e,r(i.bind(null,r),r,r.exports={})),r.exports};return i(null,e)},decompress:function(e){this.exports||(this.exports=this.require("decompress.js"));try{return this.exports(e)}catch(e){}},hasUnityMarker:function(e){var t="UnityWeb Compressed Content (brotli)";if(!e.length)return!1;var r=1&e[0]?14&e[0]?4:7:1,n=e[0]&(1<<r)-1,o=1+(Math.log(t.length-1)/Math.log(2)>>3);if(commentOffset=r+1+2+1+2+(o<<3)+7>>3,17==n||commentOffset>e.length)return!1;for(var i=n+(6+(o<<4)+(t.length-1<<6)<<r),a=0;a<commentOffset;a++,i>>>=8)if(e[a]!=(255&i))return!1;return String.fromCharCode.apply(null,e.subarray(commentOffset,commentOffset+t.length))==t}},decompress:function(e,t){var r=this.gzip.hasUnityMarker(e)?this.gzip:this.brotli.hasUnityMarker(e)?this.brotli:this.identity;if(this.serverSetupWarningEnabled&&r!=this.identity&&(console.log("You can reduce your startup time if you configure your web server to host .unityweb files using "+(r==this.gzip?"gzip":"brotli")+" compression."),this.serverSetupWarningEnabled=!1),"function"!=typeof t)return r.decompress(e);if(!r.worker){var n=URL.createObjectURL(new Blob(["this.require = ",r.require.toString(),"; this.decompress = ",r.decompress.toString(),"; this.onmessage = ",function(e){var t={id:e.data.id,decompressed:this.decompress(e.data.compressed)};postMessage(t,t.decompressed?[t.decompressed.buffer]:[])}.toString(),"; postMessage({ ready: true });"],{type:"text/javascript"}));r.worker=new Worker(n),r.worker.onmessage=function(e){return e.data.ready?void URL.revokeObjectURL(n):(this.callbacks[e.data.id](e.data.decompressed),void delete this.callbacks[e.data.id])},r.worker.callbacks={},r.worker.nextCallbackId=0}var o=r.worker.nextCallbackId++;r.worker.callbacks[o]=t,r.worker.postMessage({id:o,compressed:e},[e.buffer])},serverSetupWarningEnabled:!0},Cryptography:{crc32:function(e){var t=UnityLoader.Cryptography.crc32.module;if(!t){var r=new ArrayBuffer(16777216),n=function(e,t,r){"use asm";var n=new e.Uint8Array(r);var o=new e.Uint32Array(r);function i(e,t){e=e|0;t=t|0;var r=0;for(r=o[1024>>2]|0;t;e=e+1|0,t=t-1|0)r=o[(r&255^n[e])<<2>>2]^r>>>8^4278190080;o[1024>>2]=r}return{process:i}}({Uint8Array:Uint8Array,Uint32Array:Uint32Array},null,r);t=UnityLoader.Cryptography.crc32.module={buffer:r,HEAPU8:new Uint8Array(r),HEAPU32:new Uint32Array(r),process:n.process,crc32:1024,data:1028};for(var o=0;o<256;o++){for(var i=255^o,a=0;a<8;a++)i=i>>>1^(1&i?3988292384:0);t.HEAPU32[o]=i}}t.HEAPU32[t.crc32>>2]=0;for(var s=0;s<e.length;){var d=Math.min(t.HEAPU8.length-t.data,e.length-s);t.HEAPU8.set(e.subarray(s,s+d),t.data),crc=t.process(t.data,d),s+=d}var l=t.HEAPU32[t.crc32>>2];return new Uint8Array([l>>24,l>>16,l>>8,l])},md5:function(e){var t=UnityLoader.Cryptography.md5.module;if(!t){var r=new ArrayBuffer(16777216),n=function(e,t,r){"use asm";var n=new e.Uint32Array(r);function o(e,t){e=e|0;t=t|0;var r=0,o=0,i=0,a=0,s=0,d=0,l=0,u=0,c=0,f=0,h=0,p=0;r=n[128]|0,o=n[129]|0,i=n[130]|0,a=n[131]|0;for(;t;e=e+64|0,t=t-1|0){s=r;d=o;l=i;u=a;for(f=0;(f|0)<512;f=f+8|0){p=n[f>>2]|0;r=r+(n[f+4>>2]|0)+(n[e+(p>>>14)>>2]|0)+((f|0)<128?a^o&(i^a):(f|0)<256?i^a&(o^i):(f|0)<384?o^i^a:i^(o|~a))|0;h=(r<<(p&31)|r>>>32-(p&31))+o|0;r=a;a=i;i=o;o=h}r=r+s|0;o=o+d|0;i=i+l|0;a=a+u|0}n[128]=r;n[129]=o;n[130]=i;n[131]=a}return{process:o}}({Uint32Array:Uint32Array},null,r);t=UnityLoader.Cryptography.md5.module={buffer:r,HEAPU8:new Uint8Array(r),HEAPU32:new Uint32Array(r),process:n.process,md5:512,data:576},t.HEAPU32.set(new Uint32Array([7,3614090360,65548,3905402710,131089,606105819,196630,3250441966,262151,4118548399,327692,1200080426,393233,2821735955,458774,4249261313,524295,1770035416,589836,2336552879,655377,4294925233,720918,2304563134,786439,1804603682,851980,4254626195,917521,2792965006,983062,1236535329,65541,4129170786,393225,3225465664,720910,643717713,20,3921069994,327685,3593408605,655369,38016083,983054,3634488961,262164,3889429448,589829,568446438,917513,3275163606,196622,4107603335,524308,1163531501,851973,2850285829,131081,4243563512,458766,1735328473,786452,2368359562,327684,4294588738,524299,2272392833,720912,1839030562,917527,4259657740,65540,2763975236,262155,1272893353,458768,4139469664,655383,3200236656,851972,681279174,11,3936430074,196624,3572445317,393239,76029189,589828,3654602809,786443,3873151461,983056,530742520,131095,3299628645,6,4096336452,458762,1126891415,917519,2878612391,327701,4237533241,786438,1700485571,196618,2399980690,655375,4293915773,65557,2240044497,524294,1873313359,983050,4264355552,393231,2734768916,851989,1309151649,262150,4149444226,720906,3174756917,131087,718787259,589845,3951481745]))}t.HEAPU32.set(new Uint32Array([1732584193,4023233417,2562383102,271733878]),t.md5>>2);for(var o=0;o<e.length;){var i=Math.min(t.HEAPU8.length-t.data,e.length-o)&-64;if(t.HEAPU8.set(e.subarray(o,o+i),t.data),o+=i,t.process(t.data,i>>6),e.length-o<64){if(i=e.length-o,t.HEAPU8.set(e.subarray(e.length-i,e.length),t.data),o+=i,t.HEAPU8[t.data+i++]=128,i>56){for(var a=i;a<64;a++)t.HEAPU8[t.data+a]=0;t.process(t.data,1),i=0}for(var a=i;a<64;a++)t.HEAPU8[t.data+a]=0;for(var s=e.length,d=0,a=56;a<64;a++,d=(224&s)>>5,s/=256)t.HEAPU8[t.data+a]=((31&s)<<3)+d;t.process(t.data,1)}}return new Uint8Array(t.HEAPU8.subarray(t.md5,t.md5+16))},sha1:function(e){var t=UnityLoader.Cryptography.sha1.module;if(!t){var r=new ArrayBuffer(16777216),n=function(e,t,r){"use asm";var n=new e.Uint32Array(r);function o(e,t){e=e|0;t=t|0;var r=0,o=0,i=0,a=0,s=0,d=0,l=0,u=0,c=0,f=0,h=0,p=0;r=n[80]|0,o=n[81]|0,i=n[82]|0,a=n[83]|0,s=n[84]|0;for(;t;e=e+64|0,t=t-1|0){d=r;l=o;u=i;c=a;f=s;for(p=0;(p|0)<320;p=p+4|0,s=a,a=i,i=o<<30|o>>>2,o=r,r=h){if((p|0)<64){h=n[e+p>>2]|0;h=h<<24&4278190080|h<<8&16711680|h>>>8&65280|h>>>24&255}else{h=n[p-12>>2]^n[p-32>>2]^n[p-56>>2]^n[p-64>>2];h=h<<1|h>>>31}n[p>>2]=h;h=h+((r<<5|r>>>27)+s)+((p|0)<80?(o&i|~o&a|0)+1518500249|0:(p|0)<160?(o^i^a)+1859775393|0:(p|0)<240?(o&i|o&a|i&a)+2400959708|0:(o^i^a)+3395469782|0)|0}r=r+d|0;o=o+l|0;i=i+u|0;a=a+c|0;s=s+f|0}n[80]=r;n[81]=o;n[82]=i;n[83]=a;n[84]=s}return{process:o}}({Uint32Array:Uint32Array},null,r);t=UnityLoader.Cryptography.sha1.module={buffer:r,HEAPU8:new Uint8Array(r),HEAPU32:new Uint32Array(r),process:n.process,sha1:320,data:384}}t.HEAPU32.set(new Uint32Array([1732584193,4023233417,2562383102,271733878,3285377520]),t.sha1>>2);for(var o=0;o<e.length;){var i=Math.min(t.HEAPU8.length-t.data,e.length-o)&-64;if(t.HEAPU8.set(e.subarray(o,o+i),t.data),o+=i,t.process(t.data,i>>6),e.length-o<64){if(i=e.length-o,t.HEAPU8.set(e.subarray(e.length-i,e.length),t.data),o+=i,t.HEAPU8[t.data+i++]=128,i>56){for(var a=i;a<64;a++)t.HEAPU8[t.data+a]=0;t.process(t.data,1),i=0}for(var a=i;a<64;a++)t.HEAPU8[t.data+a]=0;for(var s=e.length,d=0,a=63;a>=56;a--,d=(224&s)>>5,s/=256)t.HEAPU8[t.data+a]=((31&s)<<3)+d;t.process(t.data,1)}}for(var l=new Uint8Array(20),a=0;a<l.length;a++)l[a]=t.HEAPU8[t.sha1+(a&-4)+3-(3&a)];return l}},Error:{init:function(){return Error.stackTraceLimit=50,window.addEventListener("error",function(e){var t=UnityLoader.Error.getModule(e);if(!t)return UnityLoader.Error.handler(e);var r=t.useWasm?t.wasmSymbolsUrl:t.asmSymbolsUrl;if(!r)return UnityLoader.Error.handler(e,t);var n=new XMLHttpRequest;n.open("GET",t.resolveBuildUrl(r)),n.responseType="arraybuffer",n.onload=function(){UnityLoader.loadCode(t,UnityLoader.Compression.decompress(new Uint8Array(n.response)),function(r){t.demangleSymbol=UnityLoader[r](),UnityLoader.Error.handler(e,t)},{isModularized:!1})},n.send()}),!0}(),stackTraceFormat:navigator.userAgent.indexOf("Chrome")!=-1?"(\\s+at\\s+)(([\\w\\d_\\.]*?)([\\w\\d_$]+)(/[\\w\\d_\\./]+|))(\\s+\\[.*\\]|)\\s*\\((blob:.*)\\)":"(\\s*)(([\\w\\d_\\.]*?)([\\w\\d_$]+)(/[\\w\\d_\\./]+|))(\\s+\\[.*\\]|)\\s*@(blob:.*)",stackTraceFormatWasm:navigator.userAgent.indexOf("Chrome")!=-1?"((\\s+at\\s*)\\s\\(<WASM>\\[(\\d+)\\]\\+\\d+\\))()":"((\\s*)wasm-function\\[(\\d+)\\])@(blob:.*)",blobParseRegExp:new RegExp("^(blob:.*)(:\\d+:\\d+)$"),getModule:function(e){var t=e.message.match(new RegExp(this.stackTraceFormat,"g"));for(var r in t){var n=t[r].match(new RegExp("^"+this.stackTraceFormat+"$")),o=n[7].match(this.blobParseRegExp);if(o&&UnityLoader.Blobs[o[1]]&&UnityLoader.Blobs[o[1]].Module)return UnityLoader.Blobs[o[1]].Module}},demangle:function(e,t){var r=e.message;return t?(r=r.replace(new RegExp(this.stackTraceFormat,"g"),function(e){var r=e.match(new RegExp("^"+this.stackTraceFormat+"$")),n=r[7].match(this.blobParseRegExp),o=t.demangleSymbol?t.demangleSymbol(r[4]):r[4],i=n&&UnityLoader.Blobs[n[1]]&&UnityLoader.Blobs[n[1]].url?UnityLoader.Blobs[n[1]].url:"blob";return r[1]+o+(r[2]!=o?" ["+r[2]+"]":"")+" ("+(n?i.substr(i.lastIndexOf("/")+1)+n[2]:r[7])+")"}.bind(this)),t.useWasm&&(r=r.replace(new RegExp(this.stackTraceFormatWasm,"g"),function(e){var r=e.match(new RegExp("^"+this.stackTraceFormatWasm+"$")),n=t.demangleSymbol?t.demangleSymbol(r[3]):r[3],o=r[4].match(this.blobParseRegExp),i=o&&UnityLoader.Blobs[o[1]]&&UnityLoader.Blobs[o[1]].url?UnityLoader.Blobs[o[1]].url:"blob";return(n==r[3]?r[1]:r[2]+n+" [wasm:"+r[3]+"]")+(r[4]?" ("+(o?i.substr(i.lastIndexOf("/")+1)+o[2]:r[4])+")":"")}.bind(this))),r):r},handler:function(e,t){var r=t?this.demangle(e,t):e.message;if(!(t&&t.errorhandler&&t.errorhandler(r,e.filename,e.lineno)||(console.log("Invoking error handler due to\n"+r),"function"==typeof dump&&dump("Invoking error handler due to\n"+r),r.indexOf("UnknownError")!=-1||r.indexOf("Program terminated with exit(0)")!=-1||this.didShowErrorMessage))){var r="An error occurred running the Unity content on this page. See your browser JavaScript console for more info. The error was:\n"+r;r.indexOf("DISABLE_EXCEPTION_CATCHING")!=-1?r="An exception has occurred, but exception handling has been disabled in this build. If you are the developer of this content, enable exceptions in your project WebGL player settings to be able to catch the exception or see the stack trace.":r.indexOf("Cannot enlarge memory arrays")!=-1?r="Out of memory. If you are the developer of this content, try allocating more memory to your WebGL build in the WebGL player settings.":r.indexOf("Invalid array buffer length")==-1&&r.indexOf("Invalid typed array length")==-1&&r.indexOf("out of memory")==-1&&r.indexOf("could not allocate memory")==-1||(r="The browser could not allocate enough memory for the WebGL content. If you are the developer of this content, try allocating less memory to your WebGL build in the WebGL player settings."),alert(r),this.didShowErrorMessage=!0}},popup:function(e,t,r){r=r||[{text:"OK"}];var n=document.createElement("div");n.style.cssText="position: absolute; top: 50%; left: 50%; -webkit-transform: translate(-50%, -50%); transform: translate(-50%, -50%); text-align: center; border: 1px solid black; padding: 5px; background: #E8E8E8";var o=document.createElement("span");o.textContent=t,n.appendChild(o),n.appendChild(document.createElement("br"));for(var i=0;i<r.length;i++){var a=document.createElement("button");r[i].text&&(a.textContent=r[i].text),r[i].callback&&(a.onclick=r[i].callback),a.style.margin="5px",a.addEventListener("click",function(){e.container.removeChild(n)}),n.appendChild(a)}e.container.appendChild(n)}},Job:{schedule:function(e,t,r,n,o){o=o||{};var i=e.Jobs[t];if(i||(i=e.Jobs[t]={dependencies:{},dependants:{}}),i.callback)throw"[UnityLoader.Job.schedule] job '"+t+"' has been already scheduled";if("function"!=typeof n)throw"[UnityLoader.Job.schedule] job '"+t+"' has invalid callback";if("object"!=typeof o)throw"[UnityLoader.Job.schedule] job '"+t+"' has invalid parameters";i.callback=function(e,t){i.starttime=performance.now(),n(e,t)},i.parameters=o,i.complete=function(r){i.endtime=performance.now(),i.result={value:r};for(var n in i.dependants){var o=e.Jobs[n];o.dependencies[t]=i.dependants[n]=!1;var a="function"!=typeof o.callback;for(var s in o.dependencies)a=a||o.dependencies[s];if(!a){if(o.executed)throw"[UnityLoader.Job.schedule] job '"+t+"' has already been executed";o.executed=!0,setTimeout(o.callback.bind(null,e,o),0)}}};var a=!1;r.forEach(function(r){var n=e.Jobs[r];n||(n=e.Jobs[r]={dependencies:{},dependants:{}}),(i.dependencies[r]=n.dependants[t]=!n.result)&&(a=!0)}),a||(i.executed=!0,setTimeout(i.callback.bind(null,e,i),0))},result:function(e,t){var r=e.Jobs[t];if(!r)throw"[UnityLoader.Job.result] job '"+t+"' does not exist";if("object"!=typeof r.result)throw"[UnityLoader.Job.result] job '"+t+"' has invalid result";return r.result.value}},Progress:{Styles:{Dark:{progressLogoUrl:"data:image/png;base64,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",progressEmptyUrl:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAI0AAAASCAYAAABmbl0zAAAACXBIWXMAAAsSAAALEgHS3X78AAAATUlEQVRo3u3aIQ4AIAwEQUr4/5cPiyMVBDOj0M2mCKgkGdAwjYCudZzLOLiITYPrCdEgGkSDaEA0iAbRIBpEA6JBNHx1vnL7V4NNwxsbCNMGI3YImu0AAAAASUVORK5CYII=",progressFullUrl:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAI0AAAASCAYAAABmbl0zAAAACXBIWXMAAAsSAAALEgHS3X78AAAAO0lEQVRo3u3SQREAAAjDMMC/56EB3omEXjtJCg5GAkyDaTANpsE0YBpMg2kwDaYB02AaTINpMA2Yhr8FO18EIBpZMeQAAAAASUVORK5CYII="},Light:{progressLogoUrl:"data:image/png;base64,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",progressEmptyUrl:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAI0AAAASCAYAAABmbl0zAAAACXBIWXMAAAsSAAALEgHS3X78AAAAUUlEQVRo3u3aMQ4AEAxAUcRJzGb3v1mt3cQglvcmc/NTA3XMFQUuNCPgVk/nahwchE2D6wnRIBpEg2hANIgG0SAaRAOiQTR8lV+5/avBpuGNDcz6A6oq1CgNAAAAAElFTkSuQmCC",progressFullUrl:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAI0AAAASCAYAAABmbl0zAAAACXBIWXMAAAsSAAALEgHS3X78AAAAQElEQVRo3u3SMREAMAgAsVIpnTvj3xlogDmR8PfxftaBgSsBpsE0mAbTYBowDabBNJgG04BpMA2mwTSYBkzDXgP/hgGnr4PpeAAAAABJRU5ErkJggg=="}},handler:function(e,t){if(e.Module){var r=UnityLoader.Progress.Styles[e.Module.splashScreenStyle],n=e.Module.progressLogoUrl?e.Module.resolveBuildUrl(e.Module.progressLogoUrl):r.progressLogoUrl,o=e.Module.progressEmptyUrl?e.Module.resolveBuildUrl(e.Module.progressEmptyUrl):r.progressEmptyUrl,i=e.Module.progressFullUrl?e.Module.resolveBuildUrl(e.Module.progressFullUrl):r.progressFullUrl,a="position: absolute; left: 50%; top: 50%; -webkit-transform: translate(-50%, -50%); transform: translate(-50%, -50%);";e.logo||(e.logo=document.createElement("div"),e.logo.style.cssText=a+"background: url('"+n+"') no-repeat center / contain; width: 154px; height: 130px;",e.container.appendChild(e.logo)),e.progress||(e.progress=document.createElement("div"),e.progress.style.cssText=a+" height: 18px; width: 141px; margin-top: 90px;",e.progress.empty=document.createElement("div"),e.progress.empty.style.cssText="background: url('"+o+"') no-repeat right / cover; float: right; width: 100%; height: 100%; display: inline-block;",e.progress.appendChild(e.progress.empty),e.progress.full=document.createElement("div"),e.progress.full.style.cssText="background: url('"+i+"') no-repeat left / cover; float: left; width: 0%; height: 100%; display: inline-block;",e.progress.appendChild(e.progress.full),e.container.appendChild(e.progress)),e.progress.full.style.width=100*t+"%",e.progress.empty.style.width=100*(1-t)+"%",1==t&&(e.logo.style.display=e.progress.style.display="none")}},update:function(e,t,r){var n=e.buildDownloadProgress[t];n||(n=e.buildDownloadProgress[t]={started:!1,finished:!1,lengthComputable:!1,total:0,loaded:0}),"object"!=typeof r||"progress"!=r.type&&"load"!=r.type||(n.started||(n.started=!0,n.lengthComputable=r.lengthComputable,n.total=r.total),n.loaded=r.loaded,"load"==r.type&&(n.finished=!0));var o=0,i=0,a=0,s=0,d=0;for(var t in e.buildDownloadProgress){var n=e.buildDownloadProgress[t];if(!n.started)return 0;a++,n.lengthComputable?(o+=n.loaded,i+=n.total,s++):n.finished||d++}var l=a?(a-d-(i?s*(i-o)/i:0))/a:0;e.unityInstance.onProgress(e.unityInstance,.9*l)}},SystemInfo:function(){var e,t,r,n="-",o=navigator.appVersion,i=navigator.userAgent,a=navigator.appName,s=navigator.appVersion,d=parseInt(navigator.appVersion,10);(t=i.indexOf("Opera"))!=-1?(a="Opera",s=i.substring(t+6),(t=i.indexOf("Version"))!=-1&&(s=i.substring(t+8))):(t=i.indexOf("MSIE"))!=-1?(a="Microsoft Internet Explorer",s=i.substring(t+5)):(t=i.indexOf("Edge"))!=-1?(a="Edge",s=i.substring(t+5)):(t=i.indexOf("Chrome"))!=-1?(a="Chrome",s=i.substring(t+7)):(t=i.indexOf("Safari"))!=-1?(a="Safari",s=i.substring(t+7),(t=i.indexOf("Version"))!=-1&&(s=i.substring(t+8))):(t=i.indexOf("Firefox"))!=-1?(a="Firefox",s=i.substring(t+8)):i.indexOf("Trident/")!=-1?(a="Microsoft Internet Explorer",s=i.substring(i.indexOf("rv:")+3)):(e=i.lastIndexOf(" ")+1)<(t=i.lastIndexOf("/"))&&(a=i.substring(e,t),s=i.substring(t+1),a.toLowerCase()==a.toUpperCase()&&(a=navigator.appName)),(r=s.indexOf(";"))!=-1&&(s=s.substring(0,r)),(r=s.indexOf(" "))!=-1&&(s=s.substring(0,r)),(r=s.indexOf(")"))!=-1&&(s=s.substring(0,r)),d=parseInt(""+s,10),isNaN(d)?(s=""+parseFloat(navigator.appVersion),d=parseInt(navigator.appVersion,10)):s=""+parseFloat(s);var l=/Mobile|mini|Fennec|Android|iP(ad|od|hone)/.test(o),u=n,c=[{s:"Windows 3.11",r:/Win16/},{s:"Windows 95",r:/(Windows 95|Win95|Windows_95)/},{s:"Windows ME",r:/(Win 9x 4.90|Windows ME)/},{s:"Windows 98",r:/(Windows 98|Win98)/},{s:"Windows CE",r:/Windows CE/},{s:"Windows 2000",r:/(Windows NT 5.0|Windows 2000)/},{s:"Windows XP",r:/(Windows NT 5.1|Windows XP)/},{s:"Windows Server 2003",r:/Windows NT 5.2/},{s:"Windows Vista",r:/Windows NT 6.0/},{s:"Windows 7",r:/(Windows 7|Windows NT 6.1)/},{s:"Windows 8.1",r:/(Windows 8.1|Windows NT 6.3)/},{s:"Windows 8",r:/(Windows 8|Windows NT 6.2)/},{s:"Windows 10",r:/(Windows 10|Windows NT 10.0)/},{s:"Windows NT 4.0",r:/(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/},{s:"Windows ME",r:/Windows ME/},{s:"Android",r:/Android/},{s:"Open BSD",r:/OpenBSD/},{s:"Sun OS",r:/SunOS/},{s:"Linux",r:/(Linux|X11)/},{s:"iOS",r:/(iPhone|iPad|iPod)/},{s:"Mac OS X",r:/Mac OS X/},{s:"Mac OS",r:/(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/},{s:"QNX",r:/QNX/},{s:"UNIX",r:/UNIX/},{s:"BeOS",r:/BeOS/},{s:"OS/2",r:/OS\/2/},{s:"Search Bot",r:/(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\/Teoma|ia_archiver)/}];for(var f in c){var h=c[f];if(h.r.test(i)){u=h.s;break}}var p=n;switch(/Windows/.test(u)&&(p=/Windows (.*)/.exec(u)[1],u="Windows"),u){case"Mac OS X":p=/Mac OS X (10[\.\_\d]+)/.exec(i)[1];break;case"Android":p=/Android ([\.\_\d]+)/.exec(i)[1];break;case"iOS":p=/OS (\d+)_(\d+)_?(\d+)?/.exec(o),p=p[1]+"."+p[2]+"."+(0|p[3])}return{width:screen.width?screen.width:0, height:screen.height?screen.height:0,browser:a,browserVersion:s,mobile:l,os:u,osVersion:p,gpu:function(){var e=document.createElement("canvas"),t=e.getContext("experimental-webgl");if(t){var r=t.getExtension("WEBGL_debug_renderer_info");if(r)return t.getParameter(r.UNMASKED_RENDERER_WEBGL)}return n}(),language:window.navigator.userLanguage||window.navigator.language,hasWebGL:function(){if(!window.WebGLRenderingContext)return 0;var e=document.createElement("canvas"),t=e.getContext("webgl2");return t?2:(t=e.getContext("experimental-webgl2"),t?2:(t=e.getContext("webgl"),t||(t=e.getContext("experimental-webgl"))?1:0))}(),hasCursorLock:function(){var e=document.createElement("canvas");return e.requestPointerLock||e.mozRequestPointerLock||e.webkitRequestPointerLock||e.msRequestPointerLock?1:0}(),hasFullscreen:function(){var e=document.createElement("canvas");return(e.requestFullScreen||e.mozRequestFullScreen||e.msRequestFullscreen||e.webkitRequestFullScreen)&&(a.indexOf("Safari")==-1||s>=10.1)?1:0}(),hasThreads:"undefined"!=typeof SharedArrayBuffer,hasWasm:"object"==typeof WebAssembly&&"function"==typeof WebAssembly.validate&&"function"==typeof WebAssembly.compile,hasWasmThreads:function(){if("object"!=typeof WebAssembly)return!1;if("undefined"==typeof SharedArrayBuffer)return!1;var e=new WebAssembly.Memory({initial:1,maximum:1,shared:!0}),t=e.buffer instanceof SharedArrayBuffer;return delete e,t}()}}(),compatibilityCheck:function(e,t,r){UnityLoader.SystemInfo.hasWebGL?UnityLoader.SystemInfo.mobile?e.popup("Please note that Unity WebGL is not currently supported on mobiles. Press OK if you wish to continue anyway.",[{text:"OK",callback:t}]):["Edge","Firefox","Chrome","Safari"].indexOf(UnityLoader.SystemInfo.browser)==-1?e.popup("Please note that your browser is not currently supported for this Unity WebGL content. Press OK if you wish to continue anyway.",[{text:"OK",callback:t}]):t():e.popup("Your browser does not support WebGL",[{text:"OK",callback:r}])},buildCompatibilityCheck:function(e,t,r){function n(){if("undefined"==typeof e.graphicsAPI)return!0;for(var t=0;t<e.graphicsAPI.length;t++){var r=e.graphicsAPI[t];if("WebGL 2.0"==r&&2==UnityLoader.SystemInfo.hasWebGL)return!0;if("WebGL 1.0"==r&&UnityLoader.SystemInfo.hasWebGL>=1)return!0;e.print("Warning: Unsupported graphics API "+r)}return!1}n()?!UnityLoader.SystemInfo.hasThreads&&e.multithreading?r("Your browser does not support multithreading."):t():r("Your browser does not support any of the required graphics API for this content.")},Blobs:{},loadCode:function(e,t,r,n){var o=[].slice.call(UnityLoader.Cryptography.md5(t)).map(function(e){return("0"+e.toString(16)).substr(-2)}).join(""),i=document.createElement("script"),a=(n.isModularized?function(e){return new Blob([e],{type:"application/javascript"})}:function(e,t){return new Blob(['UnityLoader["'+t+'"]=',e],{type:"text/javascript"})})(t,o),s=URL.createObjectURL(a);UnityLoader.Blobs[s]=n,e.deinitializers.push(function(){delete UnityLoader.Blobs[s],delete UnityLoader[o],document.body.removeChild(document.getElementById(o))}),i.src=s,i.id=o,i.onload=function(){e.developmentBuild||URL.revokeObjectURL(s),r(o,a),delete i.onload},document.body.appendChild(i)},setupIndexedDBJob:function(e,t){function r(n){r.called||(r.called=!0,e.indexedDB=n,t.complete())}try{var n=window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB,o=n.open("/idbfs-test");o.onerror=function(e){e.preventDefault(),r()},o.onsuccess=function(){o.result.close(),r(n)}}catch(e){r()}},processWasmCodeJob:function(e,t){e.wasmBinary=UnityLoader.Job.result(e,"downloadWasmCode"),t.complete()},processWasmFrameworkJob:function(e,t){var r=UnityLoader.Job.result(e,"downloadWasmFramework");UnityLoader.loadCode(e,r,function(r,n){e.mainScriptUrlOrBlob=n,e.isModularized&&(UnityLoader[r]=UnityModule),UnityLoader[r](e),t.complete()},{Module:e,url:e.wasmFrameworkUrl,isModularized:e.isModularized})},processAsmCodeJob:function(e,t){var r=UnityLoader.Job.result(e,"downloadAsmCode");UnityLoader.loadCode(e,Math.fround?r:UnityLoader.Utils.optimizeMathFround(r),function(r,n){e.isModularized?e.asmJsUrlOrBlob=n:e.asm=UnityLoader[r],t.complete()},{Module:e,url:e.asmCodeUrl,isModularized:e.isModularized})},processAsmFrameworkJob:function(e,t){var r=UnityLoader.Job.result(e,"downloadAsmFramework");UnityLoader.loadCode(e,r,function(r,n){e.isModularized&&(e.mainScriptUrlOrBlob=n,UnityLoader[r]=UnityModule),UnityLoader[r](e),t.complete()},{Module:e,url:e.asmFrameworkUrl,isModularized:e.isModularized})},processMemoryInitializerJob:function(e,t){e.memoryInitializerRequest.status=200,e.memoryInitializerRequest.response=UnityLoader.Job.result(e,"downloadMemoryInitializer"),e.memoryInitializerRequest.callback&&e.memoryInitializerRequest.callback(),t.complete()},processDataJob:function(e,t){var r=UnityLoader.Job.result(e,"downloadData"),n=new DataView(r.buffer,r.byteOffset,r.byteLength),o=0,i="UnityWebData1.0\0";if(!String.fromCharCode.apply(null,r.subarray(o,o+i.length))==i)throw"unknown data format";o+=i.length;var a=n.getUint32(o,!0);for(o+=4;o<a;){var s=n.getUint32(o,!0);o+=4;var d=n.getUint32(o,!0);o+=4;var l=n.getUint32(o,!0);o+=4;var u=String.fromCharCode.apply(null,r.subarray(o,o+l));o+=l;for(var c=0,f=u.indexOf("/",c)+1;f>0;c=f,f=u.indexOf("/",c)+1)e.FS_createPath(u.substring(0,c),u.substring(c,f-1),!0,!0);e.FS_createDataFile(u,null,r.subarray(s,s+d),!0,!0,!0)}e.removeRunDependency("processDataJob"),t.complete()},downloadJob:function(e,t){var r=t.parameters.objParameters?new UnityLoader.UnityCache.XMLHttpRequest(t.parameters.objParameters):new XMLHttpRequest;r.open("GET",t.parameters.url),r.responseType="arraybuffer",r.onload=function(){UnityLoader.Compression.decompress(new Uint8Array(r.response),function(e){t.complete(e)})},t.parameters.onprogress&&r.addEventListener("progress",t.parameters.onprogress),t.parameters.onload&&r.addEventListener("load",t.parameters.onload),r.send()},scheduleBuildDownloadJob:function(e,t,r){UnityLoader.Progress.update(e,t),UnityLoader.Job.schedule(e,t,[],UnityLoader.downloadJob,{url:e.resolveBuildUrl(e[r]),onprogress:function(r){UnityLoader.Progress.update(e,t,r)},onload:function(r){UnityLoader.Progress.update(e,t,r)},objParameters:e.companyName&&e.productName&&e.cacheControl&&(e.cacheControl[r]||e.cacheControl.default)?{companyName:e.companyName,productName:e.productName,cacheControl:e.cacheControl[r]||e.cacheControl.default}:null})},loadModule:function(e,t){if(e.useWasm=e.wasmCodeUrl&&UnityLoader.SystemInfo.hasWasm,e.useWasm){if(e.multithreading&&!UnityLoader.SystemInfo.hasWasmThreads)return void t("Your browser does not support WebAssembly Threads.");var r=["downloadWasmFramework","setupIndexedDB"];e.wasmCodeUrl.endsWith(".unityweb")&&(UnityLoader.scheduleBuildDownloadJob(e,"downloadWasmCode","wasmCodeUrl"),UnityLoader.Job.schedule(e,"processWasmCode",["downloadWasmCode"],UnityLoader.processWasmCodeJob),r.push("processWasmCode")),e.wasmMemoryUrl&&(UnityLoader.scheduleBuildDownloadJob(e,"downloadMemoryInitializer","wasmMemoryUrl"),UnityLoader.Job.schedule(e,"processMemoryInitializer",["downloadMemoryInitializer"],UnityLoader.processMemoryInitializerJob),e.memoryInitializerRequest={addEventListener:function(t,r){e.memoryInitializerRequest.callback=r}}),UnityLoader.scheduleBuildDownloadJob(e,"downloadWasmFramework","wasmFrameworkUrl"),UnityLoader.Job.schedule(e,"processWasmFramework",r,UnityLoader.processWasmFrameworkJob)}else{if(!e.asmCodeUrl)return void t("Your browser does not support WebAssembly.");UnityLoader.scheduleBuildDownloadJob(e,"downloadAsmCode","asmCodeUrl"),UnityLoader.Job.schedule(e,"processAsmCode",["downloadAsmCode"],UnityLoader.processAsmCodeJob),UnityLoader.scheduleBuildDownloadJob(e,"downloadMemoryInitializer","asmMemoryUrl"),UnityLoader.Job.schedule(e,"processMemoryInitializer",["downloadMemoryInitializer"],UnityLoader.processMemoryInitializerJob),e.memoryInitializerRequest={addEventListener:function(t,r){e.memoryInitializerRequest.callback=r}},e.asmLibraryUrl&&(e.dynamicLibraries=[e.asmLibraryUrl].map(e.resolveBuildUrl)),UnityLoader.scheduleBuildDownloadJob(e,"downloadAsmFramework","asmFrameworkUrl"),UnityLoader.Job.schedule(e,"processAsmFramework",["downloadAsmFramework","processAsmCode","setupIndexedDB"],UnityLoader.processAsmFrameworkJob)}UnityLoader.scheduleBuildDownloadJob(e,"downloadData","dataUrl"),UnityLoader.Job.schedule(e,"setupIndexedDB",[],UnityLoader.setupIndexedDBJob),e.preRun.push(function(){e.addRunDependency("processDataJob"),UnityLoader.Job.schedule(e,"processData",["downloadData"],UnityLoader.processDataJob)})},instantiate:function(e,t,r){function n(e,n){if("string"==typeof e&&!(e=document.getElementById(e)))return!1;e.innerHTML="",e.style.border=e.style.margin=e.style.padding=0,"static"==getComputedStyle(e).getPropertyValue("position")&&(e.style.position="relative"),e.style.width=n.width||e.style.width,e.style.height=n.height||e.style.height,n.container=e;var o=n.Module;o.canvas=document.createElement("canvas"),o.canvas.style.width="100%",o.canvas.style.height="100%",o.canvas.addEventListener("contextmenu",function(e){e.preventDefault()}),o.canvas.addEventListener("dragstart",function(e){e.preventDefault()}),o.canvas.id="#canvas",e.appendChild(o.canvas),o.deinitializers.push(function(){e.removeChild(o.canvas)});var i=!0;return n.compatibilityCheck(n,function(){var t=new XMLHttpRequest;t.open("GET",n.url,!0),t.responseType="text",t.onerror=function(){o.print("Could not download "+n.url),0==document.URL.indexOf("file:")&&alert("It seems your browser does not support running Unity WebGL content from file:// urls. Please upload it to an http server, or try a different browser.")},t.onload=function(){var a=JSON.parse(t.responseText);for(var s in a)"undefined"==typeof o[s]&&(o[s]=a[s]);if(o.unityVersion){var d=o.unityVersion.match(/(\d+)\.(\d+)\.(\d+)(.+)/);d&&(o.unityVersion={string:o.unityVersion,version:parseInt(d[0]),major:parseInt(d[1]),minor:parseInt(d[2]),suffix:d[3]})}o.isModularized=o.unityVersion&&o.unityVersion.version>=2019,UnityLoader.buildCompatibilityCheck(o,function(){e.style.background=o.backgroundUrl?"center/cover url('"+o.resolveBuildUrl(o.backgroundUrl)+"')":o.backgroundColor?" "+o.backgroundColor:"",n.onProgress(n,0),i=UnityLoader.loadModule(o,r.onerror)},r.onerror)},t.send()},function(){var e="Instantiation of '"+t+"' terminated due to the failed compatibility check.";"object"==typeof r&&"function"==typeof r.onerror?r.onerror(e):o.printErr(e)}),i}function o(e){return o.link=o.link||document.createElement("a"),o.link.href=e,o.link.href}"undefined"==typeof r&&(r={}),"undefined"==typeof r.onerror&&(r.onerror=function(e){i.popup(e,[{text:"OK"}])});var i={url:t,onProgress:UnityLoader.Progress.handler,compatibilityCheck:UnityLoader.compatibilityCheck,Module:{deinitializers:[],intervals:{},setInterval:function(e,t){var r=window.setInterval(e,t);return this.intervals[r]=!0,r},clearInterval:function(e){delete this.intervals[e],window.clearInterval(e)},onAbort:function(e){throw void 0!==e?(this.print(e),this.printErr(e),e=JSON.stringify(e)):e="","abort("+e+") at "+this.stackTrace()},preRun:[],postRun:[],print:function(e){console.log(e)},printErr:function(e){console.error(e)},Jobs:{},buildDownloadProgress:{},resolveBuildUrl:function(e){return e.match(/(http|https|ftp|file):\/\//)?e:t.substring(0,t.lastIndexOf("/")+1)+e},streamingAssetsUrl:function(){return o(this.resolveBuildUrl("../StreamingAssets"))},locateFile:function(e){return"Build/".concat("build.wasm"==e?this.wasmCodeUrl:e)}},SetFullscreen:function(){if(i.Module.SetFullscreen)return i.Module.SetFullscreen.apply(i.Module,arguments)},SendMessage:function(){if(i.Module.SendMessage)return i.Module.SendMessage.apply(i.Module,arguments)},Quit:function(e){"function"==typeof e&&(i.Module.onQuit=e),i.Module.shouldQuit=!0}};i.Module.unityInstance=i,i.popup=function(e,t){return UnityLoader.Error.popup(i,e,t)},i.Module.postRun.push(function(){i.onProgress(i,1),"object"==typeof r&&"function"==typeof r.onsuccess&&r.onsuccess(i.Module)});for(var a in r)if("Module"==a)for(var s in r[a])i.Module[s]=r[a][s];else i[a]=r[a];return n(e,i)||document.addEventListener("DOMContentLoaded",function(){n(e,i)}),i},instantiateAsync:function(e,t,r){return new Promise(function(n,o){const i=Object.assign({onsuccess:function(e){n(e)},onerror:function(e){o(e)}},r);UnityLoader.instantiate(e,t,i)})},Utils:{assert:function(e,t){e||abort("Assertion failed: "+t)},optimizeMathFround:function(e,t){console.log("optimizing out Math.fround calls");for(var r={LOOKING_FOR_MODULE:0,SCANNING_MODULE_VARIABLES:1,SCANNING_MODULE_FUNCTIONS:2},n=["EMSCRIPTEN_START_ASM","EMSCRIPTEN_START_FUNCS","EMSCRIPTEN_END_FUNCS"],o="var",i="global.Math.fround;",a=0,s=t?r.LOOKING_FOR_MODULE:r.SCANNING_MODULE_VARIABLES,d=0,l=0;s<=r.SCANNING_MODULE_FUNCTIONS&&a<e.length;a++)if(47==e[a]&&47==e[a+1]&&32==e[a+2]&&String.fromCharCode.apply(null,e.subarray(a+3,a+3+n[s].length))===n[s])s++;else if(s!=r.SCANNING_MODULE_VARIABLES||l||61!=e[a]||String.fromCharCode.apply(null,e.subarray(a+1,a+1+i.length))!==i){if(l&&40==e[a]){for(var u=0;u<l&&e[a-1-u]==e[d-u];)u++;if(u==l){var c=e[a-1-u];if(c<36||36<c&&c<48||57<c&&c<65||90<c&&c<95||95<c&&c<97||122<c)for(;u;u--)e[a-u]=32}}}else{for(d=a-1;32!=e[d-l];)l++;l&&String.fromCharCode.apply(null,e.subarray(d-l-o.length,d-l))===o||(d=l=0)}return e}},UnityCache:function(){function e(e){console.log("[UnityCache] "+e)}function t(e){return t.link=t.link||document.createElement("a"),t.link.href=e,t.link.href}function r(e){var t=window.location.href.match(/^[a-z]+:\/\/[^\/]+/);return!t||e.lastIndexOf(t[0],0)}function n(){function t(t){if("undefined"==typeof n.database)for(n.database=t,n.database||e("indexedDB database could not be opened");n.queue.length;){var r=n.queue.shift();n.database?n.execute.apply(n,r):"function"==typeof r.onerror&&r.onerror(new Error("operation cancelled"))}}function r(){var e=o.open(a.name,a.version);e.onupgradeneeded=function(e){var t=e.target.result;t.objectStoreNames.contains(d.name)||t.createObjectStore(d.name)},e.onsuccess=function(e){t(e.target.result)},e.onerror=function(){t(null)}}var n=this;n.queue=[];try{var o=window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB,i=o.open(a.name);i.onupgradeneeded=function(e){var t=e.target.result.createObjectStore(s.name,{keyPath:"url"});["version","company","product","updated","revalidated","accessed"].forEach(function(e){t.createIndex(e,e)})},i.onsuccess=function(e){var n=e.target.result;n.version<a.version?(n.close(),r()):t(n)},i.onerror=function(){t(null)}}catch(e){t(null)}}function o(e,t,r,n,o){var i={url:e,version:s.version,company:t,product:r,updated:n,revalidated:n,accessed:n,responseHeaders:{},xhr:{}};return o&&(["Last-Modified","ETag"].forEach(function(e){i.responseHeaders[e]=o.getResponseHeader(e)}),["responseURL","status","statusText","response"].forEach(function(e){i.xhr[e]=o[e]})),i}function i(t){this.cache={enabled:!1},t&&(this.cache.control=t.cacheControl,this.cache.company=t.companyName,this.cache.product=t.productName),this.xhr=new XMLHttpRequest(t),this.xhr.addEventListener("load",function(){var t=this.xhr,r=this.cache;r.enabled&&!r.revalidated&&(304==t.status?(r.result.revalidated=r.result.accessed,r.revalidated=!0,l.execute(s.name,"put",[r.result]),e("'"+r.result.url+"' successfully revalidated and served from the indexedDB cache")):200==t.status?(r.result=o(r.result.url,r.company,r.product,r.result.accessed,t),r.revalidated=!0,l.execute(s.name,"put",[r.result],function(t){e("'"+r.result.url+"' successfully downloaded and stored in the indexedDB cache")},function(t){e("'"+r.result.url+"' successfully downloaded but not stored in the indexedDB cache due to the error: "+t)})):e("'"+r.result.url+"' request failed with status: "+t.status+" "+t.statusText))}.bind(this))}var a={name:"UnityCache",version:2},s={name:"XMLHttpRequest",version:1},d={name:"WebAssembly",version:1};n.prototype.execute=function(e,t,r,n,o){if(this.database)try{var i=this.database.transaction([e],["put","delete","clear"].indexOf(t)!=-1?"readwrite":"readonly").objectStore(e);"openKeyCursor"==t&&(i=i.index(r[0]),r=r.slice(1));var a=i[t].apply(i,r);"function"==typeof n&&(a.onsuccess=function(e){n(e.target.result)}),a.onerror=o}catch(e){"function"==typeof o&&o(e)}else"undefined"==typeof this.database?this.queue.push(arguments):"function"==typeof o&&o(new Error("indexedDB access denied"))};var l=new n;i.prototype.send=function(t){var n=this.xhr,o=this.cache,i=arguments;return o.enabled=o.enabled&&"arraybuffer"==n.responseType&&!t,o.enabled?void l.execute(s.name,"get",[o.result.url],function(t){if(!t||t.version!=s.version)return void n.send.apply(n,i);if(o.result=t,o.result.accessed=Date.now(),"immutable"==o.control)o.revalidated=!0,l.execute(s.name,"put",[o.result]),n.dispatchEvent(new Event("load")),e("'"+o.result.url+"' served from the indexedDB cache without revalidation");else if(r(o.result.url)&&(o.result.responseHeaders["Last-Modified"]||o.result.responseHeaders.ETag)){var a=new XMLHttpRequest;a.open("HEAD",o.result.url),a.onload=function(){o.revalidated=["Last-Modified","ETag"].every(function(e){return!o.result.responseHeaders[e]||o.result.responseHeaders[e]==a.getResponseHeader(e)}),o.revalidated?(o.result.revalidated=o.result.accessed,l.execute(s.name,"put",[o.result]),n.dispatchEvent(new Event("load")),e("'"+o.result.url+"' successfully revalidated and served from the indexedDB cache")):n.send.apply(n,i)},a.send()}else o.result.responseHeaders["Last-Modified"]?(n.setRequestHeader("If-Modified-Since",o.result.responseHeaders["Last-Modified"]),n.setRequestHeader("Cache-Control","no-cache")):o.result.responseHeaders.ETag&&(n.setRequestHeader("If-None-Match",o.result.responseHeaders.ETag),n.setRequestHeader("Cache-Control","no-cache")),n.send.apply(n,i)},function(e){n.send.apply(n,i)}):n.send.apply(n,i)},i.prototype.open=function(e,r,n,i,a){return this.cache.result=o(t(r),this.cache.company,this.cache.product,Date.now()),this.cache.enabled=["must-revalidate","immutable"].indexOf(this.cache.control)!=-1&&"GET"==e&&this.cache.result.url.match("^https?://")&&("undefined"==typeof n||n)&&"undefined"==typeof i&&"undefined"==typeof a,this.cache.revalidated=!1,this.xhr.open.apply(this.xhr,arguments)},i.prototype.setRequestHeader=function(e,t){return this.cache.enabled=!1,this.xhr.setRequestHeader.apply(this.xhr,arguments)};var u=new XMLHttpRequest;for(var c in u)i.prototype.hasOwnProperty(c)||!function(e){Object.defineProperty(i.prototype,e,"function"==typeof u[e]?{value:function(){return this.xhr[e].apply(this.xhr,arguments)}}:{get:function(){return this.cache.revalidated&&this.cache.result.xhr.hasOwnProperty(e)?this.cache.result.xhr[e]:this.xhr[e]},set:function(t){this.xhr[e]=t}})}(c);return{XMLHttpRequest:i,WebAssembly:{get:function(e,r){var n={url:t(e),version:d.version,module:null,md5:null};l.execute(d.name,"get",[n.url],function(e){r(e&&e.version==d.version?e:n)},function(){r(n)})},put:function(e,t,r){l.execute(d.name,"put",[e,e.url],t,r)}}}}()};

File no 3: /FIRST AID PROJECT/APPS/TemplateData/UnityProgress.js
function UnityProgress(unityInstance, progress) { if (!unityInstance.Module) return; if (!unityInstance.logo) { unityInstance.logo = document.createElement("div"); unityInstance.logo.className = "logo " + unityInstance.Module.splashScreenStyle; unityInstance.container.appendChild(unityInstance.logo); } if (!unityInstance.progress) { unityInstance.progress = document.createElement("div"); unityInstance.progress.className = "progress " + unityInstance.Module.splashScreenStyle; unityInstance.progress.empty = document.createElement("div"); unityInstance.progress.empty.className = "empty"; unityInstance.progress.appendChild(unityInstance.progress.empty); unityInstance.progress.full = document.createElement("div"); unityInstance.progress.full.className = "full"; unityInstance.progress.appendChild(unityInstance.progress.full); unityInstance.container.appendChild(unityInstance.progress); } unityInstance.progress.full.style.width = (100 * progress) + "%"; unityInstance.progress.empty.style.width = (100 * (1 - progress)) + "%"; if (progress == 1) unityInstance.logo.style.display = unityInstance.progress.style.display = "none"; }

File no 4: /FIRST AID PROJECT/APPS/TemplateData/style.css
.webgl-content * {border: 0; margin: 0; padding: 0} .webgl-content {position: absolute; top: 50%; left: 50%; -webkit-transform: translate(-50%, -50%); transform: translate(-50%, -50%);} .webgl-content .logo, .progress {position: absolute; left: 50%; top: 50%; -webkit-transform: translate(-50%, -50%); transform: translate(-50%, -50%);} .webgl-content .logo {background: url('progressLogo.Light.png') no-repeat center / contain; width: 154px; height: 130px;} .webgl-content .progress {height: 18px; width: 141px; margin-top: 90px;} .webgl-content .progress .empty {background: url('progressEmpty.Light.png') no-repeat right / cover; float: right; width: 100%; height: 100%; display: inline-block;} .webgl-content .progress .full {background: url('progressFull.Light.png') no-repeat left / cover; float: left; width: 0%; height: 100%; display: inline-block;} .webgl-content .logo.Dark {background-image: url('progressLogo.Dark.png');} .webgl-content .progress.Dark .empty {background-image: url('progressEmpty.Dark.png');} .webgl-content .progress.Dark .full {background-image: url('progressFull.Dark.png');} .webgl-content .footer {margin-top: 5px; height: 38px; line-height: 38px; font-family: Helvetica, Verdana, Arial, sans-serif; font-size: 18px;} .webgl-content .footer .webgl-logo, .title, .fullscreen {height: 100%; display: inline-block; background: transparent center no-repeat;} .webgl-content .footer .webgl-logo {background-image: url('webgl-logo.png'); width: 204px; float: left;} .webgl-content .footer .title {margin-right: 10px; float: right;} .webgl-content .footer .fullscreen {background-image: url('fullscreen.png'); width: 38px; float: right;}

File no 5: /FIRST AID PROJECT/APPS/index.html
<!DOCTYPE html> <html lang="en-us"> <head> <meta charset="utf-8"> <meta http-equiv="Content-Type" content="text/html; charset=utf-8"> <title>Unity WebGL Player | FIRST AID PROJECT</title> <link rel="shortcut icon" href="TemplateData/favicon.ico"> <link rel="stylesheet" href="TemplateData/style.css"> <script src="TemplateData/UnityProgress.js"></script> <script src="Build/UnityLoader.js"></script> <script> var unityInstance = UnityLoader.instantiate("unityContainer", "Build/APPS.json", {onProgress: UnityProgress}); </script> </head> <body> <div class="webgl-content"> <div id="unityContainer" style="width: 960px; height: 600px"></div> <div class="footer"> <div class="webgl-logo"></div> <div class="fullscreen" onclick="unityInstance.SetFullscreen(1)"></div> <div class="title">FIRST AID PROJECT</div> </div> </div> </body> </html>

File no 6: /FIRST AID PROJECT/Assets/assets/fonts/need-for-font/license.txt
My Fonts Are free to use personal and commercial works to. But you can't sell them direktly. Please don't make illegal copies of th fonts. Thankx and regards: Koczman Bálint (Cpr.Sparhelt)

File no 7: /FIRST AID PROJECT/Assets/assets/fonts/perfect-dark-brk/perfectdark.txt
___________________________________ Perfect Dark Created by Brian Kent ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ Thanks for Downloading Perfect Dark. This Font is based on the Logo from the game Perfect Dark. This Font uses Character Extenders [ !@#$%^ ] to give some of the characters in the Font a longer TOP (when you have the letters A, a, D and/or d in your text). For example, if you type out Perfect Dark", type it out like this, Perfect D@a%rk" to give the a and r in Dark extenders. Each Extender is a different size: ! =x1 length @ =x2 length # =x3 length $ =x4 length % =x5 length ^ =x6 length The following characters do not use extenders: CcGgjOoQqSsXx0589"',. The whole Font is made with Capital letters but some of the Characters have more than 1 letter Character. They are: Ee [the e has a slightly higher middle prong like in the PD LOGO] Ff [the f has a slightly higher lower prong like in the PD LOGO] Gg Hh Ii Jj Nn Oo [you can also use 0 and ) for the O's or 0's] Ss [you can also use 5 for an S and vice versa] Uu Vv Xx A few last things. This Font uses A LOT of Kerning to make the Characters fit correctly so make sure what ever program you're using have Character Kerning ON (sometimes if you're using a text editor like Microsoft Word, you usualy have turn the Kerning ON). Finally, to make the Font look more like the Games Logo (slanted), use Italic on the Font. If you have any questions or comments, you can e-mail me at kentpw@norwich.net You can visit my Homepage <ÆNIGMA GAMES & FONTS> at http://aenigma.cellosoft.com/ ________________ INSTALLING FONTS ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ There's a couple of ways to install Fonts. The 'easy' way to install fonts is to just Unzip/place the font file [.ttf] into your Windows\Fonts directory (I always use this method). If you're unable to do it the 'easy' way, then try to do it this way (for Windows 95/98/NT): 1] Unzip the Font(s) to a folder (or somewhere, just remember where you unzipped it) on your Computer. 2] Next, click on the START button, then select SETTINGS then CONTROL PANEL. 3] When the Control Panel Window pops up, Double Click on FONTS. 4] When the FONTS window pops up, select File then Install New Font... 5] A Add Fonts window will pop up, just go to the folder that you unzipped the Font(s) to, select the Font(s) and then click on OK. Now the Font(s) are installed. Now you can use the Font(s) in programs the utilize Fonts. Make sure that you install the font(s) first, then open up your apps (so the app will recognize the font). Sometimes you'll have to wait until you computer 'auto-refreshes' for programs to recognize fonts (Windows is sometimes slow to do that). You can refresh your computer quicker by going into Windows Explorer -or- My Computer and press ALT + V, then R (or in the menubar select VIEW then REFRESH). __________ DISCLAIMER ¯¯¯¯¯¯¯¯¯¯ -The font(s) in this zip file were created by me (Brian Kent). All of my Fonts are Freeware, you can use them any way you want to (Personal use, Commercial use, or whatever). -If you have a Font related site and would like to offer my fonts on your site, go right ahead. All I ask is that you keep this text file intact with the Font. -You may not Sell or Distribute my Fonts for profit or alter them in any way without asking me first. [e-mail - kentpw@norwich.net]

File no 8: /FIRST AID PROJECT/Assets/scipts/TABsCIPT.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class TABsCIPT : MonoBehaviour { // Start is called before the first frame update void Start() { } // C# Code Snippet // Search Bar Example //void OnGUI() //{ // searchText = GUILayout.TextField(searchText); // for (int i = 0; i < words.Count; i++) // { // if (string.IsNullOrEmpty(searchText) || words[i].Contains(searchText)) // { // GUILayout.Button(words[i]); // } // } //} // Update is called once per frame void Update() { } }

File no 9: /FIRST AID PROJECT/Assets/scipts/appManager.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class appManager : MonoBehaviour { public int layerNO1 = 1; public int TabNO = 1; public static appManager instance; private void Awake() //////used to make the singleton instance { if (instance == null) { instance = this; } } // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { } }

File no 10: /FIRST AID PROJECT/Assets/scipts/uiManager.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class uiManager : MonoBehaviour { public GameObject chemicalfirstAid; public GameObject BackTab; public GameObject ExitTab; public GameObject HomeTab; public GameObject A1; public GameObject A2; public GameObject A3; public GameObject A4; public GameObject A5; public GameObject A6; public GameObject A7; public GameObject A8; public GameObject A9; GameObject[] A; public GameObject B1; public GameObject B2; public GameObject B3; public GameObject B4; public GameObject B5; public GameObject B6; public GameObject B7; public GameObject B8; public GameObject B9; GameObject[] B; // Start is called before the first frame update void Start() { A = new GameObject[9] { A1, A2, A3, A4, A5, A6, A7, A8, A9 }; B = new GameObject[9] { B1, B2, B3, B4, B5, B6, B7, B8, B9 }; } // Update is called once per frame void Update() { //if (appManager.instance.TabNO !=1) //{ // BackTab.SetActive(true); // ExitTab.SetActive(false); // HomeTab.SetActive(true); //} //else //{ // BackTab.SetActive(false); // ExitTab.SetActive(true); // HomeTab.SetActive(false); //} } public void EXITbuttonClicked() { if (appManager.instance.layerNO1 == 1) { Application.Quit(); } else if(appManager.instance.layerNO1==2) { appManager.instance.layerNO1 = 1; BackTab.SetActive(false); ExitTab.SetActive(true); HomeTab.SetActive(false); foreach (GameObject i in A) { i.SetActive(true); } foreach (GameObject j in B) { j.SetActive(false); } } else if (appManager.instance.layerNO1 == 3) { appManager.instance.layerNO1 = 1; BackTab.SetActive(false); ExitTab.SetActive(true); HomeTab.SetActive(false); chemicalfirstAid.SetActive(false); foreach (GameObject i in A) { i.SetActive(true); } } } public void BACKbuttonClicked() { if (appManager.instance.layerNO1 == 2) { HomeTab.gameObject.SetActive(false); ExitTab.gameObject.SetActive(true); BackTab.gameObject.SetActive(false); foreach (GameObject j in B) { j.SetActive(false); } foreach (GameObject i in A) { i.SetActive(true); } appManager.instance.layerNO1 = 1; } if (appManager.instance.layerNO1 == 3) { appManager.instance.layerNO1 = 2; foreach (GameObject j in B) { j.SetActive(true); } if (appManager.instance.TabNO == 20) { chemicalfirstAid.SetActive(false); } } } public void Button1Clicked() { if (appManager.instance.layerNO1 == 1) { Debug.Log("hello"); BackTab.SetActive(true); ExitTab.SetActive(false); HomeTab.SetActive(true); appManager.instance.TabNO = 11; appManager.instance.layerNO1 = 2; foreach (GameObject i in A) { i.SetActive(false); } foreach (GameObject j in B) { j.SetActive(true); } } } public void Button4Clicked() { if (appManager.instance.layerNO1 == 2) { appManager.instance.layerNO1 = 3; chemicalfirstAid.SetActive(true); appManager.instance.TabNO = 20; foreach (GameObject j in B) { j.SetActive(false); } } } }

File no 11: /FIRST AID PROJECT/Assets/Manager.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class Manager : MonoBehaviour { int ID; int ActiveStatus = 0; public GameObject CanvasOfpanels; GameObject[] PanelList = new GameObject[137]; GameObject ExitButton; GameObject HomeButton; GameObject BackButton; // Start is called before the first frame update void Start() { ID = 0; ActiveStatus = 0; for(int j=0; j<137;j++) { PanelList[j] = CanvasOfpanels.transform.GetChild(j).gameObject; //PanelList[j].SetActive(true); } ExitButton = PanelList[0].transform.GetChild(5).gameObject; HomeButton = PanelList[0].transform.GetChild(7).gameObject; BackButton = PanelList[0].transform.GetChild(6).gameObject; } void IDPanel() { ActiveStatus = 0; //ID=1 int i = ID; //i=1 int[] b = new int[9]; for(int k=0; k < 9; k++) { b[k] = (i * 10) + k + 1; // b[0]=11 // b[1]=12 // b[2]=13 // b[3]=14 // b[4]=15 // b[5]=16 // b[6]=17 // b[7]=18 // b[8]=19 } for (int c = 1; c < 137; c++) { string Name = PanelList[c].name; int ChangedToInt = int.Parse(Name); if(ChangedToInt==b[0]||ChangedToInt==b[1] || ChangedToInt == b[2] || ChangedToInt == b[3] || ChangedToInt == b[4] || ChangedToInt == b[5] || ChangedToInt == b[6] || ChangedToInt == b[7] || ChangedToInt == b[8]) { //then to set it active ActiveStatus = 1; PanelList[c].SetActive(true); } else { PanelList[c].SetActive(false); } } if (ActiveStatus == 0) { //it is the end ID = (ID * 10); for (int c = 1; c < 137; c++) { string Name = PanelList[c].name; int ChangedToInt = int.Parse(Name); if (ChangedToInt == ID) { // end panel to display PanelList[c].SetActive(true); ActiveStatus = 1; return; ///prevents unnecessary repetition :) } } } } public void HomeExitButtonClicked() { if (ID == 0) { //this will work as exit buttons //Close the program Application.Quit(); } else { // this will work as home button ActiveStatus = 0; // since if at end screen it will become inactive HomeButton.SetActive(false); ExitButton.SetActive(true); BackButton.SetActive(false); ID = 0; ///let's set all panel inactive for(int v=1; v < 137; v++) { PanelList[v].SetActive(false); } PanelList[1].SetActive(true); PanelList[20].SetActive(true); PanelList[28].SetActive(true); PanelList[37].SetActive(true); PanelList[61].SetActive(true); PanelList[65].SetActive(true); PanelList[68].SetActive(true); PanelList[78].SetActive(true); PanelList[85].SetActive(true); } } public void BackButtonClicked() { if (ID == 0) { //do nothing } else if (ID%10 == 0) { //it is the end screen so first set it inactive for (int c = 1; c < 137; c++) { string Name = PanelList[c].name; int ChangedToInt = int.Parse(Name); if (ChangedToInt == ID) { // end panel to displayed so set it inactive PanelList[c].SetActive(false); ActiveStatus = 0; ID = ID / 100; IDPanel(); } } } else { /// ID=432 ID = ID / 10; //ID=43 ///Lets set active EXIT button and inactive HOME and BACK button if we reach first if (ID == 0) { // we reach first ExitButton.SetActive(true); HomeButton.SetActive(false); BackButton.SetActive(false); } IDPanel(); } } public void Button1() { if (ID == 0) { // changes in ui is to be made // set EXIT inactive and HOME and BACK active ExitButton.SetActive(false); HomeButton.SetActive(true); BackButton.SetActive(true); } if (ID%10 == 0&&ID!=0) { // we are at the end so do nothing } else { ID = (ID * 10) + 1; IDPanel(); } } public void Button2() { if (ID == 0) { // changes in ui is to be made // set EXIT inactive and HOME and BACK active ExitButton.SetActive(false); HomeButton.SetActive(true); BackButton.SetActive(true); } if (ID % 10 == 0 && ID != 0) { // we are at the end so do nothing } else { /// ID=43 ID = (ID * 10) + 2; //ID=432 IDPanel(); } } public void Button3() { if (ID == 0) { // changes in ui is to be made // set EXIT inactive and HOME and BACK active ExitButton.SetActive(false); HomeButton.SetActive(true); BackButton.SetActive(true); } if (ID % 10 == 0 && ID != 0) { // we are at the end so do nothing } else { ID = (ID * 10) + 3; IDPanel(); } } public void Button4() { if (ID == 0) { // changes in ui is to be made // set EXIT inactive and HOME and BACK active ExitButton.SetActive(false); HomeButton.SetActive(true); BackButton.SetActive(true); } if (ID % 10 == 0 && ID != 0) { // we are at the end so do nothing } else { ID = (ID * 10) + 4; IDPanel(); } } public void Button5() { if (ID == 0) { // changes in ui is to be made // set EXIT inactive and HOME and BACK active ExitButton.SetActive(false); HomeButton.SetActive(true); BackButton.SetActive(true); } if (ID % 10 == 0 && ID != 0) { // we are at the end so do nothing } else { ID = (ID * 10) + 5; IDPanel(); } } public void Button6() { if (ID == 0) { // changes in ui is to be made // set EXIT inactive and HOME and BACK active ExitButton.SetActive(false); HomeButton.SetActive(true); BackButton.SetActive(true); } if (ID % 10 == 0 && ID != 0) { // we are at the end so do nothing } else { ID = (ID * 10) + 6; IDPanel(); } } public void Button7() { if (ID == 0) { // changes in ui is to be made // set EXIT inactive and HOME and BACK active ExitButton.SetActive(false); HomeButton.SetActive(true); BackButton.SetActive(true); } if (ID % 10 == 0 && ID != 0) { // we are at the end so do nothing } else { ID = (ID * 10) + 7; IDPanel(); } } public void Button8() { if (ID == 0) { // changes in ui is to be made // set EXIT inactive and HOME and BACK active ExitButton.SetActive(false); HomeButton.SetActive(true); BackButton.SetActive(true); } if (ID % 10 == 0 && ID != 0) { // we are at the end so do nothing } else { ID = (ID * 10) + 8; IDPanel(); } } public void Button9() { if (ID == 0) { // changes in ui is to be made // set EXIT inactive and HOME and BACK active ExitButton.SetActive(false); HomeButton.SetActive(true); BackButton.SetActive(true); } if (ID % 10 == 0 && ID != 0) { // we are at the end so do nothing } else { ID = (ID * 10) + 9; IDPanel(); } } }

File no 12: /FIRST AID PROJECT/Packages/manifest.json
{ "dependencies": { "com.unity.2d.animation": "3.2.1", "com.unity.2d.pixel-perfect": "2.0.4", "com.unity.2d.psdimporter": "2.1.3", "com.unity.2d.sprite": "1.0.0", "com.unity.2d.spriteshape": "3.0.10", "com.unity.2d.tilemap": "1.0.0", "com.unity.collab-proxy": "1.2.16", "com.unity.ide.rider": "1.1.4", "com.unity.ide.vscode": "1.1.4", "com.unity.test-framework": "1.1.13", "com.unity.textmeshpro": "2.0.1", "com.unity.timeline": "1.2.14", "com.unity.ugui": "1.0.0", "com.unity.modules.ai": "1.0.0", "com.unity.modules.androidjni": "1.0.0", "com.unity.modules.animation": "1.0.0", "com.unity.modules.assetbundle": "1.0.0", "com.unity.modules.audio": "1.0.0", "com.unity.modules.cloth": "1.0.0", "com.unity.modules.director": "1.0.0", "com.unity.modules.imageconversion": "1.0.0", "com.unity.modules.imgui": "1.0.0", "com.unity.modules.jsonserialize": "1.0.0", "com.unity.modules.particlesystem": "1.0.0", "com.unity.modules.physics": "1.0.0", "com.unity.modules.physics2d": "1.0.0", "com.unity.modules.screencapture": "1.0.0", "com.unity.modules.terrain": "1.0.0", "com.unity.modules.terrainphysics": "1.0.0", "com.unity.modules.tilemap": "1.0.0", "com.unity.modules.ui": "1.0.0", "com.unity.modules.uielements": "1.0.0", "com.unity.modules.umbra": "1.0.0", "com.unity.modules.unityanalytics": "1.0.0", "com.unity.modules.unitywebrequest": "1.0.0", "com.unity.modules.unitywebrequestassetbundle": "1.0.0", "com.unity.modules.unitywebrequestaudio": "1.0.0", "com.unity.modules.unitywebrequesttexture": "1.0.0", "com.unity.modules.unitywebrequestwww": "1.0.0", "com.unity.modules.vehicles": "1.0.0", "com.unity.modules.video": "1.0.0", "com.unity.modules.vr": "1.0.0", "com.unity.modules.wind": "1.0.0", "com.unity.modules.xr": "1.0.0" } }

File no 13: /FIRST AID PROJECT/ProjectSettings/ProjectVersion.txt
m_EditorVersion: 2019.3.9f1 m_EditorVersionWithRevision: 2019.3.9f1 (e6e740a1c473)

File no 14: /README.md
FIRST_AID This is a first aid app which provides accurate first aid regarding given emergency condition. Go You can’t perform that action at this time.

18: Project Name : Search-Engine
This project contains 2 main files, namely /README.md, /project_overview.pdf
Below we will get details about each of these files one by one:
	
File no 1: /README.md
Search-Engine In this project I built a search tool (a small retrieval system) using Boolean retrieval method for cranfield dataset. and apply various queries with conjunction, disjunction and negation of terms. Here we also have to see the effectiveness of our implementation using MAP and Precision Recall graph for 1.without stemming 2.with stemming 3. zone indexes for title and body text fields and come up with optimal weights. Go You can’t perform that action at this time.

File no 2: /project_overview.pdf
Search-Engine/project_overview.pdf at main · ar8372/Search-Engine · GitHub Skip to content Toggle navigation Sign up In this repository All GitHub ↵ Jump to ↵ No suggested jump to results In this repository All GitHub ↵ Jump to ↵ In this user All GitHub ↵ Jump to ↵ In this repository All GitHub ↵ Jump to ↵ Sign in Sign up You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session. You switched accounts on another tab or window. Reload to refresh your session. ar8372 / Search-Engine Public Notifications Fork 0 Star 2 Permalink main Switch branches/tags Branches Tags Name already in use A tag already exists with the provided branch name. Many Git commands accept both tag and branch names, so creating this branch may cause unexpected behavior. Are you sure you want to create this branch? Search-Engine/project_overview.pdf Go to file Go to file T Go to line L Copy path Copy permalink This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository. Cannot retrieve contributors at this time 245 KB Download Open with Desktop Download Delete file Sorry, something went wrong. Reload? Sorry, we cannot display this file. Sorry, this file is invalid so it cannot be displayed. Viewer requires iframe. Go You can’t perform that action at this time.

19: Project Name : COLAME
This project contains 174 main files, namely /colame/Assets/SCRIPTS/COINnO.cs, /colame/Assets/SCRIPTS/DestroyGreenCrystal.cs, /colame/Assets/SCRIPTS/DestroyMe.cs, /colame/Assets/SCRIPTS/DestroyRedCrystal.cs, /colame/Assets/SCRIPTS/DestroyblueCrystal.cs, /colame/Assets/SCRIPTS/FLAY.cs, /colame/Assets/SCRIPTS/HighPosScript.cs, /colame/Assets/SCRIPTS/ManageTheAudio.cs, /colame/Assets/SCRIPTS/Playeraudioscript.cs, /colame/Assets/SCRIPTS/PointsManager.cs, /colame/Assets/SCRIPTS/RotateBorder.cs, /colame/Assets/SCRIPTS/SOUNDs.cs, /colame/Assets/SCRIPTS/SPAWNINGpT.cs, /colame/Assets/SCRIPTS/UImanager.cs, /colame/Assets/SCRIPTS/changeColorOfSky.cs, /colame/Assets/SCRIPTS/checkingExit.cs, /colame/Assets/SCRIPTS/dont.cs, /colame/Assets/SCRIPTS/fading.cs, /colame/Assets/SCRIPTS/followPlayer.cs, /colame/Assets/SCRIPTS/followThePlayer.cs, /colame/Assets/SCRIPTS/instagram.cs, /colame/Assets/SCRIPTS/keyScript.cs, /colame/Assets/SCRIPTS/oceanFollowBall.cs, /colame/Assets/SCRIPTS/playerMovement.cs, /colame/Assets/SCRIPTS/rOTATE.cs, /colame/Assets/SCRIPTS/rotateCoin.cs, /colame/Assets/SCRIPTS/rotateCoinONIslandd.cs, /colame/Assets/SCRIPTS/rotateKey.cs, /colame/Assets/SCRIPTS/scoreScript.cs, /colame/Assets/SCRIPTS/swipe.cs, /colame/Assets/SCRIPTS/triggerScript.cs, /colame/Assets/Simple Helvetica/readme.txt, /colame/Assets/SineVFX/PostProcessingV2/Editor/Attributes/DecoratorAttribute.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/Attributes/PostProcessEditorAttribute.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/Decorators/AttributeDecorator.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/Decorators/Decorators.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/Decorators/TrackballDecorator.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/Effects/AmbientOcclusionEditor.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/Effects/AutoExposureEditor.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/Effects/BloomEditor.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/Effects/ChromaticAberrationEditor.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/Effects/ColorGradingEditor.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/Effects/DefaultPostProcessEffectEditor.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/Effects/DepthOfFieldEditor.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/Effects/LensDistortionEditor.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/Effects/ScreenSpaceReflectionsEditor.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/Effects/VignetteEditor.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/Tools/CubeLutAssetFactory.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/Tools/CubeLutAssetImporter.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/Tools/DefineSetter.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/Tools/ProfileFactory.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/Tools/ResourceAssetFactory.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/Tools/VolumeFactory.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/Utils/CurveEditor.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/Utils/EditorUtilities.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/Utils/GlobalSettings.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/Utils/PostProcessShaderIncludePath.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/Utils/SerializedParameterOverride.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/Utils/Styling.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/BaseEditor.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/EffectListEditor.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/PostProcessDebugEditor.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/PostProcessEffectBaseEditor.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/PostProcessEffectEditor.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/PostProcessLayerEditor.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/PostProcessProfileEditor.cs, /colame/Assets/SineVFX/PostProcessingV2/Editor/PostProcessVolumeEditor.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Attributes/DisplayNameAttribute.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Attributes/MaxAttribute.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Attributes/MinAttribute.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Attributes/MinMaxAttribute.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Attributes/PostProcessAttribute.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Attributes/TrackballAttribute.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/AmbientOcclusion.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/AutoExposure.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/Bloom.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/ChromaticAberration.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/ColorGrading.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/DepthOfField.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/Dithering.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/FastApproximateAntialiasing.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/Fog.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/Grain.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/LensDistortion.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/MotionBlur.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/MultiScaleVO.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/ScalableAO.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/ScreenSpaceReflections.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/SubpixelMorphologicalAntialiasing.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/TemporalAntialiasing.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/Vignette.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Monitors/HistogramMonitor.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Monitors/LightMeterMonitor.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Monitors/Monitor.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Monitors/VectorscopeMonitor.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Monitors/WaveformMonitor.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Utils/ColorUtilities.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Utils/HableCurve.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Utils/HaltonSeq.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Utils/LogHistogram.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Utils/MeshUtilities.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Utils/PropertySheet.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Utils/PropertySheetFactory.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Utils/RuntimeUtilities.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Utils/ShaderIDs.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Utils/Spline.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Utils/TargetPool.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Utils/TextureFormatUtilities.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Utils/TextureLerper.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/Utils/XRSettings.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/ParameterOverride.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/PostProcessBundle.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/PostProcessDebug.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/PostProcessDebugLayer.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/PostProcessEffectRenderer.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/PostProcessEffectSettings.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/PostProcessEvent.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/PostProcessLayer.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/PostProcessManager.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/PostProcessProfile.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/PostProcessRenderContext.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/PostProcessResources.cs, /colame/Assets/SineVFX/PostProcessingV2/Runtime/PostProcessVolume.cs, /colame/Assets/SineVFX/TranslucentCrystals/_SRP/!!!_ReadBeforeImport_!!!.txt, /colame/Assets/SineVFX/TranslucentCrystals/Readme.txt, /colame/Assets/TextMesh Pro/Documentation/TextMesh Pro User Guide 2016.pdf, /colame/Assets/TextMesh Pro/Examples & Extras/Fonts/Anton OFL.txt, /colame/Assets/TextMesh Pro/Examples & Extras/Fonts/Bangers - OFL.txt, /colame/Assets/TextMesh Pro/Examples & Extras/Fonts/Oswald-Bold - OFL.txt, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/Benchmark01.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/Benchmark01_UGUI.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/Benchmark02.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/Benchmark03.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/Benchmark04.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/CameraController.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/ChatController.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/EnvMapAnimator.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/ObjectSpin.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/ShaderPropAnimator.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/SimpleScript.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/SkewTextExample.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_DigitValidator.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_ExampleScript_01.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_FrameRateCounter.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_PhoneNumberValidator.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_TextEventCheck.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_TextEventHandler.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_TextInfoDebugTool.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_TextSelector_A.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_TextSelector_B.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_UiFrameRateCounter.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TMPro_InstructionOverlay.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TeleType.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TextConsoleSimulator.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TextMeshProFloatingText.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TextMeshSpawner.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/VertexColorCycler.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/VertexJitter.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/VertexShakeA.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/VertexShakeB.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/VertexZoom.cs, /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/WarpTextExample.cs, /colame/Assets/TextMesh Pro/Fonts/LiberationSans - OFL.txt, /colame/Assets/TextMesh Pro/Resources/LineBreaking Following Characters.txt, /colame/Assets/TextMesh Pro/Resources/LineBreaking Leading Characters.txt, /colame/Assets/TextMesh Pro/Sprites/EmojiOne Attribution.txt, /colame/Assets/TextMesh Pro/Sprites/EmojiOne.json, /colame/Assets/UI FOLDER/BUTTONS/freefantasygui/png/README.txt, /colame/Assets/UI FOLDER/TEXTfONTS/need-for-font/license.txt, /colame/Assets/UI FOLDER/TEXTfONTS/perfect-dark-brk/perfectdark.txt, /colame/Assets/dg.cs, /colame/Packages/manifest.json, /colame/ProjectSettings/ProjectVersion.txt, /README.md
Below we will get details about each of these files one by one:
	
File no 1: /colame/Assets/SCRIPTS/COINnO.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class COINnO : MonoBehaviour { public int FlagGoONce = 0; public float Spacing; public GameObject TextObject; //public GameObject TextObjectInstantiated; //public GameObject instanceScorePos; Vector3 Pos; int SpeedStringLength; string SpeedString; int noOfDiamonds; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { if (PointsManager.instance.FINISHsTATES == 1&&FlagGoONce==0) { FlagGoONce = 1; Pos = transform.position; noOfDiamonds = PointsManager.instance.NoOfDiamonds; SpeedString = noOfDiamonds.ToString(); SpeedStringLength = SpeedString.Length; Debug.Log("string length =" + SpeedStringLength); for(int i = 0; i < SpeedStringLength; i++) { //TextObjectInstantiated = Instantiate(TextObject, Pos, Quaternion.identity); //method 1 // TextObjectInstantiated.transform.parent = transform; //mehod 2 GameObject TextObjectInstantiated =Instantiate(TextObject, Pos, Quaternion.identity, transform); float a = (4.0f / 5.0f) * Spacing; float b = ((3.0f / 5.0f) * Spacing); TextObjectInstantiated.transform.position += new Vector3(a*i, 0, b * i); switch (SpeedString[i]) { case '0': (TextObjectInstantiated.transform.GetChild(0).gameObject).SetActive(true); break; case '1': (TextObjectInstantiated.transform.GetChild(1).gameObject).SetActive(true); break; case '2': (TextObjectInstantiated.transform.GetChild(2).gameObject).SetActive(true); break; case '3': (TextObjectInstantiated.transform.GetChild(3).gameObject).SetActive(true); break; case '4': (TextObjectInstantiated.transform.GetChild(4).gameObject).SetActive(true); break; case '5': (TextObjectInstantiated.transform.GetChild(5).gameObject).SetActive(true); break; case '6': (TextObjectInstantiated.transform.GetChild(6).gameObject).SetActive(true); break; case '7': (TextObjectInstantiated.transform.GetChild(7).gameObject).SetActive(true); break; case '8': (TextObjectInstantiated.transform.GetChild(8).gameObject).SetActive(true); break; case '9': (TextObjectInstantiated.transform.GetChild(9).gameObject).SetActive(true); break; } //transform.position += transform.TransformDirection(Spacing,0,0); // Pos = transform.position; } } } }

File no 2: /colame/Assets/SCRIPTS/DestroyGreenCrystal.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class DestroyGreenCrystal : MonoBehaviour { public int massOfACrystal; public int differenceOfMass; // RaycastHit a; Ray l; // Start is called before the first frame update void Start() { // + new Vector3(0, -1, 0) this is not necessary as collision is not checked with self. Vector3 pq = transform.position + new Vector3(0, -1, 0); Vector3 c = new Vector3(0, -1, 0); l = new Ray(pq, c); } // Update is called once per frame void Update() { Debug.DrawRay(l.origin, l.direction * 5, Color.red); // Debug.DrawRay(pq, c*10, Color.red); //if (Physics.Raycast(pq,c*10,out a,Mathf.Infinity)) //{ // Console.WriteLine("hiiting "); // //if (a.transform.gameObject == null) // //{ // //} // // hitting on the bridge //} if (Physics.Raycast(l, Mathf.Infinity)) { //Debug.Log("hi check"); // Console.WriteLine("hiiting "); //if (a.transform.gameObject == null) //{ //} // hitting on the bridge } else { // Debug.Log("hi chek"); Destroy(gameObject); //Console.WriteLine("not hitting"); // Destroy(gameObject); } //if(Physics.Raycast(l,out a, Mathf.Infinity)) //{ //} } private void OnTriggerEnter(Collider other) { if (PointsManager.instance.gamestate == 10) { return; } if (other.gameObject.transform.tag == "PlayerGreen") { PointsManager.instance.increaseDiamonds(); //coin = Instantiate(coinPrefab, transform.position, Quaternion.identity); GameObject CRYSTAL8 = gameObject.transform.GetChild(7).gameObject; PointsManager.instance.Instantiatecoin(CRYSTAL8.transform.position); Destroy(gameObject); } else if (other.gameObject.transform.tag == "PlayerRed" || other.gameObject.transform.tag == "PlayerBlue") { //////////////////destroying gameobject//////////// if (PointsManager.instance.speed < 180) { Destroy(gameObject, 7f); } else { Destroy(gameObject, 5f); } PointsManager.instance.OnWrongCollision(); Rigidbody rb = gameObject.GetComponent<Rigidbody>(); BoxCollider bc = gameObject.GetComponent<BoxCollider>(); bc.isTrigger = false; // rb.useGravity = true; bc.enabled = false; GameObject CRYSTAL1 = gameObject.transform.GetChild(0).gameObject; GameObject CRYSTAL2 = gameObject.transform.GetChild(1).gameObject; GameObject CRYSTAL3 = gameObject.transform.GetChild(2).gameObject; GameObject CRYSTAL4 = gameObject.transform.GetChild(3).gameObject; GameObject CRYSTAL5 = gameObject.transform.GetChild(4).gameObject; GameObject CRYSTAL6 = gameObject.transform.GetChild(5).gameObject; GameObject CRYSTAL7 = gameObject.transform.GetChild(6).gameObject; CRYSTAL1.GetComponent<CapsuleCollider>().enabled = true; CRYSTAL1.GetComponent<Rigidbody>().useGravity = true; CRYSTAL1.GetComponent<Rigidbody>().mass = massOfACrystal + (6 * differenceOfMass); CRYSTAL2.GetComponent<CapsuleCollider>().enabled = true; CRYSTAL2.GetComponent<Rigidbody>().useGravity = true; CRYSTAL2.GetComponent<Rigidbody>().mass = massOfACrystal + (5 * differenceOfMass); CRYSTAL3.GetComponent<CapsuleCollider>().enabled = true; CRYSTAL3.GetComponent<Rigidbody>().useGravity = true; CRYSTAL3.GetComponent<Rigidbody>().mass = massOfACrystal + (4 * differenceOfMass); CRYSTAL4.GetComponent<CapsuleCollider>().enabled = true; CRYSTAL4.GetComponent<Rigidbody>().useGravity = true; CRYSTAL4.GetComponent<Rigidbody>().mass = massOfACrystal + (3 * differenceOfMass); CRYSTAL5.GetComponent<CapsuleCollider>().enabled = true; CRYSTAL5.GetComponent<Rigidbody>().useGravity = true; CRYSTAL5.GetComponent<Rigidbody>().mass = massOfACrystal + (2 * differenceOfMass); CRYSTAL6.GetComponent<CapsuleCollider>().enabled = true; CRYSTAL6.GetComponent<Rigidbody>().useGravity = true; CRYSTAL6.GetComponent<Rigidbody>().mass = massOfACrystal + differenceOfMass; CRYSTAL7.GetComponent<CapsuleCollider>().enabled = true; CRYSTAL7.GetComponent<Rigidbody>().useGravity = true; CRYSTAL7.GetComponent<Rigidbody>().mass = massOfACrystal; } } }

File no 3: /colame/Assets/SCRIPTS/DestroyMe.cs
﻿using System; using System.Collections; using System.Collections.Generic; using UnityEngine; public class DestroyMe : MonoBehaviour { // RaycastHit a; Ray l; // Start is called before the first frame update void Start() { // + new Vector3(0, -1, 0) this is not necessary as collision is not checked with self. Vector3 pq = transform.position + new Vector3(0, -1, 0); Vector3 c = new Vector3(0, -1, 0); l = new Ray(pq, c); } // Update is called once per frame void Update() { Debug.DrawRay(l.origin, l.direction *5, Color.red); // Debug.DrawRay(pq, c*10, Color.red); //if (Physics.Raycast(pq,c*10,out a,Mathf.Infinity)) //{ // Console.WriteLine("hiiting "); // //if (a.transform.gameObject == null) // //{ // //} // // hitting on the bridge //} if (Physics.Raycast(l, Mathf.Infinity)) { //Debug.Log("hi check"); // Console.WriteLine("hiiting "); //if (a.transform.gameObject == null) //{ //} // hitting on the bridge } else { // Debug.Log("hi chek"); Destroy(gameObject); //Console.WriteLine("not hitting"); // Destroy(gameObject); } //if(Physics.Raycast(l,out a, Mathf.Infinity)) //{ //} } }

File no 4: /colame/Assets/SCRIPTS/DestroyRedCrystal.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class DestroyRedCrystal : MonoBehaviour { public int massOfACrystal; public int differenceOfMass; // Start is called before the first frame update // RaycastHit a; Ray l; // Start is called before the first frame update void Start() { // + new Vector3(0, -1, 0) this is not necessary as collision is not checked with self. Vector3 pq = transform.position + new Vector3(0, -1, 0); Vector3 c = new Vector3(0, -1, 0); l = new Ray(pq, c); } // Update is called once per frame void Update() { Debug.DrawRay(l.origin, l.direction * 5, Color.red); // Debug.DrawRay(pq, c*10, Color.red); //if (Physics.Raycast(pq,c*10,out a,Mathf.Infinity)) //{ // Console.WriteLine("hiiting "); // //if (a.transform.gameObject == null) // //{ // //} // // hitting on the bridge //} if (Physics.Raycast(l, Mathf.Infinity)) { //Debug.Log("hi check"); // Console.WriteLine("hiiting "); //if (a.transform.gameObject == null) //{ //} // hitting on the bridge } else { // Debug.Log("hi chek"); Destroy(gameObject); //Console.WriteLine("not hitting"); // Destroy(gameObject); } //if(Physics.Raycast(l,out a, Mathf.Infinity)) //{ //} } private void OnTriggerEnter(Collider other) { if (PointsManager.instance.gamestate == 10) { return; } if (other.gameObject.transform.tag == "PlayerRed") { PointsManager.instance.increaseDiamonds(); // coin = Instantiate(coinPrefab, transform.position, Quaternion.identity); GameObject CRYSTAL8 = gameObject.transform.GetChild(7).gameObject; PointsManager.instance.Instantiatecoin(CRYSTAL8.transform.position); Destroy(gameObject); } else if (other.gameObject.transform.tag == "PlayerGreen" || other.gameObject.transform.tag == "PlayerBlue") { //////////////////destroying gameobject//////////// if (PointsManager.instance.speed<180) { Destroy(gameObject, 7f); } else { Destroy(gameObject, 5f); } PointsManager.instance.OnWrongCollision(); Rigidbody rb = gameObject.GetComponent<Rigidbody>(); BoxCollider bc = gameObject.GetComponent<BoxCollider>(); bc.isTrigger = false; // rb.useGravity = true; bc.enabled = false; GameObject CRYSTAL1 = gameObject.transform.GetChild(0).gameObject; GameObject CRYSTAL2 = gameObject.transform.GetChild(1).gameObject; GameObject CRYSTAL3 = gameObject.transform.GetChild(2).gameObject; GameObject CRYSTAL4 = gameObject.transform.GetChild(3).gameObject; GameObject CRYSTAL5 = gameObject.transform.GetChild(4).gameObject; GameObject CRYSTAL6 = gameObject.transform.GetChild(5).gameObject; GameObject CRYSTAL7 = gameObject.transform.GetChild(6).gameObject; CRYSTAL1.GetComponent<CapsuleCollider>().enabled = true; CRYSTAL1.GetComponent<Rigidbody>().useGravity = true; CRYSTAL1.GetComponent<Rigidbody>().mass = massOfACrystal+(6* differenceOfMass); CRYSTAL2.GetComponent<CapsuleCollider>().enabled = true; CRYSTAL2.GetComponent<Rigidbody>().useGravity = true; CRYSTAL2.GetComponent<Rigidbody>().mass = massOfACrystal+(5* differenceOfMass); CRYSTAL3.GetComponent<CapsuleCollider>().enabled = true; CRYSTAL3.GetComponent<Rigidbody>().useGravity = true; CRYSTAL3.GetComponent<Rigidbody>().mass = massOfACrystal+(4* differenceOfMass); CRYSTAL4.GetComponent<CapsuleCollider>().enabled = true; CRYSTAL4.GetComponent<Rigidbody>().useGravity = true; CRYSTAL4.GetComponent<Rigidbody>().mass = massOfACrystal+(3* differenceOfMass); CRYSTAL5.GetComponent<CapsuleCollider>().enabled = true; CRYSTAL5.GetComponent<Rigidbody>().useGravity = true; CRYSTAL5.GetComponent<Rigidbody>().mass = massOfACrystal+(2* differenceOfMass); CRYSTAL6.GetComponent<CapsuleCollider>().enabled = true; CRYSTAL6.GetComponent<Rigidbody>().useGravity = true; CRYSTAL6.GetComponent<Rigidbody>().mass = massOfACrystal+ differenceOfMass; CRYSTAL7.GetComponent<CapsuleCollider>().enabled = true; CRYSTAL7.GetComponent<Rigidbody>().useGravity = true; CRYSTAL7.GetComponent<Rigidbody>().mass = massOfACrystal; } } }

File no 5: /colame/Assets/SCRIPTS/DestroyblueCrystal.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class DestroyblueCrystal : MonoBehaviour { public int massOfACrystal; public int differenceOfMass; // RaycastHit a; Ray l; // Start is called before the first frame update void Start() { // + new Vector3(0, -1, 0) this is not necessary as collision is not checked with self. Vector3 pq = transform.position + new Vector3(0, -1, 0); Vector3 c = new Vector3(0, -1, 0); l = new Ray(pq, c); } // Update is called once per frame void Update() { Debug.DrawRay(l.origin, l.direction * 5, Color.red); // Debug.DrawRay(pq, c*10, Color.red); //if (Physics.Raycast(pq,c*10,out a,Mathf.Infinity)) //{ // Console.WriteLine("hiiting "); // //if (a.transform.gameObject == null) // //{ // //} // // hitting on the bridge //} if (Physics.Raycast(l, Mathf.Infinity)) { //Debug.Log("hi check"); // Console.WriteLine("hiiting "); //if (a.transform.gameObject == null) //{ //} // hitting on the bridge } else { // Debug.Log("hi chek"); Destroy(gameObject); //Console.WriteLine("not hitting"); // Destroy(gameObject); } //if(Physics.Raycast(l,out a, Mathf.Infinity)) //{ //} } private void OnTriggerEnter(Collider other) { if (PointsManager.instance.gamestate == 10) { return; } if (other.gameObject.transform.tag == "PlayerBlue") { PointsManager.instance.increaseDiamonds(); //coin = Instantiate(coinPrefab, transform.position, Quaternion.identity); GameObject CRYSTAL8 = gameObject.transform.GetChild(7).gameObject; PointsManager.instance.Instantiatecoin(CRYSTAL8.transform.position); Destroy(gameObject); } else if (other.gameObject.transform.tag == "PlayerGreen" || other.gameObject.transform.tag == "PlayerRed") { //////////////////destroying gameobject//////////// if (PointsManager.instance.speed<180) { Destroy(gameObject, 7f); //Destroy(gameObject, 7f); } else { Destroy(gameObject, 5f); } PointsManager.instance.OnWrongCollision(); Rigidbody rb = gameObject.GetComponent<Rigidbody>(); BoxCollider bc = gameObject.GetComponent<BoxCollider>(); bc.isTrigger = false; // rb.useGravity = true; bc.enabled = false; GameObject CRYSTAL1 = gameObject.transform.GetChild(0).gameObject; GameObject CRYSTAL2 = gameObject.transform.GetChild(1).gameObject; GameObject CRYSTAL3 = gameObject.transform.GetChild(2).gameObject; GameObject CRYSTAL4 = gameObject.transform.GetChild(3).gameObject; GameObject CRYSTAL5 = gameObject.transform.GetChild(4).gameObject; GameObject CRYSTAL6 = gameObject.transform.GetChild(5).gameObject; GameObject CRYSTAL7 = gameObject.transform.GetChild(6).gameObject; CRYSTAL1.GetComponent<CapsuleCollider>().enabled = true; CRYSTAL1.GetComponent<Rigidbody>().useGravity = true; CRYSTAL1.GetComponent<Rigidbody>().mass = massOfACrystal + (6 * differenceOfMass); CRYSTAL2.GetComponent<CapsuleCollider>().enabled = true; CRYSTAL2.GetComponent<Rigidbody>().useGravity = true; CRYSTAL2.GetComponent<Rigidbody>().mass = massOfACrystal + (5 * differenceOfMass); CRYSTAL3.GetComponent<CapsuleCollider>().enabled = true; CRYSTAL3.GetComponent<Rigidbody>().useGravity = true; CRYSTAL3.GetComponent<Rigidbody>().mass = massOfACrystal + (4 * differenceOfMass); CRYSTAL4.GetComponent<CapsuleCollider>().enabled = true; CRYSTAL4.GetComponent<Rigidbody>().useGravity = true; CRYSTAL4.GetComponent<Rigidbody>().mass = massOfACrystal + (3 * differenceOfMass); CRYSTAL5.GetComponent<CapsuleCollider>().enabled = true; CRYSTAL5.GetComponent<Rigidbody>().useGravity = true; CRYSTAL5.GetComponent<Rigidbody>().mass = massOfACrystal + (2 * differenceOfMass); CRYSTAL6.GetComponent<CapsuleCollider>().enabled = true; CRYSTAL6.GetComponent<Rigidbody>().useGravity = true; CRYSTAL6.GetComponent<Rigidbody>().mass = massOfACrystal + differenceOfMass; CRYSTAL7.GetComponent<CapsuleCollider>().enabled = true; CRYSTAL7.GetComponent<Rigidbody>().useGravity = true; CRYSTAL7.GetComponent<Rigidbody>().mass = massOfACrystal; } } }

File no 6: /colame/Assets/SCRIPTS/FLAY.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class FLAY : MonoBehaviour { public float decreaseVolumeOfCoin; public int CrystalMarkedWithSound = 0; public float Time1 = 0; public float Time2; public float xRotate, yRotate, zRotate; Rigidbody RB; // Start is called before the first frame update void Start() { RB = GetComponent<Rigidbody>(); Destroy(gameObject, 3f); } // Update is called once per frame void Update() { RB.AddForce(0, 3000f*Time.deltaTime, 6000f*Time.deltaTime); transform.Rotate(xRotate * Time.deltaTime, yRotate * Time.deltaTime, zRotate * Time.deltaTime); if (CrystalMarkedWithSound == 1&&UImanager.instance.Tempmusic2==1) { //Time1 += Time.deltaTime; //if(Time1==.2f) //{ // gameObject.GetComponent<AudioSource>().volume = .07f; //} //if (Time1 == .3f) //{ // gameObject.GetComponent<AudioSource>().volume = .06f; //} //if (Time1 == .4f) //{ // gameObject.GetComponent<AudioSource>().volume = .04f; //} //if (Time1 == .5f) //{ // gameObject.GetComponent<AudioSource>().volume = .01f; //} //if (Time1 >= Time2) //{ // gameObject.GetComponent<AudioSource>().Stop(); // CrystalMarkedWithSound = 0; //} ////coroutine gives better sound effect /// StartCoroutine("DecreaseSpeed"); CrystalMarkedWithSound = 0; } } IEnumerator DecreaseSpeed() { //gameObject.GetComponent<AudioSource>().volume = .5f; while (gameObject.GetComponent<AudioSource>().volume > 0) { gameObject.GetComponent<AudioSource>().volume -= decreaseVolumeOfCoin * Time.deltaTime; yield return new WaitForEndOfFrame(); } gameObject.GetComponent<AudioSource>().Stop(); StopCoroutine("DecreaseSpeed"); } }

File no 7: /colame/Assets/SCRIPTS/HighPosScript.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class HighPosScript : MonoBehaviour { public int FlagGoONce = 0; public float Spacing; public GameObject TextObject; //public GameObject TextObjectInstantiated; //public GameObject instanceScorePos; Vector3 Pos; int SpeedStringLength; string SpeedString; int noOfDiamonds; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { if (PointsManager.instance.FINISHsTATES == 1 && FlagGoONce == 0) { FlagGoONce = 1; Pos = transform.position; noOfDiamonds = PointsManager.instance.highestScore; ////simple modification in no of diamonds SpeedString = noOfDiamonds.ToString(); SpeedStringLength = SpeedString.Length; Debug.Log("string length =" + SpeedStringLength); for (int i = 0; i < SpeedStringLength; i++) { //TextObjectInstantiated = Instantiate(TextObject, Pos, Quaternion.identity); //method 1 // TextObjectInstantiated.transform.parent = transform; //mehod 2 GameObject TextObjectInstantiated = Instantiate(TextObject, Pos, Quaternion.identity, transform); float a = (4.0f / 5.0f) * Spacing; float b = ((3.0f / 5.0f) * Spacing); TextObjectInstantiated.transform.position += new Vector3(a * i, 0, 0); /////simple modification in no of diamonds switch (SpeedString[i]) { case '0': (TextObjectInstantiated.transform.GetChild(0).gameObject).SetActive(true); break; case '1': (TextObjectInstantiated.transform.GetChild(1).gameObject).SetActive(true); break; case '2': (TextObjectInstantiated.transform.GetChild(2).gameObject).SetActive(true); break; case '3': (TextObjectInstantiated.transform.GetChild(3).gameObject).SetActive(true); break; case '4': (TextObjectInstantiated.transform.GetChild(4).gameObject).SetActive(true); break; case '5': (TextObjectInstantiated.transform.GetChild(5).gameObject).SetActive(true); break; case '6': (TextObjectInstantiated.transform.GetChild(6).gameObject).SetActive(true); break; case '7': (TextObjectInstantiated.transform.GetChild(7).gameObject).SetActive(true); break; case '8': (TextObjectInstantiated.transform.GetChild(8).gameObject).SetActive(true); break; case '9': (TextObjectInstantiated.transform.GetChild(9).gameObject).SetActive(true); break; } //transform.position += transform.TransformDirection(Spacing,0,0); // Pos = transform.position; } } } }

File no 8: /colame/Assets/SCRIPTS/ManageTheAudio.cs
﻿using UnityEngine.Audio; using System; using UnityEngine; public class ManageTheAudio : MonoBehaviour { public SOUNDs[] ListOfSounds; public int music1Status = 1; public int music2Status = 1; public static ManageTheAudio instance; private void Awake() { if (instance == null) { instance = this; } else { Destroy(gameObject); } DontDestroyOnLoad(gameObject); foreach(SOUNDs s in ListOfSounds) { s.AUDIOsOURCE= gameObject.AddComponent<AudioSource>(); s.AUDIOsOURCE.clip = s.SongDropHere; s.AUDIOsOURCE.volume = s.volume; s.AUDIOsOURCE.pitch = s.pitch; s.AUDIOsOURCE.loop = s.LoopIt; //s.AUDIOsOURCE.playOnAwake = s.StatusOfPlayOnAwake; //play on awake won't work } } // Start is called before the first frame update private void Start() { Play("Theme",0f); } public void Play(string NAME,float time) { SOUNDs s= Array.Find(ListOfSounds, SOUNDss => SOUNDss.name == NAME); ///quite confusing clear now if (s == null) { Debug.LogWarning("name " + NAME + " is not found"); return; } s.AUDIOsOURCE.Play(); s.AUDIOsOURCE.time = time; } public void ThemeVol0() { Debug.Log("called to vol0"); ListOfSounds[0].AUDIOsOURCE.volume = 0; } public void ThemeVol1() { Debug.Log("called to vol1"); ListOfSounds[0].AUDIOsOURCE.volume = 0.07f; } public void soundVo0() { ListOfSounds[1].AUDIOsOURCE.volume = 0f; ListOfSounds[2].AUDIOsOURCE.volume = 0f; ListOfSounds[3].AUDIOsOURCE.volume = 0f; ListOfSounds[4].AUDIOsOURCE.volume = 0f; ListOfSounds[5].AUDIOsOURCE.volume = 0f; ListOfSounds[6].AUDIOsOURCE.volume = 0f; ListOfSounds[7].AUDIOsOURCE.volume = 0f; ListOfSounds[8].AUDIOsOURCE.volume = 0f; ListOfSounds[9].AUDIOsOURCE.volume = 0f; ListOfSounds[10].AUDIOsOURCE.volume = 0f; ListOfSounds[11].AUDIOsOURCE.volume = 0f; } public void soundVo1() { ListOfSounds[1].AUDIOsOURCE.volume = 0.3f; ListOfSounds[2].AUDIOsOURCE.volume = 0.648f; ListOfSounds[3].AUDIOsOURCE.volume = 0.2f; ListOfSounds[4].AUDIOsOURCE.volume = 0.3f; ListOfSounds[5].AUDIOsOURCE.volume = 1f; ListOfSounds[6].AUDIOsOURCE.volume = .3f; ListOfSounds[7].AUDIOsOURCE.volume = 0.15f; ListOfSounds[8].AUDIOsOURCE.volume = .5f; ListOfSounds[9].AUDIOsOURCE.volume = 1f; ListOfSounds[10].AUDIOsOURCE.volume = 0.5f; ListOfSounds[11].AUDIOsOURCE.volume = 0.7f; } }

File no 9: /colame/Assets/SCRIPTS/Playeraudioscript.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class Playeraudioscript : MonoBehaviour { // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { } }

File no 10: /colame/Assets/SCRIPTS/PointsManager.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; public class PointsManager : MonoBehaviour { public int DifferenceINLevelVal; public int findLevel; public int phaseNO = 0; //public static int ScreenWidth=Screen.width; //public static int ScreenHeight = Screen.height; public float GameIncA, GameIncB, GameDownA, GameDownB, PowerUpLevelChangeSoundA, PowerUpLevelChangeSoundB, GameOverDramaticSoundA, GameOverDramaticSoundB; public int freezetheBall = 0; //public Animation anim; ///////////////////////////increase speed of animation public GameObject LevelDisplay; public Text LevelNoTextDisplay; public int levelchangeDelay; int callAgain = 0; int diamondCount = 0; int repeatNO = 0; public int MainMenuShowOnce; public int DiskState = 1; bool StartClicked; /////////////////////////////// public float t; public Image rEDWARNING; public Image maskI; public float MaskLength; ///////////////////////////////////////////////////////////////// public Text ScoreText; public Text DiamondText; /////////////////////////////////////////////////////////////// public int FINISHsTATES = 0; ////////////////////////////////////////////store location of spawning point//////////////// public Vector3 LocationOfSpawningBridge; public float MinSpreadx, MaxSpreadx, MinSpready, MaxSpready, MinSpreadz, MaxSpreadz; /////////////////////////////////////////////////coin istantiated/////////////////////// GameObject coinInstantiated; public GameObject coinPrefab; ////////////////////////////////////////////////checking variable change///////////////////////// float slot1, slot2; int SpeedIncreasingStatus = 0; ///////////////////////////////////////////////////////////////////////////////////////////////// public int LevelI = 0, LevelF; public int level=0; public int StopBall = 0;/////////////////////to stop ball Cutoff speed was causing problem as now speed - cutoff speed can be negative public float MinSpeed, MaxSpeed,JumpSpeed,rateToReachTopSpeed; public int gamestate = -1; public float score=0; public int scoreInt; public int HighScore = 0; /////this has to be attached to some memory public int NoOfDiamonds; public int NOOfKeys; public int NoOfEggs; public float speed; public float x=0f; public int highestScore; public float rateToCallIncreasespeed; public float rateOfAngleChange; public int collision = 0; public static PointsManager instance; private void Awake() { freezetheBall = 0; if (instance == null) { instance = this; } slot1 = MaxSpeed; scoreInt = 0; NoOfDiamonds = 0; ScoreText.text = scoreInt.ToString(); //////////////////////////////increase score DiamondText.text = NoOfDiamonds.ToString(); } public void increaseDiamonds() { ///lets add sound Invoke("PointsGettingsound", GameIncB); //PointsGettingsound(); diamondCount = NoOfDiamonds; NoOfDiamonds += 10; if (repeatNO == 0) { repeatNO = 1; StartCoroutine("IncreaseDiamondsSTEPWise"); } } private void PointsGettingsound() { ManageTheAudio.instance.Play("Game+", GameIncA); } IEnumerator IncreaseDiamondsSTEPWise() { yield return null; while (DiamondText.text!=NoOfDiamonds.ToString()) { diamondCount += 1; //ScoreText.text = scoreInt.ToString(); DiamondText.text = diamondCount.ToString(); yield return new WaitForSeconds(.05f); // ScoreText.text = scoreInt.ToString(); // DiamondText.text = NoOfDiamonds.ToString(); } repeatNO = 0; StopCoroutine("IncreaseDiamondsSTEPWise"); } //public void increaseDiamonds() //{ // if (repeatNO == 0) // { // repeatNO = 1; // diamondCount = 10; // InvokeRepeating("increaseNOOfDiamondsSlowly", .001f, .001f); // } // if (repeatNO == 1) // { // repeatNO = 2; // callAgain = 1; // //called twice // } // if (repeatNO == 2) // { // callAgain = 1; // } // //NoOfDiamonds += 10; //} //void increaseNOOfDiamondsSlowly() //{ // NoOfDiamonds += 1; // ScoreText.text = scoreInt.ToString(); // DiamondText.text = NoOfDiamonds.ToString(); // diamondCount -= 1; // if (diamondCount <= 0) // { // diamondCount = 10; // repeatNO = 0; // CancelInvoke("increaseNOOfDiamondsSlowly"); // if (callAgain == 1) // { // callAgain = 0; // InvokeRepeating("increaseNOOfDiamondsSlowly", .001f, .001f); // } // } //} public void CheckStartClicked() { gamestate = 0; ///////experiment StartClicked = true; } ////////////////////////////////////////////////coin istantiation///////////////////////// public void Instantiatecoin(Vector3 crystalpos) { StartCoroutine("hello", crystalpos); Debug.Log("COIN CREATED"); } IEnumerator hello(Vector3 c) { int firstcoin = 0; yield return null; int l = 0; while (l < 10) { l = l + 1; //coinInstantiated = Instantiate(coinPrefab, c, Quaternion.identity); coinInstantiated = Instantiate(coinPrefab, new Vector3(c.x,c.y,c.z+.5f), Quaternion.Euler(new Vector3(Random.Range(MinSpreadx, MaxSpreadx), Random.Range(MinSpready, MaxSpready), Random.Range(MinSpreadz, MaxSpreadz) ))); if (firstcoin == 0) { ////add audio coinInstantiated.GetComponent<FLAY>().CrystalMarkedWithSound = 1; AudioSource a= coinInstantiated.GetComponent<AudioSource>(); a.time = 1f; if (UImanager.instance.Tempmusic2 == 1) { a.volume = 10f; } a.Play(); firstcoin = 1; } //yield return new WaitForEndOfFrame(); yield return new WaitForSeconds(.02f); } } ///////////////////////////////////////////////////////////////////////////////////////// // Start is called before the first frame update void Start() { rateToCallIncreasespeed = .1f; //if (ScreenWidth == Screen.width || ScreenHeight == Screen.height) //{ // ScreenHeight = Screen.width - (640 * 2); // ScreenWidth = Screen.height - (360 * 2); // Screen.SetResolution(ScreenWidth, ScreenHeight, true); //} //$ Debug.Log(((5 / 8) * (Mathf.Pow(16.1f, 2.1f))) + 160.1); } // Update is called once per frame void Update() { if (gamestate == 20) //////////////////aaaaaaaaaaaa { /// } ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// //maskI.rectTransform.sizeDelta = new Vector2(maskI.rectTransform.sizeDelta.x, (1)*MaskLength); BELOW METHOD IS BEAUTIFUL if (speed < MinSpeed) { float c = 225 - ((speed / MinSpeed) * 40); maskI.rectTransform.sizeDelta = new Vector2(maskI.rectTransform.sizeDelta.x, c); } if (speed >= MinSpeed && speed < 250) ////////////////taking 250 instead of maxspeed gives idea on absolute value so good playing experience $ no change { float d = 185 - (((speed - MinSpeed) / (250 - MinSpeed)) * 185); maskI.rectTransform.sizeDelta = new Vector2(maskI.rectTransform.sizeDelta.x, d); Debug.Log("is masking called;;;;;;;;;;;;;;;;;;;;"); } ////////////////////////////////////////////////////////////////////////////////checking variable change that is max speed//////////// //slot2 = MaxSpeed; //if (slot2 != slot1) //{ // if ((SpeedIncreasingStatus == 0) && (slot2 > slot1)&&(gamestate!=0&&gamestate!=10)) ////////////// HERE KEPT GAMESTATES IN OR BUT WAS AN ERROR // { // /////not invoke and that is where problem lies // x = Mathf.Pow(((8.0f / 5.0f) * (speed - MinSpeed)), .5f); // InvokeRepeating("IncreaseSpeed", 1f, rateToCallIncreasespeed); // gamestate = 4; //////since it is alternate solution so adjust in above update where to cance the invoke (why write same code twice) // SpeedIncreasingStatus = 1; // } //} this was when speed was changing $ ////////////////////////////////////////////////////////////////////////////////Control max speed////////////////////////////////////// //if (level==1|| level == 3 || level == 6 || level == 9) //{ // MaxSpeed = 250; // JumpSpeed = 60; //} //else //{ // //MaxSpeed = 200; ///////$ // MaxSpeed = 250; // JumpSpeed = 60;///////$ //} $ ///////////////////////////////////////////////////////////////////////////////////////////////LEVELS//////////////////////////////////////////// ///showing level change animation findLevel = scoreInt % 6000; if (findLevel <= 2000) { phaseNO = 1; } else if (findLevel <= 4000) { phaseNO = 2; } else { phaseNO = 3; //DisplayLevelChange(); } // DisplayLevelChange(); /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// if (speed <= 0 && gamestate != 0 && gamestate != 20) /////////////////this is for end to correct the speed if any left to make it 0 //////////aaaaaaaaa { speed = 0; StopBall = 1; //// lets assign high score here only if (highestScore < scoreInt) { highestScore = scoreInt; } } if (gamestate == 4 && speed >= MaxSpeed) ///this line is used for both m1 and m2 actually whole update is used so cheer no change to do here in both cases { CancelInvoke("IncreaseSpeed"); SpeedIncreasingStatus = 0; gamestate = 2; /////////////very important point we called the same condition and thus loop is completed basically there are total 4 cases on collision and those 4 cases only repeat this line is not necessary for method 2 } //////MOST IMPORTANTLY THERE SHOULD BE ONLY 2 CASES /////1 WHEN SPEED IS LESS THAN 200 AND THUS INVOKE IS NOT CANCELLED YET /////2 WHEN SPEED IS MORE THAN 200 AND THUS INVOKE IS CANCELLED if (gamestate == 0 && StartClicked == true) { StartClicked = false; gamestate = 1; InvokeRepeating("IncreaseSpeed", 1f, rateToCallIncreasespeed); SpeedIncreasingStatus = 1; } if (gamestate == 0 && PlayerPrefs.GetInt("diskState") == 1) { gamestate = 1; InvokeRepeating("IncreaseSpeed", 1f, rateToCallIncreasespeed); SpeedIncreasingStatus = 1; } if (gamestate == 1 && speed >= MaxSpeed) { gamestate = 2; CancelInvoke("IncreaseSpeed"); SpeedIncreasingStatus = 0; } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// if (scoreInt < (6000 + DifferenceINLevelVal)) { level = 0; LevelF = 0; } else if (scoreInt < (12000 + DifferenceINLevelVal)) { level = 1; LevelF = 1; } else if (scoreInt < (18000 + DifferenceINLevelVal)) { level = 2; LevelF = 2; } else if (scoreInt < (24000 + DifferenceINLevelVal)) { level = 3; LevelF = 3; } else if (scoreInt < (30000 + DifferenceINLevelVal)) { level = 4; LevelF = 4; } else if (scoreInt < (36000 + DifferenceINLevelVal)) { level = 5; LevelF = 5; } else { level = 6; LevelF = 6; } ///////////////////////////////////// if (LevelI != LevelF) { LevelI = LevelF; StartCoroutine("FlyParallely"); StartCoroutine("FlySoundInvokeLate"); Invoke("DeactivateLeveDisplayLate", 5f); //DeactivateLeveDisplayLate(); } } private void DeactivateLeveDisplayLate() { LevelDisplay.SetActive(false); } private void DisplayLevelChange() { if (scoreInt % (6000+DifferenceINLevelVal) == levelchangeDelay && scoreInt > 1000) { //LevelDisplay.SetActive(true); //LevelNoTextDisplay.text = level.ToString(); ////anim = LevelDisplay.GetComponent<Animation>(); these codes are to increase speed of animation when player speed in high //LevelDisplay.GetComponent<Animator>().Play("Fly"); //foreach (AnimationState state in anim) //{ // state.speed = 0.001F; //} StartCoroutine("FlyParallely"); StartCoroutine("FlySoundInvokeLate"); //Invoke("FlySoundInvokeLate", PowerUpLevelChangeSoundB); //FlySoundInvokeLate(); } if (scoreInt % (6000+DifferenceINLevelVal) == (levelchangeDelay + 100)) { LevelDisplay.SetActive(false); // LevelDisplay.GetComponent<Animator>().Play("LevelChangeAnimation"); } } IEnumerator FlyParallely() { LevelDisplay.SetActive(true); LevelNoTextDisplay.text = level.ToString(); //anim = LevelDisplay.GetComponent<Animation>(); these codes are to increase speed of animation when player speed in high LevelDisplay.GetComponent<Animator>().Play("Fly"); yield return null; StopCoroutine("FlyParallely"); } IEnumerator FlySoundInvokeLate() { ManageTheAudio.instance.Play("PowerUpLevelChangeSound", PowerUpLevelChangeSoundA); yield return null; StopCoroutine("FlySoundInvokeLate"); } //private void FlySoundInvokeLate() //{ // ManageTheAudio.instance.Play("PowerUpLevelChangeSound", PowerUpLevelChangeSoundA); //} private void FixedUpdate() { if (gamestate != 0 && gamestate != 10&gamestate!=20) ////////////aaaaaaaaaa { score = score + Time.deltaTime*(speed/10); scoreInt = Mathf.FloorToInt(score); // Debug.Log(scoreInt+ " " +speed); ScoreText.text = scoreInt.ToString(); //////////////////////////////increase score } } void IncreaseSpeed() { ////as many times speed changes pitch of sound also changes// UImanager.instance.CheckSpeedForRollingBall(); /// x = x + rateToReachTopSpeed; speed = ( (5.0f / 8.0f) * (Mathf.Pow(x, 2)) ) + MinSpeed; //Debug.Log(((5.0f / 8.0f) * (Mathf.Pow(x, 2))) + MinSpeed); } IEnumerator bLINKred() { rEDWARNING.gameObject.SetActive(true); yield return new WaitForSeconds(t); rEDWARNING.gameObject.SetActive(false); yield return new WaitForSeconds(t); rEDWARNING.gameObject.SetActive(true); yield return new WaitForSeconds(t); rEDWARNING.gameObject.SetActive(false); StopCoroutine("bLINKred"); } public void OnWrongCollision() { UImanager.instance.sound1.Play(); Invoke("GameDownSoundLate", GameDownB); //GameDownSoundLate(); rateToCallIncreasespeed = .04f; ///this will ensure first time accelaration is slow and next time it is fast ////////////////////////////////////////////////////METHOD 1/////////////////////////////////////////////////////////////////////// //if (gamestate == 2) //{ // //// speed is already 200 and invoke repeat is cancelled // //gamestate = 3; THIS IS WRONG SINCE IT WILL NEVER STOP IT CHECKS TO STOP ONLY AT GAMESTATE 1&4 // gamestate = 1; // speed = speed - 10f; // x = Mathf.Pow(((8.0f / 5.0f) * (speed - 160)), .5f); // InvokeRepeating("IncreaseSpeed", .1f, rateToIncreasespeed); //} //else if (gamestate == 1) //{ // ////speed has not reached 200 and the invokerepeat is not cancelled yet // CancelInvoke("IncreaseSpeed"); // speed = speed - 10f; // if (speed <= 160) // { // ////gameover // gamestate = 10; // } // if (speed > 160) // { // gamestate = 4; //////IF SPEED GETS200 THEN AGAIN WILL BE INVOKE CANCELED // x = Mathf.Pow(((8.0f / 5.0f) * (speed - 160)), .5f); // InvokeRepeating("IncreaseSpeed", .1f, rateToIncreasespeed); // } //} //else if (gamestate == 4) //{ // ///// we are in second phase that is now it is sure that speed increasing invoke is still being called so first cancel that NO HERE ALSO IT CAN SPEED GO BEYOND // CancelInvoke("IncreaseSpeed"); // ////// now we will decrease the speed remember decreasing speed first and then canelling the invoke may cause problem in calculation // speed = speed - 10f; // /////now we will check what is the speed and according to that we will decide what to do // if (speed <= 160) // { // ///then the player lost the game we will pause the game and bring the loop back to where it all started that is // gamestate = 10; ////back to where it started actually dont put here 0 otherwise on mouse click will start back // } // else if (speed < 200) // { // gamestate = 4; // ////we will invoke the speed increasing function here we will later on specify time for earch 170,180,...etc but for now keep this // x = Mathf.Pow(((8.0f / 5.0f) * (speed - 160)), .5f); // InvokeRepeating("IncreaseSpeed", .1f, rateToIncreasespeed); // } //} /////////////////////////////////////////////////////METOD 2/////////////////////////////////////////////////////////////////////// if (speed < MaxSpeed) { ///means invoke is not cancelled yet CancelInvoke("IncreaseSpeed"); speed = speed - JumpSpeed; ///sound part UImanager.instance.CheckSpeedForRollingBall(); /// if (speed <= MinSpeed) { ////gameover rEDWARNING.gameObject.SetActive(true); Debug.Log("game is over"); ///it is checked only when any collision happens so even if cutoff speed is more than minspeed or the starting speed it will not finish untill there is any collision gamestate = 10; ////back to where it started actually dont put here 0 otherwise on mouse click will start back StartCoroutine("SpeedToZero"); Invoke("StartTheDynamicGameoverSoundLate", GameOverDramaticSoundB); //StartTheDynamicGameoverSoundLate(); /////also ensure the sound SpeedIncreasingStatus = 0; } else if (speed > MinSpeed) { ////game is on StartCoroutine("bLINKred"); x = Mathf.Pow(((8.0f / 5.0f) * (speed - MinSpeed)), .5f); InvokeRepeating("IncreaseSpeed", 5f, rateToCallIncreasespeed); //$5-1 gamestate = 4; //////since it is alternate solution so adjust in above update where to cance the invoke (why write same code twice) SpeedIncreasingStatus = 1; } } else if (speed >= MaxSpeed) { /////means invoke is cancelled and speed is 200 so StartCoroutine("bLINKred"); speed = speed - JumpSpeed; ///sound part UImanager.instance.CheckSpeedForRollingBall(); /// x = Mathf.Pow(((8.0f / 5.0f) * (speed - MinSpeed)), .5f); InvokeRepeating("IncreaseSpeed", 5f, rateToCallIncreasespeed); //$5-1 gamestate = 4; //////since it is alternate solution so adjust in above update where to cance the invoke (why write same code twice) SpeedIncreasingStatus = 1; } } private void StartTheDynamicGameoverSoundLate() { ManageTheAudio.instance.Play("GameOverDramaticSound", GameOverDramaticSoundA); } private void GameDownSoundLate() { ManageTheAudio.instance.Play("Game-", GameDownA); } IEnumerator SpeedToZero() { yield return new WaitForSeconds(.1f); while (speed > 0) { //speed = speed - .5f; //// value of decreament in one call speed = speed - .6f; ///sound part UImanager.instance.CheckSpeedForRollingBall(); /// Debug.Log("speed to 0 coroutine is called"); yield return new WaitForSeconds(.001f); //////// how often is value decreased per second } speed = 0; freezetheBall = 1; StopCoroutine("SpeedToZero"); } }

File no 11: /colame/Assets/SCRIPTS/RotateBorder.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class RotateBorder : MonoBehaviour { float j; int i; public float BorderRotationSpeed; // Start is called before the first frame update void Start() { i = Random.Range(0, 2); if (i == 0) { j = BorderRotationSpeed; } else { j = -BorderRotationSpeed; } } // Update is called once per frame void Update() { //if(PointsManager.instance.level==7|| PointsManager.instance.level == 8 || PointsManager.instance.level == 9) //{ // transform.Rotate(0, j * Time.deltaTime, 0); //} $ if (PointsManager.instance.level == 4 || PointsManager.instance.level >=5 ) { transform.Rotate(0, j * Time.deltaTime, 0); } } }

File no 12: /colame/Assets/SCRIPTS/SOUNDs.cs
﻿using UnityEngine.Audio; using UnityEngine; using System; [System.Serializable] public class SOUNDs { public string name; public AudioClip SongDropHere; [Range(0,1)] public float volume; [Range(0.1f, 3f)] public float pitch; public bool LoopIt; //public bool StatusOfPlayOnAwake; //play on awake wont work [NonSerialized] ////this is to make because i always want the Audio Manager scipt to be the souce public AudioSource AUDIOsOURCE; }

File no 13: /colame/Assets/SCRIPTS/SPAWNINGpT.cs
﻿using System; using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.SocialPlatforms; using Random = UnityEngine.Random; public class SPAWNINGpT : MonoBehaviour { public int FLAG = 0; int STATEiNVOKE = 0; ///////////////Experimental int InvokeState = 0; /////////////this was introduced to check invoke at the end int lastthingspawwned = 0; int lastborderspawwned = 2; //0 for nothing ,1 for redborder ,2 for greenborder ,3 for yellowborder ,4 for crystal pack RGB ,5 for crystal pack RBG,6 for crystal pack GRB,7 for crystal pack GBR ,8 for crystal pack BRG,9 for crystal pack BGR; // lastborderspawwned=0,1 for redborder,2 for greenborder,3 for blueborder; public GameObject crystalred, crystalgreen, crystalblue, borderred,bordergreen,borderblue; // public GameObject bordercrystalPosLeft, bordercrystalPosMiddle, bordercrystalPosRight; int randomNOborder; bool initialspawn = true; public bool gameState = false; int flag=1; public float MaxrangeOfDist; public float MinrangeOfDist; public float MinimalrangeOfDist; public GameObject player; Vector3 spawnigptvector; bool validToSpawn =true; public GameObject bridgePrefab; GameObject spawnedBridgeObject; // Start is called before the first frame update void Start() { // Debug.Log("hi there"); // spawnigptvector = spawnpt.transform.position; spawnigptvector = new Vector3(0,0,19); //InvokeRepeating(spawnBridge(), 2f, 2f); PointsManager.instance.LocationOfSpawningBridge = spawnigptvector; } // Update is called once per frame void Update() { /////////////////////////////////////////////////////////////////////////////////////////////////// if (PointsManager.instance.gamestate==0&&FLAG==0) { STATEiNVOKE = 1; } if (STATEiNVOKE==1) { FLAG = 1; ////////////this will prevent re invoking on any further mouse click InvokeRepeating("spawnBridge", 1f, 1f); STATEiNVOKE = 2; InvokeState = 1; Debug.Log("reeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"); } if ((player.transform.position - spawnigptvector).magnitude < MinrangeOfDist && STATEiNVOKE == 3) { InvokeRepeating("spawnBridge", 1f, 1f); STATEiNVOKE = 2; InvokeState = 1; } if ((player.transform.position - spawnigptvector).magnitude > MaxrangeOfDist &&(STATEiNVOKE==2||STATEiNVOKE==4)) { CancelInvoke("spawnBridge"); STATEiNVOKE = 3; InvokeState = 0; } if ((player.transform.position - spawnigptvector).magnitude < MinimalrangeOfDist &&STATEiNVOKE==2) { CancelInvoke("spawnBridge"); //InvokeRepeating("spawnBridge", 1f, .5f); $ InvokeRepeating("spawnBridge", .1f, .2f); STATEiNVOKE = 4; InvokeState = 1; } //else { CancelInvoke("spawnBridge"); // Console.WriteLine("error"); // Debug.Log("error"); //} //////////////////////////////////////////EXPERIMENT/////////////////////////////////////// // if (Input.GetMouseButtonDown(0)) // { // gameState = true; // } // if (gameState && initialspawn) // { // InvokeState = 1; /////////////////Invoking right now // InvokeRepeating("spawnBridge", 1f, 1f); // initialspawn = false; // //transform.Translate(0, 0, forceToBall * Time.deltaTime); // } // Console.WriteLine("hi check"); //// Debug.Log("hi there update"); // if ((player.transform.position - spawnigptvector).magnitude > MaxrangeOfDist&&flag==1) // { // validToSpawn = false; // flag = 0; // CancelInvoke("spawnBridge"); // InvokeState = 0; ///////////////////not invoking right now // Console.WriteLine("enter2"); // Debug.Log("enter2"); // } // else if ((player.transform.position - spawnigptvector).magnitude < MinrangeOfDist && (player.transform.position - spawnigptvector).magnitude > MinimalrangeOfDist && flag == 0) // { // validToSpawn = true; // flag = 1; // if (PointsManager.instance.level == 1 || PointsManager.instance.level == 3 || PointsManager.instance.level == 6 || PointsManager.instance.level == 9) // { // InvokeRepeating("spawnBridge", 1f, .5f); // } // else // { // InvokeRepeating("spawnBridge", 1f, 1f); // } // InvokeState = 1; ////////////////////////invoking right now // Console.WriteLine("enter1"); // Debug.Log("enter1"); // } // else if ((player.transform.position - spawnigptvector).magnitude < MinimalrangeOfDist && flag == 1) // { // validToSpawn = true; // flag = 1; // CancelInvoke("spawnBridge"); // if(PointsManager.instance.level==1|| PointsManager.instance.level == 3 || PointsManager.instance.level == 6 || PointsManager.instance.level == 9) // { // InvokeRepeating("spawnBridge", 1f, .5f); // } // else // { // InvokeRepeating("spawnBridge", 1f, 1f); // } // InvokeState = 1; ////////////////////////invoking right now // Console.WriteLine("enter1"); // Debug.Log("enter1"); // } //else { CancelInvoke("spawnBridge"); // Console.WriteLine("error"); // Debug.Log("error"); //} //////////////////////////////////////this part is about cancelling invoke at the end of game if (PointsManager.instance.gamestate == 10) { if (InvokeState == 0) { //////////////not invoking so ok } else if (InvokeState == 1) { ////////////////invoking right now so cancel it CancelInvoke("spawnBridge"); InvokeState = 0; } } } ////////////////////////////////////SEND LOCATION OF SPAWNING POINT////////////////////////// public void spawningPointLocation() { PointsManager.instance.LocationOfSpawningBridge = spawnigptvector; Debug.Log(spawnigptvector+"hello this is location of spawnning point"); } void spawnBridge() { /////////////////// int Phase = PointsManager.instance.scoreInt % 6000; ////////////////// spawnedBridgeObject = Instantiate(bridgePrefab, spawnigptvector, Quaternion.identity); GameObject ChildGameObject1 = spawnedBridgeObject.transform.GetChild(2).gameObject; spawnigptvector = ChildGameObject1.transform.position; spawningPointLocation(); ///////////////////////////this was to get access to location of spawning point for to bring the island GameObject Zborder = spawnedBridgeObject.transform.GetChild(5).gameObject; GameObject Zcrystalleft = spawnedBridgeObject.transform.GetChild(6).gameObject; GameObject Zcrystalmiddle = spawnedBridgeObject.transform.GetChild(7).gameObject; GameObject Zcrystalright = spawnedBridgeObject.transform.GetChild(8).gameObject; GameObject ZBleft = spawnedBridgeObject.transform.GetChild(9).gameObject; GameObject ZBmiddle = spawnedBridgeObject.transform.GetChild(10).gameObject; GameObject ZBright = spawnedBridgeObject.transform.GetChild(11).gameObject; /////////////////////////////////BORDER POSITION FILLING randomNOborder = Random.Range(0, 20); if (randomNOborder < 3 && (lastthingspawwned!=1&& lastthingspawwned != 2&& lastthingspawwned != 3)) //takes care of two consecutive borders { ////////////////////////////////////////////////////border spawning // lastborderspawwned takes care of any two same color border being spawwned consecutively int abk = Random.Range(0, 2); if (lastborderspawwned == 1) { if (abk == 0) { GameObject b = Instantiate(bordergreen, Zborder.transform.position, Quaternion.identity); lastthingspawwned = 2; lastborderspawwned = 2; } if (abk == 1) { GameObject c = Instantiate(borderblue, Zborder.transform.position, Quaternion.identity); lastthingspawwned = 3; lastborderspawwned = 3; } } else if (lastborderspawwned == 2) { if (abk == 0) { GameObject c = Instantiate(borderblue, Zborder.transform.position, Quaternion.identity); lastthingspawwned = 3; lastborderspawwned = 3; } if (abk == 1) { GameObject a = Instantiate(borderred, Zborder.transform.position, Quaternion.identity); lastthingspawwned = 1; lastborderspawwned = 1; } } else if (lastborderspawwned == 3) { if (abk == 0) { GameObject b = Instantiate(bordergreen, Zborder.transform.position, Quaternion.identity); lastthingspawwned = 2; lastborderspawwned = 2; } if (abk == 1) { GameObject a = Instantiate(borderred, Zborder.transform.position, Quaternion.identity); lastthingspawwned = 1; lastborderspawwned = 1; } } } else if (randomNOborder < 20) { //////////////////////////////////////////////////////////////////////////////////CRYSTAL SPAWNING //0 for nothing ,1 for redborder ,2 for greenborder ,3 for yellowborder ,4 for crystal pack RGB ,5 for crystal pack RBG,6 for crystal pack GRB,7 for crystal pack GBR ,8 for crystal pack BRG,9 for crystal pack BGR; int randomNOcrystal1 = Random.Range(0, 6001); // to be worked out for other level?? float randomRotationCrystal = Random.Range(0, 5f); ////?????????????????????????????????????????????????????????????????????????????????????????????????????10//////////////5////////////// if (randomNOcrystal1 < Phase+3000) // randomNOcrystal was creating problem since used inside other fn also so put 1 in front { GameObject[] crystal1 = { crystalred, crystalgreen, crystalblue }; // randomNOcrystal was creating problem since used inside other fn also so put 1 in front //crystal spawning new technique generating random //int NoOfCrystals; //if (PointsManager.instance.level==2|| PointsManager.instance.level == 3 || PointsManager.instance.level == 5 || PointsManager.instance.level == 6 || PointsManager.instance.level == 8 || PointsManager.instance.level == 9) //{ // NoOfCrystals = Random.Range(0, 3); ///////////////////////////this will make sure that only one crystal is instantiated in given levels //} //else //{ // NoOfCrystals = Random.Range(0, 2); //} $ int NoOfCrystals; if (PointsManager.instance.level == 1 || PointsManager.instance.level == 3 || PointsManager.instance.level >= 6) { NoOfCrystals = Random.Range(0, 3); ///////////////////////////this will make sure that only one crystal is instantiated in given levels } else { NoOfCrystals = Random.Range(0, 2); } if (NoOfCrystals == 0) { //no crystal instantiated if (Phase >= 4000) ////$ made to make more dense { //one crystal instantiated int CrystalColor = Random.Range(0, 3); if (CrystalColor == 0) { //red crystal instantiated int PosOfCrystal = Random.Range(0, 3); if (PosOfCrystal == 0) { //left side crystal is created GameObject a = Instantiate(crystal1[0], ZBleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 1) { //middle side crystal is created //GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal1[0], ZBmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; //a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); //c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 2) { //right side crystal is created //GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal1[1], ZBright.transform.position, Quaternion.identity); lastthingspawwned = 8; // a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (CrystalColor == 1) { //green crystal instantiated int PosOfCrystal = Random.Range(0, 3); if (PosOfCrystal == 0) { //left side crystal is created GameObject a = Instantiate(crystal1[1], ZBleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 1) { //middle side crystal is created //GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal1[1], ZBmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; // a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 2) { //right side crystal is created //GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); // GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal1[1], ZBright.transform.position, Quaternion.identity); lastthingspawwned = 8; //a.transform.Rotate(0, Random.Range(0, 360), 0); //b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (CrystalColor == 2) { //blue crystal instantiated int PosOfCrystal = Random.Range(0, 3); if (PosOfCrystal == 0) { //left side crystal is created GameObject a = Instantiate(crystal1[2], ZBleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); // GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); //c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 1) { //middle side crystal is created // GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal1[2], ZBmiddle.transform.position, Quaternion.identity); // GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; // a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 2) { //right side crystal is created //GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal1[2], ZBright.transform.position, Quaternion.identity); lastthingspawwned = 8; // a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } } } else if (NoOfCrystals == 1) //here approach different from that of when NoOfCrystals==2 there everything summed at first only here it is hierarchy but benefit of NoOfCrystals ==2 aproach we dont need to write multiple times random { //one crystal instantiated int CrystalColor = Random.Range(0, 3); if (CrystalColor == 0) { //red crystal instantiated int PosOfCrystal = Random.Range(0, 3); if (PosOfCrystal == 0) { //left side crystal is created GameObject a = Instantiate(crystal1[0], ZBleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 1) { //middle side crystal is created //GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal1[0], ZBmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; //a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); //c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 2) { //right side crystal is created //GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal1[1], ZBright.transform.position, Quaternion.identity); lastthingspawwned = 8; // a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (CrystalColor == 1) { //green crystal instantiated int PosOfCrystal = Random.Range(0, 3); if (PosOfCrystal == 0) { //left side crystal is created GameObject a = Instantiate(crystal1[1], ZBleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 1) { //middle side crystal is created //GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal1[1], ZBmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; // a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 2) { //right side crystal is created //GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); // GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal1[1], ZBright.transform.position, Quaternion.identity); lastthingspawwned = 8; //a.transform.Rotate(0, Random.Range(0, 360), 0); //b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (CrystalColor == 2) { //blue crystal instantiated int PosOfCrystal = Random.Range(0, 3); if (PosOfCrystal == 0) { //left side crystal is created GameObject a = Instantiate(crystal1[2], ZBleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); // GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); //c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 1) { //middle side crystal is created // GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal1[2], ZBmiddle.transform.position, Quaternion.identity); // GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; // a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 2) { //right side crystal is created //GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal1[2], ZBright.transform.position, Quaternion.identity); lastthingspawwned = 8; // a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } } else if (NoOfCrystals == 2) { //two crystal instantiated int orderSet = Random.Range(0, 27); //orderSet 0=R-R,1=G-G,2=B-B,3=R-G,4=G-R,5=R-G,6=B-R,7=B-G,8=G-B, , 9=-RR,10=-GG,11=-BB,12=-RG,13=-GR,14=-RB,15=-BR,16=-BG,17=-GB, ,18=RR,19=GG,20=BB,21=RG,22=GR-,23=RB-,24=BR-,25=BG-,26=GB- if (orderSet == 0) { GameObject a = Instantiate(crystal1[0], ZBleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[1], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal1[0], ZBright.transform.position, Quaternion.identity); lastthingspawwned = 4; a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (orderSet == 1) { GameObject a = Instantiate(crystal1[1], ZBleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[1], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal1[1], ZBright.transform.position, Quaternion.identity); lastthingspawwned = 4; a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (orderSet == 2) { GameObject a = Instantiate(crystal1[2], ZBleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[1], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal1[2], ZBright.transform.position, Quaternion.identity); lastthingspawwned = 4; a.transform.Rotate(0, Random.Range(0, 360), 0); //b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (orderSet == 3) { GameObject a = Instantiate(crystal1[0], ZBleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[1], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal1[1], ZBright.transform.position, Quaternion.identity); lastthingspawwned = 4; a.transform.Rotate(0, Random.Range(0, 360), 0); //b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (orderSet == 4) { GameObject a = Instantiate(crystal1[1], ZBleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[1], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal1[0], ZBright.transform.position, Quaternion.identity); lastthingspawwned = 4; a.transform.Rotate(0, Random.Range(0, 360), 0); //b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (orderSet == 5) { GameObject a = Instantiate(crystal1[0], ZBleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[1], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal1[2], ZBright.transform.position, Quaternion.identity); lastthingspawwned = 4; a.transform.Rotate(0, Random.Range(0, 360), 0); //b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (orderSet == 6) { GameObject a = Instantiate(crystal1[2], ZBleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[1], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal1[0], ZBright.transform.position, Quaternion.identity); lastthingspawwned = 4; a.transform.Rotate(0, Random.Range(0, 360), 0); //b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (orderSet == 7) { GameObject a = Instantiate(crystal1[2], ZBleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[1], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal1[1], ZBright.transform.position, Quaternion.identity); lastthingspawwned = 4; a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (orderSet == 8) { if (lastthingspawwned == 11 || lastthingspawwned == 15 || lastthingspawwned == 16) { SpecialCaseSpawnningOfCrystal(ZBleft, ZBmiddle, ZBright, crystal1); } else { //GameObject a = Instantiate(crystal1[0], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal1[1], ZBmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal1[2], ZBright.transform.position, Quaternion.identity); // lastthingspawwned = 4; lastthingspawwned = 21; //a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// else if (orderSet == 9) { if (lastthingspawwned == 12 || lastthingspawwned == 13 || lastthingspawwned == 14 || lastthingspawwned == 15 || lastthingspawwned == 16) { SpecialCaseSpawnningOfCrystal(ZBleft, ZBmiddle, ZBright, crystal1); } else { //GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal1[0], ZBmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal1[0], ZBright.transform.position, Quaternion.identity); lastthingspawwned = 24; // a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 10) { if (lastthingspawwned == 11 || lastthingspawwned == 13 || lastthingspawwned == 14 || lastthingspawwned == 15 || lastthingspawwned == 16 ) { SpecialCaseSpawnningOfCrystal(ZBleft, ZBmiddle, ZBright, crystal1); } else { //GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal1[1], ZBmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal1[1], ZBright.transform.position, Quaternion.identity); lastthingspawwned = 25; //a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 11) { if (lastthingspawwned == 11 || lastthingspawwned == 12 || lastthingspawwned == 14 || lastthingspawwned == 15 || lastthingspawwned == 16) { SpecialCaseSpawnningOfCrystal(ZBleft, ZBmiddle, ZBright, crystal1); } else { //GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal1[2], ZBmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal1[2], ZBright.transform.position, Quaternion.identity); lastthingspawwned = 26; //a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 12) { if ( lastthingspawwned == 13 || lastthingspawwned == 14 || lastthingspawwned == 15) { SpecialCaseSpawnningOfCrystal(ZBleft, ZBmiddle, ZBright, crystal1); } else { //GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal1[0], ZBmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal1[1], ZBright.transform.position, Quaternion.identity); lastthingspawwned = 23; //a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 13) { if ( lastthingspawwned == 13 || lastthingspawwned == 14 || lastthingspawwned == 15) { SpecialCaseSpawnningOfCrystal(ZBleft, ZBmiddle, ZBright, crystal1); } else { //GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal1[1], ZBmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal1[0], ZBright.transform.position, Quaternion.identity); lastthingspawwned = 23; //a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 14) { if ( lastthingspawwned == 12 || lastthingspawwned == 14 || lastthingspawwned == 16) { SpecialCaseSpawnningOfCrystal(ZBleft, ZBmiddle, ZBright, crystal1); } else { // GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal1[0], ZBmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal1[2], ZBright.transform.position, Quaternion.identity); lastthingspawwned = 22; //a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 15) { if ( lastthingspawwned == 12 || lastthingspawwned == 14 || lastthingspawwned == 16 ) { SpecialCaseSpawnningOfCrystal(ZBleft, ZBmiddle, ZBright, crystal1); } else { //GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal1[2], ZBmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal1[0], ZBright.transform.position, Quaternion.identity); lastthingspawwned = 22; //a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 16) { if (lastthingspawwned == 11|| lastthingspawwned == 15 || lastthingspawwned == 16 ) { SpecialCaseSpawnningOfCrystal(ZBleft, ZBmiddle, ZBright, crystal1); } else { //GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal1[2], ZBmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal1[1], ZBright.transform.position, Quaternion.identity); lastthingspawwned = 21; // a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 17) { if (lastthingspawwned == 11 || lastthingspawwned == 15 || lastthingspawwned == 16) { SpecialCaseSpawnningOfCrystal(ZBleft, ZBmiddle, ZBright, crystal1); } else { //GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal1[1], ZBmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal1[2], ZBright.transform.position, Quaternion.identity); lastthingspawwned = 21; //a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// else if (orderSet == 18) { if ( lastthingspawwned == 22 || lastthingspawwned == 23 || lastthingspawwned == 24 || lastthingspawwned == 25 || lastthingspawwned == 26) { SpecialCaseSpawnningOfCrystal(ZBleft, ZBmiddle, ZBright, crystal1); } else { GameObject a = Instantiate(crystal1[0], ZBleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal1[0], ZBmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[2], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 14; a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); //c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 19) { if (lastthingspawwned == 21 || lastthingspawwned == 23 || lastthingspawwned == 24 || lastthingspawwned == 25 || lastthingspawwned == 26) { SpecialCaseSpawnningOfCrystal(ZBleft, ZBmiddle, ZBright, crystal1); } else { GameObject a = Instantiate(crystal1[1], ZBleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal1[1], ZBmiddle.transform.position, Quaternion.identity); // GameObject c = Instantiate(crystal[2], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 15; a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); //c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 20) { if ( lastthingspawwned == 21 || lastthingspawwned == 22 || lastthingspawwned == 24 || lastthingspawwned == 25 || lastthingspawwned == 26) { SpecialCaseSpawnningOfCrystal(ZBleft, ZBmiddle, ZBright, crystal1); } else { GameObject a = Instantiate(crystal1[2], ZBleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal1[2], ZBmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[2], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 16; a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); //c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 21) { if (lastthingspawwned == 13 || lastthingspawwned == 14 || lastthingspawwned == 15) { SpecialCaseSpawnningOfCrystal(ZBleft, ZBmiddle, ZBright, crystal1); } else { GameObject a = Instantiate(crystal1[0], ZBleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal1[1], ZBmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[2], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 13; a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 22) { if (lastthingspawwned == 13 || lastthingspawwned == 14 || lastthingspawwned == 15) { SpecialCaseSpawnningOfCrystal(ZBleft, ZBmiddle, ZBright, crystal1); } else { GameObject a = Instantiate(crystal1[1], ZBleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal1[0], ZBmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[2], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 13; a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); //c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 23) { if (lastthingspawwned == 12 || lastthingspawwned == 14 || lastthingspawwned == 16) { SpecialCaseSpawnningOfCrystal(ZBleft, ZBmiddle, ZBright, crystal1); } else { GameObject a = Instantiate(crystal1[0], ZBleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal1[2], ZBmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[2], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 12; a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); //c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 24) { if (lastthingspawwned == 12 || lastthingspawwned == 14 || lastthingspawwned == 16) { SpecialCaseSpawnningOfCrystal(ZBleft, ZBmiddle, ZBright, crystal1); } else { GameObject a = Instantiate(crystal1[2], ZBleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal1[0], ZBmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[2], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 12; a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 25) { if (lastthingspawwned == 11 || lastthingspawwned == 15 || lastthingspawwned == 16) { SpecialCaseSpawnningOfCrystal(ZBleft, ZBmiddle, ZBright, crystal1); } else { GameObject a = Instantiate(crystal1[2], ZBleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal1[1], ZBmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[2], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 11; a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); //c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 26) { if (lastthingspawwned == 11 || lastthingspawwned == 15 || lastthingspawwned == 16) { SpecialCaseSpawnningOfCrystal(ZBleft, ZBmiddle, ZBright, crystal1); } else { GameObject a = Instantiate(crystal1[1], ZBleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal1[2], ZBmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[2], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 11; a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); //c.transform.Rotate(0, Random.Range(0, 360), 0); } } } } } /////////////////////////////////////////CRYSTAL POSTION FILLING int randomNOcrystal = Random.Range(0, 6001); // to be worked out for other level?? float randomRotationCrystal = Random.Range(0, 5f); if (randomNOcrystal < Phase+3000) { GameObject[] crystal = { crystalred, crystalgreen, crystalblue }; //crystal spawning old method helped only in creating a wall of crystals //int spawncrystalOrder = Random.Range(0, 6); //GameObject[] crystal = { crystalred, crystalgreen, crystalblue }; //switch (spawncrystalOrder) //{ // case 0: // { // //int l = Random.Range(0, 2); // GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); // GameObject b = Instantiate(crystal[1], Zcrystalmiddle.transform.position, Quaternion.identity); // GameObject c = Instantiate(crystal[2], Zcrystalright.transform.position, Quaternion.identity); // lastthingspawwned = 4; // a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); // } // break; // case 1: // { // GameObject a = Instantiate(crystal[1], Zcrystalleft.transform.position, Quaternion.identity); // a.transform.Rotate(0, Random.Range(0, 360), 0); // GameObject b = Instantiate(crystal[2], Zcrystalmiddle.transform.position, Quaternion.identity); // b.transform.Rotate(0, Random.Range(0, 360), 0); // GameObject c = Instantiate(crystal[0], Zcrystalright.transform.position, Quaternion.identity); // c.transform.Rotate(0, Random.Range(0, 360), 0); // lastthingspawwned = 7; // } // break; // case 2: // { // GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); // GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); // GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); // lastthingspawwned = 8; // a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); // } // break; // case 3: // { // GameObject a = Instantiate(crystal[1], Zcrystalleft.transform.position, Quaternion.identity); // GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); // GameObject c = Instantiate(crystal[2], Zcrystalright.transform.position, Quaternion.identity); // lastthingspawwned = 6; // a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); // } // break; // case 4: // { // GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); // GameObject b = Instantiate(crystal[1], Zcrystalmiddle.transform.position, Quaternion.identity); // GameObject c = Instantiate(crystal[0], Zcrystalright.transform.position, Quaternion.identity); // lastthingspawwned = 9; // a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); // } // break; // case 5: // { // GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); // GameObject b = Instantiate(crystal[2], Zcrystalmiddle.transform.position, Quaternion.identity); // GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); // lastthingspawwned = 5; // a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); // } // break; //} //crystal spawning new technique generating random //int NoOfCrystals; //if (PointsManager.instance.level == 2 || PointsManager.instance.level == 3 || PointsManager.instance.level == 5 || PointsManager.instance.level == 6 || PointsManager.instance.level == 8 || PointsManager.instance.level == 9) //{ // NoOfCrystals = Random.Range(0, 3); ///////////////////////////this will make sure that only one crystal is instantiated in given levels //} //else //{ // NoOfCrystals = Random.Range(0, 2); //} $ int NoOfCrystals; if (PointsManager.instance.level == 1 || PointsManager.instance.level == 3 || PointsManager.instance.level >= 6 ) { NoOfCrystals = Random.Range(0, 3); ///////////////////////////this will make sure that only one crystal is instantiated in given levels } else { NoOfCrystals = Random.Range(0, 2); } //this below is used everywhere for 1 crystal or 2 crystal with few twicks //GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); //lastthingspawwned = 8; //a.transform.Rotate(0, Random.Range(0, 360), 0); //b.transform.Rotate(0, Random.Range(0, 360), 0); //c.transform.Rotate(0, Random.Range(0, 360), 0); if (NoOfCrystals == 0) { //no crystal instantiated if (Phase >= 4000) { //one crystal instantiated ///$ make more dense int CrystalColor = Random.Range(0, 3); if (CrystalColor == 0) { //red crystal instantiated int PosOfCrystal = Random.Range(0, 3); if (PosOfCrystal == 0) { //left side crystal is created GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 1) { //middle side crystal is created //GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; //a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); //c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 2) { //right side crystal is created //GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; // a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (CrystalColor == 1) { //green crystal instantiated int PosOfCrystal = Random.Range(0, 3); if (PosOfCrystal == 0) { //left side crystal is created GameObject a = Instantiate(crystal[1], Zcrystalleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 1) { //middle side crystal is created //GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal[1], Zcrystalmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; // a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 2) { //right side crystal is created //GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); // GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; //a.transform.Rotate(0, Random.Range(0, 360), 0); //b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (CrystalColor == 2) { //blue crystal instantiated int PosOfCrystal = Random.Range(0, 3); if (PosOfCrystal == 0) { //left side crystal is created GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); // GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); //c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 1) { //middle side crystal is created // GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal[2], Zcrystalmiddle.transform.position, Quaternion.identity); // GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; // a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 2) { //right side crystal is created //GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal[2], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; // a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } } } else if (NoOfCrystals == 1) //here approach different from that of when NoOfCrystals==2 there everything summed at first only here it is hierarchy but benefit of NoOfCrystals ==2 aproach we dont need to write multiple times random { //one crystal instantiated int CrystalColor = Random.Range(0, 3); if (CrystalColor == 0) { //red crystal instantiated int PosOfCrystal = Random.Range(0, 3); if (PosOfCrystal == 0) { //left side crystal is created GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 1) { //middle side crystal is created //GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; //a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); //c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 2) { //right side crystal is created //GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; // a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (CrystalColor == 1) { //green crystal instantiated int PosOfCrystal = Random.Range(0, 3); if (PosOfCrystal == 0) { //left side crystal is created GameObject a = Instantiate(crystal[1], Zcrystalleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 1) { //middle side crystal is created //GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal[1], Zcrystalmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; // a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 2) { //right side crystal is created //GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); // GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; //a.transform.Rotate(0, Random.Range(0, 360), 0); //b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (CrystalColor == 2) { //blue crystal instantiated int PosOfCrystal = Random.Range(0, 3); if (PosOfCrystal == 0) { //left side crystal is created GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); // GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); //c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 1) { //middle side crystal is created // GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal[2], Zcrystalmiddle.transform.position, Quaternion.identity); // GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; // a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 2) { //right side crystal is created //GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal[2], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; // a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } } else if (NoOfCrystals == 2) { //two crystal instantiated int orderSet = Random.Range(0,27); //orderSet 0=R-R,1=G-G,2=B-B,3=R-G,4=G-R,5=R-G,6=B-R,7=B-G,8=G-B, , 9=-RR,10=-GG,11=-BB,12=-RG,13=-GR,14=-RB,15=-BR,16=-BG,17=-GB, ,18=RR,19=GG,20=BB,21=RG,22=GR-,23=RB-,24=BR-,25=BG-,26=GB- if (orderSet == 0) { GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[1], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal[0], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 4; a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (orderSet == 1) { GameObject a = Instantiate(crystal[1], Zcrystalleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[1], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 4; a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (orderSet == 2) { GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[1], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal[2], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 4; a.transform.Rotate(0, Random.Range(0, 360), 0); //b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (orderSet == 3) { GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[1], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 4; a.transform.Rotate(0, Random.Range(0, 360), 0); //b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (orderSet == 4) { GameObject a = Instantiate(crystal[1], Zcrystalleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[1], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal[0], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 4; a.transform.Rotate(0, Random.Range(0, 360), 0); //b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (orderSet == 5) { GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[1], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal[2], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 4; a.transform.Rotate(0, Random.Range(0, 360), 0); //b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (orderSet == 6) { GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[1], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal[0], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 4; a.transform.Rotate(0, Random.Range(0, 360), 0); //b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (orderSet == 7) { GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[1], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 4; a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (orderSet == 8) { GameObject a = Instantiate(crystal[1], Zcrystalleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[1], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal[2], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 4; a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// else if (orderSet == 9) { if (lastthingspawwned == 12 || lastthingspawwned == 13 || lastthingspawwned == 14 || lastthingspawwned == 15 || lastthingspawwned == 16) { SpecialCaseSpawnningOfCrystal(Zcrystalleft, Zcrystalmiddle, Zcrystalright, crystal); } else { //GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal[0], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 24; // a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 10) { if (lastthingspawwned == 11 || lastthingspawwned == 13 || lastthingspawwned == 14 || lastthingspawwned == 15 || lastthingspawwned == 16) { SpecialCaseSpawnningOfCrystal(Zcrystalleft, Zcrystalmiddle, Zcrystalright, crystal); } else { //GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal[1], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 25; //a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 11) { if (lastthingspawwned == 11 || lastthingspawwned == 12 || lastthingspawwned == 14 || lastthingspawwned == 15 || lastthingspawwned == 16) { SpecialCaseSpawnningOfCrystal(Zcrystalleft, Zcrystalmiddle, Zcrystalright, crystal); } else { //GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal[2], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal[2], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 26; //a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 12) { if (lastthingspawwned == 13 || lastthingspawwned == 14 || lastthingspawwned == 15) { SpecialCaseSpawnningOfCrystal(Zcrystalleft, Zcrystalmiddle, Zcrystalright, crystal); } else { //GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 23; //a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 13) { if (lastthingspawwned == 13 || lastthingspawwned == 14 || lastthingspawwned == 15) { SpecialCaseSpawnningOfCrystal(Zcrystalleft, Zcrystalmiddle, Zcrystalright, crystal); } else { //GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal[1], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal[0], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 23; //a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 14) { if (lastthingspawwned == 12 || lastthingspawwned == 14 || lastthingspawwned == 16) { SpecialCaseSpawnningOfCrystal(Zcrystalleft, Zcrystalmiddle, Zcrystalright, crystal); } else { // GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal[2], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 22; //a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 15) { if (lastthingspawwned == 12 || lastthingspawwned == 14 || lastthingspawwned == 16 ) { SpecialCaseSpawnningOfCrystal(Zcrystalleft, Zcrystalmiddle, Zcrystalright, crystal); } else { //GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal[2], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal[0], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 22; //a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 16) { if (lastthingspawwned == 11 || lastthingspawwned == 15 || lastthingspawwned == 16) { SpecialCaseSpawnningOfCrystal(Zcrystalleft, Zcrystalmiddle, Zcrystalright, crystal); } else { //GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal[2], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 21; // a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 17) { if (lastthingspawwned == 11 ||lastthingspawwned == 15 || lastthingspawwned == 16 ) { SpecialCaseSpawnningOfCrystal(Zcrystalleft, Zcrystalmiddle, Zcrystalright, crystal); } else { //GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal[1], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal[2], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 21; //a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// else if (orderSet == 18) { if (lastthingspawwned == 22 || lastthingspawwned == 23 || lastthingspawwned == 24 || lastthingspawwned == 25 || lastthingspawwned == 26) { SpecialCaseSpawnningOfCrystal(Zcrystalleft, Zcrystalmiddle, Zcrystalright, crystal); } else { GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[2], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 14; a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); //c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 19) { if (lastthingspawwned == 21 || lastthingspawwned == 23 || lastthingspawwned == 24 || lastthingspawwned == 25 || lastthingspawwned == 26) { SpecialCaseSpawnningOfCrystal(Zcrystalleft, Zcrystalmiddle, Zcrystalright, crystal); } else { GameObject a = Instantiate(crystal[1], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal[1], Zcrystalmiddle.transform.position, Quaternion.identity); // GameObject c = Instantiate(crystal[2], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 15; a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); //c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 20) { if (lastthingspawwned == 21 || lastthingspawwned == 22 || lastthingspawwned == 24 || lastthingspawwned == 25 || lastthingspawwned == 26) { SpecialCaseSpawnningOfCrystal(Zcrystalleft, Zcrystalmiddle, Zcrystalright, crystal); } else { GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal[2], Zcrystalmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[2], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 16; a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); //c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 21) { if (lastthingspawwned == 13 || lastthingspawwned == 14 || lastthingspawwned == 15) { SpecialCaseSpawnningOfCrystal(Zcrystalleft, Zcrystalmiddle, Zcrystalright, crystal); } else { GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal[1], Zcrystalmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[2], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 13; a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 22) { if (lastthingspawwned == 13 || lastthingspawwned == 14 || lastthingspawwned == 15) { SpecialCaseSpawnningOfCrystal(Zcrystalleft, Zcrystalmiddle, Zcrystalright, crystal); } else { GameObject a = Instantiate(crystal[1], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[2], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 13; a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); //c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 23) { if (lastthingspawwned == 12 || lastthingspawwned == 14 || lastthingspawwned == 16) { SpecialCaseSpawnningOfCrystal(Zcrystalleft, Zcrystalmiddle, Zcrystalright, crystal); } else { GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal[2], Zcrystalmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[2], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 12; a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); //c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 24) { if (lastthingspawwned == 12 || lastthingspawwned == 14 || lastthingspawwned == 16) { SpecialCaseSpawnningOfCrystal(Zcrystalleft, Zcrystalmiddle, Zcrystalright, crystal); } else { GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[2], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 12; a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 25) { if (lastthingspawwned == 11 || lastthingspawwned == 15 || lastthingspawwned == 16) { SpecialCaseSpawnningOfCrystal(Zcrystalleft, Zcrystalmiddle, Zcrystalright, crystal); } else { GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal[1], Zcrystalmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[2], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 11; a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); //c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (orderSet == 26) { if (lastthingspawwned == 11 || lastthingspawwned == 15 || lastthingspawwned == 16) { SpecialCaseSpawnningOfCrystal(Zcrystalleft, Zcrystalmiddle, Zcrystalright, crystal); } else { GameObject a = Instantiate(crystal[1], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal[2], Zcrystalmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[2], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 11; a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); //c.transform.Rotate(0, Random.Range(0, 360), 0); } } } } } private void SpecialCaseSpawnningOfCrystal(GameObject ZBleft, GameObject ZBmiddle, GameObject ZBright, GameObject[] crystal1) { //one crystal instantiated int CrystalColor = Random.Range(0, 3); if (CrystalColor == 0) { //red crystal instantiated int PosOfCrystal = Random.Range(0, 3); if (PosOfCrystal == 0) { //left side crystal is created GameObject a = Instantiate(crystal1[0], ZBleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 1) { //middle side crystal is created //GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal1[0], ZBmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; //a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); //c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 2) { //right side crystal is created //GameObject a = Instantiate(crystal[0], Zcrystalleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal1[1], ZBright.transform.position, Quaternion.identity); lastthingspawwned = 8; // a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (CrystalColor == 1) { //green crystal instantiated int PosOfCrystal = Random.Range(0, 3); if (PosOfCrystal == 0) { //left side crystal is created GameObject a = Instantiate(crystal1[1], ZBleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 1) { //middle side crystal is created //GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal1[1], ZBmiddle.transform.position, Quaternion.identity); //GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; // a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 2) { //right side crystal is created //GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); // GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal1[1], ZBright.transform.position, Quaternion.identity); lastthingspawwned = 8; //a.transform.Rotate(0, Random.Range(0, 360), 0); //b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } else if (CrystalColor == 2) { //blue crystal instantiated int PosOfCrystal = Random.Range(0, 3); if (PosOfCrystal == 0) { //left side crystal is created GameObject a = Instantiate(crystal1[2], ZBleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); // GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); //c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 1) { //middle side crystal is created // GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); GameObject b = Instantiate(crystal1[2], ZBmiddle.transform.position, Quaternion.identity); // GameObject c = Instantiate(crystal[1], Zcrystalright.transform.position, Quaternion.identity); lastthingspawwned = 8; // a.transform.Rotate(0, Random.Range(0, 360), 0); b.transform.Rotate(0, Random.Range(0, 360), 0); // c.transform.Rotate(0, Random.Range(0, 360), 0); } else if (PosOfCrystal == 2) { //right side crystal is created //GameObject a = Instantiate(crystal[2], Zcrystalleft.transform.position, Quaternion.identity); //GameObject b = Instantiate(crystal[0], Zcrystalmiddle.transform.position, Quaternion.identity); GameObject c = Instantiate(crystal1[2], ZBright.transform.position, Quaternion.identity); lastthingspawwned = 8; // a.transform.Rotate(0, Random.Range(0, 360), 0); // b.transform.Rotate(0, Random.Range(0, 360), 0); c.transform.Rotate(0, Random.Range(0, 360), 0); } } } } //0 for nothing ,1 for redborder ,2 for greenborder ,3 for blueborder ,4 for crystal pack RGB ,5 for crystal pack RBG,6 for crystal pack GRB,7 for crystal pack GBR ,8 for crystal pack BRG,9 for crystal pack BGR, //, 11 for AA_ missing red,, 12 for AA_ missing green,, 13 for AA_ missing redBlue,// 14 for AA_ red,, 15 for AA_ green,, 15 for AA_ Blue,///, 21 for _AA missing red,, 22 for _AA missing green,, 23 for _AA missing blue, 21 for _AA missing red,// 24 for _AA red,, 25 for _AA green,, 26 for _AA blue, /* we have to be very picky lets see>>>>>>>>>>>>>... AA_ _AA 11 21 -red unavailable 12 22 -green unavailable 13 23 -blue unavailable 14 24 -only red 15 25 -only blue 16 26 -only green for example if spawning 11 then last thing spawned can't be 21,25,26 and this is very picy as for rest we will have each color crystal let say 11 and 22 then in first red unavailable but in second red is available */ ///////////Detail on levels /////////////////NO OF CRYSTALS /////////MAX SPEED/////////ROTATION OF CRYSTAL ////// ROTATION OF BOARD ///leve 0 1 200 0 0 ///level 1 1 250 0 0 $ ///level 2 1/2 200 0 0 ///level 3 1/2 250 0 0 $ ///level 4 1 200 1 0 ///level 5 1/2 200 1 0 ///level 6 1/2 250 1 0 $ ///level 7 1 200 0 1 ///level 8 1/2 200 1 1 ///level 9 1/2 250 1 1 $ ///level 10 /// ///////////Detail on levels /////////////////NO OF CRYSTALS /////////MAX SPEED/////////ROTATION OF CRYSTAL ////// ROTATION OF BOARD ///leve 0 1 200 0 0 5000 ///level 1 1/2 200 0 0 10000 ///level 2 1 200 1 0 ///level 3 1/2 200 1 0 ///level 4 1 200 0 1 ///level 5 1 200 1 1 //////level 6 1/2 200 1 1 ///level 10

File no 14: /colame/Assets/SCRIPTS/UImanager.cs
﻿using System.Collections; using System.Collections.Generic; using System.Runtime.ExceptionServices; using UnityEngine; using UnityEngine.SceneManagement; using UnityEngine.UI; public class UImanager : MonoBehaviour { public GameObject spawnObj; /// instead of image i use Gameobject RED and that also worked /////////////public Image RedWarning; public GameObject RED; int TempSwipeLeft, TempSwipeRight ,TempKey,TempKeyNoChange=0; public GameObject SwipeRight, SwipeLeft; public GameObject coinsPrefab; public int Tempmusic1, Tempmusic2; public float panel1, panel2, LeaderBoardSoundNLeaderBoardSoundA, LeaderBoardSoundNLeaderBoardSoundB,initialPitch,PitchChangeValue, WaitToReplaySound,WaitChangeValue; /// <summary> /// /sound /// </summary> public GameObject Player; public AudioSource[] mysound; public AudioSource sound1; public AudioSource sound2; public float setTheMaxPitch; /// int demoScore, demoCoins, demohighScore; public float IncreasetotaltimeA, IncreasetotaltimeB, IncreasetotaltimeC, elapsedtimeA; public GameObject star1, star2, star3; int callUpdateOnce = 0; int ScoreC; int HighScoreC; int NoOfDiamondsC; public Text HighScoreTextMainMenu; public Text CoinsTextMainMenu; public Text HighScoreTextPauseMenu; public Text CoinsTextPauseMenu; public Text HighScoreTextGameOverMenu; public Text CointsGameoverMenu; public Text ScoreGameoverMenu; public Text NoOfKeysRequired; public Text TotalNoOfKeys; public Text LevelTextPause; public int TotalNOOfDiamondsSystem; ////////////////////////////////////////////////// // public Text PausePanelDiamondText; ///////////////////////////////////////////////// public float t1=0; public float t2; public GameObject MainMenuUp; public GameObject GameOverPanelshow; public GameObject LifePanel; public static UImanager instance; public GameObject PausePanel; int flagForPreventingRecallingofPlayerPrefs = 0; public int lifeState = 0; private void Awake() { TempKeyNoChange = 0; if (PlayerPrefs.HasKey("Key")) { TempKey = PlayerPrefs.GetInt("Key"); } else { PlayerPrefs.SetInt("Key", 0); TempKey = 0; } //if (PlayerPrefs.HasKey("SwipeRight")) //{ // TempSwipeRight = PlayerPrefs.GetInt("SwipeRight"); //} //else ///two prefs not needed //{ // TempSwipeRight = 0; // // PlayerPrefs.SetInt("SwipeRight", 0); //} just write this TempSwipeRight =0; if (PlayerPrefs.HasKey("SwipeLeft")) { Debug.Log("a called"); TempSwipeLeft = 2; flagForPreventingRecallingofPlayerPrefs = 1; } else { Debug.Log("b called"); TempSwipeLeft = 0; //PlayerPrefs.SetInt("SwipeLeft", 0); flagForPreventingRecallingofPlayerPrefs = 0; } /////////////////////////////////////////////////////////////////////////////////////// if (PlayerPrefs.HasKey("music1")) { Tempmusic1 = PlayerPrefs.GetInt("music1"); } else { Tempmusic1 = 1; PlayerPrefs.SetInt("music1", 1); } if (PlayerPrefs.HasKey("music2")) { Tempmusic2 = PlayerPrefs.GetInt("music2"); } else { Tempmusic2 = 1; PlayerPrefs.SetInt("music2", 1); } // PlayerPrefs.SetInt("ScoreComp", 0); ////not required ScoreC = 0; //PlayerPrefs.SetInt("HighScoreComp", 0); use this two to refresh value to 0 //PlayerPrefs.SetInt("diamondsNOComp", 0); if (PlayerPrefs.HasKey("HighScoreComp")) { HighScoreC = PlayerPrefs.GetInt("HighScoreComp"); } else { HighScoreC = 0; PlayerPrefs.SetInt("HighScoreComp", 0); } if (PlayerPrefs.HasKey("diamondsNOComp")) { NoOfDiamondsC = PlayerPrefs.GetInt("diamondsNOComp"); } else { NoOfDiamondsC = 0; PlayerPrefs.SetInt("diamondsNOComp", 0); } if (PlayerPrefs.HasKey("ScoreNOComp")) { ScoreC = PlayerPrefs.GetInt("ScoreNOComp"); } else { ScoreC = 0; PlayerPrefs.SetInt("ScoreNOComp", 0); } Debug.Log("awake called"); if (instance == null) { instance = this; } } // Start is called before the first frame update void Start() { ////sounds/// mysound = Player.GetComponents<AudioSource>(); sound1 = mysound[0]; sound2 = mysound[1]; if (Tempmusic1 == 0) { ManageTheAudio.instance.ThemeVol0(); } else { ManageTheAudio.instance.ThemeVol1(); } if (Tempmusic2 == 0) { ManageTheAudio.instance.soundVo0(); sound1.volume = 0; sound2.volume = 0; coinsPrefab.GetComponent<AudioSource>().volume = 0f; Player.GetComponents<AudioSource>(); } else { ManageTheAudio.instance.soundVo1(); sound1.volume = .8f; sound2.volume = 1f; coinsPrefab.GetComponent<AudioSource>().volume = 0.008f; } if (ManageTheAudio.instance.music1Status == 1) { } ////////// // PlayerPrefs.SetInt("diskState",0) ; if (PlayerPrefs.GetInt("diskState")==0) { MainMenuUp.SetActive(true); HighScoreTextMainMenu.text = HighScoreC.ToString(); CoinsTextMainMenu.text = NoOfDiamondsC.ToString(); Debug.Log("ddddddddddddddddddddddddddddddddddddddddddddddddddddd"); Debug.Log("ddddddddgggggggggggggggggggggggggggggggggggggggggg" + Tempmusic1); if (Tempmusic1 == 0) { GameObject musicOff = MainMenuUp.transform.GetChild(15).gameObject; musicOff.SetActive(true); GameObject musicOn = MainMenuUp.transform.GetChild(18).gameObject; musicOn.SetActive(false); } else { GameObject musicOff = MainMenuUp.transform.GetChild(15).gameObject; musicOff.SetActive(false); GameObject musicOn = MainMenuUp.transform.GetChild(18).gameObject; musicOn.SetActive(true); } if (Tempmusic2 == 0) { GameObject musicOff = MainMenuUp.transform.GetChild(16).gameObject; musicOff.SetActive(true); GameObject musicOn = MainMenuUp.transform.GetChild(19).gameObject; musicOn.SetActive(false); } else { GameObject musicOff = MainMenuUp.transform.GetChild(16).gameObject; musicOff.SetActive(false); GameObject musicOn = MainMenuUp.transform.GetChild(19).gameObject; musicOn.SetActive(true); } } else { GameOverPanelshow.gameObject.SetActive(true); PointsManager.instance.gamestate = 0; ScoreGameoverMenu.text = ScoreC.ToString(); HighScoreTextGameOverMenu.text = HighScoreC.ToString(); CointsGameoverMenu.text = NoOfDiamondsC.ToString(); ///to set value in gameover panel while going up ///panel up sound //ManageTheAudio.instance.Play("panel", panel1); Invoke("panelUpSounInvokeLate", panel2); GameOverPanelshow.gameObject.GetComponent<Animator>().Play("moveGameOverUp"); //show animation ////sound sound2.Play(); CheckSpeedForRollingBall(); /// } PlayerPrefs.SetInt("diskScore", PointsManager.instance.scoreInt); //PlayerPrefs.SetInt("diskState", PointsManager.instance.DiskState); } public void PlayClickedEndgamePanel() { Resume1(); ///// this is to ensure that bridge stop destroying after gameover panel is displayed and someone intentionally left at that panel for long. //sound add ManageTheAudio.instance.Play("button", 0f); /// PlayerPrefs.SetInt("HighScoreComp", HighScoreC); PlayerPrefs.SetInt("diamondsNOComp", NoOfDiamondsC); PlayerPrefs.SetInt("ScoreNOComp", ScoreC); PlayerPrefs.SetInt("diskState",1); //public static void Save(); ManageTheAudio.instance.Play("button", 0f); sound2.Stop(); if (TempKeyNoChange == 1) { PlayerPrefs.SetInt("Key", TempKey); } if (TempSwipeLeft == 2 & flagForPreventingRecallingofPlayerPrefs == 0) { SwipeGuide(); ///ensures name is assignes only once } SceneManager.LoadScene(0); //GameOverPanelshow.gameObject.GetComponent<Animator>().Play("moveGameOverUp"); ////need to load scene again //PointsManager.instance.gamestate = 0; //MainMenuUp.gameObject.SetActive(false);//////////expo Debug.Log(" scene is loaded is this executed"); } public void KeyIncrease() { TempKey += 1; TempKeyNoChange = 1; } public void KeyDecrease() { TempKey -= 1; TempKeyNoChange = 1; } public void PlayClicked() { //////////////////////////////////////////////////////////////////////////////////// //TempSwipeLeft=0; //this was set just to check in while making the game // TempSwipeRight = 0; /////////////////////////////////////////////////////////////////////////////////// ManageTheAudio.instance.Play("button", 0f); ////lets add sound //sound2.Play(); Invoke("StartRollingFirstTime", .01f); //FindObjectOfType<ManageTheAudio>().Play("") Invoke("panelUpSounInvokeLate", panel2); //panelUpSounInvokeLate(); MainMenuUp.gameObject.GetComponent<Animator>().Play("mainMenuUp"); } private void panelUpSounInvokeLate() { ManageTheAudio.instance.Play("panel", panel1); } public void CheckSpeedForRollingBall() { sound2.pitch = PointsManager.instance.speed * setTheMaxPitch / 250; } void StartRollingFirstTime() { sound2.Play(); sound2.pitch = 0; } public void PauseClick() { //sound ManageTheAudio.instance.Play("button", 0f); LevelTextPause.text = PointsManager.instance.level.ToString(); int v; v = PointsManager.instance.scoreInt% (6000+PointsManager.instance.DifferenceINLevelVal) ; HighScoreTextPauseMenu.text = HighScoreC.ToString(); CoinsTextPauseMenu.text = NoOfDiamondsC.ToString(); ////pause panel diamond //PointsManager.instance.gamestate = 20; ///faith PausePanel.SetActive(true); star1.SetActive(false); star2.SetActive(false); star3.SetActive(false); if (v < 2000) { star1.SetActive(true); star2.SetActive(false); star3.SetActive(false); //case 1; } else if (v < 4000) { star1.SetActive(true); star2.SetActive(true); star3.SetActive(false); //case 2; } else if (v < (6000+PointsManager.instance.DifferenceINLevelVal)) { star1.SetActive(true); star2.SetActive(true); star3.SetActive(true); //case 3; } sound2.Pause(); PauseGame(); } public void Resumeclicked() { ///sound ManageTheAudio.instance.Play("button", 0f); sound2.Play(); PausePanel.SetActive(false); // Invoke("ResumeGame", 3f); ResumeGame(); } void PauseGame() { Time.timeScale = 0; // Time.unscaledDeltaTime = 0; } void ResumeGame() { //StartCoroutine("hi"); Resume1(); } void Resume1() { Time.timeScale = 1; //Time.unscaledDeltaTime = 1; } // Update is called once per frame void Update() { /////////////////////////////////////////////all about what is pressed when lifeState is 1; ////////////////////////////////////////////////////////////////////// ////swipe right panel if (Player.transform.position.z >=1.5f&& TempSwipeRight==0&&TempSwipeLeft==0) { SwipeRight.gameObject.SetActive(true); SwipeRight.gameObject.GetComponent<Animator>().Play("swipeRight"); TempSwipeRight = 1; } if (Player.transform.position.z >=6f&&TempSwipeRight==1&TempSwipeLeft==0) { SwipeRight.gameObject.SetActive(false); //SwipeRight.gameObject.GetComponent<Animation>().Play("swipeRight"); TempSwipeRight = 2; } ////swipe left panel if (Player.transform.position.z >= 8.5f&& TempSwipeLeft==0) { SwipeLeft.gameObject.SetActive(true); SwipeLeft.gameObject.GetComponent<Animator>().Play("swipeLeft"); TempSwipeLeft = 1; } if (Player.transform.position.z >= 12.5f) { SwipeLeft.gameObject.SetActive(false); //SwipeRight.gameObject.GetComponent<Animation>().Play("swipeRight"); TempSwipeLeft = 2; } if (PointsManager.instance.gamestate == 10) { ///float demoScore, demoCoins,demohighScore; make it gloabally available withing the script demohighScore = HighScoreC; ////it has to be kept outside // demoCoins = NoOfDiamondsC; if (PointsManager.instance.scoreInt >HighScoreC) { HighScoreC = PointsManager.instance.scoreInt; } if (callUpdateOnce == 0) { callUpdateOnce = 1; ScoreC = PointsManager.instance.scoreInt; demoScore = 0; demoCoins = NoOfDiamondsC; NoOfDiamondsC += PointsManager.instance.NoOfDiamonds; //CointsGameoverMenu.text = NoOfDiamondsC.ToString(); //ScoreGameoverMenu.text = PointsManager.instance.scoreInt.ToString(); // HighScoreTextGameOverMenu.text = HighScoreC.ToString(); MainMenuUp.SetActive(false); Invoke("InvokeLifePanelLate", 3.8f); Invoke("whatToDoIfNOthingIsClicked",3.5f+6f); //InvokeLifePanelLate(); //Invoke("GameoverPanelShowLate", 3.8f + 5.5f); //Invoke("GameoverPanelShowLate", 3.8f); //GameoverPanelShowLate(); //StartCoroutine("IncreaseScoreDiamondHighScore"); } //GameOverPanelshow.gameObject.SetActive(true); ////so that it doesn't pop up in } } public void whatToDoIfNOthingIsClicked() { if (lifeState == 1) { Invoke("GameoverPanelShowLate", .3f); } } public void ElseButtonclicked() { if (lifeState == 1) { lifeState = 2; } else { lifeState = 3; LifePanel.GetComponent<Animator>().enabled = false; Invoke("GameoverPanelShowLate", .3f); } } public void AddButtonclicked() { ///sound ManageTheAudio.instance.Play("button", 0f); lifeState = 5; //LifePanel.GetComponent<Animator>().enabled = false; /////Add LifePanel.SetActive(false); //Invoke("StartRollingFirstTime", .01f); PointsManager.instance.StopBall = 0; PointsManager.instance.freezetheBall = 0; Player.GetComponent<playerMovement>().UnfreezeTheBall(); //@ PointsManager.instance.CheckStartClicked(); RED.SetActive(false); callUpdateOnce = 0; spawnObj.GetComponent<SPAWNINGpT>().FLAG = 0; PointsManager.instance.speed = 200f; //////////////this will make it feel that it started from where it was left CheckSpeedForRollingBall(); PointsManager.instance.rateToCallIncreasespeed = .07f; //PointsManager.instance.gamestate = 4; //add show here Invoke("waitforSeconds", 5f); //lifeState = 9; } public void KeyClicked() { ///sound ManageTheAudio.instance.Play("button", 0f); lifeState = 6; if (TempKey > 0) { lifeState = 7; /// //Restart LifePanel.SetActive(false); //Invoke("StartRollingFirstTime", .01f); PointsManager.instance.StopBall = 0; PointsManager.instance.freezetheBall = 0; Player.GetComponent<playerMovement>().UnfreezeTheBall(); //@ PointsManager.instance.CheckStartClicked(); RED.SetActive(false); callUpdateOnce = 0; spawnObj.GetComponent<SPAWNINGpT>().FLAG = 0; PointsManager.instance.speed = 280f; //////////////this will make it feel that it started from where it was left CheckSpeedForRollingBall(); PointsManager.instance.rateToCallIncreasespeed = .07f; // PointsManager.instance.gamestate = 4; KeyDecrease(); Invoke("waitforSeconds", 5f); //waitforSeconds(); } } private void waitforSeconds() { if (lifeState == 7) { lifeState = 8; } if (lifeState == 5) { lifeState = 9; } } private void InvokeLifePanelLate() { Debug.Log("life caaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaled;"); LifePanel.SetActive(true); TotalNoOfKeys.text = TempKey.ToString(); int c = 1; NoOfKeysRequired.text = c.ToString(); LifePanel.GetComponent<Animator>().Play("BlinkLife"); lifeState = 1; } private void GameoverPanelShowLate() { LifePanel.SetActive(false); GameOverPanelshow.gameObject.SetActive(true); ScoreGameoverMenu.text = demoScore.ToString(); ////o always at starting GameOverPanelshow.gameObject.GetComponent<Animator>().Play("GameoverPanelDown"); Invoke("panelUpSounInvokeLate", panel2); if (demohighScore < HighScoreC) { Debug.Log("HIGHsCOREcALLED"); HighScoreTextGameOverMenu.text = demohighScore.ToString(); StartCoroutine("IncreaseHighScore"); } else { HighScoreTextGameOverMenu.text = HighScoreC.ToString(); } if (demoCoins < NoOfDiamondsC) { Debug.Log("COINcALLED"); CointsGameoverMenu.text = demoCoins.ToString(); StartCoroutine("IncreaseDiamond"); } else { CointsGameoverMenu.text = NoOfDiamondsC.ToString(); } if (demoScore < ScoreC) { Debug.Log("sCOREcALLED"); StartCoroutine("IncreaseScore"); //Invoke("ScoreIncreasingSound", LeaderBoardSoundNLeaderBoardSoundB); //ScoreIncreasingSound(); StartCoroutine("AudioSoundMaker"); } else { ScoreGameoverMenu.text = PointsManager.instance.scoreInt.ToString(); ///but here rarely come } } IEnumerator AudioSoundMaker() { yield return new WaitForSeconds(LeaderBoardSoundNLeaderBoardSoundB); int v = 0; while (v < 1000) { v += 1; ManageTheAudio.instance.Play("LeaderBoardSoundNLeaderBoardSound", LeaderBoardSoundNLeaderBoardSoundA); ManageTheAudio.instance.ListOfSounds[10].AUDIOsOURCE.pitch = initialPitch; initialPitch += PitchChangeValue; yield return new WaitForSeconds(WaitToReplaySound); WaitToReplaySound -= WaitChangeValue; // ManageTheAudio.instance.ListOfSounds[10].AUDIOsOURCE.Stop(); //ManageTheAudio.instance.Stop("LeaderBoardSoundNLeaderBoardSound"); } } private void ScoreIncreasingSound() { ManageTheAudio.instance.Play("LeaderBoardSoundNLeaderBoardSound", LeaderBoardSoundNLeaderBoardSoundA); } IEnumerator IncreaseScore() { //yield return null; yield return new WaitForSeconds(1.8f); elapsedtimeA = 0; IncreasetotaltimeA += (PointsManager.instance.score / 10000) ; while (elapsedtimeA < IncreasetotaltimeA) { elapsedtimeA += Time.deltaTime; float currentValA = Mathf.Lerp(demoScore, ScoreC, Mathf.Clamp01(elapsedtimeA / IncreasetotaltimeA)); ScoreGameoverMenu.text = Mathf.RoundToInt(currentValA).ToString(); /// Invoke("IncreaseLeaderboardScoreLateInvoke", LeaderBoardSoundNLeaderBoardSoundB); ///Aproach x for leader board didn't work //IncreaseLeaderboardScoreLateInvoke(); yield return new WaitForEndOfFrame(); } StopCoroutine("AudioSoundMaker"); ManageTheAudio.instance.Play("endBeep", .2f); PauseClick(); /// this is to ensure that bridge stop destroying after gameover panel is displayed and someone intentionally left at that panel for long. StopCoroutine("IncreaseScore"); } private void IncreaseLeaderboardScoreLateInvoke() { ManageTheAudio.instance.Play("LeaderBoardSoundNLeaderBoardSound", LeaderBoardSoundNLeaderBoardSoundA); } IEnumerator IncreaseHighScore() { // yield return null; yield return new WaitForSeconds(1.8f); elapsedtimeA = 0; while (elapsedtimeA < IncreasetotaltimeB) { elapsedtimeA += Time.deltaTime; float currentValB = Mathf.Lerp(demohighScore,HighScoreC, Mathf.Clamp01(elapsedtimeA / IncreasetotaltimeB)); HighScoreTextGameOverMenu.text = Mathf.RoundToInt(currentValB).ToString(); /// Invoke("IncreaseLeaderboardScoreLateInvoke", LeaderBoardSoundNLeaderBoardSoundB); ///Aproach x for leader board didn't work yield return new WaitForEndOfFrame(); } StopCoroutine("IncreaseHighScore"); } IEnumerator IncreaseDiamond() { //yield return null; yield return new WaitForSeconds(1.8f); elapsedtimeA = 0; while (elapsedtimeA < IncreasetotaltimeC) { elapsedtimeA += Time.deltaTime; float currentValC = Mathf.Lerp(demoCoins, NoOfDiamondsC, Mathf.Clamp01(elapsedtimeA / IncreasetotaltimeA)); CointsGameoverMenu.text = Mathf.RoundToInt(currentValC).ToString(); /// Invoke("IncreaseLeaderboardScoreLateInvoke", LeaderBoardSoundNLeaderBoardSoundB); ///Aproach x for leader board didn't work yield return new WaitForEndOfFrame(); } StopCoroutine("IncreaseDiamond"); } public void quitGAme() { if (TempKeyNoChange == 1) { PlayerPrefs.SetInt("Key", TempKey); } if (TempSwipeLeft == 2 & flagForPreventingRecallingofPlayerPrefs == 0) { SwipeGuide(); ///ensures name is assignes only once } ///sound ManageTheAudio.instance.Play("button", 0f); PlayerPrefs.SetInt("diskState", 0); PlayerPrefs.SetInt("music1", Tempmusic1); PlayerPrefs.SetInt("music2", Tempmusic2); Application.Quit(); } private void SwipeGuide() { PlayerPrefs.SetInt("SwipeLeft", TempSwipeLeft); } void OnApplicationQuit() //////////this helps see it in unity app that when we want to call quitGame this has to be done { if (TempKeyNoChange == 1) { PlayerPrefs.SetInt("Key", TempKey); } if (TempSwipeLeft == 2 & flagForPreventingRecallingofPlayerPrefs == 0) { SwipeGuide(); ///ensures name is assignes only once } ///////////////////////////////////////////////////////////////////////// PlayerPrefs.SetInt("music1", Tempmusic1); PlayerPrefs.SetInt("music2", Tempmusic2); if (PointsManager.instance.scoreInt > HighScoreC) { HighScoreC = PointsManager.instance.scoreInt; } NoOfDiamondsC += PointsManager.instance.NoOfDiamonds; PlayerPrefs.SetInt("HighScoreComp", HighScoreC); PlayerPrefs.SetInt("diamondsNOComp", NoOfDiamondsC); PlayerPrefs.SetInt("diskState", 0); //Debug.Log("Application ending after " + Time.time + " seconds"); } void OnApplicationPause() //////////this helps see it in unity app that when we want to call quitGame this has to be done { if (TempKeyNoChange == 1) { PlayerPrefs.SetInt("Key", TempKey); } if (TempSwipeLeft == 2 & flagForPreventingRecallingofPlayerPrefs == 0) { SwipeGuide(); ///ensures name is assignes only once } ///////////////////////////////////////////////////////////////////////// PlayerPrefs.SetInt("music1", Tempmusic1); PlayerPrefs.SetInt("music2", Tempmusic2); if (PointsManager.instance.scoreInt > HighScoreC) { HighScoreC = PointsManager.instance.scoreInt; } NoOfDiamondsC += PointsManager.instance.NoOfDiamonds; PlayerPrefs.SetInt("HighScoreComp", HighScoreC); PlayerPrefs.SetInt("diamondsNOComp", NoOfDiamondsC); PlayerPrefs.SetInt("diskState", 0); //Debug.Log("Application ending after " + Time.time + " seconds"); } public void GoToMainMenu() { Resume1(); ///// this is to ensure that bridge stop destroying after gameover panel is displayed and someone intentionally left at that panel for long. ManageTheAudio.instance.Play("button", 0f); PlayerPrefs.SetInt("HighScoreComp", HighScoreC); PlayerPrefs.SetInt("diamondsNOComp", NoOfDiamondsC); PlayerPrefs.SetInt("diskState",0); PlayerPrefs.SetInt("music1", Tempmusic1); PlayerPrefs.SetInt("music2", Tempmusic2); if (TempKeyNoChange == 1) { PlayerPrefs.SetInt("Key", TempKey); } if (TempSwipeLeft == 2 & flagForPreventingRecallingofPlayerPrefs == 0) { SwipeGuide(); ///ensures name is assignes only once } SceneManager.LoadScene(0); } public void ThemeVol0() { ///sound ManageTheAudio.instance.Play("button", 0f); Tempmusic1 = 0; ManageTheAudio.instance.ThemeVol0(); GameObject musicOff = MainMenuUp.transform.GetChild(15).gameObject; musicOff.SetActive(true); GameObject musicOn = MainMenuUp.transform.GetChild(18).gameObject; musicOn.SetActive(false); } public void ThemeVol1() { ///sound ManageTheAudio.instance.Play("button", 0f); Tempmusic1 = 1; ManageTheAudio.instance.ThemeVol1(); GameObject musicOff = MainMenuUp.transform.GetChild(15).gameObject; musicOff.SetActive(false); GameObject musicOn = MainMenuUp.transform.GetChild(18).gameObject; musicOn.SetActive(true); } public void soundVol0() { ///sound ManageTheAudio.instance.Play("button", 0f); Tempmusic2 = 0; ManageTheAudio.instance.soundVo0(); GameObject musicOff = MainMenuUp.transform.GetChild(16).gameObject; musicOff.SetActive(true); GameObject musicOn = MainMenuUp.transform.GetChild(19).gameObject; musicOn.SetActive(false); coinsPrefab.GetComponent<AudioSource>().volume = 0f; sound1.volume = 0f; sound2.volume = 0f; } public void soundVol1() { ///sound ManageTheAudio.instance.Play("button", 0f); Tempmusic2 = 1; ManageTheAudio.instance.soundVo1(); GameObject musicOff = MainMenuUp.transform.GetChild(16).gameObject; musicOff.SetActive(false); GameObject musicOn = MainMenuUp.transform.GetChild(19).gameObject; musicOn.SetActive(true); coinsPrefab.GetComponent<AudioSource>().volume = 0.008f; sound1.volume = .8f; sound2.volume = 1f; } }

File no 15: /colame/Assets/SCRIPTS/changeColorOfSky.cs
﻿using System; using System.Collections; using System.Collections.Generic; using UnityEngine; public class changeColorOfSky : MonoBehaviour { int flag = 0; float exposureStart = 0.7f; float exposureEnd = 0f; public float currentExposure; public float currentAlpha; float fadeTiming = 5f; // Start is called before the first frame update void Start() { ////////////////Debug.Log(Time.deltaTime + "this is time"); important no matter how many times you call it will not reach there RenderSettings.skybox.SetFloat("_Exposure", currentExposure); } // Update is called once per frame void Update() { ///////////////////Debug.Log("hello this is the lerp "+Mathf.Lerp(1, 2, .2f)); important no matter how many times you call it will not reach there if (PointsManager.instance.level==1&&(flag==0)) { exposureStart = .7f; exposureEnd = 0f; fadeDown(); flag = 1; } if (PointsManager.instance.level == 2 && (flag == 1)) { exposureStart = 0f; exposureEnd = 0.7f; fadeDown(); flag = 0; } if (PointsManager.instance.level == 3 && (flag == 0)) { exposureStart = .7f; exposureEnd = 0f; fadeDown(); flag = 1; } if (PointsManager.instance.level == 4 && (flag == 1)) { exposureStart = 0f; exposureEnd = 0.7f; fadeDown(); flag = 0; } if (PointsManager.instance.level == 5 && (flag == 0)) { exposureStart = .7f; exposureEnd = 0f; fadeDown(); flag = 1; } if (PointsManager.instance.level == 6 && (flag == 1)) { exposureStart = 0f; exposureEnd = 0.7f; fadeDown(); flag = 0; } if (PointsManager.instance.level == 7 && (flag == 0)) { exposureStart = .7f; exposureEnd = 0f; fadeDown(); flag = 1; } if (PointsManager.instance.level == 8 && (flag == 1)) { exposureStart = 0f; exposureEnd = 0.7f; fadeDown(); flag = 0; } if (PointsManager.instance.level == 9 && (flag == 0)) { exposureStart = .7f; exposureEnd = 0f; fadeDown(); flag = 1; } } private void fadeDown() { StartCoroutine(Fade(exposureStart, exposureEnd)); } IEnumerator Fade(float startAlpha, float endAlpha) { float elapsedTime = 0.0f; //while (elapsedTime < fadeTiming) //{ // elapsedTime += Time.deltaTime; // currentAlpha = Mathf.Lerp(startAlpha, endAlpha, Mathf.Clamp01(elapsedTime / fadeTiming)); // RenderSettings.skybox.SetFloat("_Exposure", currentExposure); // yield return new WaitForEndOfFrame(); //} while (elapsedTime < fadeTiming) { elapsedTime += Time.deltaTime; ////////////////////counts total time finished Debug.Log(elapsedTime+" "+currentExposure); currentExposure = Mathf.Lerp(exposureStart,exposureEnd, Mathf.Clamp01(elapsedTime / fadeTiming)); RenderSettings.skybox.SetFloat("_Exposure", currentExposure); Debug.Log("hi"); yield return new WaitForEndOfFrame(); } } }

File no 16: /colame/Assets/SCRIPTS/checkingExit.cs
﻿using System; using System.Collections; using System.Collections.Generic; using UnityEngine; public class checkingExit : MonoBehaviour { public GameObject Ball; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { } void OnTriggerExit(Collider other) { Console.WriteLine("exiting of trigger"); if (PointsManager.instance.gamestate != 10) //this ensure that platform dont destroy after the ball is has stopped { if (other.gameObject.tag == "Player" || other.gameObject.tag == "PlayerBlue" || other.gameObject.tag == "PlayerGreen" || other.gameObject.tag == "PlayerRed") { //Destroy(gameObject) Destroy(gameObject, 2f); } } else { if (other.gameObject.tag == "Player" || other.gameObject.tag == "PlayerBlue" || other.gameObject.tag == "PlayerGreen" || other.gameObject.tag == "PlayerRed") { //Destroy(gameObject) Destroy(gameObject, 15f); } } } }

File no 17: /colame/Assets/SCRIPTS/dont.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class dont : MonoBehaviour { public static dont instance; public int k = 0; // Start is called before the first frame update void Start() { } private void Awake() { if (instance = null) { instance = this; } DontDestroyOnLoad(this.gameObject); } // Update is called once per frame void Update() { } }

File no 18: /colame/Assets/SCRIPTS/fading.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class fading : MonoBehaviour { int flag = 0; float exposureStart = 0.6f; float exposureEnd = 0.2f; public float currentExposure = 10f; float currentAlpha; float fadeTiming = 0.5f; //public float interval; //public float exposure; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { if (PointsManager.instance.score > 100&&(flag==0)) { fadeDown(); flag = 1; } } void fadeTheSky() { //for (int i = 0; i < 10; i++) //{ // yield return new WaitForSeconds(interval); // exposure += 0.3f; // RenderSettings.skybox.SetFloat("_Exposure", exposure); //} } private void fadeDown() { StartCoroutine(Fade(exposureStart, exposureEnd)); } IEnumerator Fade(float startAlpha, float endAlpha) { float elapsedTime = 0.0f; while (elapsedTime < fadeTiming) { elapsedTime += Time.deltaTime; currentAlpha = Mathf.Lerp(startAlpha, endAlpha, Mathf.Clamp01(elapsedTime / fadeTiming)); RenderSettings.skybox.SetFloat("_Exposure", currentExposure); yield return new WaitForEndOfFrame(); } } }

File no 19: /colame/Assets/SCRIPTS/followPlayer.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class followPlayer : MonoBehaviour { public GameObject player; Vector3 pointingvector; Vector3 initialPosOfCamera; Vector3 finalPosofCamera; public float lerprat; public float lerpratATEND; // Start is called before the first frame update private void Awake() { pointingvector = player.transform.position - transform.position; } void Start() { } // Update is called once per frame void Update() { if (PointsManager.instance.gamestate!=0&& PointsManager.instance.gamestate!=10) { initialPosOfCamera = transform.position; //finalPosofCamera = initialPosOfCamera + pointingvector; my error point finalPosofCamera = player.transform.position - pointingvector; Vector3 update = Vector3.Lerp(finalPosofCamera, initialPosOfCamera, lerprat * Time.deltaTime); transform.position = new Vector3(transform.position.x, update.y, update.z); } if (PointsManager.instance.gamestate == 10) { /// stop following ball this code will be written later for now just stop the moment it looses /////////////this are working ok } } }

File no 20: /colame/Assets/SCRIPTS/followThePlayer.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class followThePlayer : MonoBehaviour { public GameObject sampleocean; public GameObject endpt; Vector3 endPt; GameObject prefabCreated1; GameObject prefabCreated2; // Start is called before the first frame update void Start() { endPt = endpt.transform.position; // endPt = new Vector3(0, 0, 70); } // Update is called once per frame void Update() { } private void OnTriggerEnter(Collider other) { if (other.gameObject.tag == "Player") { prefabCreated1 = Instantiate(sampleocean, endPt, Quaternion.identity); GameObject child1= prefabCreated1.transform.GetChild(1).gameObject; endPt = child1.transform.position; } } private void OnTriggerExit(Collider other) { if (other.gameObject.tag == "Player") { Destroy(gameObject); } } }

File no 21: /colame/Assets/SCRIPTS/instagram.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class instagram : MonoBehaviour { public GameObject saj; // Start is called before the first frame update void Start() { Instantiate(saj, gameObject.transform.GetChild(0).transform.position, Quaternion.identity); Debug.Log(gameObject.transform.GetChild(0).transform.position + "this the location of chilld where cube is spawnned") ; } // Update is called once per frame void Update() { } }

File no 22: /colame/Assets/SCRIPTS/keyScript.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class keyScript : MonoBehaviour { public int FlagGoONce = 0; public float Spacing; public GameObject TextObject; //public GameObject TextObjectInstantiated; //public GameObject instanceScorePos; Vector3 Pos; int SpeedStringLength; string SpeedString; int noOfDiamonds; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { if (PointsManager.instance.FINISHsTATES == 1 && FlagGoONce == 0) { FlagGoONce = 1; Pos = transform.position; noOfDiamonds = PointsManager.instance.NOOfKeys; SpeedString = noOfDiamonds.ToString(); SpeedStringLength = SpeedString.Length; Debug.Log("string length =" + SpeedStringLength); for (int i = 0; i < SpeedStringLength; i++) { //TextObjectInstantiated = Instantiate(TextObject, Pos, Quaternion.identity); //method 1 // TextObjectInstantiated.transform.parent = transform; //mehod 2 GameObject TextObjectInstantiated = Instantiate(TextObject, Pos, Quaternion.identity, transform); float a = (4.0f / 5.0f) * Spacing; float b = ((3.0f / 5.0f) * Spacing); TextObjectInstantiated.transform.position += new Vector3(-a * i, 0, -b * i); switch (SpeedString[i]) { case '0': (TextObjectInstantiated.transform.GetChild(0).gameObject).SetActive(true); break; case '1': (TextObjectInstantiated.transform.GetChild(1).gameObject).SetActive(true); break; case '2': (TextObjectInstantiated.transform.GetChild(2).gameObject).SetActive(true); break; case '3': (TextObjectInstantiated.transform.GetChild(3).gameObject).SetActive(true); break; case '4': (TextObjectInstantiated.transform.GetChild(4).gameObject).SetActive(true); break; case '5': (TextObjectInstantiated.transform.GetChild(5).gameObject).SetActive(true); break; case '6': (TextObjectInstantiated.transform.GetChild(6).gameObject).SetActive(true); break; case '7': (TextObjectInstantiated.transform.GetChild(7).gameObject).SetActive(true); break; case '8': (TextObjectInstantiated.transform.GetChild(8).gameObject).SetActive(true); break; case '9': (TextObjectInstantiated.transform.GetChild(9).gameObject).SetActive(true); break; } //transform.position += transform.TransformDirection(Spacing,0,0); // Pos = transform.position; } } } }

File no 23: /colame/Assets/SCRIPTS/oceanFollowBall.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class oceanFollowBall : MonoBehaviour { public bool gamestate; public GameObject player; Vector3 pointingvector; Vector3 initialPosOfocean; Vector3 finalPosofocean; public float lerprat; // Start is called before the first frame update private void Awake() { pointingvector = player.transform.position - transform.position; } void Start() { gamestate = true; } // Update is called once per frame void Update() { if (gamestate) { initialPosOfocean = transform.position; //finalPosofCamera = initialPosOfCamera + pointingvector; my error point finalPosofocean = player.transform.position - pointingvector; Vector3 update = Vector3.Lerp(finalPosofocean, initialPosOfocean, lerprat * Time.deltaTime); //transform.position = update; transform.position = new Vector3(update.x, transform.position.y, update.z); } } }

File no 24: /colame/Assets/SCRIPTS/playerMovement.cs
﻿using System.Collections; using System.Collections.Generic; using System.Runtime.InteropServices.ComTypes; using UnityEngine; public class playerMovement : MonoBehaviour { //sound public float BallLeftRight1, BallLeftRight2; public float speedfactor; public int BallPos = -1; public float waitTheCoroutine; int leftcoroutinecheck = 0; int rightcoroutinecheck = 0; public float rateOfDirectionChange; public int forceToBall; int fixingforce = 0; int fixingspeed = 0; public static int indexPlayer; public static int indexCrystal; public float speedOfBall; Rigidbody rb; public bool gameState=false; // Start is called before the first frame update void Start() { BallPos = -1; rb = gameObject.GetComponent<Rigidbody>(); } // Update is called once per frame void Update() { transform.position = new Vector3(transform.position.x, .34f, transform.position.z); //this is for mobile touch if (swipe.instance.LeftSwipe==1 && PointsManager.instance.gamestate != 10 && PointsManager.instance.gamestate != 0 && PointsManager.instance.gamestate != -1) { //BallPos = 0; fixingforce = 1; swipe.instance.LeftSwipe = 0; } if (swipe.instance.RightSwipe==1&& PointsManager.instance.gamestate != 10 && PointsManager.instance.gamestate != 0 && PointsManager.instance.gamestate != -1) { //BallPos = 0; fixingforce = 2; swipe.instance.RightSwipe = 0; } //this is for keyboard left and right arrow if (Input.GetKeyDown(KeyCode.LeftArrow)&&PointsManager.instance.gamestate!=10 && PointsManager.instance.gamestate != 0 &&PointsManager.instance.gamestate!=-1) { //BallPos = 0; fixingforce = 1; } if (Input.GetKeyDown(KeyCode.RightArrow) && PointsManager.instance.gamestate != 10 && PointsManager.instance.gamestate != 0 && PointsManager.instance.gamestate != -1) { //BallPos = 0; fixingforce = 2; } if (PointsManager.instance.gamestate==0) { gameState = true; } if (gameState) { // transform.Translate(0, 0, forceToBall*Time.deltaTime); fixingspeed = 1; } } public void UnfreezeTheBall() { rb.constraints = RigidbodyConstraints.None; } private void FixedUpdate() { if (PointsManager.instance.gamestate == 20) { } transform.Rotate(PointsManager.instance.speed * Time.deltaTime * speedfactor, 0, 0, Space.World); //////////////////makes it look natural ////////////////////////////////////////////////////////////////////////////////////////////////// if (PointsManager.instance.StopBall == 1&&PointsManager.instance.gamestate!=-1&& PointsManager.instance.gamestate != 0&PointsManager.instance.freezetheBall==1) { Debug.Log("55555555555555555555555555ssssssss"); ///this is different freeze rotation rb.constraints = RigidbodyConstraints.FreezeRotation; rb.constraints= RigidbodyConstraints.FreezePosition; // rb.constraints = RigidbodyConstraints.None; this is when we want to unfreeze the rotation. } ////////////////////////checking speed decrease of ball if (PointsManager.instance.gamestate != 0 && PointsManager.instance.gamestate != 10) { changeSpeed(); } if (BallPos == 1) { transform.position = new Vector3(-.7f, transform.position.y, transform.position.z); } if (BallPos == 2) { transform.position = new Vector3(0f, transform.position.y, transform.position.z); } if (BallPos == 3) { transform.position = new Vector3(.7f, transform.position.y, transform.position.z); } if (BallPos == -1) { transform.position = new Vector3(0f, transform.position.y, transform.position.z); //BallPos = 0; } if (fixingspeed==1) { moveballForward(); fixingspeed = 0; } if (fixingforce == 1) { moveBallLeft(); fixingforce = 0; } if (fixingforce == 2) { moveBallRight(); fixingforce = 0; } } void changeSpeed() { speedOfBall = PointsManager.instance.speed; /////speed changer // rb.AddForce(0, 0, forceToBall * Time.deltaTime); rb.velocity = new Vector3(0, 0, speedOfBall * Time.deltaTime); } void moveBallLeft() { Debug.Log("left key is pressed"); float a = transform.position.x; if (a == 0) { leftcoroutinecheck = 1; StartCoroutine("moveLeftCoroutine"); } if (a ==.7f) { leftcoroutinecheck = 2; StartCoroutine("moveLeftCoroutine"); } } void moveBallRight() { Debug.Log("right key is pressed"); float b = transform.position.x; if (b == 0) { rightcoroutinecheck = 1; StartCoroutine("moveRightCoroutine"); } if (b==-.7f) { rightcoroutinecheck = 2; StartCoroutine("moveRightCoroutine"); } } IEnumerator moveRightCoroutine() { //ballSwipeSound(); /// yield return new WaitForSeconds(waitTheCoroutine); dont wait coroutine for fast response if (rightcoroutinecheck == 1) { Invoke("ballSwipeSound", BallLeftRight2); BallPos = 0; //object is at centre transform.position = new Vector3(.1f, transform.position.y, transform.position.z); yield return new WaitForSeconds(waitTheCoroutine); transform.position = new Vector3(.2f, transform.position.y, transform.position.z); yield return new WaitForSeconds(waitTheCoroutine); transform.position = new Vector3(.3f, transform.position.y, transform.position.z); yield return new WaitForSeconds(waitTheCoroutine); transform.position = new Vector3(.4f, transform.position.y, transform.position.z); yield return new WaitForSeconds(waitTheCoroutine); transform.position = new Vector3(.5f, transform.position.y, transform.position.z); yield return new WaitForSeconds(waitTheCoroutine); transform.position = new Vector3(.6f, transform.position.y, transform.position.z); yield return new WaitForSeconds(waitTheCoroutine); transform.position = new Vector3(.7f, transform.position.y, transform.position.z); yield return new WaitForSeconds(waitTheCoroutine); rightcoroutinecheck = 0; BallPos = 3; StopCoroutine("moveRightCoroutine"); } if (rightcoroutinecheck == 2) { Invoke("ballSwipeSound", BallLeftRight2); BallPos = 0; //object is at left side transform.position = new Vector3(-.6f, transform.position.y, transform.position.z); yield return new WaitForSeconds(waitTheCoroutine); transform.position = new Vector3(-.5f, transform.position.y, transform.position.z); yield return new WaitForSeconds(waitTheCoroutine); transform.position = new Vector3(-.4f, transform.position.y, transform.position.z); yield return new WaitForSeconds(waitTheCoroutine); transform.position = new Vector3(-.3f, transform.position.y, transform.position.z); yield return new WaitForSeconds(waitTheCoroutine); transform.position = new Vector3(-.2f, transform.position.y, transform.position.z); yield return new WaitForSeconds(waitTheCoroutine); transform.position = new Vector3(-.1f, transform.position.y, transform.position.z); yield return new WaitForSeconds(waitTheCoroutine); transform.position = new Vector3(0, transform.position.y, transform.position.z); yield return new WaitForSeconds(waitTheCoroutine); rightcoroutinecheck = 0; BallPos = 2; StopCoroutine("moveRightcoroutine"); } } private void ballSwipeSound() { ManageTheAudio.instance.Play("ballLeftRightSound", BallLeftRight1); } IEnumerator moveLeftCoroutine() { ///yield return new WaitForSeconds(waitTheCoroutine); if (leftcoroutinecheck == 1) { Invoke("ballSwipeSound", BallLeftRight2); BallPos = 0; //object is at centre transform.position = new Vector3(-.1f, transform.position.y, transform.position.z); yield return new WaitForSeconds(waitTheCoroutine); transform.position = new Vector3(-.2f, transform.position.y, transform.position.z); yield return new WaitForSeconds(waitTheCoroutine); transform.position = new Vector3(-.3f, transform.position.y, transform.position.z); yield return new WaitForSeconds(waitTheCoroutine); transform.position = new Vector3(-.4f, transform.position.y, transform.position.z); yield return new WaitForSeconds(waitTheCoroutine); transform.position = new Vector3(-.5f, transform.position.y, transform.position.z); yield return new WaitForSeconds(waitTheCoroutine); transform.position = new Vector3(-.6f, transform.position.y, transform.position.z); yield return new WaitForSeconds(waitTheCoroutine); transform.position = new Vector3(-.7f, transform.position.y, transform.position.z); yield return new WaitForSeconds(waitTheCoroutine); leftcoroutinecheck = 0; BallPos = 1; StopCoroutine("moveLeftcoroutine"); } if (leftcoroutinecheck == 2) { Invoke("ballSwipeSound", BallLeftRight2); BallPos = 0; //object is at right side transform.position = new Vector3(.6f, transform.position.y, transform.position.z); yield return new WaitForSeconds(waitTheCoroutine); transform.position = new Vector3(.5f, transform.position.y, transform.position.z); yield return new WaitForSeconds(waitTheCoroutine); transform.position = new Vector3(.4f, transform.position.y, transform.position.z); yield return new WaitForSeconds(waitTheCoroutine); transform.position = new Vector3(.3f, transform.position.y, transform.position.z); yield return new WaitForSeconds(waitTheCoroutine); transform.position = new Vector3(.2f, transform.position.y, transform.position.z); yield return new WaitForSeconds(waitTheCoroutine); transform.position = new Vector3(.1f, transform.position.y, transform.position.z); yield return new WaitForSeconds(waitTheCoroutine); transform.position = new Vector3(0, transform.position.y, transform.position.z); yield return new WaitForSeconds(waitTheCoroutine); leftcoroutinecheck = 0; BallPos = 2; StopCoroutine("moveLeftcoroutine"); } } void moveballForward() { speedOfBall = PointsManager.instance.speed; /////speed changer // rb.AddForce(0, 0, forceToBall * Time.deltaTime); rb.velocity = new Vector3(0, 0, speedOfBall * Time.deltaTime); } private void OnTriggerExit(Collider other) { if (other.transform.gameObject.tag == "BorderRed") { gameObject.GetComponent<Renderer>().material = other.transform.gameObject.GetComponent<Renderer>().material; gameObject.tag = "PlayerRed"; Destroy(other.transform.gameObject, 1f); indexPlayer = 1; } if (other.transform.gameObject.tag == "BorderGreen") { gameObject.GetComponent<Renderer>().material = other.transform.gameObject.GetComponent<Renderer>().material; gameObject.tag = "PlayerGreen"; Destroy(other.transform.gameObject, 1f); indexPlayer = 2; } if (other.transform.gameObject.tag == "BorderBlue") { gameObject.GetComponent<Renderer>().material = GameObject.FindWithTag("BorderBlue").GetComponent<Renderer>().material; gameObject.tag = "PlayerBlue"; Destroy(other.transform.gameObject, 1f); indexPlayer = 3; } } private void OnTriggerEnter(Collider other) { float c = ((8 * PointsManager.instance.speed) - 560) / 900; if (other.transform.gameObject.tag == "BorderRed") { ManageTheAudio.instance.Play("box", 0f); ManageTheAudio.instance.ListOfSounds[5].AUDIOsOURCE.pitch = c; Debug.Log("tagged"); } if (other.transform.gameObject.tag == "BorderGreen") { ManageTheAudio.instance.Play("box", 0f); Debug.Log("tagged"); ManageTheAudio.instance.ListOfSounds[5].AUDIOsOURCE.pitch = c; } if (other.transform.gameObject.tag == "BorderBlue") { ManageTheAudio.instance.Play("box", 0f); Debug.Log("tagged"); ManageTheAudio.instance.ListOfSounds[5].AUDIOsOURCE.pitch = c; } /// ManageTheAudio.instance.Play("box", 0f); if (other.transform.gameObject.tag == "CrystalRed") { if (indexPlayer == 1) { //point //Debug.Log("pointc"); } else { //loose //Debug.Log("loosec"); } } if (other.transform.gameObject.tag == "CrystalGreen") { if (indexPlayer == 2) { //point //Debug.Log("pointc"); } else { //loose // Debug.Log("loosec"); } } if (other.transform.gameObject.tag == "CrystalBlue") { if (indexPlayer == 3) { //point //Debug.Log("pointc"); } else { //loose // Debug.Log("loosec"); } } } }

File no 25: /colame/Assets/SCRIPTS/rOTATE.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class rOTATE : MonoBehaviour { float j; int i; public float CrystalRotationSpeed; // Start is called before the first frame update void Start() { i = Random.Range(0, 2); if (i == 0) { j = CrystalRotationSpeed; } else { j = -CrystalRotationSpeed; } } // Update is called once per frame void Update() { //if (PointsManager.instance.level == 4 || PointsManager.instance.level == 5 || PointsManager.instance.level == 6 || PointsManager.instance.level == 8 || PointsManager.instance.level == 9) //{ // transform.Rotate(0, j * Time.deltaTime, 0); //} $ if (PointsManager.instance.level == 2 || PointsManager.instance.level == 3 || PointsManager.instance.level >=5 ) { transform.Rotate(0, j * Time.deltaTime, 0); } } }

File no 26: /colame/Assets/SCRIPTS/rotateCoin.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class rotateCoin : MonoBehaviour { public float xRotate, yRotate, zRotate; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { transform.Rotate(xRotate * Time.deltaTime, yRotate * Time.deltaTime, zRotate * Time.deltaTime,Space.World); } }

File no 27: /colame/Assets/SCRIPTS/rotateCoinONIslandd.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class rotateCoinONIslandd : MonoBehaviour { public float xRotate, yRotate, zRotate; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { transform.Rotate(xRotate*Time.deltaTime, yRotate*Time.deltaTime, zRotate*Time.deltaTime); } }

File no 28: /colame/Assets/SCRIPTS/rotateKey.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class rotateKey : MonoBehaviour { public float Yrotate; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { transform.Rotate(0, Yrotate*Time.deltaTime, 0,Space.World); } }

File no 29: /colame/Assets/SCRIPTS/scoreScript.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class scoreScript : MonoBehaviour { public int FlagGoONce = 0; public float Spacing; public GameObject TextObject; //public GameObject TextObjectInstantiated; //public GameObject instanceScorePos; Vector3 Pos; int SpeedStringLength; string SpeedString; int noOfDiamonds; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { if (PointsManager.instance.FINISHsTATES == 1 && FlagGoONce == 0) { FlagGoONce = 1; Pos = transform.position; noOfDiamonds = PointsManager.instance.scoreInt; ////just a small twick in diamonds no SpeedString = noOfDiamonds.ToString(); SpeedStringLength = SpeedString.Length; Debug.Log("string length =" + SpeedStringLength); for (int i = 0; i < SpeedStringLength; i++) { //TextObjectInstantiated = Instantiate(TextObject, Pos, Quaternion.identity); //method 1 // TextObjectInstantiated.transform.parent = transform; //mehod 2 GameObject TextObjectInstantiated = Instantiate(TextObject, Pos, Quaternion.identity, transform); float a = (4.0f / 5.0f) * Spacing; float b = ((3.0f / 5.0f) * Spacing); TextObjectInstantiated.transform.position += new Vector3(a * i, 0, -b * i); switch (SpeedString[i]) { case '0': (TextObjectInstantiated.transform.GetChild(0).gameObject).SetActive(true); break; case '1': (TextObjectInstantiated.transform.GetChild(1).gameObject).SetActive(true); break; case '2': (TextObjectInstantiated.transform.GetChild(2).gameObject).SetActive(true); break; case '3': (TextObjectInstantiated.transform.GetChild(3).gameObject).SetActive(true); break; case '4': (TextObjectInstantiated.transform.GetChild(4).gameObject).SetActive(true); break; case '5': (TextObjectInstantiated.transform.GetChild(5).gameObject).SetActive(true); break; case '6': (TextObjectInstantiated.transform.GetChild(6).gameObject).SetActive(true); break; case '7': (TextObjectInstantiated.transform.GetChild(7).gameObject).SetActive(true); break; case '8': (TextObjectInstantiated.transform.GetChild(8).gameObject).SetActive(true); break; case '9': (TextObjectInstantiated.transform.GetChild(9).gameObject).SetActive(true); break; } //transform.position += transform.TransformDirection(Spacing,0,0); // Pos = transform.position; } } } }

File no 30: /colame/Assets/SCRIPTS/swipe.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class swipe : MonoBehaviour { public int LeftSwipe = 0; public int RightSwipe = 0; Vector3 startpos; Vector3 endpos; float starttime; float endtime; Vector2 touchvector; float touchtime; public float mindistance; public float maxtime; public static swipe instance; private void Awake() { if (instance == null) { instance = this; } } // Start is called before the first frame update void Start() { //rb = player.GetComponent<Rigidbody2D>(); } // Update is called once per frame void Update() { if (Input.touchCount > 0) { Touch touch = Input.GetTouch(0); if (touch.phase == TouchPhase.Began) { startpos = touch.position; starttime = Time.time; } else if (touch.phase == TouchPhase.Ended) { endpos = touch.position; endtime = Time.time; touchvector = endpos - startpos; touchtime = endtime - starttime; if (((touchvector).magnitude) >= mindistance && touchtime < maxtime) { swipetouch(); } } } } private void swipetouch() { //print("it is swiping"); if ((Mathf.Abs(touchvector.x)) > (Mathf.Abs(touchvector.y))) { //print("it is horizontal swiping"); if (touchvector.x > 0) { print("it is right swipe"); RightSwipe = 1; } if (touchvector.x < 0) { print("it is left swipe"); LeftSwipe = 1; } } //if ((Mathf.Abs(touchvector.x)) < (Mathf.Abs(touchvector.y))) //{ // // print("it is vertical swiping"); // if (touchvector.x > 0) // { // print("it is up swipe"); // // jump(); // player.GetComponent<sam>().jump(); // } // if (touchvector.x < 0) // { // print("it is down swipe"); // } //} } }

File no 31: /colame/Assets/SCRIPTS/triggerScript.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class triggerScript : MonoBehaviour { // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { } private void OnTriggerStay(Collider other) { if (UImanager.instance.lifeState == 5 || UImanager.instance.lifeState == 7) { if (other.gameObject.tag == "CrystalBlue" || other.gameObject.tag == "CrystalRed" || other.gameObject.tag == "CrystalGreen"|| other.gameObject.tag == "BorderGreen"|| other.gameObject.tag == "BorderRed"|| other.gameObject.tag == "BorderBlue") { Destroy(other.gameObject); Debug.Log("deeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"); } } } }

File no 32: /colame/Assets/Simple Helvetica/readme.txt
Simple Helvetica - a 3D character plugin for Unity3D Version 1.0 Contact Info: http://www.pepwuper.com/ Brandon Wu - brandon@pepwuper.com copyright © 2012, Studio Pepwuper, inc ================ SIMPLE HELVETICA ================ Simple Helvetica is an easy-to-use 3D character model generator that enable you to instantly create text in 3D space for use in games and in GUI. Features - 3D text models (font: Helvetica) - Script to easily create, update, and generate 3D models in editor and during gameplay - Full Inspector integration - No need to hit Play to see the results - Full iOS, Android and Flash support - Full source code - simple C# code - No DLLs or external resources - Support for lighting/shadows, normal mapping, refraction (Unity Pro Only), texturing, Substance - Interaction with other gameobjects - Option to add box colliders and rigidbody =============== GETTING STARTED =============== 1. Select from Menu: GameObject > Create Other > Simple Helvetica 2. Click on the Text Area under "Text" 3. Type away and start using text 3D objects in your scene! Notice: - You can hit "enter" or "return" on your keyboard to insert a line break. Multiple lines is supported - Each time you update your text, new 3D character objects are generated. So if you've gone into the individual child objects and made changes directly to them, those changes will not be retained. - Undo is not currently supported. Text: This defines what characters will be generated - variable: Text (string) - default value: "SIMPLE HELVETICA\n \nby Studio Pepwuper" Character Spacing: This determines how far apart the characters are. - variable: CharacterSpacing (float) - default value: 4f Line Spacing: This determines the vertical (Y) distance between the lines. - variable: LineSpacing (float) - default value: 22f Space Width: This determines how wide the "space" character is. - variable: SpaceWidth (float) - default value: 8f + Box Colliders: Add box colliders to all generated 3D character objects. Option to make them all triggers by checking "Is Trigger" (variable: BoxColliderIsTrigger) - Box Collders: Remove box colliders. + Rigidbody: Add rigidbody to all generated 3D character objects. Options to adjust rogidbody settings and apply them to all generated 3D character objects. Apply Mesh Renderer Settings: By default, all 3D character objects shared the same "Default" material. You can use different ones for each individual object. You can also force all objects to use the same material and mesh renderer settings as the parent object by pressing down on "Apply Mesh Renderer Settings". ======================================================================== How to Construct a Simple Helvetica Prefab (in case if you overwrite it) ======================================================================== 1. Create an empty GameObject (Menu: GameObject > Create Empty) 2. Rename it Simple Helvetica (optional) 3. Add SimpleHelvetica.cs component 4. Move "_Alphabets" from /Simple Helvetica/Models into the same GameObject 5. Add Mesh Renderer if you want to use the "Apply Mesh Renderer Settings" function (Menu: Component > Mesh > Mesh Renderer) 6. Done! ============== PUBLIC METHODS ============== GenerateText() - Generate 3D character objects as defined by the Text string variable. AddBoxCollider() - Add box colliders to all 3D character child objects. RemoveBoxCollider() - Remove box colliders on all 3D character child objects. AddRigidbody() - Add rigidbody to all 3D character child objects. RemoveRigidbody() - Remove rigidbodies on all 3D character child objects. SetBoxColliderVariables() - Update box collider variables on all 3D character child objects with the setting on this parent object. SetRigidbodyVariables() - Update rigidbody variables on all 3D character child objects with the setting on this parent object. ResetRigidbodyVariables() - Reset rigidbody variables on all 3D character child objects to the default value. ApplyMeshRenderer() - Apply the mesh renderer settings on this parent object to all 3D character child objects ==================== SUPPORTED CHARACTERS ==================== `1234567890-= qwertyuiop[]\ asdfghjkl;' zxcvbnm,./ ~!@#$%^&*()_+ QWERTYUIOP{}| ASDFGHJKL:" ZXCVBNM<>?

File no 33: /colame/Assets/SineVFX/PostProcessingV2/Editor/Attributes/DecoratorAttribute.cs
using System; namespace UnityEditor.Rendering.PostProcessing { /// <summary> /// Tells a <see cref="AttributeDecorator"/> class which inspector attribute it's a decorator /// for. /// </summary> /// <seealso cref="AttributeDecorator"/> [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)] public sealed class DecoratorAttribute : Attribute { /// <summary> /// The attribute type that this decorator can inspect. /// </summary> public readonly Type attributeType; /// <summary> /// Creates a new attribute. /// </summary> /// <param name="attributeType">The type that this decorator can inspect</param> public DecoratorAttribute(Type attributeType) { this.attributeType = attributeType; } } }

File no 34: /colame/Assets/SineVFX/PostProcessingV2/Editor/Attributes/PostProcessEditorAttribute.cs
using System; namespace UnityEditor.Rendering.PostProcessing { /// <summary> /// Tells a <see cref="PostProcessEffectEditor{T}"/> class which run-time type it's an editor /// for. When you make a custom editor for an effect, you need put this attribute on the editor /// class. /// </summary> /// <seealso cref="PostProcessEffectEditor{T}"/> [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)] public sealed class PostProcessEditorAttribute : Attribute { /// <summary> /// The type that this editor can edit. /// </summary> public readonly Type settingsType; /// <summary> /// Creates a new attribute. /// </summary> /// <param name="settingsType">The type that this editor can edit</param> public PostProcessEditorAttribute(Type settingsType) { this.settingsType = settingsType; } } }

File no 35: /colame/Assets/SineVFX/PostProcessingV2/Editor/Decorators/AttributeDecorator.cs
using System; using UnityEngine; namespace UnityEditor.Rendering.PostProcessing { /// <summary> /// The base abstract class for all attribute decorators. /// </summary> public abstract class AttributeDecorator { /// <summary> /// Override this and return <c>false</c> if you want to customize the override checkbox /// position, else it'll automatically draw it and put the property content in a /// horizontal scope. /// </summary> /// <returns><c>true</c> if the override checkbox should be automatically put next to the /// property, <c>false</c> if it uses a custom position</returns> public virtual bool IsAutoProperty() { return true; } /// <summary> /// The rendering method called for the custom GUI. /// </summary> /// <param name="property">The property to draw the UI for</param> /// <param name="overrideState">The override checkbox property</param> /// <param name="title">The title and tooltip for the property</param> /// <param name="attribute">A reference to the property attribute set on the original field /// </param> /// <returns><c>true</c> if the property UI got rendered successfully, <c>false</c> to /// fallback on the default editor UI for this property</returns> public abstract bool OnGUI(SerializedProperty property, SerializedProperty overrideState, GUIContent title, Attribute attribute); } }

File no 36: /colame/Assets/SineVFX/PostProcessingV2/Editor/Decorators/Decorators.cs
using System; using UnityEngine; namespace UnityEditor.Rendering.PostProcessing { [Decorator(typeof(RangeAttribute))] internal sealed class RangeDecorator : AttributeDecorator { public override bool OnGUI(SerializedProperty property, SerializedProperty overrideState, GUIContent title, Attribute attribute) { var attr = (RangeAttribute)attribute; if (property.propertyType == SerializedPropertyType.Float) { property.floatValue = EditorGUILayout.Slider(title, property.floatValue, attr.min, attr.max); return true; } if (property.propertyType == SerializedPropertyType.Integer) { property.intValue = EditorGUILayout.IntSlider(title, property.intValue, (int)attr.min, (int)attr.max); return true; } return false; } } [Decorator(typeof(UnityEngine.Rendering.PostProcessing.MinAttribute))] internal sealed class MinDecorator : AttributeDecorator { public override bool OnGUI(SerializedProperty property, SerializedProperty overrideState, GUIContent title, Attribute attribute) { var attr = (UnityEngine.Rendering.PostProcessing.MinAttribute)attribute; if (property.propertyType == SerializedPropertyType.Float) { float v = EditorGUILayout.FloatField(title, property.floatValue); property.floatValue = Mathf.Max(v, attr.min); return true; } if (property.propertyType == SerializedPropertyType.Integer) { int v = EditorGUILayout.IntField(title, property.intValue); property.intValue = Mathf.Max(v, (int)attr.min); return true; } return false; } } [Decorator(typeof(UnityEngine.Rendering.PostProcessing.MaxAttribute))] internal sealed class MaxDecorator : AttributeDecorator { public override bool OnGUI(SerializedProperty property, SerializedProperty overrideState, GUIContent title, Attribute attribute) { var attr = (UnityEngine.Rendering.PostProcessing.MaxAttribute)attribute; if (property.propertyType == SerializedPropertyType.Float) { float v = EditorGUILayout.FloatField(title, property.floatValue); property.floatValue = Mathf.Min(v, attr.max); return true; } if (property.propertyType == SerializedPropertyType.Integer) { int v = EditorGUILayout.IntField(title, property.intValue); property.intValue = Mathf.Min(v, (int)attr.max); return true; } return false; } } [Decorator(typeof(UnityEngine.Rendering.PostProcessing.MinMaxAttribute))] internal sealed class MinMaxDecorator : AttributeDecorator { public override bool OnGUI(SerializedProperty property, SerializedProperty overrideState, GUIContent title, Attribute attribute) { var attr = (UnityEngine.Rendering.PostProcessing.MinMaxAttribute)attribute; if (property.propertyType == SerializedPropertyType.Float) { float v = EditorGUILayout.FloatField(title, property.floatValue); property.floatValue = Mathf.Clamp(v, attr.min, attr.max); return true; } if (property.propertyType == SerializedPropertyType.Integer) { int v = EditorGUILayout.IntField(title, property.intValue); property.intValue = Mathf.Clamp(v, (int)attr.min, (int)attr.max); return true; } if (property.propertyType == SerializedPropertyType.Vector2) { var v = property.vector2Value; EditorGUILayout.MinMaxSlider(title, ref v.x, ref v.y, attr.min, attr.max); property.vector2Value = v; return true; } return false; } } [Decorator(typeof(ColorUsageAttribute))] internal sealed class ColorUsageDecorator : AttributeDecorator { public override bool OnGUI(SerializedProperty property, SerializedProperty overrideState, GUIContent title, Attribute attribute) { var attr = (ColorUsageAttribute)attribute; if (property.propertyType != SerializedPropertyType.Color) return false; #if UNITY_2018_1_OR_NEWER property.colorValue = EditorGUILayout.ColorField(title, property.colorValue, true, attr.showAlpha, attr.hdr); #else ColorPickerHDRConfig hdrConfig = null; if (attr.hdr) { hdrConfig = new ColorPickerHDRConfig( attr.minBrightness, attr.maxBrightness, attr.minExposureValue, attr.maxExposureValue ); } property.colorValue = EditorGUILayout.ColorField(title, property.colorValue, true, attr.showAlpha, attr.hdr, hdrConfig); #endif return true; } } }

File no 37: /colame/Assets/SineVFX/PostProcessingV2/Editor/Decorators/TrackballDecorator.cs
using System; using UnityEngine; using UnityEngine.Rendering.PostProcessing; namespace UnityEditor.Rendering.PostProcessing { [Decorator(typeof(TrackballAttribute))] internal sealed class TrackballDecorator : AttributeDecorator { static readonly int k_ThumbHash = "colorWheelThumb".GetHashCode(); static Material s_Material; bool m_ResetState; Vector2 m_CursorPos; public override bool IsAutoProperty() { return false; } public override bool OnGUI(SerializedProperty property, SerializedProperty overrideState, GUIContent title, Attribute attribute) { if (property.propertyType != SerializedPropertyType.Vector4) return false; var value = property.vector4Value; using (new EditorGUILayout.VerticalScope()) { using (new EditorGUI.DisabledScope(!overrideState.boolValue)) DrawWheel(ref value, overrideState.boolValue, (TrackballAttribute)attribute); DrawLabelAndOverride(title, overrideState); } if (m_ResetState) { value = Vector4.zero; m_ResetState = false; } property.vector4Value = value; return true; } void DrawWheel(ref Vector4 value, bool overrideState, TrackballAttribute attr) { var wheelRect = GUILayoutUtility.GetAspectRect(1f); float size = wheelRect.width; float hsize = size / 2f; float radius = 0.38f * size; Vector3 hsv; Color.RGBToHSV(value, out hsv.x, out hsv.y, out hsv.z); float offset = value.w; // Thumb var thumbPos = Vector2.zero; float theta = hsv.x * (Mathf.PI * 2f); thumbPos.x = Mathf.Cos(theta + (Mathf.PI / 2f)); thumbPos.y = Mathf.Sin(theta - (Mathf.PI / 2f)); thumbPos *= hsv.y * radius; // Draw the wheel if (Event.current.type == EventType.Repaint) { // Retina support float scale = EditorGUIUtility.pixelsPerPoint; if (s_Material == null) s_Material = new Material(Shader.Find("Hidden/PostProcessing/Editor/Trackball")) { hideFlags = HideFlags.HideAndDontSave }; // Wheel texture #if UNITY_2018_1_OR_NEWER const RenderTextureReadWrite kReadWrite = RenderTextureReadWrite.sRGB; #else const RenderTextureReadWrite kReadWrite = RenderTextureReadWrite.Linear; #endif var oldRT = RenderTexture.active; var rt = RenderTexture.GetTemporary((int)(size * scale), (int)(size * scale), 0, RenderTextureFormat.ARGB32, kReadWrite); s_Material.SetFloat("_Offset", offset); s_Material.SetFloat("_DisabledState", overrideState ? 1f : 0.5f); s_Material.SetVector("_Resolution", new Vector2(size * scale, size * scale / 2f)); Graphics.Blit(null, rt, s_Material, EditorGUIUtility.isProSkin ? 0 : 1); RenderTexture.active = oldRT; GUI.DrawTexture(wheelRect, rt); RenderTexture.ReleaseTemporary(rt); var thumbSize = Styling.wheelThumbSize; var thumbSizeH = thumbSize / 2f; Styling.wheelThumb.Draw(new Rect(wheelRect.x + hsize + thumbPos.x - thumbSizeH.x, wheelRect.y + hsize + thumbPos.y - thumbSizeH.y, thumbSize.x, thumbSize.y), false, false, false, false); } // Input var bounds = wheelRect; bounds.x += hsize - radius; bounds.y += hsize - radius; bounds.width = bounds.height = radius * 2f; hsv = GetInput(bounds, hsv, thumbPos, radius); value = Color.HSVToRGB(hsv.x, hsv.y, 1f); value.w = offset; // Offset var sliderRect = GUILayoutUtility.GetRect(1f, 17f); float padding = sliderRect.width * 0.05f; // 5% padding sliderRect.xMin += padding; sliderRect.xMax -= padding; value.w = GUI.HorizontalSlider(sliderRect, value.w, -1f, 1f); if (attr.mode == TrackballAttribute.Mode.None) return; // Values var displayValue = Vector3.zero; switch (attr.mode) { case TrackballAttribute.Mode.Lift: displayValue = ColorUtilities.ColorToLift(value); break; case TrackballAttribute.Mode.Gamma: displayValue = ColorUtilities.ColorToInverseGamma(value); break; case TrackballAttribute.Mode.Gain: displayValue = ColorUtilities.ColorToGain(value); break; } using (new EditorGUI.DisabledGroupScope(true)) { var valuesRect = GUILayoutUtility.GetRect(1f, 17f); valuesRect.width /= 3f; GUI.Label(valuesRect, displayValue.x.ToString("F2"), EditorStyles.centeredGreyMiniLabel); valuesRect.x += valuesRect.width; GUI.Label(valuesRect, displayValue.y.ToString("F2"), EditorStyles.centeredGreyMiniLabel); valuesRect.x += valuesRect.width; GUI.Label(valuesRect, displayValue.z.ToString("F2"), EditorStyles.centeredGreyMiniLabel); valuesRect.x += valuesRect.width; } } void DrawLabelAndOverride(GUIContent title, SerializedProperty overrideState) { // Title var areaRect = GUILayoutUtility.GetRect(1f, 17f); var labelSize = Styling.wheelLabel.CalcSize(title); var labelRect = new Rect(areaRect.x + areaRect.width / 2 - labelSize.x / 2, areaRect.y, labelSize.x, labelSize.y); GUI.Label(labelRect, title, Styling.wheelLabel); // Override checkbox var overrideRect = new Rect(labelRect.x - 17, labelRect.y + 3, 17f, 17f); EditorUtilities.DrawOverrideCheckbox(overrideRect, overrideState); } Vector3 GetInput(Rect bounds, Vector3 hsv, Vector2 thumbPos, float radius) { var e = Event.current; var id = GUIUtility.GetControlID(k_ThumbHash, FocusType.Passive, bounds); var mousePos = e.mousePosition; if (e.type == EventType.MouseDown && GUIUtility.hotControl == 0 && bounds.Contains(mousePos)) { if (e.button == 0) { var center = new Vector2(bounds.x + radius, bounds.y + radius); float dist = Vector2.Distance(center, mousePos); if (dist <= radius) { e.Use(); m_CursorPos = new Vector2(thumbPos.x + radius, thumbPos.y + radius); GUIUtility.hotControl = id; GUI.changed = true; } } else if (e.button == 1) { e.Use(); GUI.changed = true; m_ResetState = true; } } else if (e.type == EventType.MouseDrag && e.button == 0 && GUIUtility.hotControl == id) { e.Use(); GUI.changed = true; m_CursorPos += e.delta * GlobalSettings.trackballSensitivity; GetWheelHueSaturation(m_CursorPos.x, m_CursorPos.y, radius, out hsv.x, out hsv.y); } else if (e.rawType == EventType.MouseUp && e.button == 0 && GUIUtility.hotControl == id) { e.Use(); GUIUtility.hotControl = 0; } return hsv; } void GetWheelHueSaturation(float x, float y, float radius, out float hue, out float saturation) { float dx = (x - radius) / radius; float dy = (y - radius) / radius; float d = Mathf.Sqrt(dx * dx + dy * dy); hue = Mathf.Atan2(dx, -dy); hue = 1f - ((hue > 0) ? hue : (Mathf.PI * 2f) + hue) / (Mathf.PI * 2f); saturation = Mathf.Clamp01(d); } } }

File no 38: /colame/Assets/SineVFX/PostProcessingV2/Editor/Effects/AmbientOcclusionEditor.cs
using UnityEngine; using UnityEngine.Rendering.PostProcessing; namespace UnityEditor.Rendering.PostProcessing { [PostProcessEditor(typeof(AmbientOcclusion))] internal sealed class AmbientOcclusionEditor : PostProcessEffectEditor<AmbientOcclusion> { SerializedParameterOverride m_Mode; SerializedParameterOverride m_Intensity; SerializedParameterOverride m_Color; SerializedParameterOverride m_AmbientOnly; SerializedParameterOverride m_ThicknessModifier; SerializedParameterOverride m_DirectLightingStrength; SerializedParameterOverride m_Quality; SerializedParameterOverride m_Radius; public override void OnEnable() { m_Mode = FindParameterOverride(x => x.mode); m_Intensity = FindParameterOverride(x => x.intensity); m_Color = FindParameterOverride(x => x.color); m_AmbientOnly = FindParameterOverride(x => x.ambientOnly); m_ThicknessModifier = FindParameterOverride(x => x.thicknessModifier); m_DirectLightingStrength = FindParameterOverride(x => x.directLightingStrength); m_Quality = FindParameterOverride(x => x.quality); m_Radius = FindParameterOverride(x => x.radius); } public override void OnInspectorGUI() { PropertyField(m_Mode); int aoMode = m_Mode.value.intValue; if (RuntimeUtilities.scriptableRenderPipelineActive && aoMode == (int)AmbientOcclusionMode.ScalableAmbientObscurance) { EditorGUILayout.HelpBox("Scalable ambient obscurance doesn't work with scriptable render pipelines.", MessageType.Warning); return; } #if !UNITY_2017_1_OR_NEWER if (aoMode == (int)AmbientOcclusionMode.MultiScaleVolumetricObscurance) { EditorGUILayout.HelpBox("Multi-scale volumetric obscurance requires Unity 2017.1 or more.", MessageType.Warning); return; } #endif PropertyField(m_Intensity); if (aoMode == (int)AmbientOcclusionMode.ScalableAmbientObscurance) { PropertyField(m_Radius); PropertyField(m_Quality); } else if (aoMode == (int)AmbientOcclusionMode.MultiScaleVolumetricObscurance) { if (!SystemInfo.supportsComputeShaders) EditorGUILayout.HelpBox("Multi-scale volumetric obscurance requires compute shader support.", MessageType.Warning); PropertyField(m_ThicknessModifier); if (RuntimeUtilities.scriptableRenderPipelineActive) PropertyField(m_DirectLightingStrength); } PropertyField(m_Color); PropertyField(m_AmbientOnly); if (m_AmbientOnly.overrideState.boolValue && m_AmbientOnly.value.boolValue && !RuntimeUtilities.scriptableRenderPipelineActive) EditorGUILayout.HelpBox("Ambient-only only works with cameras rendering in Deferred + HDR", MessageType.Info); } } }

File no 39: /colame/Assets/SineVFX/PostProcessingV2/Editor/Effects/AutoExposureEditor.cs
using UnityEngine; using UnityEngine.Rendering.PostProcessing; namespace UnityEditor.Rendering.PostProcessing { [PostProcessEditor(typeof(AutoExposure))] internal sealed class AutoExposureEditor : PostProcessEffectEditor<AutoExposure> { SerializedParameterOverride m_Filtering; SerializedParameterOverride m_MinLuminance; SerializedParameterOverride m_MaxLuminance; SerializedParameterOverride m_KeyValue; SerializedParameterOverride m_EyeAdaptation; SerializedParameterOverride m_SpeedUp; SerializedParameterOverride m_SpeedDown; public override void OnEnable() { m_Filtering = FindParameterOverride(x => x.filtering); m_MinLuminance = FindParameterOverride(x => x.minLuminance); m_MaxLuminance = FindParameterOverride(x => x.maxLuminance); m_KeyValue = FindParameterOverride(x => x.keyValue); m_EyeAdaptation = FindParameterOverride(x => x.eyeAdaptation); m_SpeedUp = FindParameterOverride(x => x.speedUp); m_SpeedDown = FindParameterOverride(x => x.speedDown); } public override void OnInspectorGUI() { if (!SystemInfo.supportsComputeShaders) EditorGUILayout.HelpBox("Auto exposure requires compute shader support.", MessageType.Warning); EditorUtilities.DrawHeaderLabel("Exposure"); PropertyField(m_Filtering); PropertyField(m_MinLuminance); PropertyField(m_MaxLuminance); // Clamp min/max adaptation values float minLum = m_MinLuminance.value.floatValue; float maxLum = m_MaxLuminance.value.floatValue; m_MinLuminance.value.floatValue = Mathf.Min(minLum, maxLum); m_MaxLuminance.value.floatValue = Mathf.Max(minLum, maxLum); PropertyField(m_KeyValue); EditorGUILayout.Space(); EditorUtilities.DrawHeaderLabel("Adaptation"); PropertyField(m_EyeAdaptation); if (m_EyeAdaptation.value.intValue == (int)EyeAdaptation.Progressive) { PropertyField(m_SpeedUp); PropertyField(m_SpeedDown); } } } }

File no 40: /colame/Assets/SineVFX/PostProcessingV2/Editor/Effects/BloomEditor.cs
using UnityEngine.Rendering.PostProcessing; namespace UnityEditor.Rendering.PostProcessing { [PostProcessEditor(typeof(Bloom))] internal sealed class BloomEditor : PostProcessEffectEditor<Bloom> { SerializedParameterOverride m_Intensity; SerializedParameterOverride m_Threshold; SerializedParameterOverride m_SoftKnee; SerializedParameterOverride m_Clamp; SerializedParameterOverride m_Diffusion; SerializedParameterOverride m_AnamorphicRatio; SerializedParameterOverride m_Color; SerializedParameterOverride m_FastMode; SerializedParameterOverride m_DirtTexture; SerializedParameterOverride m_DirtIntensity; public override void OnEnable() { m_Intensity = FindParameterOverride(x => x.intensity); m_Threshold = FindParameterOverride(x => x.threshold); m_SoftKnee = FindParameterOverride(x => x.softKnee); m_Clamp = FindParameterOverride(x => x.clamp); m_Diffusion = FindParameterOverride(x => x.diffusion); m_AnamorphicRatio = FindParameterOverride(x => x.anamorphicRatio); m_Color = FindParameterOverride(x => x.color); m_FastMode = FindParameterOverride(x => x.fastMode); m_DirtTexture = FindParameterOverride(x => x.dirtTexture); m_DirtIntensity = FindParameterOverride(x => x.dirtIntensity); } public override void OnInspectorGUI() { EditorUtilities.DrawHeaderLabel("Bloom"); PropertyField(m_Intensity); PropertyField(m_Threshold); PropertyField(m_SoftKnee); PropertyField(m_Clamp); PropertyField(m_Diffusion); PropertyField(m_AnamorphicRatio); PropertyField(m_Color); PropertyField(m_FastMode); if (m_FastMode.overrideState.boolValue && !m_FastMode.value.boolValue && EditorUtilities.isTargetingConsolesOrMobiles) EditorGUILayout.HelpBox("For performance reasons it is recommended to use Fast Mode on mobile and console platforms.", MessageType.Warning); EditorGUILayout.Space(); EditorUtilities.DrawHeaderLabel("Dirtiness"); PropertyField(m_DirtTexture); PropertyField(m_DirtIntensity); if (RuntimeUtilities.isVREnabled) { if ((m_DirtIntensity.overrideState.boolValue && m_DirtIntensity.value.floatValue > 0f) || (m_DirtTexture.overrideState.boolValue && m_DirtTexture.value.objectReferenceValue != null)) EditorGUILayout.HelpBox("Using a dirt texture in VR is not recommended.", MessageType.Warning); } } } }

File no 41: /colame/Assets/SineVFX/PostProcessingV2/Editor/Effects/ChromaticAberrationEditor.cs
﻿using UnityEngine.Rendering.PostProcessing; namespace UnityEditor.Rendering.PostProcessing { [PostProcessEditor(typeof(ChromaticAberration))] internal sealed class ChromaticAberrationEditor : PostProcessEffectEditor<ChromaticAberration> { SerializedParameterOverride m_SpectralLut; SerializedParameterOverride m_Intensity; SerializedParameterOverride m_FastMode; public override void OnEnable() { m_SpectralLut = FindParameterOverride(x => x.spectralLut); m_Intensity = FindParameterOverride(x => x.intensity); m_FastMode = FindParameterOverride(x => x.fastMode); } public override void OnInspectorGUI() { base.OnInspectorGUI(); PropertyField(m_SpectralLut); PropertyField(m_Intensity); PropertyField(m_FastMode); if (m_FastMode.overrideState.boolValue && !m_FastMode.value.boolValue && EditorUtilities.isTargetingConsolesOrMobiles) EditorGUILayout.HelpBox("For performance reasons it is recommended to use Fast Mode on mobile and console platforms.", MessageType.Warning); } } }

File no 42: /colame/Assets/SineVFX/PostProcessingV2/Editor/Effects/ColorGradingEditor.cs
using System.Collections.Generic; using UnityEngine; using UnityEngine.Rendering.PostProcessing; namespace UnityEditor.Rendering.PostProcessing { [PostProcessEditor(typeof(ColorGrading))] internal sealed class ColorGradingEditor : PostProcessEffectEditor<ColorGrading> { SerializedParameterOverride m_GradingMode; static GUIContent[] s_Curves = { new GUIContent("Master"), new GUIContent("Red"), new GUIContent("Green"), new GUIContent("Blue"), new GUIContent("Hue Vs Hue"), new GUIContent("Hue Vs Sat"), new GUIContent("Sat Vs Sat"), new GUIContent("Lum Vs Sat") }; SerializedParameterOverride m_ExternalLut; SerializedParameterOverride m_Tonemapper; SerializedParameterOverride m_ToneCurveToeStrength; SerializedParameterOverride m_ToneCurveToeLength; SerializedParameterOverride m_ToneCurveShoulderStrength; SerializedParameterOverride m_ToneCurveShoulderLength; SerializedParameterOverride m_ToneCurveShoulderAngle; SerializedParameterOverride m_ToneCurveGamma; SerializedParameterOverride m_LdrLut; SerializedParameterOverride m_LdrLutContribution; SerializedParameterOverride m_Temperature; SerializedParameterOverride m_Tint; SerializedParameterOverride m_ColorFilter; SerializedParameterOverride m_HueShift; SerializedParameterOverride m_Saturation; SerializedParameterOverride m_Brightness; SerializedParameterOverride m_PostExposure; SerializedParameterOverride m_Contrast; SerializedParameterOverride m_MixerRedOutRedIn; SerializedParameterOverride m_MixerRedOutGreenIn; SerializedParameterOverride m_MixerRedOutBlueIn; SerializedParameterOverride m_MixerGreenOutRedIn; SerializedParameterOverride m_MixerGreenOutGreenIn; SerializedParameterOverride m_MixerGreenOutBlueIn; SerializedParameterOverride m_MixerBlueOutRedIn; SerializedParameterOverride m_MixerBlueOutGreenIn; SerializedParameterOverride m_MixerBlueOutBlueIn; SerializedParameterOverride m_Lift; SerializedParameterOverride m_Gamma; SerializedParameterOverride m_Gain; SerializedParameterOverride m_MasterCurve; SerializedParameterOverride m_RedCurve; SerializedParameterOverride m_GreenCurve; SerializedParameterOverride m_BlueCurve; SerializedParameterOverride m_HueVsHueCurve; SerializedParameterOverride m_HueVsSatCurve; SerializedParameterOverride m_SatVsSatCurve; SerializedParameterOverride m_LumVsSatCurve; // Internal references to the actual animation curves // Needed for the curve editor SerializedProperty m_RawMasterCurve; SerializedProperty m_RawRedCurve; SerializedProperty m_RawGreenCurve; SerializedProperty m_RawBlueCurve; SerializedProperty m_RawHueVsHueCurve; SerializedProperty m_RawHueVsSatCurve; SerializedProperty m_RawSatVsSatCurve; SerializedProperty m_RawLumVsSatCurve; CurveEditor m_CurveEditor; Dictionary<SerializedProperty, Color> m_CurveDict; // Custom tone curve drawing const int k_CustomToneCurveResolution = 48; const float k_CustomToneCurveRangeY = 1.025f; readonly Vector3[] m_RectVertices = new Vector3[4]; readonly Vector3[] m_LineVertices = new Vector3[2]; readonly Vector3[] m_CurveVertices = new Vector3[k_CustomToneCurveResolution]; Rect m_CustomToneCurveRect; readonly HableCurve m_HableCurve = new HableCurve(); public override void OnEnable() { m_GradingMode = FindParameterOverride(x => x.gradingMode); m_ExternalLut = FindParameterOverride(x => x.externalLut); m_Tonemapper = FindParameterOverride(x => x.tonemapper); m_ToneCurveToeStrength = FindParameterOverride(x => x.toneCurveToeStrength); m_ToneCurveToeLength = FindParameterOverride(x => x.toneCurveToeLength); m_ToneCurveShoulderStrength = FindParameterOverride(x => x.toneCurveShoulderStrength); m_ToneCurveShoulderLength = FindParameterOverride(x => x.toneCurveShoulderLength); m_ToneCurveShoulderAngle = FindParameterOverride(x => x.toneCurveShoulderAngle); m_ToneCurveGamma = FindParameterOverride(x => x.toneCurveGamma); m_LdrLut = FindParameterOverride(x => x.ldrLut); m_LdrLutContribution = FindParameterOverride(x => x.ldrLutContribution); m_Temperature = FindParameterOverride(x => x.temperature); m_Tint = FindParameterOverride(x => x.tint); m_ColorFilter = FindParameterOverride(x => x.colorFilter); m_HueShift = FindParameterOverride(x => x.hueShift); m_Saturation = FindParameterOverride(x => x.saturation); m_Brightness = FindParameterOverride(x => x.brightness); m_PostExposure = FindParameterOverride(x => x.postExposure); m_Contrast = FindParameterOverride(x => x.contrast); m_MixerRedOutRedIn = FindParameterOverride(x => x.mixerRedOutRedIn); m_MixerRedOutGreenIn = FindParameterOverride(x => x.mixerRedOutGreenIn); m_MixerRedOutBlueIn = FindParameterOverride(x => x.mixerRedOutBlueIn); m_MixerGreenOutRedIn = FindParameterOverride(x => x.mixerGreenOutRedIn); m_MixerGreenOutGreenIn = FindParameterOverride(x => x.mixerGreenOutGreenIn); m_MixerGreenOutBlueIn = FindParameterOverride(x => x.mixerGreenOutBlueIn); m_MixerBlueOutRedIn = FindParameterOverride(x => x.mixerBlueOutRedIn); m_MixerBlueOutGreenIn = FindParameterOverride(x => x.mixerBlueOutGreenIn); m_MixerBlueOutBlueIn = FindParameterOverride(x => x.mixerBlueOutBlueIn); m_Lift = FindParameterOverride(x => x.lift); m_Gamma = FindParameterOverride(x => x.gamma); m_Gain = FindParameterOverride(x => x.gain); m_MasterCurve = FindParameterOverride(x => x.masterCurve); m_RedCurve = FindParameterOverride(x => x.redCurve); m_GreenCurve = FindParameterOverride(x => x.greenCurve); m_BlueCurve = FindParameterOverride(x => x.blueCurve); m_HueVsHueCurve = FindParameterOverride(x => x.hueVsHueCurve); m_HueVsSatCurve = FindParameterOverride(x => x.hueVsSatCurve); m_SatVsSatCurve = FindParameterOverride(x => x.satVsSatCurve); m_LumVsSatCurve = FindParameterOverride(x => x.lumVsSatCurve); m_RawMasterCurve = FindProperty(x => x.masterCurve.value.curve); m_RawRedCurve = FindProperty(x => x.redCurve.value.curve); m_RawGreenCurve = FindProperty(x => x.greenCurve.value.curve); m_RawBlueCurve = FindProperty(x => x.blueCurve.value.curve); m_RawHueVsHueCurve = FindProperty(x => x.hueVsHueCurve.value.curve); m_RawHueVsSatCurve = FindProperty(x => x.hueVsSatCurve.value.curve); m_RawSatVsSatCurve = FindProperty(x => x.satVsSatCurve.value.curve); m_RawLumVsSatCurve = FindProperty(x => x.lumVsSatCurve.value.curve); m_CurveEditor = new CurveEditor(); m_CurveDict = new Dictionary<SerializedProperty, Color>(); // Prepare the curve editor SetupCurve(m_RawMasterCurve, new Color(1f, 1f, 1f), 2, false); SetupCurve(m_RawRedCurve, new Color(1f, 0f, 0f), 2, false); SetupCurve(m_RawGreenCurve, new Color(0f, 1f, 0f), 2, false); SetupCurve(m_RawBlueCurve, new Color(0f, 0.5f, 1f), 2, false); SetupCurve(m_RawHueVsHueCurve, new Color(1f, 1f, 1f), 0, true); SetupCurve(m_RawHueVsSatCurve, new Color(1f, 1f, 1f), 0, true); SetupCurve(m_RawSatVsSatCurve, new Color(1f, 1f, 1f), 0, false); SetupCurve(m_RawLumVsSatCurve, new Color(1f, 1f, 1f), 0, false); } public override void OnInspectorGUI() { PropertyField(m_GradingMode); var gradingMode = (GradingMode)m_GradingMode.value.intValue; // Check if we're in gamma or linear and display a warning if we're trying to do hdr // color grading while being in gamma mode if (gradingMode != GradingMode.LowDefinitionRange) { if (QualitySettings.activeColorSpace == ColorSpace.Gamma) EditorGUILayout.HelpBox("ColorSpace in project settings is set to Gamma, HDR color grading won't look correct. Switch to Linear or use LDR color grading mode instead.", MessageType.Warning); } if (m_GradingMode.overrideState.boolValue && gradingMode == GradingMode.External) { if (!SystemInfo.supports3DRenderTextures || !SystemInfo.supportsComputeShaders) EditorGUILayout.HelpBox("HDR color grading requires compute shader & 3D render texture support.", MessageType.Warning); } if (gradingMode == GradingMode.LowDefinitionRange) DoStandardModeGUI(false); else if (gradingMode == GradingMode.HighDefinitionRange) DoStandardModeGUI(true); else if (gradingMode == GradingMode.External) DoExternalModeGUI(); EditorGUILayout.Space(); } void SetupCurve(SerializedProperty prop, Color color, uint minPointCount, bool loop) { var state = CurveEditor.CurveState.defaultState; state.color = color; state.visible = false; state.minPointCount = minPointCount; state.onlyShowHandlesOnSelection = true; state.zeroKeyConstantValue = 0.5f; state.loopInBounds = loop; m_CurveEditor.Add(prop, state); m_CurveDict.Add(prop, color); } void DoExternalModeGUI() { PropertyField(m_ExternalLut); var lut = m_ExternalLut.value.objectReferenceValue; if (lut != null) { if (lut.GetType() == typeof(Texture3D)) { var o = (Texture3D)lut; if (o.width == o.height && o.height == o.depth) return; } else if (lut.GetType() == typeof(RenderTexture)) { var o = (RenderTexture)lut; if (o.width == o.height && o.height == o.volumeDepth) return; } EditorGUILayout.HelpBox("Custom LUTs have to be log-encoded 3D textures or 3D render textures with cube format.", MessageType.Warning); } } void DoStandardModeGUI(bool hdr) { if (!hdr) { PropertyField(m_LdrLut); PropertyField(m_LdrLutContribution); var lut = (target as ColorGrading).ldrLut.value; CheckLutImportSettings(lut); } if (hdr) { EditorGUILayout.Space(); EditorUtilities.DrawHeaderLabel("Tonemapping"); PropertyField(m_Tonemapper); if (m_Tonemapper.value.intValue == (int)Tonemapper.Custom) { DrawCustomToneCurve(); PropertyField(m_ToneCurveToeStrength); PropertyField(m_ToneCurveToeLength); PropertyField(m_ToneCurveShoulderStrength); PropertyField(m_ToneCurveShoulderLength); PropertyField(m_ToneCurveShoulderAngle); PropertyField(m_ToneCurveGamma); } } EditorGUILayout.Space(); EditorUtilities.DrawHeaderLabel("White Balance"); PropertyField(m_Temperature); PropertyField(m_Tint); EditorGUILayout.Space(); EditorUtilities.DrawHeaderLabel("Tone"); if (hdr) PropertyField(m_PostExposure); PropertyField(m_ColorFilter); PropertyField(m_HueShift); PropertyField(m_Saturation); if (!hdr) PropertyField(m_Brightness); PropertyField(m_Contrast); EditorGUILayout.Space(); int currentChannel = GlobalSettings.currentChannelMixer; using (new EditorGUILayout.HorizontalScope()) { EditorGUILayout.PrefixLabel("Channel Mixer", GUIStyle.none, Styling.headerLabel); EditorGUI.BeginChangeCheck(); { using (new EditorGUILayout.HorizontalScope()) { GUILayoutUtility.GetRect(9f, 18f, GUILayout.ExpandWidth(false)); // Dirty hack to do proper right column alignement if (GUILayout.Toggle(currentChannel == 0, EditorUtilities.GetContent("Red|Red output channel."), EditorStyles.miniButtonLeft)) currentChannel = 0; if (GUILayout.Toggle(currentChannel == 1, EditorUtilities.GetContent("Green|Green output channel."), EditorStyles.miniButtonMid)) currentChannel = 1; if (GUILayout.Toggle(currentChannel == 2, EditorUtilities.GetContent("Blue|Blue output channel."), EditorStyles.miniButtonRight)) currentChannel = 2; } } if (EditorGUI.EndChangeCheck()) GUI.FocusControl(null); } GlobalSettings.currentChannelMixer = currentChannel; if (currentChannel == 0) { PropertyField(m_MixerRedOutRedIn); PropertyField(m_MixerRedOutGreenIn); PropertyField(m_MixerRedOutBlueIn); } else if (currentChannel == 1) { PropertyField(m_MixerGreenOutRedIn); PropertyField(m_MixerGreenOutGreenIn); PropertyField(m_MixerGreenOutBlueIn); } else { PropertyField(m_MixerBlueOutRedIn); PropertyField(m_MixerBlueOutGreenIn); PropertyField(m_MixerBlueOutBlueIn); } EditorGUILayout.Space(); EditorUtilities.DrawHeaderLabel("Trackballs"); using (new EditorGUILayout.HorizontalScope()) { PropertyField(m_Lift); GUILayout.Space(4f); PropertyField(m_Gamma); GUILayout.Space(4f); PropertyField(m_Gain); } EditorGUILayout.Space(); EditorUtilities.DrawHeaderLabel("Grading Curves"); DoCurvesGUI(hdr); } void CheckLutImportSettings(Texture lut) { if (lut != null) { var importer = AssetImporter.GetAtPath(AssetDatabase.GetAssetPath(lut)) as TextureImporter; // Fails when using an internal texture as you can't change import settings on // builtin resources, thus the check for null if (importer != null) { bool valid = importer.anisoLevel == 0 && importer.mipmapEnabled == false && importer.sRGBTexture == false && importer.textureCompression == TextureImporterCompression.Uncompressed && importer.wrapMode == TextureWrapMode.Clamp; if (!valid) EditorUtilities.DrawFixMeBox("Invalid LUT import settings.", () => SetLutImportSettings(importer)); } if (lut.width != lut.height * lut.height) { EditorGUILayout.HelpBox("The Lookup Texture size is invalid. Width should be Height * Height.", MessageType.Error); } } } void SetLutImportSettings(TextureImporter importer) { importer.textureType = TextureImporterType.Default; importer.mipmapEnabled = false; importer.anisoLevel = 0; importer.sRGBTexture = false; importer.npotScale = TextureImporterNPOTScale.None; importer.textureCompression = TextureImporterCompression.Uncompressed; importer.alphaSource = TextureImporterAlphaSource.None; importer.wrapMode = TextureWrapMode.Clamp; importer.SaveAndReimport(); AssetDatabase.Refresh(); } void DrawCustomToneCurve() { EditorGUILayout.Space(); // Reserve GUI space using (new GUILayout.HorizontalScope()) { GUILayout.Space(EditorGUI.indentLevel * 15f); m_CustomToneCurveRect = GUILayoutUtility.GetRect(128, 80); } if (Event.current.type != EventType.Repaint) return; // Prepare curve data float toeStrength = m_ToneCurveToeStrength.value.floatValue; float toeLength = m_ToneCurveToeLength.value.floatValue; float shoulderStrength = m_ToneCurveShoulderStrength.value.floatValue; float shoulderLength = m_ToneCurveShoulderLength.value.floatValue; float shoulderAngle = m_ToneCurveShoulderAngle.value.floatValue; float gamma = m_ToneCurveGamma.value.floatValue; m_HableCurve.Init( toeStrength, toeLength, shoulderStrength, shoulderLength, shoulderAngle, gamma ); float endPoint = m_HableCurve.whitePoint; // Background m_RectVertices[0] = PointInRect(0f, 0f, endPoint); m_RectVertices[1] = PointInRect(endPoint, 0f, endPoint); m_RectVertices[2] = PointInRect(endPoint, k_CustomToneCurveRangeY, endPoint); m_RectVertices[3] = PointInRect(0f, k_CustomToneCurveRangeY, endPoint); Handles.DrawSolidRectangleWithOutline(m_RectVertices, Color.white * 0.1f, Color.white * 0.4f); // Vertical guides if (endPoint < m_CustomToneCurveRect.width / 3) { int steps = Mathf.CeilToInt(endPoint); for (var i = 1; i < steps; i++) DrawLine(i, 0, i, k_CustomToneCurveRangeY, 0.4f, endPoint); } // Label Handles.Label(m_CustomToneCurveRect.position + Vector2.right, "Custom Tone Curve", EditorStyles.miniLabel); // Draw the acual curve var vcount = 0; while (vcount < k_CustomToneCurveResolution) { float x = endPoint * vcount / (k_CustomToneCurveResolution - 1); float y = m_HableCurve.Eval(x); if (y < k_CustomToneCurveRangeY) { m_CurveVertices[vcount++] = PointInRect(x, y, endPoint); } else { if (vcount > 1) { // Extend the last segment to the top edge of the rect. var v1 = m_CurveVertices[vcount - 2]; var v2 = m_CurveVertices[vcount - 1]; var clip = (m_CustomToneCurveRect.y - v1.y) / (v2.y - v1.y); m_CurveVertices[vcount - 1] = v1 + (v2 - v1) * clip; } break; } } if (vcount > 1) { Handles.color = Color.white * 0.9f; Handles.DrawAAPolyLine(2f, vcount, m_CurveVertices); } } void DrawLine(float x1, float y1, float x2, float y2, float grayscale, float rangeX) { m_LineVertices[0] = PointInRect(x1, y1, rangeX); m_LineVertices[1] = PointInRect(x2, y2, rangeX); Handles.color = Color.white * grayscale; Handles.DrawAAPolyLine(2f, m_LineVertices); } Vector3 PointInRect(float x, float y, float rangeX) { x = Mathf.Lerp(m_CustomToneCurveRect.x, m_CustomToneCurveRect.xMax, x / rangeX); y = Mathf.Lerp(m_CustomToneCurveRect.yMax, m_CustomToneCurveRect.y, y / k_CustomToneCurveRangeY); return new Vector3(x, y, 0); } void ResetVisibleCurves() { foreach (var curve in m_CurveDict) { var state = m_CurveEditor.GetCurveState(curve.Key); state.visible = false; m_CurveEditor.SetCurveState(curve.Key, state); } } void SetCurveVisible(SerializedProperty rawProp, SerializedProperty overrideProp) { var state = m_CurveEditor.GetCurveState(rawProp); state.visible = true; state.editable = overrideProp.boolValue; m_CurveEditor.SetCurveState(rawProp, state); } void CurveOverrideToggle(SerializedProperty overrideProp) { overrideProp.boolValue = GUILayout.Toggle(overrideProp.boolValue, EditorUtilities.GetContent("Override"), EditorStyles.toolbarButton); } static Material s_MaterialGrid; void DoCurvesGUI(bool hdr) { EditorGUILayout.Space(); ResetVisibleCurves(); using (new EditorGUI.DisabledGroupScope(serializedObject.isEditingMultipleObjects)) { int curveEditingId = 0; SerializedProperty currentCurveRawProp = null; // Top toolbar using (new GUILayout.HorizontalScope(EditorStyles.toolbar)) { curveEditingId = DoCurveSelectionPopup(GlobalSettings.currentCurve, hdr); curveEditingId = Mathf.Clamp(curveEditingId, hdr ? 4 : 0, 7); EditorGUILayout.Space(); switch (curveEditingId) { case 0: CurveOverrideToggle(m_MasterCurve.overrideState); SetCurveVisible(m_RawMasterCurve, m_MasterCurve.overrideState); currentCurveRawProp = m_RawMasterCurve; break; case 1: CurveOverrideToggle(m_RedCurve.overrideState); SetCurveVisible(m_RawRedCurve, m_RedCurve.overrideState); currentCurveRawProp = m_RawRedCurve; break; case 2: CurveOverrideToggle(m_GreenCurve.overrideState); SetCurveVisible(m_RawGreenCurve, m_GreenCurve.overrideState); currentCurveRawProp = m_RawGreenCurve; break; case 3: CurveOverrideToggle(m_BlueCurve.overrideState); SetCurveVisible(m_RawBlueCurve, m_BlueCurve.overrideState); currentCurveRawProp = m_RawBlueCurve; break; case 4: CurveOverrideToggle(m_HueVsHueCurve.overrideState); SetCurveVisible(m_RawHueVsHueCurve, m_HueVsHueCurve.overrideState); currentCurveRawProp = m_RawHueVsHueCurve; break; case 5: CurveOverrideToggle(m_HueVsSatCurve.overrideState); SetCurveVisible(m_RawHueVsSatCurve, m_HueVsSatCurve.overrideState); currentCurveRawProp = m_RawHueVsSatCurve; break; case 6: CurveOverrideToggle(m_SatVsSatCurve.overrideState); SetCurveVisible(m_RawSatVsSatCurve, m_SatVsSatCurve.overrideState); currentCurveRawProp = m_RawSatVsSatCurve; break; case 7: CurveOverrideToggle(m_LumVsSatCurve.overrideState); SetCurveVisible(m_RawLumVsSatCurve, m_LumVsSatCurve.overrideState); currentCurveRawProp = m_RawLumVsSatCurve; break; } GUILayout.FlexibleSpace(); if (GUILayout.Button("Reset", EditorStyles.toolbarButton)) { switch (curveEditingId) { case 0: m_RawMasterCurve.animationCurveValue = AnimationCurve.Linear(0f, 0f, 1f, 1f); break; case 1: m_RawRedCurve.animationCurveValue = AnimationCurve.Linear(0f, 0f, 1f, 1f); break; case 2: m_RawGreenCurve.animationCurveValue = AnimationCurve.Linear(0f, 0f, 1f, 1f); break; case 3: m_RawBlueCurve.animationCurveValue = AnimationCurve.Linear(0f, 0f, 1f, 1f); break; case 4: m_RawHueVsHueCurve.animationCurveValue = new AnimationCurve(); break; case 5: m_RawHueVsSatCurve.animationCurveValue = new AnimationCurve(); break; case 6: m_RawSatVsSatCurve.animationCurveValue = new AnimationCurve(); break; case 7: m_RawLumVsSatCurve.animationCurveValue = new AnimationCurve(); break; } } GlobalSettings.currentCurve = curveEditingId; } // Curve area var settings = m_CurveEditor.settings; var rect = GUILayoutUtility.GetAspectRect(2f); var innerRect = settings.padding.Remove(rect); if (Event.current.type == EventType.Repaint) { // Background EditorGUI.DrawRect(rect, new Color(0.15f, 0.15f, 0.15f, 1f)); if (curveEditingId == 4 || curveEditingId == 5) DrawBackgroundTexture(innerRect, 0); else if (curveEditingId == 6 || curveEditingId == 7) DrawBackgroundTexture(innerRect, 1); // Bounds Handles.color = Color.white * (GUI.enabled ? 1f : 0.5f); Handles.DrawSolidRectangleWithOutline(innerRect, Color.clear, new Color(0.8f, 0.8f, 0.8f, 0.5f)); // Grid setup Handles.color = new Color(1f, 1f, 1f, 0.05f); int hLines = (int)Mathf.Sqrt(innerRect.width); int vLines = (int)(hLines / (innerRect.width / innerRect.height)); // Vertical grid int gridOffset = Mathf.FloorToInt(innerRect.width / hLines); int gridPadding = ((int)(innerRect.width) % hLines) / 2; for (int i = 1; i < hLines; i++) { var offset = i * Vector2.right * gridOffset; offset.x += gridPadding; Handles.DrawLine(innerRect.position + offset, new Vector2(innerRect.x, innerRect.yMax - 1) + offset); } // Horizontal grid gridOffset = Mathf.FloorToInt(innerRect.height / vLines); gridPadding = ((int)(innerRect.height) % vLines) / 2; for (int i = 1; i < vLines; i++) { var offset = i * Vector2.up * gridOffset; offset.y += gridPadding; Handles.DrawLine(innerRect.position + offset, new Vector2(innerRect.xMax - 1, innerRect.y) + offset); } } // Curve editor if (m_CurveEditor.OnGUI(rect)) { Repaint(); GUI.changed = true; } if (Event.current.type == EventType.Repaint) { // Borders Handles.color = Color.black; Handles.DrawLine(new Vector2(rect.x, rect.y - 18f), new Vector2(rect.xMax, rect.y - 18f)); Handles.DrawLine(new Vector2(rect.x, rect.y - 19f), new Vector2(rect.x, rect.yMax)); Handles.DrawLine(new Vector2(rect.x, rect.yMax), new Vector2(rect.xMax, rect.yMax)); Handles.DrawLine(new Vector2(rect.xMax, rect.yMax), new Vector2(rect.xMax, rect.y - 18f)); bool editable = m_CurveEditor.GetCurveState(currentCurveRawProp).editable; string editableString = editable ? string.Empty : "(Not Overriding)\n"; // Selection info var selection = m_CurveEditor.GetSelection(); var infoRect = innerRect; infoRect.x += 5f; infoRect.width = 100f; infoRect.height = 30f; if (selection.curve != null && selection.keyframeIndex > -1) { var key = selection.keyframe.Value; GUI.Label(infoRect, string.Format("{0}\n{1}", key.time.ToString("F3"), key.value.ToString("F3")), Styling.preLabel); } else { GUI.Label(infoRect, editableString, Styling.preLabel); } } } } void DrawBackgroundTexture(Rect rect, int pass) { if (s_MaterialGrid == null) s_MaterialGrid = new Material(Shader.Find("Hidden/PostProcessing/Editor/CurveGrid")) { hideFlags = HideFlags.HideAndDontSave }; float scale = EditorGUIUtility.pixelsPerPoint; #if UNITY_2018_1_OR_NEWER const RenderTextureReadWrite kReadWrite = RenderTextureReadWrite.sRGB; #else const RenderTextureReadWrite kReadWrite = RenderTextureReadWrite.Linear; #endif var oldRt = RenderTexture.active; var rt = RenderTexture.GetTemporary(Mathf.CeilToInt(rect.width * scale), Mathf.CeilToInt(rect.height * scale), 0, RenderTextureFormat.ARGB32, kReadWrite); s_MaterialGrid.SetFloat("_DisabledState", GUI.enabled ? 1f : 0.5f); s_MaterialGrid.SetFloat("_PixelScaling", EditorGUIUtility.pixelsPerPoint); Graphics.Blit(null, rt, s_MaterialGrid, pass); RenderTexture.active = oldRt; GUI.DrawTexture(rect, rt); RenderTexture.ReleaseTemporary(rt); } int DoCurveSelectionPopup(int id, bool hdr) { GUILayout.Label(s_Curves[id], EditorStyles.toolbarPopup, GUILayout.MaxWidth(150f)); var lastRect = GUILayoutUtility.GetLastRect(); var e = Event.current; if (e.type == EventType.MouseDown && e.button == 0 && lastRect.Contains(e.mousePosition)) { var menu = new GenericMenu(); for (int i = 0; i < s_Curves.Length; i++) { if (i == 4) menu.AddSeparator(""); if (hdr && i < 4) menu.AddDisabledItem(s_Curves[i]); else { int current = i; // Capture local for closure menu.AddItem(s_Curves[i], current == id, () => GlobalSettings.currentCurve = current); } } menu.DropDown(new Rect(lastRect.xMin, lastRect.yMax, 1f, 1f)); } return id; } } }

File no 43: /colame/Assets/SineVFX/PostProcessingV2/Editor/Effects/DefaultPostProcessEffectEditor.cs
using System; using System.Collections.Generic; using System.Linq; using System.Reflection; using UnityEngine.Rendering.PostProcessing; namespace UnityEditor.Rendering.PostProcessing { /// <summary> /// A default effect editor that gathers all parameters and list them vertically in the /// inspector. /// </summary> public class DefaultPostProcessEffectEditor : PostProcessEffectBaseEditor { List<SerializedParameterOverride> m_Parameters; /// <inheritdoc /> public override void OnEnable() { m_Parameters = new List<SerializedParameterOverride>(); var fields = target.GetType() .GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic) .Where(t => t.FieldType.IsSubclassOf(typeof(ParameterOverride)) && t.Name != "enabled") .Where(t => (t.IsPublic && t.GetCustomAttributes(typeof(NonSerializedAttribute), false).Length == 0) || (t.GetCustomAttributes(typeof(UnityEngine.SerializeField), false).Length > 0) ) .ToList(); foreach (var field in fields) { var property = serializedObject.FindProperty(field.Name); var attributes = field.GetCustomAttributes(false).Cast<Attribute>().ToArray(); var parameter = new SerializedParameterOverride(property, attributes); m_Parameters.Add(parameter); } } /// <inheritdoc /> public override void OnInspectorGUI() { foreach (var parameter in m_Parameters) PropertyField(parameter); } } }

File no 44: /colame/Assets/SineVFX/PostProcessingV2/Editor/Effects/DepthOfFieldEditor.cs
using UnityEngine; using UnityEngine.Rendering.PostProcessing; namespace UnityEditor.Rendering.PostProcessing { [PostProcessEditor(typeof(DepthOfField))] internal sealed class DepthOfFieldEditor : PostProcessEffectEditor<DepthOfField> { SerializedParameterOverride m_FocusDistance; SerializedParameterOverride m_Aperture; SerializedParameterOverride m_FocalLength; SerializedParameterOverride m_KernelSize; public override void OnEnable() { m_FocusDistance = FindParameterOverride(x => x.focusDistance); m_Aperture = FindParameterOverride(x => x.aperture); m_FocalLength = FindParameterOverride(x => x.focalLength); m_KernelSize = FindParameterOverride(x => x.kernelSize); } public override void OnInspectorGUI() { if (SystemInfo.graphicsShaderLevel < 35) EditorGUILayout.HelpBox("Depth Of Field is only supported on the following platforms:\nDX11+, OpenGL 3.2+, OpenGL ES 3+, Metal, Vulkan, PS4/XB1 consoles.", MessageType.Warning); PropertyField(m_FocusDistance); PropertyField(m_Aperture); PropertyField(m_FocalLength); PropertyField(m_KernelSize); } } }

File no 45: /colame/Assets/SineVFX/PostProcessingV2/Editor/Effects/LensDistortionEditor.cs
using UnityEngine.Rendering.PostProcessing; namespace UnityEditor.Rendering.PostProcessing { [PostProcessEditor(typeof(LensDistortion))] internal sealed class LensDistortionEditor : DefaultPostProcessEffectEditor { public override void OnInspectorGUI() { if (RuntimeUtilities.isVREnabled) EditorGUILayout.HelpBox("Lens Distortion is automatically disabled when VR is enabled.", MessageType.Warning); base.OnInspectorGUI(); } } }

File no 46: /colame/Assets/SineVFX/PostProcessingV2/Editor/Effects/ScreenSpaceReflectionsEditor.cs
using UnityEngine; using UnityEngine.Rendering.PostProcessing; namespace UnityEditor.Rendering.PostProcessing { [PostProcessEditor(typeof(ScreenSpaceReflections))] internal sealed class ScreenSpaceReflectionsEditor : PostProcessEffectEditor<ScreenSpaceReflections> { SerializedParameterOverride m_Preset; SerializedParameterOverride m_MaximumIterationCount; SerializedParameterOverride m_Thickness; SerializedParameterOverride m_Resolution; SerializedParameterOverride m_MaximumMarchDistance; SerializedParameterOverride m_DistanceFade; SerializedParameterOverride m_Vignette; public override void OnEnable() { m_Preset = FindParameterOverride(x => x.preset); m_MaximumIterationCount = FindParameterOverride(x => x.maximumIterationCount); m_Thickness = FindParameterOverride(x => x.thickness); m_Resolution = FindParameterOverride(x => x.resolution); m_MaximumMarchDistance = FindParameterOverride(x => x.maximumMarchDistance); m_DistanceFade = FindParameterOverride(x => x.distanceFade); m_Vignette = FindParameterOverride(x => x.vignette); } public override void OnInspectorGUI() { if (RuntimeUtilities.scriptableRenderPipelineActive) { EditorGUILayout.HelpBox("This effect doesn't work with scriptable render pipelines yet.", MessageType.Warning); return; } if (Camera.main != null && Camera.main.actualRenderingPath != RenderingPath.DeferredShading) EditorGUILayout.HelpBox("This effect only works with the deferred rendering path.", MessageType.Warning); if (!SystemInfo.supportsComputeShaders) EditorGUILayout.HelpBox("This effect requires compute shader support.", MessageType.Warning); PropertyField(m_Preset); if (m_Preset.value.intValue == (int)ScreenSpaceReflectionPreset.Custom) { PropertyField(m_MaximumIterationCount); PropertyField(m_Thickness); PropertyField(m_Resolution); EditorGUILayout.Space(); } PropertyField(m_MaximumMarchDistance); PropertyField(m_DistanceFade); PropertyField(m_Vignette); } } }

File no 47: /colame/Assets/SineVFX/PostProcessingV2/Editor/Effects/VignetteEditor.cs
using UnityEngine; using UnityEngine.Rendering.PostProcessing; namespace UnityEditor.Rendering.PostProcessing { [PostProcessEditor(typeof(Vignette))] internal sealed class VignetteEditor : PostProcessEffectEditor<Vignette> { SerializedParameterOverride m_Mode; SerializedParameterOverride m_Color; SerializedParameterOverride m_Center; SerializedParameterOverride m_Intensity; SerializedParameterOverride m_Smoothness; SerializedParameterOverride m_Roundness; SerializedParameterOverride m_Rounded; SerializedParameterOverride m_Mask; SerializedParameterOverride m_Opacity; public override void OnEnable() { m_Mode = FindParameterOverride(x => x.mode); m_Color = FindParameterOverride(x => x.color); m_Center = FindParameterOverride(x => x.center); m_Intensity = FindParameterOverride(x => x.intensity); m_Smoothness = FindParameterOverride(x => x.smoothness); m_Roundness = FindParameterOverride(x => x.roundness); m_Rounded = FindParameterOverride(x => x.rounded); m_Mask = FindParameterOverride(x => x.mask); m_Opacity = FindParameterOverride(x => x.opacity); } public override void OnInspectorGUI() { PropertyField(m_Mode); PropertyField(m_Color); if (m_Mode.value.intValue == (int)VignetteMode.Classic) { PropertyField(m_Center); PropertyField(m_Intensity); PropertyField(m_Smoothness); PropertyField(m_Roundness); PropertyField(m_Rounded); } else { PropertyField(m_Mask); var mask = (target as Vignette).mask.value; // Checks import settings on the mask if (mask != null) { var importer = AssetImporter.GetAtPath(AssetDatabase.GetAssetPath(mask)) as TextureImporter; // Fails when using an internal texture as you can't change import settings on // builtin resources, thus the check for null if (importer != null) { bool valid = importer.anisoLevel == 0 && importer.mipmapEnabled == false && importer.alphaSource == TextureImporterAlphaSource.FromGrayScale && importer.textureCompression == TextureImporterCompression.Uncompressed && importer.wrapMode == TextureWrapMode.Clamp; if (!valid) EditorUtilities.DrawFixMeBox("Invalid mask import settings.", () => SetMaskImportSettings(importer)); } } PropertyField(m_Opacity); } } void SetMaskImportSettings(TextureImporter importer) { importer.textureType = TextureImporterType.SingleChannel; importer.alphaSource = TextureImporterAlphaSource.FromGrayScale; importer.textureCompression = TextureImporterCompression.Uncompressed; importer.anisoLevel = 0; importer.mipmapEnabled = false; importer.wrapMode = TextureWrapMode.Clamp; importer.SaveAndReimport(); AssetDatabase.Refresh(); } } }

File no 48: /colame/Assets/SineVFX/PostProcessingV2/Editor/Tools/CubeLutAssetFactory.cs
using System; using System.IO; using System.Text; using UnityEngine; using UnityEngine.Rendering.PostProcessing; namespace UnityEditor.Rendering.PostProcessing { // CUBE lut specs: // http://wwwimages.adobe.com/content/dam/Adobe/en/products/speedgrade/cc/pdfs/cube-lut-specification-1.0.pdf static class CubeLutAssetFactory { const int kVersion = 1; const int kSize = 33; #if POSTFX_DEBUG_MENUS [MenuItem("Tools/Post-processing/Create Utility Luts")] #endif static void CreateLuts() { Dump("Linear to Unity Log r" + kVersion, ColorUtilities.LinearToLogC); Dump("Unity Log to Linear r" + kVersion, ColorUtilities.LogCToLinear); Dump("sRGB to Unity Log r" + kVersion, x => ColorUtilities.LinearToLogC(Mathf.GammaToLinearSpace(x))); Dump("Unity Log to sRGB r" + kVersion, x => Mathf.LinearToGammaSpace(ColorUtilities.LogCToLinear(x))); Dump("Linear to sRGB r" + kVersion, Mathf.LinearToGammaSpace); Dump("sRGB to Linear r" + kVersion, Mathf.GammaToLinearSpace); AssetDatabase.Refresh(); } static void Dump(string title, Func<float, float> eval) { var sb = new StringBuilder(); sb.AppendFormat("TITLE \"{0}\"\n", title); sb.AppendFormat("LUT_3D_SIZE {0}\n", kSize); sb.AppendFormat("DOMAIN_MIN {0} {0} {0}\n", 0f); sb.AppendFormat("DOMAIN_MAX {0} {0} {0}\n", 1f); const float kSizeMinusOne = (float)kSize - 1f; for (int x = 0; x < kSize; x++) for (int y = 0; y < kSize; y++) for (int z = 0; z < kSize; z++) { float ox = eval((float)x / kSizeMinusOne); float oy = eval((float)y / kSizeMinusOne); float oz = eval((float)z / kSizeMinusOne); // Resolve & Photoshop use BGR as default, let's make it easier for users sb.AppendFormat("{0} {1} {2}\n", oz, oy, ox); } var content = sb.ToString(); var path = Path.Combine(Application.dataPath, string.Format("{0}.cube", title)); File.WriteAllText(path, content); } } }

File no 49: /colame/Assets/SineVFX/PostProcessingV2/Editor/Tools/CubeLutAssetImporter.cs
using System.Collections.Generic; using System.Globalization; using System.IO; using System.Text; using UnityEngine; namespace UnityEditor.Rendering.PostProcessing { sealed class CubeLutAssetImporter : AssetPostprocessor { static List<string> s_Excluded = new List<string>() { "Linear to sRGB r1", "Linear to Unity Log r1", "sRGB to Linear r1", "sRGB to Unity Log r1", "Unity Log to Linear r1", "Unity Log to sRGB r1" }; static void OnPostprocessAllAssets(string[] imported, string[] deleted, string[] moved, string[] movedFrom) { foreach (string path in imported) { string ext = Path.GetExtension(path); string filename = Path.GetFileNameWithoutExtension(path); if (string.IsNullOrEmpty(ext) || s_Excluded.Contains(filename)) continue; ext = ext.ToLowerInvariant(); if (ext.Equals(".cube")) ImportCubeLut(path); } } // Basic CUBE lut parser // Specs: http://wwwimages.adobe.com/content/dam/Adobe/en/products/speedgrade/cc/pdfs/cube-lut-specification-1.0.pdf static void ImportCubeLut(string path) { // Remove the 'Assets' part of the path & build absolute path string fullpath = path.Substring(7); fullpath = Path.Combine(Application.dataPath, fullpath); // Read the lut data string[] lines = File.ReadAllLines(fullpath); // Start parsing int i = 0; int size = -1; int sizeCube = -1; var table = new List<Color>(); var domainMin = Color.black; var domainMax = Color.white; while (true) { if (i >= lines.Length) { if (table.Count != sizeCube) Debug.LogError("Premature end of file"); break; } string line = FilterLine(lines[i]); if (string.IsNullOrEmpty(line)) goto next; // Header data if (line.StartsWith("TITLE")) goto next; // Skip the title tag, we don't need it if (line.StartsWith("LUT_3D_SIZE")) { string sizeStr = line.Substring(11).TrimStart(); if (!int.TryParse(sizeStr, out size)) { Debug.LogError("Invalid data on line " + i); break; } if (size < 2 || size > 256) { Debug.LogError("LUT size out of range"); break; } sizeCube = size * size * size; goto next; } if (line.StartsWith("DOMAIN_MIN")) { if (!ParseDomain(i, line, ref domainMin)) break; goto next; } if (line.StartsWith("DOMAIN_MAX")) { if (!ParseDomain(i, line, ref domainMax)) break; goto next; } // Table string[] row = line.Split(); if (row.Length != 3) { Debug.LogError("Invalid data on line " + i); break; } var color = Color.black; for (int j = 0; j < 3; j++) { float d; if (!float.TryParse(row[j], NumberStyles.Float, CultureInfo.InvariantCulture.NumberFormat, out d)) { Debug.LogError("Invalid data on line " + i); break; } color[j] = d; } table.Add(color); next: i++; } if (sizeCube != table.Count) { Debug.LogError("Wrong table size - Expected " + sizeCube + " elements, got " + table.Count); return; } // Check if the Texture3D already exists, update it in this case (better workflow for // the user) string assetPath = Path.ChangeExtension(path, ".asset"); var tex = AssetDatabase.LoadAssetAtPath<Texture3D>(assetPath); if (tex != null) { tex.SetPixels(table.ToArray(), 0); tex.Apply(); } else { // Generate a new Texture3D tex = new Texture3D(size, size, size, TextureFormat.RGBAHalf, false) { anisoLevel = 0, filterMode = FilterMode.Bilinear, wrapMode = TextureWrapMode.Clamp, }; tex.SetPixels(table.ToArray(), 0); tex.Apply(); // Save to disk AssetDatabase.CreateAsset(tex, assetPath); } AssetDatabase.SaveAssets(); AssetDatabase.Refresh(); } static string FilterLine(string line) { var filtered = new StringBuilder(); line = line.TrimStart().TrimEnd(); int len = line.Length; int i = 0; while (i < len) { char c = line[i]; if (c == '#') // Filters comment out break; filtered.Append(c); i++; } return filtered.ToString(); } static bool ParseDomain(int i, string line, ref Color domain) { string[] domainStrs = line.Substring(10).TrimStart().Split(); if (domainStrs.Length != 3) { Debug.LogError("Invalid data on line " + i); return false; } for (int j = 0; j < 3; j++) { float d; if (!float.TryParse(domainStrs[j], NumberStyles.Float, CultureInfo.InvariantCulture.NumberFormat, out d)) { Debug.LogError("Invalid data on line " + i); return false; } domain[j] = d; } return true; } } }

File no 50: /colame/Assets/SineVFX/PostProcessingV2/Editor/Tools/DefineSetter.cs
using System; using System.Linq; namespace UnityEditor.Rendering.PostProcessing { [InitializeOnLoad] sealed class DefineSetter { const string k_Define = "UNITY_POST_PROCESSING_STACK_V2"; static DefineSetter() { var targets = Enum.GetValues(typeof(BuildTargetGroup)) .Cast<BuildTargetGroup>() .Where(x => x != BuildTargetGroup.Unknown) .Where(x => !IsObsolete(x)); foreach (var target in targets) { var defines = PlayerSettings.GetScriptingDefineSymbolsForGroup(target).Trim(); var list = defines.Split(';', ' ') .Where(x => !string.IsNullOrEmpty(x)) .ToList(); if (list.Contains(k_Define)) continue; list.Add(k_Define); defines = list.Aggregate((a, b) => a + ";" + b); PlayerSettings.SetScriptingDefineSymbolsForGroup(target, defines); } } static bool IsObsolete(BuildTargetGroup group) { var attrs = typeof(BuildTargetGroup) .GetField(group.ToString()) .GetCustomAttributes(typeof(ObsoleteAttribute), false); return attrs != null && attrs.Length > 0; } } }

File no 51: /colame/Assets/SineVFX/PostProcessingV2/Editor/Tools/ProfileFactory.cs
using UnityEngine; using UnityEditor.ProjectWindowCallback; using System.IO; using UnityEngine.SceneManagement; using UnityEngine.Rendering.PostProcessing; namespace UnityEditor.Rendering.PostProcessing { /// <summary> /// An utility class to help the creation of new post-processing profile assets. /// </summary> public sealed class ProfileFactory { [MenuItem("Assets/Create/Post-processing Profile", priority = 201)] static void CreatePostProcessProfile() { //var icon = EditorGUIUtility.FindTexture("ScriptableObject Icon"); ProjectWindowUtil.StartNameEditingIfProjectWindowExists(0, ScriptableObject.CreateInstance<DoCreatePostProcessProfile>(), "New Post-processing Profile.asset", null, null); } /// <summary> /// Creates a post-processing profile asset at the given location. /// </summary> /// <param name="path">The path to use relative to the project folder</param> /// <returns>The newly created profile</returns> public static PostProcessProfile CreatePostProcessProfileAtPath(string path) { var profile = ScriptableObject.CreateInstance<PostProcessProfile>(); profile.name = Path.GetFileName(path); AssetDatabase.CreateAsset(profile, path); AssetDatabase.SaveAssets(); AssetDatabase.Refresh(); return profile; } /// <summary> /// Creates a post-processing profile asset and automatically put it in a sub folder next /// to the given scene. /// </summary> /// <param name="scene">A scene</param> /// <param name="targetName">A name for the new profile</param> /// <returns>The newly created profile</returns> public static PostProcessProfile CreatePostProcessProfile(Scene scene, string targetName) { var path = string.Empty; if (string.IsNullOrEmpty(scene.path)) { path = "Assets/"; } else { var scenePath = Path.GetDirectoryName(scene.path); var extPath = scene.name + "_Profiles"; var profilePath = scenePath + "/" + extPath; if (!AssetDatabase.IsValidFolder(profilePath)) AssetDatabase.CreateFolder(scenePath, extPath); path = profilePath + "/"; } path += targetName + " Profile.asset"; path = AssetDatabase.GenerateUniqueAssetPath(path); var profile = ScriptableObject.CreateInstance<PostProcessProfile>(); AssetDatabase.CreateAsset(profile, path); AssetDatabase.SaveAssets(); AssetDatabase.Refresh(); return profile; } } class DoCreatePostProcessProfile : EndNameEditAction { public override void Action(int instanceId, string pathName, string resourceFile) { var profile = ProfileFactory.CreatePostProcessProfileAtPath(pathName); ProjectWindowUtil.ShowCreatedAsset(profile); } } }

File no 52: /colame/Assets/SineVFX/PostProcessingV2/Editor/Tools/ResourceAssetFactory.cs
using UnityEngine; using UnityEngine.Rendering.PostProcessing; namespace UnityEditor.Rendering.PostProcessing { static class ResourceAssetFactory { #if POSTFX_DEBUG_MENUS [MenuItem("Tools/Post-processing/Create Resources Asset")] #endif static void CreateAsset() { var asset = ScriptableObject.CreateInstance<PostProcessResources>(); AssetDatabase.CreateAsset(asset, "Assets/PostProcessResources.asset"); AssetDatabase.SaveAssets(); AssetDatabase.Refresh(); } } }

File no 53: /colame/Assets/SineVFX/PostProcessingV2/Editor/Tools/VolumeFactory.cs
using UnityEngine; using UnityEngine.Rendering.PostProcessing; namespace UnityEditor.Rendering.PostProcessing { internal static class VolumeFactory { [MenuItem("GameObject/3D Object/Post-process Volume")] static void CreateVolume() { var gameObject = new GameObject("Post-process Volume"); var collider = gameObject.AddComponent<BoxCollider>(); collider.size = Vector3.one; collider.isTrigger = true; gameObject.AddComponent<PostProcessVolume>(); Selection.objects = new [] { gameObject }; EditorApplication.ExecuteMenuItem("GameObject/Move To View"); } } }

File no 54: /colame/Assets/SineVFX/PostProcessingV2/Editor/Utils/CurveEditor.cs
using System; using System.Collections.Generic; using UnityEngine; namespace UnityEditor.Rendering.PostProcessing { internal sealed class CurveEditor { #region Enums enum EditMode { None, Moving, TangentEdit } enum Tangent { In, Out } #endregion #region Structs public struct Settings { public Rect bounds; public RectOffset padding; public Color selectionColor; public float curvePickingDistance; public float keyTimeClampingDistance; public static Settings defaultSettings { get { return new Settings { bounds = new Rect(0f, 0f, 1f, 1f), padding = new RectOffset(10, 10, 10, 10), selectionColor = Color.yellow, curvePickingDistance = 6f, keyTimeClampingDistance = 1e-4f }; } } } public struct CurveState { public bool visible; public bool editable; public uint minPointCount; public float zeroKeyConstantValue; public Color color; public float width; public float handleWidth; public bool showNonEditableHandles; public bool onlyShowHandlesOnSelection; public bool loopInBounds; public static CurveState defaultState { get { return new CurveState { visible = true, editable = true, minPointCount = 2, zeroKeyConstantValue = 0f, color = Color.white, width = 2f, handleWidth = 2f, showNonEditableHandles = true, onlyShowHandlesOnSelection = false, loopInBounds = false }; } } } public struct Selection { public SerializedProperty curve; public int keyframeIndex; public Keyframe? keyframe; public Selection(SerializedProperty curve, int keyframeIndex, Keyframe? keyframe) { this.curve = curve; this.keyframeIndex = keyframeIndex; this.keyframe = keyframe; } } internal struct MenuAction { internal SerializedProperty curve; internal int index; internal Vector3 position; internal MenuAction(SerializedProperty curve) { this.curve = curve; this.index = -1; this.position = Vector3.zero; } internal MenuAction(SerializedProperty curve, int index) { this.curve = curve; this.index = index; this.position = Vector3.zero; } internal MenuAction(SerializedProperty curve, Vector3 position) { this.curve = curve; this.index = -1; this.position = position; } } #endregion #region Fields & properties public Settings settings { get; private set; } readonly Dictionary<SerializedProperty, CurveState> m_Curves; Rect m_CurveArea; SerializedProperty m_SelectedCurve; int m_SelectedKeyframeIndex = -1; EditMode m_EditMode = EditMode.None; Tangent m_TangentEditMode; bool m_Dirty; #endregion #region Constructors & destructors public CurveEditor() : this(Settings.defaultSettings) { } public CurveEditor(Settings settings) { this.settings = settings; m_Curves = new Dictionary<SerializedProperty, CurveState>(); } #endregion #region Public API public void Add(params SerializedProperty[] curves) { foreach (var curve in curves) Add(curve, CurveState.defaultState); } public void Add(SerializedProperty curve) { Add(curve, CurveState.defaultState); } public void Add(SerializedProperty curve, CurveState state) { // Make sure the property is in fact an AnimationCurve var animCurve = curve.animationCurveValue; if (animCurve == null) throw new ArgumentException("curve"); if (m_Curves.ContainsKey(curve)) Debug.LogWarning("Curve has already been added to the editor"); m_Curves.Add(curve, state); } public void Remove(SerializedProperty curve) { m_Curves.Remove(curve); } public void RemoveAll() { m_Curves.Clear(); } public CurveState GetCurveState(SerializedProperty curve) { CurveState state; if (!m_Curves.TryGetValue(curve, out state)) throw new KeyNotFoundException("curve"); return state; } public void SetCurveState(SerializedProperty curve, CurveState state) { if (!m_Curves.ContainsKey(curve)) throw new KeyNotFoundException("curve"); m_Curves[curve] = state; } public Selection GetSelection() { Keyframe? key = null; if (m_SelectedKeyframeIndex > -1) { var curve = m_SelectedCurve.animationCurveValue; if (m_SelectedKeyframeIndex >= curve.length) m_SelectedKeyframeIndex = -1; else key = curve[m_SelectedKeyframeIndex]; } return new Selection(m_SelectedCurve, m_SelectedKeyframeIndex, key); } public void SetKeyframe(SerializedProperty curve, int keyframeIndex, Keyframe keyframe) { var animCurve = curve.animationCurveValue; SetKeyframe(animCurve, keyframeIndex, keyframe); SaveCurve(curve, animCurve); } public bool OnGUI(Rect rect) { if (Event.current.type == EventType.Repaint) m_Dirty = false; GUI.BeginClip(rect); { var area = new Rect(Vector2.zero, rect.size); m_CurveArea = settings.padding.Remove(area); foreach (var curve in m_Curves) OnCurveGUI(area, curve.Key, curve.Value); OnGeneralUI(area); } GUI.EndClip(); return m_Dirty; } #endregion #region UI & events void OnCurveGUI(Rect rect, SerializedProperty curve, CurveState state) { // Discard invisible curves if (!state.visible) return; var animCurve = curve.animationCurveValue; var keys = animCurve.keys; var length = keys.Length; // Curve drawing // Slightly dim non-editable curves var color = state.color; if (!state.editable || !GUI.enabled) color.a *= 0.5f; Handles.color = color; var bounds = settings.bounds; if (length == 0) { var p1 = CurveToCanvas(new Vector3(bounds.xMin, state.zeroKeyConstantValue)); var p2 = CurveToCanvas(new Vector3(bounds.xMax, state.zeroKeyConstantValue)); Handles.DrawAAPolyLine(state.width, p1, p2); } else if (length == 1) { var p1 = CurveToCanvas(new Vector3(bounds.xMin, keys[0].value)); var p2 = CurveToCanvas(new Vector3(bounds.xMax, keys[0].value)); Handles.DrawAAPolyLine(state.width, p1, p2); } else { var prevKey = keys[0]; for (int k = 1; k < length; k++) { var key = keys[k]; var pts = BezierSegment(prevKey, key); if (float.IsInfinity(prevKey.outTangent) || float.IsInfinity(key.inTangent)) { var s = HardSegment(prevKey, key); Handles.DrawAAPolyLine(state.width, s[0], s[1], s[2]); } else Handles.DrawBezier(pts[0], pts[3], pts[1], pts[2], color, null, state.width); prevKey = key; } // Curve extents & loops if (keys[0].time > bounds.xMin) { if (state.loopInBounds) { var p1 = keys[length - 1]; p1.time -= settings.bounds.width; var p2 = keys[0]; var pts = BezierSegment(p1, p2); if (float.IsInfinity(p1.outTangent) || float.IsInfinity(p2.inTangent)) { var s = HardSegment(p1, p2); Handles.DrawAAPolyLine(state.width, s[0], s[1], s[2]); } else Handles.DrawBezier(pts[0], pts[3], pts[1], pts[2], color, null, state.width); } else { var p1 = CurveToCanvas(new Vector3(bounds.xMin, keys[0].value)); var p2 = CurveToCanvas(keys[0]); Handles.DrawAAPolyLine(state.width, p1, p2); } } if (keys[length - 1].time < bounds.xMax) { if (state.loopInBounds) { var p1 = keys[length - 1]; var p2 = keys[0]; p2.time += settings.bounds.width; var pts = BezierSegment(p1, p2); if (float.IsInfinity(p1.outTangent) || float.IsInfinity(p2.inTangent)) { var s = HardSegment(p1, p2); Handles.DrawAAPolyLine(state.width, s[0], s[1], s[2]); } else Handles.DrawBezier(pts[0], pts[3], pts[1], pts[2], color, null, state.width); } else { var p1 = CurveToCanvas(keys[length - 1]); var p2 = CurveToCanvas(new Vector3(bounds.xMax, keys[length - 1].value)); Handles.DrawAAPolyLine(state.width, p1, p2); } } } // Make sure selection is correct (undo can break it) bool isCurrentlySelectedCurve = curve == m_SelectedCurve; if (isCurrentlySelectedCurve && m_SelectedKeyframeIndex >= length) m_SelectedKeyframeIndex = -1; if (!state.editable) m_SelectedKeyframeIndex = -1; float enabledFactor = GUI.enabled ? 1f : 0.8f; // Handles & keys for (int k = 0; k < length; k++) { bool isCurrentlySelectedKeyframe = k == m_SelectedKeyframeIndex; var e = Event.current; var pos = CurveToCanvas(keys[k]); var hitRect = new Rect(pos.x - 8f, pos.y - 8f, 16f, 16f); var offset = isCurrentlySelectedCurve ? new RectOffset(5, 5, 5, 5) : new RectOffset(6, 6, 6, 6); var outTangent = pos + CurveTangentToCanvas(keys[k].outTangent).normalized * 40f; var inTangent = pos - CurveTangentToCanvas(keys[k].inTangent).normalized * 40f; var inTangentHitRect = new Rect(inTangent.x - 7f, inTangent.y - 7f, 14f, 14f); var outTangentHitrect = new Rect(outTangent.x - 7f, outTangent.y - 7f, 14f, 14f); // Draw if (state.editable || state.showNonEditableHandles) { if (e.type == EventType.Repaint) { var selectedColor = (isCurrentlySelectedCurve && isCurrentlySelectedKeyframe) ? settings.selectionColor : state.color; // Keyframe EditorGUI.DrawRect(offset.Remove(hitRect), selectedColor * enabledFactor); // Tangents if (isCurrentlySelectedCurve && (!state.onlyShowHandlesOnSelection || (state.onlyShowHandlesOnSelection && isCurrentlySelectedKeyframe))) { Handles.color = selectedColor * enabledFactor; if (k > 0 || state.loopInBounds) { Handles.DrawAAPolyLine(state.handleWidth, pos, inTangent); EditorGUI.DrawRect(offset.Remove(inTangentHitRect), selectedColor); } if (k < length - 1 || state.loopInBounds) { Handles.DrawAAPolyLine(state.handleWidth, pos, outTangent); EditorGUI.DrawRect(offset.Remove(outTangentHitrect), selectedColor); } } } } // Events if (state.editable) { // Keyframe move if (m_EditMode == EditMode.Moving && e.type == EventType.MouseDrag && isCurrentlySelectedCurve && isCurrentlySelectedKeyframe) { EditMoveKeyframe(animCurve, keys, k); } // Tangent editing if (m_EditMode == EditMode.TangentEdit && e.type == EventType.MouseDrag && isCurrentlySelectedCurve && isCurrentlySelectedKeyframe) { bool alreadyBroken = !(Mathf.Approximately(keys[k].inTangent, keys[k].outTangent) || (float.IsInfinity(keys[k].inTangent) && float.IsInfinity(keys[k].outTangent))); EditMoveTangent(animCurve, keys, k, m_TangentEditMode, e.shift || !(alreadyBroken || e.control)); } // Keyframe selection & context menu if (e.type == EventType.MouseDown && rect.Contains(e.mousePosition)) { if (hitRect.Contains(e.mousePosition)) { if (e.button == 0) { SelectKeyframe(curve, k); m_EditMode = EditMode.Moving; e.Use(); } else if (e.button == 1) { // Keyframe context menu var menu = new GenericMenu(); menu.AddItem(new GUIContent("Delete Key"), false, (x) => { var action = (MenuAction)x; var curveValue = action.curve.animationCurveValue; action.curve.serializedObject.Update(); RemoveKeyframe(curveValue, action.index); m_SelectedKeyframeIndex = -1; SaveCurve(action.curve, curveValue); action.curve.serializedObject.ApplyModifiedProperties(); }, new MenuAction(curve, k)); menu.ShowAsContext(); e.Use(); } } } // Tangent selection & edit mode if (e.type == EventType.MouseDown && rect.Contains(e.mousePosition)) { if (inTangentHitRect.Contains(e.mousePosition) && (k > 0 || state.loopInBounds)) { SelectKeyframe(curve, k); m_EditMode = EditMode.TangentEdit; m_TangentEditMode = Tangent.In; e.Use(); } else if (outTangentHitrect.Contains(e.mousePosition) && (k < length - 1 || state.loopInBounds)) { SelectKeyframe(curve, k); m_EditMode = EditMode.TangentEdit; m_TangentEditMode = Tangent.Out; e.Use(); } } // Mouse up - clean up states if (e.rawType == EventType.MouseUp && m_EditMode != EditMode.None) { m_EditMode = EditMode.None; } // Set cursors { EditorGUIUtility.AddCursorRect(hitRect, MouseCursor.MoveArrow); if (k > 0 || state.loopInBounds) EditorGUIUtility.AddCursorRect(inTangentHitRect, MouseCursor.RotateArrow); if (k < length - 1 || state.loopInBounds) EditorGUIUtility.AddCursorRect(outTangentHitrect, MouseCursor.RotateArrow); } } } Handles.color = Color.white; SaveCurve(curve, animCurve); } void OnGeneralUI(Rect rect) { var e = Event.current; // Selection if (e.type == EventType.MouseDown) { GUI.FocusControl(null); m_SelectedCurve = null; m_SelectedKeyframeIndex = -1; bool used = false; var hit = CanvasToCurve(e.mousePosition); float curvePickValue = CurveToCanvas(hit).y; // Try and select a curve foreach (var curve in m_Curves) { if (!curve.Value.editable || !curve.Value.visible) continue; var prop = curve.Key; var state = curve.Value; var animCurve = prop.animationCurveValue; float hitY = animCurve.length == 0 ? state.zeroKeyConstantValue : animCurve.Evaluate(hit.x); var curvePos = CurveToCanvas(new Vector3(hit.x, hitY)); if (Mathf.Abs(curvePos.y - curvePickValue) < settings.curvePickingDistance) { m_SelectedCurve = prop; if (e.clickCount == 2 && e.button == 0) { // Create a keyframe on double-click on this curve EditCreateKeyframe(animCurve, hit, true, state.zeroKeyConstantValue); SaveCurve(prop, animCurve); } else if (e.button == 1) { // Curve context menu var menu = new GenericMenu(); menu.AddItem(new GUIContent("Add Key"), false, (x) => { var action = (MenuAction)x; var curveValue = action.curve.animationCurveValue; action.curve.serializedObject.Update(); EditCreateKeyframe(curveValue, hit, true, 0f); SaveCurve(action.curve, curveValue); action.curve.serializedObject.ApplyModifiedProperties(); }, new MenuAction(prop, hit)); menu.ShowAsContext(); e.Use(); used = true; } } } if (e.clickCount == 2 && e.button == 0 && m_SelectedCurve == null) { // Create a keyframe on every curve on double-click foreach (var curve in m_Curves) { if (!curve.Value.editable || !curve.Value.visible) continue; var prop = curve.Key; var state = curve.Value; var animCurve = prop.animationCurveValue; EditCreateKeyframe(animCurve, hit, e.alt, state.zeroKeyConstantValue); SaveCurve(prop, animCurve); } } else if (!used && e.button == 1) { // Global context menu var menu = new GenericMenu(); menu.AddItem(new GUIContent("Add Key At Position"), false, () => ContextMenuAddKey(hit, false)); menu.AddItem(new GUIContent("Add Key On Curves"), false, () => ContextMenuAddKey(hit, true)); menu.ShowAsContext(); } e.Use(); } // Delete selected key(s) if (e.type == EventType.KeyDown && (e.keyCode == KeyCode.Delete || e.keyCode == KeyCode.Backspace)) { if (m_SelectedKeyframeIndex != -1 && m_SelectedCurve != null) { var animCurve = m_SelectedCurve.animationCurveValue; var length = animCurve.length; if (m_Curves[m_SelectedCurve].minPointCount < length && length >= 0) { EditDeleteKeyframe(animCurve, m_SelectedKeyframeIndex); m_SelectedKeyframeIndex = -1; SaveCurve(m_SelectedCurve, animCurve); } e.Use(); } } } void SaveCurve(SerializedProperty prop, AnimationCurve curve) { prop.animationCurveValue = curve; } void Invalidate() { m_Dirty = true; } #endregion #region Keyframe manipulations void SelectKeyframe(SerializedProperty curve, int keyframeIndex) { m_SelectedKeyframeIndex = keyframeIndex; m_SelectedCurve = curve; Invalidate(); } void ContextMenuAddKey(Vector3 hit, bool createOnCurve) { SerializedObject serializedObject = null; foreach (var curve in m_Curves) { if (!curve.Value.editable || !curve.Value.visible) continue; var prop = curve.Key; var state = curve.Value; if (serializedObject == null) { serializedObject = prop.serializedObject; serializedObject.Update(); } var animCurve = prop.animationCurveValue; EditCreateKeyframe(animCurve, hit, createOnCurve, state.zeroKeyConstantValue); SaveCurve(prop, animCurve); } if (serializedObject != null) serializedObject.ApplyModifiedProperties(); Invalidate(); } void EditCreateKeyframe(AnimationCurve curve, Vector3 position, bool createOnCurve, float zeroKeyConstantValue) { float tangent = EvaluateTangent(curve, position.x); if (createOnCurve) { position.y = curve.length == 0 ? zeroKeyConstantValue : curve.Evaluate(position.x); } AddKeyframe(curve, new Keyframe(position.x, position.y, tangent, tangent)); } void EditDeleteKeyframe(AnimationCurve curve, int keyframeIndex) { RemoveKeyframe(curve, keyframeIndex); } void AddKeyframe(AnimationCurve curve, Keyframe newValue) { curve.AddKey(newValue); Invalidate(); } void RemoveKeyframe(AnimationCurve curve, int keyframeIndex) { curve.RemoveKey(keyframeIndex); Invalidate(); } void SetKeyframe(AnimationCurve curve, int keyframeIndex, Keyframe newValue) { var keys = curve.keys; if (keyframeIndex > 0) newValue.time = Mathf.Max(keys[keyframeIndex - 1].time + settings.keyTimeClampingDistance, newValue.time); if (keyframeIndex < keys.Length - 1) newValue.time = Mathf.Min(keys[keyframeIndex + 1].time - settings.keyTimeClampingDistance, newValue.time); curve.MoveKey(keyframeIndex, newValue); Invalidate(); } void EditMoveKeyframe(AnimationCurve curve, Keyframe[] keys, int keyframeIndex) { var key = CanvasToCurve(Event.current.mousePosition); float inTgt = keys[keyframeIndex].inTangent; float outTgt = keys[keyframeIndex].outTangent; SetKeyframe(curve, keyframeIndex, new Keyframe(key.x, key.y, inTgt, outTgt)); } void EditMoveTangent(AnimationCurve curve, Keyframe[] keys, int keyframeIndex, Tangent targetTangent, bool linkTangents) { var pos = CanvasToCurve(Event.current.mousePosition); float time = keys[keyframeIndex].time; float value = keys[keyframeIndex].value; pos -= new Vector3(time, value); if (targetTangent == Tangent.In && pos.x > 0f) pos.x = 0f; if (targetTangent == Tangent.Out && pos.x < 0f) pos.x = 0f; float tangent; if (Mathf.Approximately(pos.x, 0f)) tangent = pos.y < 0f ? float.PositiveInfinity : float.NegativeInfinity; else tangent = pos.y / pos.x; float inTangent = keys[keyframeIndex].inTangent; float outTangent = keys[keyframeIndex].outTangent; if (targetTangent == Tangent.In || linkTangents) inTangent = tangent; if (targetTangent == Tangent.Out || linkTangents) outTangent = tangent; SetKeyframe(curve, keyframeIndex, new Keyframe(time, value, inTangent, outTangent)); } #endregion #region Maths utilities Vector3 CurveToCanvas(Keyframe keyframe) { return CurveToCanvas(new Vector3(keyframe.time, keyframe.value)); } Vector3 CurveToCanvas(Vector3 position) { var bounds = settings.bounds; var output = new Vector3((position.x - bounds.x) / (bounds.xMax - bounds.x), (position.y - bounds.y) / (bounds.yMax - bounds.y)); output.x = output.x * (m_CurveArea.xMax - m_CurveArea.xMin) + m_CurveArea.xMin; output.y = (1f - output.y) * (m_CurveArea.yMax - m_CurveArea.yMin) + m_CurveArea.yMin; return output; } Vector3 CanvasToCurve(Vector3 position) { var bounds = settings.bounds; var output = position; output.x = (output.x - m_CurveArea.xMin) / (m_CurveArea.xMax - m_CurveArea.xMin); output.y = (output.y - m_CurveArea.yMin) / (m_CurveArea.yMax - m_CurveArea.yMin); output.x = Mathf.Lerp(bounds.x, bounds.xMax, output.x); output.y = Mathf.Lerp(bounds.yMax, bounds.y, output.y); return output; } Vector3 CurveTangentToCanvas(float tangent) { if (!float.IsInfinity(tangent)) { var bounds = settings.bounds; float ratio = (m_CurveArea.width / m_CurveArea.height) / ((bounds.xMax - bounds.x) / (bounds.yMax - bounds.y)); return new Vector3(1f, -tangent / ratio).normalized; } return float.IsPositiveInfinity(tangent) ? Vector3.up : Vector3.down; } Vector3[] BezierSegment(Keyframe start, Keyframe end) { var segment = new Vector3[4]; segment[0] = CurveToCanvas(new Vector3(start.time, start.value)); segment[3] = CurveToCanvas(new Vector3(end.time, end.value)); float middle = start.time + ((end.time - start.time) * 0.333333f); float middle2 = start.time + ((end.time - start.time) * 0.666666f); segment[1] = CurveToCanvas(new Vector3(middle, ProjectTangent(start.time, start.value, start.outTangent, middle))); segment[2] = CurveToCanvas(new Vector3(middle2, ProjectTangent(end.time, end.value, end.inTangent, middle2))); return segment; } Vector3[] HardSegment(Keyframe start, Keyframe end) { var segment = new Vector3[3]; segment[0] = CurveToCanvas(start); segment[1] = CurveToCanvas(new Vector3(end.time, start.value)); segment[2] = CurveToCanvas(end); return segment; } float ProjectTangent(float inPosition, float inValue, float inTangent, float projPosition) { return inValue + ((projPosition - inPosition) * inTangent); } float EvaluateTangent(AnimationCurve curve, float time) { int prev = -1, next = 0; for (int i = 0; i < curve.keys.Length; i++) { if (time > curve.keys[i].time) { prev = i; next = i + 1; } else break; } if (next == 0) return 0f; if (prev == curve.keys.Length - 1) return 0f; const float kD = 1e-3f; float tp = Mathf.Max(time - kD, curve.keys[prev].time); float tn = Mathf.Min(time + kD, curve.keys[next].time); float vp = curve.Evaluate(tp); float vn = curve.Evaluate(tn); if (Mathf.Approximately(tn, tp)) return (vn - vp > 0f) ? float.PositiveInfinity : float.NegativeInfinity; return (vn - vp) / (tn - tp); } #endregion } }

File no 55: /colame/Assets/SineVFX/PostProcessingV2/Editor/Utils/EditorUtilities.cs
using System; using System.Collections.Generic; using System.Linq; using UnityEngine; using UnityEngine.Assertions; using UnityEngine.Rendering.PostProcessing; namespace UnityEditor.Rendering.PostProcessing { /// <summary> /// A set of editor utilities used in post-processing editors. /// </summary> public static class EditorUtilities { static Dictionary<string, GUIContent> s_GUIContentCache; static Dictionary<Type, AttributeDecorator> s_AttributeDecorators; static PostProcessEffectSettings s_ClipboardContent; /// <summary> /// Returns <c>true</c> if the current target is a console, <c>false</c> otherwise. /// </summary> public static bool isTargetingConsoles { get { var t = EditorUserBuildSettings.activeBuildTarget; return t == BuildTarget.PS4 || t == BuildTarget.XboxOne || t == BuildTarget.Switch; } } /// <summary> /// Returns <c>true</c> if the current target is a mobile, <c>false</c> otherwise. /// </summary> public static bool isTargetingMobiles { get { var t = EditorUserBuildSettings.activeBuildTarget; return t == BuildTarget.Android || t == BuildTarget.iOS || t == BuildTarget.tvOS #if !UNITY_2018_2_OR_NEWER || t == BuildTarget.Tizen #endif #if !UNITY_2018_3_OR_NEWER || t == BuildTarget.N3DS || t == BuildTarget.PSP2 #endif ; } } /// <summary> /// Returns <c>true</c> if the current target is a console or a mobile, <c>false</c> /// otherwise. /// </summary> public static bool isTargetingConsolesOrMobiles { get { return isTargetingConsoles || isTargetingMobiles; } } static EditorUtilities() { s_GUIContentCache = new Dictionary<string, GUIContent>(); s_AttributeDecorators = new Dictionary<Type, AttributeDecorator>(); ReloadDecoratorTypes(); } [Callbacks.DidReloadScripts] static void OnEditorReload() { ReloadDecoratorTypes(); } static void ReloadDecoratorTypes() { s_AttributeDecorators.Clear(); // Look for all the valid attribute decorators var types = RuntimeUtilities.GetAllAssemblyTypes() .Where( t => t.IsSubclassOf(typeof(AttributeDecorator)) && t.IsDefined(typeof(DecoratorAttribute), false) && !t.IsAbstract ); // Store them foreach (var type in types) { var attr = type.GetAttribute<DecoratorAttribute>(); var decorator = (AttributeDecorator)Activator.CreateInstance(type); s_AttributeDecorators.Add(attr.attributeType, decorator); } } internal static AttributeDecorator GetDecorator(Type attributeType) { AttributeDecorator decorator; return !s_AttributeDecorators.TryGetValue(attributeType, out decorator) ? null : decorator; } /// <summary> /// Gets a <see cref="GUIContent"/> for the given label and tooltip. These are recycled /// internally and help reduce the garbage collector pressure in the editor. /// </summary> /// <param name="textAndTooltip">The label and tooltip separated by a <c>|</c> /// character</param> /// <returns>A recycled <see cref="GUIContent"/></returns> public static GUIContent GetContent(string textAndTooltip) { if (string.IsNullOrEmpty(textAndTooltip)) return GUIContent.none; GUIContent content; if (!s_GUIContentCache.TryGetValue(textAndTooltip, out content)) { var s = textAndTooltip.Split('|'); content = new GUIContent(s[0]); if (s.Length > 1 && !string.IsNullOrEmpty(s[1])) content.tooltip = s[1]; s_GUIContentCache.Add(textAndTooltip, content); } return content; } /// <summary> /// Draws a UI box with a description and a "Fix Me" button next to it. /// </summary> /// <param name="text">The description</param> /// <param name="action">The action to execute when the button is clicked</param> public static void DrawFixMeBox(string text, Action action) { Assert.IsNotNull(action); EditorGUILayout.HelpBox(text, MessageType.Warning); GUILayout.Space(-32); using (new EditorGUILayout.HorizontalScope()) { GUILayout.FlexibleSpace(); if (GUILayout.Button("Fix", GUILayout.Width(60))) action(); GUILayout.Space(8); } GUILayout.Space(11); } /// <summary> /// Draws a horizontal split line. /// </summary> public static void DrawSplitter() { var rect = GUILayoutUtility.GetRect(1f, 1f); // Splitter rect should be full-width rect.xMin = 0f; rect.width += 4f; if (Event.current.type != EventType.Repaint) return; EditorGUI.DrawRect(rect, Styling.splitter); } /// <summary> /// Draws a toggle using the "override checkbox" style. /// </summary> /// <param name="rect">The position and size of the toggle</param> /// <param name="property">The override state property for the toggle</param> public static void DrawOverrideCheckbox(Rect rect, SerializedProperty property) { property.boolValue = GUI.Toggle(rect, property.boolValue, GetContent("|Override this setting for this volume."), Styling.smallTickbox); } /// <summary> /// Draws a header label. /// </summary> /// <param name="title">The label to display as a header</param> public static void DrawHeaderLabel(string title) { EditorGUILayout.LabelField(title, Styling.headerLabel); } internal static bool DrawHeader(string title, bool state) { var backgroundRect = GUILayoutUtility.GetRect(1f, 17f); var labelRect = backgroundRect; labelRect.xMin += 16f; labelRect.xMax -= 20f; var foldoutRect = backgroundRect; foldoutRect.y += 1f; foldoutRect.width = 13f; foldoutRect.height = 13f; // Background rect should be full-width backgroundRect.xMin = 0f; backgroundRect.width += 4f; // Background EditorGUI.DrawRect(backgroundRect, Styling.headerBackground); // Title EditorGUI.LabelField(labelRect, GetContent(title), EditorStyles.boldLabel); // Foldout state = GUI.Toggle(foldoutRect, state, GUIContent.none, EditorStyles.foldout); var e = Event.current; if (e.type == EventType.MouseDown && backgroundRect.Contains(e.mousePosition) && e.button == 0) { state = !state; e.Use(); } return state; } internal static bool DrawHeader(string title, SerializedProperty group, SerializedProperty activeField, PostProcessEffectSettings target, Action resetAction, Action removeAction) { Assert.IsNotNull(group); Assert.IsNotNull(activeField); Assert.IsNotNull(target); var backgroundRect = GUILayoutUtility.GetRect(1f, 17f); var labelRect = backgroundRect; labelRect.xMin += 32f; labelRect.xMax -= 20f; var foldoutRect = backgroundRect; foldoutRect.y += 1f; foldoutRect.width = 13f; foldoutRect.height = 13f; var toggleRect = backgroundRect; toggleRect.x += 16f; toggleRect.y += 2f; toggleRect.width = 13f; toggleRect.height = 13f; var menuIcon = Styling.paneOptionsIcon; var menuRect = new Rect(labelRect.xMax + 4f, labelRect.y + 4f, menuIcon.width, menuIcon.height); // Background rect should be full-width backgroundRect.xMin = 0f; backgroundRect.width += 4f; // Background EditorGUI.DrawRect(backgroundRect, Styling.headerBackground); // Title using (new EditorGUI.DisabledScope(!activeField.boolValue)) EditorGUI.LabelField(labelRect, GetContent(title), EditorStyles.boldLabel); // foldout group.serializedObject.Update(); group.isExpanded = GUI.Toggle(foldoutRect, group.isExpanded, GUIContent.none, EditorStyles.foldout); group.serializedObject.ApplyModifiedProperties(); // Active checkbox activeField.serializedObject.Update(); activeField.boolValue = GUI.Toggle(toggleRect, activeField.boolValue, GUIContent.none, Styling.smallTickbox); activeField.serializedObject.ApplyModifiedProperties(); // Dropdown menu icon GUI.DrawTexture(menuRect, menuIcon); // Handle events var e = Event.current; if (e.type == EventType.MouseDown) { if (menuRect.Contains(e.mousePosition)) { ShowHeaderContextMenu(new Vector2(menuRect.x, menuRect.yMax), target, resetAction, removeAction); e.Use(); } else if (labelRect.Contains(e.mousePosition)) { if (e.button == 0) group.isExpanded = !group.isExpanded; else ShowHeaderContextMenu(e.mousePosition, target, resetAction, removeAction); e.Use(); } } return group.isExpanded; } static void ShowHeaderContextMenu(Vector2 position, PostProcessEffectSettings target, Action resetAction, Action removeAction) { Assert.IsNotNull(resetAction); Assert.IsNotNull(removeAction); var menu = new GenericMenu(); menu.AddItem(GetContent("Reset"), false, () => resetAction()); menu.AddItem(GetContent("Remove"), false, () => removeAction()); menu.AddSeparator(string.Empty); menu.AddItem(GetContent("Copy Settings"), false, () => CopySettings(target)); if (CanPaste(target)) menu.AddItem(GetContent("Paste Settings"), false, () => PasteSettings(target)); else menu.AddDisabledItem(GetContent("Paste Settings")); menu.DropDown(new Rect(position, Vector2.zero)); } static void CopySettings(PostProcessEffectSettings target) { Assert.IsNotNull(target); if (s_ClipboardContent != null) { RuntimeUtilities.Destroy(s_ClipboardContent); s_ClipboardContent = null; } s_ClipboardContent = (PostProcessEffectSettings)ScriptableObject.CreateInstance(target.GetType()); EditorUtility.CopySerializedIfDifferent(target, s_ClipboardContent); } static void PasteSettings(PostProcessEffectSettings target) { Assert.IsNotNull(target); Assert.IsNotNull(s_ClipboardContent); Assert.AreEqual(s_ClipboardContent.GetType(), target.GetType()); Undo.RecordObject(target, "Paste Settings"); EditorUtility.CopySerializedIfDifferent(s_ClipboardContent, target); } static bool CanPaste(PostProcessEffectSettings target) { return s_ClipboardContent != null && s_ClipboardContent.GetType() == target.GetType(); } } }

File no 56: /colame/Assets/SineVFX/PostProcessingV2/Editor/Utils/GlobalSettings.cs
using UnityEngine; using UnityEngine.Rendering.PostProcessing; namespace UnityEditor.Rendering.PostProcessing { static class GlobalSettings { static class Keys { internal const string trackballSensitivity = "PostProcessing.Trackball.Sensitivity"; internal const string volumeGizmoColor = "PostProcessing.Volume.GizmoColor"; internal const string currentChannelMixer = "PostProcessing.ChannelMixer.CurrentChannel"; internal const string currentCurve = "PostProcessing.Curve.Current"; } static bool m_Loaded = false; static float m_TrackballSensitivity = 0.2f; internal static float trackballSensitivity { get { return m_TrackballSensitivity; } set { TrySave(ref m_TrackballSensitivity, value, Keys.trackballSensitivity); } } static Color m_VolumeGizmoColor = new Color(0.2f, 0.8f, 0.1f, 0.5f); internal static Color volumeGizmoColor { get { return m_VolumeGizmoColor; } set { TrySave(ref m_VolumeGizmoColor, value, Keys.volumeGizmoColor); } } static int m_CurrentChannelMixer = 0; internal static int currentChannelMixer { get { return m_CurrentChannelMixer; } set { TrySave(ref m_CurrentChannelMixer, value, Keys.currentChannelMixer); } } static int m_CurrentCurve = 0; internal static int currentCurve { get { return m_CurrentCurve; } set { TrySave(ref m_CurrentCurve, value, Keys.currentCurve); } } static GlobalSettings() { Load(); } #if UNITY_2018_3_OR_NEWER [SettingsProvider] static SettingsProvider PreferenceGUI() { return new SettingsProvider("Preferences/Post-processing", SettingsScope.User) { guiHandler = searchContext => OpenGUI() }; } #else [PreferenceItem("Post-processing")] static void PreferenceGUI() { OpenGUI(); } #endif static void OpenGUI() { if (!m_Loaded) Load(); EditorGUILayout.Space(); trackballSensitivity = EditorGUILayout.Slider("Trackballs Sensitivity", trackballSensitivity, 0.05f, 1f); volumeGizmoColor = EditorGUILayout.ColorField("Volume Gizmo Color", volumeGizmoColor); } static void Load() { m_TrackballSensitivity = EditorPrefs.GetFloat(Keys.trackballSensitivity, 0.2f); m_VolumeGizmoColor = GetColor(Keys.volumeGizmoColor, new Color(0.2f, 0.8f, 0.1f, 0.5f)); m_CurrentChannelMixer = EditorPrefs.GetInt(Keys.currentChannelMixer, 0); m_CurrentCurve = EditorPrefs.GetInt(Keys.currentCurve, 0); m_Loaded = true; } static Color GetColor(string key, Color defaultValue) { int value = EditorPrefs.GetInt(key, (int)ColorUtilities.ToHex(defaultValue)); return ColorUtilities.ToRGBA((uint)value); } static void TrySave<T>(ref T field, T newValue, string key) { if (field.Equals(newValue)) return; if (typeof(T) == typeof(float)) EditorPrefs.SetFloat(key, (float)(object)newValue); else if (typeof(T) == typeof(int)) EditorPrefs.SetInt(key, (int)(object)newValue); else if (typeof(T) == typeof(bool)) EditorPrefs.SetBool(key, (bool)(object)newValue); else if (typeof(T) == typeof(string)) EditorPrefs.SetString(key, (string)(object)newValue); else if (typeof(T) == typeof(Color)) EditorPrefs.SetInt(key, (int)ColorUtilities.ToHex((Color)(object)newValue)); field = newValue; } } }

File no 57: /colame/Assets/SineVFX/PostProcessingV2/Editor/Utils/PostProcessShaderIncludePath.cs
﻿using System.Linq; using UnityEngine; using System.IO; namespace UnityEditor.Experimental.Rendering { static class PostProcessShaderIncludePath { #if UNITY_2018_1_OR_NEWER && !UNITY_2018_3_OR_NEWER [ShaderIncludePath] #endif public static string[] GetPaths() { var srpMarker = Directory.GetFiles(Application.dataPath, "POSTFXMARKER", SearchOption.AllDirectories).FirstOrDefault(); var paths = new string[srpMarker == null ? 1 : 2]; var index = 0; if (srpMarker != null) { paths[index] = Directory.GetParent(srpMarker).ToString(); index++; } paths[index] = Path.GetFullPath("Packages/com.unity.postprocessing"); return paths; } } }

File no 58: /colame/Assets/SineVFX/PostProcessingV2/Editor/Utils/SerializedParameterOverride.cs
using System; using System.Linq; using UnityEngine.Rendering.PostProcessing; namespace UnityEditor.Rendering.PostProcessing { /// <summary> /// A wrapper used for <see cref="ParameterOverride{T}"/> serialization and easy access to the /// underlying property and override state. /// </summary> public sealed class SerializedParameterOverride { /// <summary> /// The override state property of the serialized parameter. /// </summary> public SerializedProperty overrideState { get; private set; } /// <summary> /// The value property of the serialized parameter. /// </summary> public SerializedProperty value { get; private set; } /// <summary> /// An array of all attributes set on the original parameter. /// </summary> public Attribute[] attributes { get; private set; } internal SerializedProperty baseProperty; /// <summary> /// Returns the display name of the property. /// </summary> public string displayName { get { return baseProperty.displayName; } } internal SerializedParameterOverride(SerializedProperty property, Attribute[] attributes) { baseProperty = property.Copy(); var localCopy = baseProperty.Copy(); localCopy.Next(true); overrideState = localCopy.Copy(); localCopy.Next(false); value = localCopy.Copy(); this.attributes = attributes; } /// <summary> /// Gets the attribute of type <c>T</c> from the original parameter. /// </summary> /// <typeparam name="T">The type of attribute to look for</typeparam> /// <returns>And attribute or type <c>T</c>, or <c>null</c> if none has been found</returns> public T GetAttribute<T>() where T : Attribute { return (T)attributes.FirstOrDefault(x => x is T); } } }

File no 59: /colame/Assets/SineVFX/PostProcessingV2/Editor/Utils/Styling.cs
using UnityEngine; using UnityEngine.Rendering.PostProcessing; namespace UnityEditor.Rendering.PostProcessing { /// <summary> /// Common styles used for Post-processing editor controls. /// </summary> public static class Styling { /// <summary> /// Style for the override checkbox. /// </summary> public static readonly GUIStyle smallTickbox; /// <summary> /// Style for the labels in the toolbar of each effect. /// </summary> public static readonly GUIStyle miniLabelButton; static readonly Color splitterDark; static readonly Color splitterLight; /// <summary> /// Color of UI splitters. /// </summary> public static Color splitter { get { return EditorGUIUtility.isProSkin ? splitterDark : splitterLight; } } static readonly Texture2D paneOptionsIconDark; static readonly Texture2D paneOptionsIconLight; /// <summary> /// Option icon used in effect headers. /// </summary> public static Texture2D paneOptionsIcon { get { return EditorGUIUtility.isProSkin ? paneOptionsIconDark : paneOptionsIconLight; } } /// <summary> /// Style for effect header labels. /// </summary> public static readonly GUIStyle headerLabel; static readonly Color headerBackgroundDark; static readonly Color headerBackgroundLight; /// <summary> /// Color of effect header backgrounds. /// </summary> public static Color headerBackground { get { return EditorGUIUtility.isProSkin ? headerBackgroundDark : headerBackgroundLight; } } /// <summary> /// Style for the trackball labels. /// </summary> public static readonly GUIStyle wheelLabel; /// <summary> /// Style for the trackball cursors. /// </summary> public static readonly GUIStyle wheelThumb; /// <summary> /// Size of the trackball cursors. /// </summary> public static readonly Vector2 wheelThumbSize; /// <summary> /// Style for the curve editor position info. /// </summary> public static readonly GUIStyle preLabel; static Styling() { smallTickbox = new GUIStyle("ShurikenToggle"); miniLabelButton = new GUIStyle(EditorStyles.miniLabel); miniLabelButton.normal = new GUIStyleState { background = RuntimeUtilities.transparentTexture, scaledBackgrounds = null, textColor = Color.grey }; var activeState = new GUIStyleState { background = RuntimeUtilities.transparentTexture, scaledBackgrounds = null, textColor = Color.white }; miniLabelButton.active = activeState; miniLabelButton.onNormal = activeState; miniLabelButton.onActive = activeState; splitterDark = new Color(0.12f, 0.12f, 0.12f, 1.333f); splitterLight = new Color(0.6f, 0.6f, 0.6f, 1.333f); headerBackgroundDark = new Color(0.1f, 0.1f, 0.1f, 0.2f); headerBackgroundLight = new Color(1f, 1f, 1f, 0.2f); paneOptionsIconDark = (Texture2D)EditorGUIUtility.Load("Builtin Skins/DarkSkin/Images/pane options.png"); paneOptionsIconLight = (Texture2D)EditorGUIUtility.Load("Builtin Skins/LightSkin/Images/pane options.png"); headerLabel = new GUIStyle(EditorStyles.miniLabel); wheelThumb = new GUIStyle("ColorPicker2DThumb"); wheelThumbSize = new Vector2( !Mathf.Approximately(wheelThumb.fixedWidth, 0f) ? wheelThumb.fixedWidth : wheelThumb.padding.horizontal, !Mathf.Approximately(wheelThumb.fixedHeight, 0f) ? wheelThumb.fixedHeight : wheelThumb.padding.vertical ); wheelLabel = new GUIStyle(EditorStyles.miniLabel); preLabel = new GUIStyle("ShurikenLabel"); } } }

File no 60: /colame/Assets/SineVFX/PostProcessingV2/Editor/BaseEditor.cs
using System; using System.Linq.Expressions; using UnityEngine; using UnityEngine.Rendering.PostProcessing; namespace UnityEditor.Rendering.PostProcessing { /// <summary> /// Small wrapper on top of <see cref="Editor"/> to ease the access of the underlying component /// and its serialized fields. /// </summary> /// <typeparam name="T">The type of the target component to make an editor for</typeparam> /// <example> /// <code> /// public class MyMonoBehaviour : MonoBehaviour /// { /// public float myProperty = 1.0f; /// } /// /// [CustomEditor(typeof(MyMonoBehaviour))] /// public sealed class MyMonoBehaviourEditor : BaseEditor&lt;MyMonoBehaviour&gt; /// { /// SerializedProperty m_MyProperty; /// /// void OnEnable() /// { /// m_MyProperty = FindProperty(x => x.myProperty); /// } /// /// public override void OnInspectorGUI() /// { /// EditorGUILayout.PropertyField(m_MyProperty); /// } /// } /// </code> /// </example> public class BaseEditor<T> : Editor where T : MonoBehaviour { /// <summary> /// The target component. /// </summary> protected T m_Target { get { return (T)target; } } /// <summary> /// /// </summary> /// <typeparam name="TValue"></typeparam> /// <param name="expr"></param> /// <returns></returns> protected SerializedProperty FindProperty<TValue>(Expression<Func<T, TValue>> expr) { return serializedObject.FindProperty(RuntimeUtilities.GetFieldPath(expr)); } } }

File no 61: /colame/Assets/SineVFX/PostProcessingV2/Editor/EffectListEditor.cs
using System; using System.Collections.Generic; using System.Linq; using UnityEngine; using UnityEngine.Assertions; using UnityEngine.Rendering.PostProcessing; namespace UnityEditor.Rendering.PostProcessing { /// <summary> /// This class is used to draw the user interface in the inspector for all the settings /// contained in a <see cref="PostProcessProfile"/>. /// </summary> public sealed class EffectListEditor { /// <summary> /// A reference to the <see cref="PostProcessProfile"/> being displayed by this editor. /// </summary> public PostProcessProfile asset { get; private set; } Editor m_BaseEditor; SerializedObject m_SerializedObject; SerializedProperty m_SettingsProperty; Dictionary<Type, Type> m_EditorTypes; // SettingsType => EditorType List<PostProcessEffectBaseEditor> m_Editors; /// <summary> /// Creates a new instance to be used inside an existing <see cref="Editor"/>. /// </summary> /// <param name="editor">A reference to the parent editor instance.</param> public EffectListEditor(Editor editor) { Assert.IsNotNull(editor); m_BaseEditor = editor; } /// <summary> /// Initializes the editor. This method should be called before <see cref="OnGUI"/> is /// called. /// </summary> /// <param name="asset">A reference to the <see cref="PostProcessProfile"/> that will be /// displayed.</param> /// <param name="serializedObject">A <see cref="SerializedObject"/> of the given <paramref /// name="asset"/> instance.</param> public void Init(PostProcessProfile asset, SerializedObject serializedObject) { Assert.IsNotNull(asset); Assert.IsNotNull(serializedObject); this.asset = asset; m_SerializedObject = serializedObject; m_SettingsProperty = serializedObject.FindProperty("settings"); Assert.IsNotNull(m_SettingsProperty); m_EditorTypes = new Dictionary<Type, Type>(); m_Editors = new List<PostProcessEffectBaseEditor>(); // Gets the list of all available postfx editors var editorTypes = RuntimeUtilities.GetAllAssemblyTypes() .Where( t => t.IsSubclassOf(typeof(PostProcessEffectBaseEditor)) && t.IsDefined(typeof(PostProcessEditorAttribute), false) && !t.IsAbstract ); // Map them to their corresponding settings type foreach (var editorType in editorTypes) { var attribute = editorType.GetAttribute<PostProcessEditorAttribute>(); m_EditorTypes.Add(attribute.settingsType, editorType); } // Create editors for existing settings for (int i = 0; i < this.asset.settings.Count; i++) CreateEditor(this.asset.settings[i], m_SettingsProperty.GetArrayElementAtIndex(i)); // Keep track of undo/redo to redraw the inspector when that happens Undo.undoRedoPerformed += OnUndoRedoPerformed; } void OnUndoRedoPerformed() { asset.isDirty = true; // Dumb hack to make sure the serialized object is up to date on undo (else there'll be // a state mismatch when this class is used in a GameObject inspector). m_SerializedObject.Update(); m_SerializedObject.ApplyModifiedProperties(); // Seems like there's an issue with the inspector not repainting after some undo events // This will take care of that m_BaseEditor.Repaint(); } void CreateEditor(PostProcessEffectSettings settings, SerializedProperty property, int index = -1) { var settingsType = settings.GetType(); Type editorType; if (!m_EditorTypes.TryGetValue(settingsType, out editorType)) editorType = typeof(DefaultPostProcessEffectEditor); var editor = (PostProcessEffectBaseEditor)Activator.CreateInstance(editorType); editor.Init(settings, m_BaseEditor); editor.baseProperty = property.Copy(); if (index < 0) m_Editors.Add(editor); else m_Editors[index] = editor; } // Clears & recreate all editors - mainly used when the volume has been modified outside of // the editor (user scripts, inspector reset etc). void RefreshEditors() { // Disable all editors first foreach (var editor in m_Editors) editor.OnDisable(); // Remove them m_Editors.Clear(); // Recreate editors for existing settings, if any for (int i = 0; i < asset.settings.Count; i++) CreateEditor(asset.settings[i], m_SettingsProperty.GetArrayElementAtIndex(i)); } /// <summary> /// This method should be called when the editor is destroyed or disabled. /// </summary> public void Clear() { if (m_Editors == null) return; // Hasn't been inited yet foreach (var editor in m_Editors) editor.OnDisable(); m_Editors.Clear(); m_EditorTypes.Clear(); Undo.undoRedoPerformed -= OnUndoRedoPerformed; } /// <summary> /// Draws the settings for the <see cref="PostProcessProfile"/> referenced in the editor. /// </summary> public void OnGUI() { if (asset == null) return; if (asset.isDirty) { RefreshEditors(); asset.isDirty = false; } bool isEditable = !VersionControl.Provider.isActive || AssetDatabase.IsOpenForEdit(asset, StatusQueryOptions.UseCachedIfPossible); using (new EditorGUI.DisabledScope(!isEditable)) { EditorGUILayout.LabelField(EditorUtilities.GetContent("Overrides"), EditorStyles.boldLabel); // Override list for (int i = 0; i < m_Editors.Count; i++) { var editor = m_Editors[i]; string title = editor.GetDisplayTitle(); int id = i; // Needed for closure capture below EditorUtilities.DrawSplitter(); bool displayContent = EditorUtilities.DrawHeader( title, editor.baseProperty, editor.activeProperty, editor.target, () => ResetEffectOverride(editor.target.GetType(), id), () => RemoveEffectOverride(id) ); if (displayContent) { using (new EditorGUI.DisabledScope(!editor.activeProperty.boolValue)) editor.OnInternalInspectorGUI(); } } if (m_Editors.Count > 0) { EditorUtilities.DrawSplitter(); EditorGUILayout.Space(); } else { EditorGUILayout.HelpBox("No override set on this volume.", MessageType.Info); } if (GUILayout.Button("Add effect...", EditorStyles.miniButton)) { var menu = new GenericMenu(); var typeMap = PostProcessManager.instance.settingsTypes; foreach (var kvp in typeMap) { var type = kvp.Key; var title = EditorUtilities.GetContent(kvp.Value.menuItem); bool exists = asset.HasSettings(type); if (!exists) menu.AddItem(title, false, () => AddEffectOverride(type)); else menu.AddDisabledItem(title); } menu.ShowAsContext(); } EditorGUILayout.Space(); } } void AddEffectOverride(Type type) { m_SerializedObject.Update(); var effect = CreateNewEffect(type); Undo.RegisterCreatedObjectUndo(effect, "Add Effect Override"); // Store this new effect as a subasset so we can reference it safely afterwards. Only when its not an instantiated profile if (EditorUtility.IsPersistent(asset)) AssetDatabase.AddObjectToAsset(effect, asset); // Grow the list first, then add - that's how serialized lists work in Unity m_SettingsProperty.arraySize++; var effectProp = m_SettingsProperty.GetArrayElementAtIndex(m_SettingsProperty.arraySize - 1); effectProp.objectReferenceValue = effect; // Create & store the internal editor object for this effect CreateEditor(effect, effectProp); m_SerializedObject.ApplyModifiedProperties(); // Force save / refresh. Important to do this last because SaveAssets can cause effect to become null! if (EditorUtility.IsPersistent(asset)) { EditorUtility.SetDirty(asset); AssetDatabase.SaveAssets(); } } void RemoveEffectOverride(int id) { // Huh. Hack to keep foldout state on the next element... bool nextFoldoutState = false; if (id < m_Editors.Count - 1) nextFoldoutState = m_Editors[id + 1].baseProperty.isExpanded; // Remove from the cached editors list m_Editors[id].OnDisable(); m_Editors.RemoveAt(id); m_SerializedObject.Update(); var property = m_SettingsProperty.GetArrayElementAtIndex(id); var effect = property.objectReferenceValue; // Unassign it (should be null already but serialization does funky things property.objectReferenceValue = null; // ...and remove the array index itself from the list m_SettingsProperty.DeleteArrayElementAtIndex(id); // Finally refresh editor reference to the serialized settings list for (int i = 0; i < m_Editors.Count; i++) m_Editors[i].baseProperty = m_SettingsProperty.GetArrayElementAtIndex(i).Copy(); if (id < m_Editors.Count) m_Editors[id].baseProperty.isExpanded = nextFoldoutState; m_SerializedObject.ApplyModifiedProperties(); // Destroy the setting object after ApplyModifiedProperties(). If we do it before, redo // actions will be in the wrong order and the reference to the setting object in the // list will be lost. Undo.DestroyObjectImmediate(effect); // Force save / refresh EditorUtility.SetDirty(asset); AssetDatabase.SaveAssets(); } // Reset is done by deleting and removing the object from the list and adding a new one in // the place as it was before void ResetEffectOverride(Type type, int id) { // Remove from the cached editors list m_Editors[id].OnDisable(); m_Editors[id] = null; m_SerializedObject.Update(); var property = m_SettingsProperty.GetArrayElementAtIndex(id); var prevSettings = property.objectReferenceValue; // Unassign it but down remove it from the array to keep the index available property.objectReferenceValue = null; // Create a new object var newEffect = CreateNewEffect(type); Undo.RegisterCreatedObjectUndo(newEffect, "Reset Effect Override"); // Store this new effect as a subasset so we can reference it safely afterwards AssetDatabase.AddObjectToAsset(newEffect, asset); // Put it in the reserved space property.objectReferenceValue = newEffect; // Create & store the internal editor object for this effect CreateEditor(newEffect, property, id); m_SerializedObject.ApplyModifiedProperties(); // Same as RemoveEffectOverride, destroy at the end so it's recreated first on Undo to // make sure the GUID exists before undoing the list state Undo.DestroyObjectImmediate(prevSettings); // Force save / refresh EditorUtility.SetDirty(asset); AssetDatabase.SaveAssets(); } PostProcessEffectSettings CreateNewEffect(Type type) { var effect = (PostProcessEffectSettings)ScriptableObject.CreateInstance(type); effect.hideFlags = HideFlags.HideInInspector | HideFlags.HideInHierarchy; effect.name = type.Name; effect.enabled.value = true; return effect; } } }

File no 62: /colame/Assets/SineVFX/PostProcessingV2/Editor/PostProcessDebugEditor.cs
using UnityEngine; using UnityEngine.Rendering.PostProcessing; namespace UnityEditor.Rendering.PostProcessing { [CustomEditor(typeof(PostProcessDebug))] sealed class PostProcessDebugEditor : BaseEditor<PostProcessDebug> { SerializedProperty m_PostProcessLayer; SerializedProperty m_LightMeterEnabled; SerializedProperty m_HistogramEnabled; SerializedProperty m_WaveformEnabled; SerializedProperty m_VectorscopeEnabled; SerializedProperty m_Overlay; SerializedObject m_LayerObject; SerializedProperty m_LightMeterShowCurves; SerializedProperty m_HistogramChannel; SerializedProperty m_WaveformExposure; SerializedProperty m_VectorscopeExposure; SerializedProperty m_LinearDepth; SerializedProperty m_MotionColorIntensity; SerializedProperty m_MotionGridSize; SerializedProperty m_ColorBlindness; SerializedProperty m_ColorBlindnessStrength; void OnEnable() { m_PostProcessLayer = FindProperty(x => x.postProcessLayer); m_LightMeterEnabled = FindProperty(x => x.lightMeter); m_HistogramEnabled = FindProperty(x => x.histogram); m_WaveformEnabled = FindProperty(x => x.waveform); m_VectorscopeEnabled = FindProperty(x => x.vectorscope); m_Overlay = FindProperty(x => x.debugOverlay); if (m_PostProcessLayer.objectReferenceValue != null) RebuildProperties(); } void RebuildProperties() { if (m_PostProcessLayer.objectReferenceValue == null) return; m_LayerObject = new SerializedObject(m_Target.postProcessLayer); m_LightMeterShowCurves = m_LayerObject.FindProperty("debugLayer.lightMeter.showCurves"); m_HistogramChannel = m_LayerObject.FindProperty("debugLayer.histogram.channel"); m_WaveformExposure = m_LayerObject.FindProperty("debugLayer.waveform.exposure"); m_VectorscopeExposure = m_LayerObject.FindProperty("debugLayer.vectorscope.exposure"); m_LinearDepth = m_LayerObject.FindProperty("debugLayer.overlaySettings.linearDepth"); m_MotionColorIntensity = m_LayerObject.FindProperty("debugLayer.overlaySettings.motionColorIntensity"); m_MotionGridSize = m_LayerObject.FindProperty("debugLayer.overlaySettings.motionGridSize"); m_ColorBlindness = m_LayerObject.FindProperty("debugLayer.overlaySettings.colorBlindnessType"); m_ColorBlindnessStrength = m_LayerObject.FindProperty("debugLayer.overlaySettings.colorBlindnessStrength"); } public override void OnInspectorGUI() { serializedObject.Update(); using (var changed = new EditorGUI.ChangeCheckScope()) { EditorGUILayout.PropertyField(m_PostProcessLayer); serializedObject.ApplyModifiedProperties(); // Needed to rebuild properties after a change serializedObject.Update(); if (changed.changed) RebuildProperties(); } if (RuntimeUtilities.scriptableRenderPipelineActive) { EditorGUILayout.Space(); EditorGUILayout.HelpBox("A scriptable render pipeline is active, these features might not be available.", MessageType.Info); } if (m_PostProcessLayer.objectReferenceValue != null) { m_LayerObject.Update(); // Overlays EditorGUILayout.Space(); EditorGUILayout.LabelField(EditorUtilities.GetContent("Overlay"), EditorStyles.boldLabel); EditorGUI.indentLevel++; EditorGUILayout.PropertyField(m_Overlay); DoOverlayGUI(DebugOverlay.Depth, m_LinearDepth); DoOverlayGUI(DebugOverlay.MotionVectors, m_MotionColorIntensity, m_MotionGridSize); DoOverlayGUI(DebugOverlay.ColorBlindnessSimulation, m_ColorBlindness, m_ColorBlindnessStrength); // Special cases if (m_Overlay.intValue == (int)DebugOverlay.NANTracker && m_Target.postProcessLayer.stopNaNPropagation) EditorGUILayout.HelpBox("Disable \"Stop NaN Propagation\" in the Post-process layer or NaNs will be overwritten!", MessageType.Warning); EditorGUI.indentLevel--; // Monitors EditorGUILayout.Space(); EditorGUILayout.LabelField(EditorUtilities.GetContent("Monitors"), EditorStyles.boldLabel); EditorGUI.indentLevel++; DoMonitorGUI(EditorUtilities.GetContent("Light Meter"), m_LightMeterEnabled, m_LightMeterShowCurves); DoMonitorGUI(EditorUtilities.GetContent("Histogram"), m_HistogramEnabled, m_HistogramChannel); DoMonitorGUI(EditorUtilities.GetContent("Waveform"), m_WaveformEnabled, m_WaveformExposure); DoMonitorGUI(EditorUtilities.GetContent("Vectoscope"), m_VectorscopeEnabled, m_VectorscopeExposure); EditorGUI.indentLevel--; m_LayerObject.ApplyModifiedProperties(); } serializedObject.ApplyModifiedProperties(); } void DoMonitorGUI(GUIContent content, SerializedProperty prop, params SerializedProperty[] settings) { EditorGUILayout.PropertyField(prop, content); if (settings == null || settings.Length == 0) return; if (prop.boolValue) { EditorGUI.indentLevel++; foreach (var p in settings) EditorGUILayout.PropertyField(p); EditorGUI.indentLevel--; } } void DoOverlayGUI(DebugOverlay overlay, params SerializedProperty[] settings) { if (m_Overlay.intValue != (int)overlay) return; if (settings == null || settings.Length == 0) return; foreach (var p in settings) EditorGUILayout.PropertyField(p); } } }

File no 63: /colame/Assets/SineVFX/PostProcessingV2/Editor/PostProcessEffectBaseEditor.cs
using System; using UnityEngine; using UnityEngine.Rendering.PostProcessing; namespace UnityEditor.Rendering.PostProcessing { /// <summary> /// The base class for all post-processing effect related editors. If you want to customize the /// look of a custom post-processing effect, inherit from <see cref="PostProcessEffectEditor{T}"/> /// instead. /// </summary> /// <seealso cref="PostProcessEffectEditor{T}"/> public class PostProcessEffectBaseEditor { internal PostProcessEffectSettings target { get; private set; } internal SerializedObject serializedObject { get; private set; } internal SerializedProperty baseProperty; internal SerializedProperty activeProperty; SerializedProperty m_Enabled; Editor m_Inspector; internal PostProcessEffectBaseEditor() { } /// <summary> /// Repaints the inspector. /// </summary> public void Repaint() { m_Inspector.Repaint(); } internal void Init(PostProcessEffectSettings target, Editor inspector) { this.target = target; m_Inspector = inspector; serializedObject = new SerializedObject(target); m_Enabled = serializedObject.FindProperty("enabled.value"); activeProperty = serializedObject.FindProperty("active"); OnEnable(); } /// <summary> /// Called when the editor is initialized. /// </summary> public virtual void OnEnable() { } /// <summary> /// Called when the editor is de-initialized. /// </summary> public virtual void OnDisable() { } internal void OnInternalInspectorGUI() { serializedObject.Update(); TopRowFields(); OnInspectorGUI(); EditorGUILayout.Space(); serializedObject.ApplyModifiedProperties(); } /// <summary> /// Called every time the inspector is being redrawn. This is where you should add your UI /// drawing code. /// </summary> public virtual void OnInspectorGUI() { } /// <summary> /// Returns the label to use as the effect title. You can override this to return a custom /// label, else it will use the effect type as the title. /// </summary> /// <returns>The label to use as the effect title</returns> public virtual string GetDisplayTitle() { return ObjectNames.NicifyVariableName(target.GetType().Name); } void TopRowFields() { using (new EditorGUILayout.HorizontalScope()) { if (GUILayout.Button(EditorUtilities.GetContent("All|Toggle all overrides on. To maximize performances you should only toggle overrides that you actually need."), Styling.miniLabelButton, GUILayout.Width(17f), GUILayout.ExpandWidth(false))) SetAllOverridesTo(true); if (GUILayout.Button(EditorUtilities.GetContent("None|Toggle all overrides off."), Styling.miniLabelButton, GUILayout.Width(32f), GUILayout.ExpandWidth(false))) SetAllOverridesTo(false); GUILayout.FlexibleSpace(); bool enabled = m_Enabled.boolValue; enabled = GUILayout.Toggle(enabled, EditorUtilities.GetContent("On|Enable this effect."), EditorStyles.miniButtonLeft, GUILayout.Width(35f), GUILayout.ExpandWidth(false)); enabled = !GUILayout.Toggle(!enabled, EditorUtilities.GetContent("Off|Disable this effect."), EditorStyles.miniButtonRight, GUILayout.Width(35f), GUILayout.ExpandWidth(false)); m_Enabled.boolValue = enabled; } } void SetAllOverridesTo(bool state) { Undo.RecordObject(target, "Toggle All"); target.SetAllOverridesTo(state); serializedObject.Update(); } /// <summary> /// Draws a property UI element. /// </summary> /// <param name="property">The property to draw</param> protected void PropertyField(SerializedParameterOverride property) { var title = EditorUtilities.GetContent(property.displayName); PropertyField(property, title); } /// <summary> /// Draws a property UI element with a custom title and/or tooltip. /// </summary> /// <param name="property">The property to draw</param> /// <param name="title">A custom title and/or tooltip</param> protected void PropertyField(SerializedParameterOverride property, GUIContent title) { // Check for DisplayNameAttribute first var displayNameAttr = property.GetAttribute<DisplayNameAttribute>(); if (displayNameAttr != null) title.text = displayNameAttr.displayName; // Add tooltip if it's missing and an attribute is available if (string.IsNullOrEmpty(title.tooltip)) { var tooltipAttr = property.GetAttribute<TooltipAttribute>(); if (tooltipAttr != null) title.tooltip = tooltipAttr.tooltip; } // Look for a compatible attribute decorator AttributeDecorator decorator = null; Attribute attribute = null; foreach (var attr in property.attributes) { // Use the first decorator we found if (decorator == null) { decorator = EditorUtilities.GetDecorator(attr.GetType()); attribute = attr; } // Draw unity built-in Decorators (Space, Header) if (attr is PropertyAttribute) { if (attr is SpaceAttribute) { EditorGUILayout.GetControlRect(false, (attr as SpaceAttribute).height); } else if (attr is HeaderAttribute) { var rect = EditorGUILayout.GetControlRect(false, 24f); rect.y += 8f; rect = EditorGUI.IndentedRect(rect); EditorGUI.LabelField(rect, (attr as HeaderAttribute).header, Styling.headerLabel); } } } bool invalidProp = false; if (decorator != null && !decorator.IsAutoProperty()) { if (decorator.OnGUI(property.value, property.overrideState, title, attribute)) return; // Attribute is invalid for the specified property; use default unity field instead invalidProp = true; } using (new EditorGUILayout.HorizontalScope()) { // Override checkbox var overrideRect = GUILayoutUtility.GetRect(17f, 17f, GUILayout.ExpandWidth(false)); overrideRect.yMin += 4f; EditorUtilities.DrawOverrideCheckbox(overrideRect, property.overrideState); // Property using (new EditorGUI.DisabledScope(!property.overrideState.boolValue)) { if (decorator != null && !invalidProp) { if (decorator.OnGUI(property.value, property.overrideState, title, attribute)) return; } // Default unity field if (property.value.hasVisibleChildren && property.value.propertyType != SerializedPropertyType.Vector2 && property.value.propertyType != SerializedPropertyType.Vector3) { GUILayout.Space(12f); EditorGUILayout.PropertyField(property.value, title, true); } else { EditorGUILayout.PropertyField(property.value, title); } } } } } }

File no 64: /colame/Assets/SineVFX/PostProcessingV2/Editor/PostProcessEffectEditor.cs
using System; using System.Linq.Expressions; using UnityEngine.Rendering.PostProcessing; namespace UnityEditor.Rendering.PostProcessing { /// <summary> /// The class to inherit from when designing custom effect editors. /// </summary> /// <typeparam name="T">The effect type to create an editor for</typeparam> public class PostProcessEffectEditor<T> : PostProcessEffectBaseEditor where T : PostProcessEffectSettings { /// <summary> /// Find a serialized property using an expression instead of a string. This is safer as it /// helps avoiding typos and make code refactoring easier. /// </summary> /// <typeparam name="TValue">The serialized value type</typeparam> /// <param name="expr">The expression to parse to reach the property</param> /// <returns>A <see cref="SerializedProperty"/> or <c>null</c> if none was found</returns> /// <example> /// <code> /// [Serializable] /// public class MyEffect : PostProcessEffectSettings /// { /// public float myParameter = 1f; /// } /// /// [PostProcessEditor(typeof(MyEffect))] /// public class MyEffectEditor : PostProcessEffectEditor&lt;MyEffect&gt; /// { /// SerializedProperty m_MyParameter; /// /// public override void OnEnable() /// { /// m_MyParameter = FindProperty(x => x.myParameter); /// } /// } /// </code> /// </example> /// <remarks> /// If you're trying to retrieve a <see cref="SerializedParameterOverride"/>, you should /// use <seealso cref="FindParameterOverride{TValue}"/> instead. /// </remarks> /// <seealso cref="SerializedProperty"/> /// <seealso cref="FindParameterOverride{TValue}"/> protected SerializedProperty FindProperty<TValue>(Expression<Func<T, TValue>> expr) { return serializedObject.FindProperty(RuntimeUtilities.GetFieldPath(expr)); } /// <summary> /// Find a serialized parameter override using an expression instead of a string. This is /// safer as it helps avoiding typos and make code refactoring easier. /// </summary> /// <typeparam name="TValue">The serialized value type</typeparam> /// <param name="expr">The expression to parse to reach the parameter override</param> /// <returns>A <see cref="SerializedParameterOverride"/> or <c>null</c> if none was /// found</returns> /// <example> /// <code> /// [Serializable] /// public class MyEffect : PostProcessEffectSettings /// { /// public FloatParameter myParameter = new FloatParameter { value = 1f }; /// } /// /// [PostProcessEditor(typeof(MyEffect))] /// public class MyEffectEditor : PostProcessEffectEditor&lt;MyEffect&gt; /// { /// SerializedParameterOverride m_MyParameter; /// /// public override void OnEnable() /// { /// m_MyParameter = FindParameterOverride(x => x.myParameter); /// } /// } /// </code> /// </example> /// <seealso cref="SerializedParameterOverride"/> protected SerializedParameterOverride FindParameterOverride<TValue>(Expression<Func<T, TValue>> expr) { var property = serializedObject.FindProperty(RuntimeUtilities.GetFieldPath(expr)); var attributes = RuntimeUtilities.GetMemberAttributes(expr); return new SerializedParameterOverride(property, attributes); } } }

File no 65: /colame/Assets/SineVFX/PostProcessingV2/Editor/PostProcessLayerEditor.cs
using System; using System.Collections.Generic; using System.Linq; using UnityEngine; using UnityEngine.Rendering.PostProcessing; using UnityEditorInternal; using System.IO; namespace UnityEditor.Rendering.PostProcessing { using SerializedBundleRef = PostProcessLayer.SerializedBundleRef; using EXRFlags = Texture2D.EXRFlags; [CanEditMultipleObjects, CustomEditor(typeof(PostProcessLayer))] sealed class PostProcessLayerEditor : BaseEditor<PostProcessLayer> { SerializedProperty m_StopNaNPropagation; #pragma warning disable 414 SerializedProperty m_DirectToCameraTarget; #pragma warning restore 414 SerializedProperty m_VolumeTrigger; SerializedProperty m_VolumeLayer; SerializedProperty m_AntialiasingMode; SerializedProperty m_TaaJitterSpread; SerializedProperty m_TaaSharpness; SerializedProperty m_TaaStationaryBlending; SerializedProperty m_TaaMotionBlending; SerializedProperty m_SmaaQuality; SerializedProperty m_FxaaFastMode; SerializedProperty m_FxaaKeepAlpha; SerializedProperty m_FogEnabled; SerializedProperty m_FogExcludeSkybox; SerializedProperty m_ShowToolkit; SerializedProperty m_ShowCustomSorter; Dictionary<PostProcessEvent, ReorderableList> m_CustomLists; static GUIContent[] s_AntialiasingMethodNames = { new GUIContent("No Anti-aliasing"), new GUIContent("Fast Approximate Anti-aliasing (FXAA)"), new GUIContent("Subpixel Morphological Anti-aliasing (SMAA)"), new GUIContent("Temporal Anti-aliasing (TAA)") }; enum ExportMode { FullFrame, DisablePost, BreakBeforeColorGradingLinear, BreakBeforeColorGradingLog } void OnEnable() { m_StopNaNPropagation = FindProperty(x => x.stopNaNPropagation); m_DirectToCameraTarget = FindProperty(x => x.finalBlitToCameraTarget); m_VolumeTrigger = FindProperty(x => x.volumeTrigger); m_VolumeLayer = FindProperty(x => x.volumeLayer); m_AntialiasingMode = FindProperty(x => x.antialiasingMode); m_TaaJitterSpread = FindProperty(x => x.temporalAntialiasing.jitterSpread); m_TaaSharpness = FindProperty(x => x.temporalAntialiasing.sharpness); m_TaaStationaryBlending = FindProperty(x => x.temporalAntialiasing.stationaryBlending); m_TaaMotionBlending = FindProperty(x => x.temporalAntialiasing.motionBlending); m_SmaaQuality = FindProperty(x => x.subpixelMorphologicalAntialiasing.quality); m_FxaaFastMode = FindProperty(x => x.fastApproximateAntialiasing.fastMode); m_FxaaKeepAlpha = FindProperty(x => x.fastApproximateAntialiasing.keepAlpha); m_FogEnabled = FindProperty(x => x.fog.enabled); m_FogExcludeSkybox = FindProperty(x => x.fog.excludeSkybox); m_ShowToolkit = serializedObject.FindProperty("m_ShowToolkit"); m_ShowCustomSorter = serializedObject.FindProperty("m_ShowCustomSorter"); } void OnDisable() { m_CustomLists = null; } public override void OnInspectorGUI() { serializedObject.Update(); var camera = m_Target.GetComponent<Camera>(); #if !UNITY_2017_2_OR_NEWER if (RuntimeUtilities.isSinglePassStereoSelected) EditorGUILayout.HelpBox("Unity 2017.2+ required for full Single-pass stereo rendering support.", MessageType.Warning); #endif DoVolumeBlending(); DoAntialiasing(); DoFog(camera); EditorGUILayout.PropertyField(m_StopNaNPropagation, EditorUtilities.GetContent("Stop NaN Propagation|Automatically replaces NaN/Inf in shaders by a black pixel to avoid breaking some effects. This will slightly affect performances and should only be used if you experience NaN issues that you can't fix. Has no effect on GLES2 platforms.")); #if UNITY_2019_1_OR_NEWER if (!RuntimeUtilities.scriptableRenderPipelineActive) EditorGUILayout.PropertyField(m_DirectToCameraTarget, EditorUtilities.GetContent("Directly to Camera Target|Use the final blit to the camera render target for postprocessing. This has less overhead but breaks compatibility with legacy image effect that use OnRenderImage.")); #endif EditorGUILayout.Space(); DoToolkit(); DoCustomEffectSorter(); EditorUtilities.DrawSplitter(); EditorGUILayout.Space(); serializedObject.ApplyModifiedProperties(); } void DoVolumeBlending() { EditorGUILayout.LabelField(EditorUtilities.GetContent("Volume blending"), EditorStyles.boldLabel); EditorGUI.indentLevel++; { // The layout system sort of break alignement when mixing inspector fields with // custom layouted fields, do the layout manually instead var indentOffset = EditorGUI.indentLevel * 15f; var lineRect = GUILayoutUtility.GetRect(1, EditorGUIUtility.singleLineHeight); var labelRect = new Rect(lineRect.x, lineRect.y, EditorGUIUtility.labelWidth - indentOffset, lineRect.height); var fieldRect = new Rect(labelRect.xMax, lineRect.y, lineRect.width - labelRect.width - 60f, lineRect.height); var buttonRect = new Rect(fieldRect.xMax, lineRect.y, 60f, lineRect.height); EditorGUI.PrefixLabel(labelRect, EditorUtilities.GetContent("Trigger|A transform that will act as a trigger for volume blending.")); m_VolumeTrigger.objectReferenceValue = (Transform)EditorGUI.ObjectField(fieldRect, m_VolumeTrigger.objectReferenceValue, typeof(Transform), true); if (GUI.Button(buttonRect, EditorUtilities.GetContent("This|Assigns the current GameObject as a trigger."), EditorStyles.miniButton)) m_VolumeTrigger.objectReferenceValue = m_Target.transform; if (m_VolumeTrigger.objectReferenceValue == null) EditorGUILayout.HelpBox("No trigger has been set, the camera will only be affected by global volumes.", MessageType.Info); EditorGUILayout.PropertyField(m_VolumeLayer, EditorUtilities.GetContent("Layer|This camera will only be affected by volumes in the selected scene-layers.")); int mask = m_VolumeLayer.intValue; if (mask == 0) EditorGUILayout.HelpBox("No layer has been set, the trigger will never be affected by volumes.", MessageType.Warning); else if (mask == -1 || ((mask & 1) != 0)) EditorGUILayout.HelpBox("Do not use \"Everything\" or \"Default\" as a layer mask as it will slow down the volume blending process! Put post-processing volumes in their own dedicated layer for best performances.", MessageType.Warning); } EditorGUI.indentLevel--; EditorGUILayout.Space(); } void DoAntialiasing() { EditorGUILayout.LabelField(EditorUtilities.GetContent("Anti-aliasing"), EditorStyles.boldLabel); EditorGUI.indentLevel++; { m_AntialiasingMode.intValue = EditorGUILayout.Popup(EditorUtilities.GetContent("Mode|The anti-aliasing method to use. FXAA is fast but low quality. SMAA works well for non-HDR scenes. TAA is a bit slower but higher quality and works well with HDR."), m_AntialiasingMode.intValue, s_AntialiasingMethodNames); if (m_AntialiasingMode.intValue == (int)PostProcessLayer.Antialiasing.TemporalAntialiasing) { #if !UNITY_2017_3_OR_NEWER if (RuntimeUtilities.isSinglePassStereoSelected) EditorGUILayout.HelpBox("TAA requires Unity 2017.3+ for Single-pass stereo rendering support.", MessageType.Warning); #endif EditorGUILayout.PropertyField(m_TaaJitterSpread); EditorGUILayout.PropertyField(m_TaaStationaryBlending); EditorGUILayout.PropertyField(m_TaaMotionBlending); EditorGUILayout.PropertyField(m_TaaSharpness); } else if (m_AntialiasingMode.intValue == (int)PostProcessLayer.Antialiasing.SubpixelMorphologicalAntialiasing) { if (RuntimeUtilities.isSinglePassStereoSelected) EditorGUILayout.HelpBox("SMAA doesn't work with Single-pass stereo rendering.", MessageType.Warning); EditorGUILayout.PropertyField(m_SmaaQuality); if (m_SmaaQuality.intValue != (int)SubpixelMorphologicalAntialiasing.Quality.Low && EditorUtilities.isTargetingConsolesOrMobiles) EditorGUILayout.HelpBox("For performance reasons it is recommended to use Low Quality on mobile and console platforms.", MessageType.Warning); } else if (m_AntialiasingMode.intValue == (int)PostProcessLayer.Antialiasing.FastApproximateAntialiasing) { EditorGUILayout.PropertyField(m_FxaaFastMode); EditorGUILayout.PropertyField(m_FxaaKeepAlpha); if (!m_FxaaFastMode.boolValue && EditorUtilities.isTargetingConsolesOrMobiles) EditorGUILayout.HelpBox("For performance reasons it is recommended to use Fast Mode on mobile and console platforms.", MessageType.Warning); } } EditorGUI.indentLevel--; EditorGUILayout.Space(); } void DoFog(Camera camera) { if (camera == null || camera.actualRenderingPath != RenderingPath.DeferredShading) return; EditorGUILayout.LabelField(EditorUtilities.GetContent("Deferred Fog"), EditorStyles.boldLabel); EditorGUI.indentLevel++; { EditorGUILayout.PropertyField(m_FogEnabled); if (m_FogEnabled.boolValue) { EditorGUILayout.PropertyField(m_FogExcludeSkybox); EditorGUILayout.HelpBox("This adds fog compatibility to the deferred rendering path; actual fog settings should be set in the Lighting panel.", MessageType.Info); } } EditorGUI.indentLevel--; EditorGUILayout.Space(); } void DoToolkit() { EditorUtilities.DrawSplitter(); m_ShowToolkit.boolValue = EditorUtilities.DrawHeader("Toolkit", m_ShowToolkit.boolValue); if (m_ShowToolkit.boolValue) { GUILayout.Space(2); if (GUILayout.Button(EditorUtilities.GetContent("Export frame to EXR..."), EditorStyles.miniButton)) { var menu = new GenericMenu(); menu.AddItem(EditorUtilities.GetContent("Full Frame (as displayed)"), false, () => ExportFrameToExr(ExportMode.FullFrame)); menu.AddItem(EditorUtilities.GetContent("Disable post-processing"), false, () => ExportFrameToExr(ExportMode.DisablePost)); menu.AddItem(EditorUtilities.GetContent("Break before Color Grading (Linear)"), false, () => ExportFrameToExr(ExportMode.BreakBeforeColorGradingLinear)); menu.AddItem(EditorUtilities.GetContent("Break before Color Grading (Log)"), false, () => ExportFrameToExr(ExportMode.BreakBeforeColorGradingLog)); menu.ShowAsContext(); } if (GUILayout.Button(EditorUtilities.GetContent("Select all layer volumes|Selects all the volumes that will influence this layer."), EditorStyles.miniButton)) { var volumes = RuntimeUtilities.GetAllSceneObjects<PostProcessVolume>() .Where(x => (m_VolumeLayer.intValue & (1 << x.gameObject.layer)) != 0) .Select(x => x.gameObject) .Cast<UnityEngine.Object>() .ToArray(); if (volumes.Length > 0) Selection.objects = volumes; } if (GUILayout.Button(EditorUtilities.GetContent("Select all active volumes|Selects all volumes currently affecting the layer."), EditorStyles.miniButton)) { var volumes = new List<PostProcessVolume>(); PostProcessManager.instance.GetActiveVolumes(m_Target, volumes); if (volumes.Count > 0) { Selection.objects = volumes .Select(x => x.gameObject) .Cast<UnityEngine.Object>() .ToArray(); } } GUILayout.Space(3); } } void DoCustomEffectSorter() { EditorUtilities.DrawSplitter(); m_ShowCustomSorter.boolValue = EditorUtilities.DrawHeader("Custom Effect Sorting", m_ShowCustomSorter.boolValue); if (m_ShowCustomSorter.boolValue) { bool isInPrefab = false; // Init lists if needed if (m_CustomLists == null) { // In some cases the editor will refresh before components which means // components might not have been fully initialized yet. In this case we also // need to make sure that we're not in a prefab as sorteBundles isn't a // serializable object and won't exist until put on a scene. if (m_Target.sortedBundles == null) { isInPrefab = string.IsNullOrEmpty(m_Target.gameObject.scene.name); if (!isInPrefab) { // sortedBundles will be initialized and ready to use on the next frame Repaint(); } } else { // Create a reorderable list for each injection event m_CustomLists = new Dictionary<PostProcessEvent, ReorderableList>(); foreach (var evt in Enum.GetValues(typeof(PostProcessEvent)).Cast<PostProcessEvent>()) { var bundles = m_Target.sortedBundles[evt]; var listName = ObjectNames.NicifyVariableName(evt.ToString()); var list = new ReorderableList(bundles, typeof(SerializedBundleRef), true, true, false, false); list.drawHeaderCallback = (rect) => { EditorGUI.LabelField(rect, listName); }; list.drawElementCallback = (rect, index, isActive, isFocused) => { var sbr = (SerializedBundleRef)list.list[index]; EditorGUI.LabelField(rect, sbr.bundle.attribute.menuItem); }; list.onReorderCallback = (l) => { EditorUtility.SetDirty(m_Target); }; m_CustomLists.Add(evt, list); } } } GUILayout.Space(5); if (isInPrefab) { EditorGUILayout.HelpBox("Not supported in prefabs.", MessageType.Info); GUILayout.Space(3); return; } bool anyList = false; if (m_CustomLists != null) { foreach (var kvp in m_CustomLists) { var list = kvp.Value; // Skip empty lists to avoid polluting the inspector if (list.count == 0) continue; list.DoLayoutList(); anyList = true; } } if (!anyList) { EditorGUILayout.HelpBox("No custom effect loaded.", MessageType.Info); GUILayout.Space(3); } } } void ExportFrameToExr(ExportMode mode) { string path = EditorUtility.SaveFilePanel("Export EXR...", "", "Frame", "exr"); if (string.IsNullOrEmpty(path)) return; EditorUtility.DisplayProgressBar("Export EXR", "Rendering...", 0f); var camera = m_Target.GetComponent<Camera>(); var w = camera.pixelWidth; var h = camera.pixelHeight; var texOut = new Texture2D(w, h, TextureFormat.RGBAFloat, false, true); var target = RenderTexture.GetTemporary(w, h, 24, RenderTextureFormat.ARGBFloat, RenderTextureReadWrite.Linear); var lastActive = RenderTexture.active; var lastTargetSet = camera.targetTexture; var lastPostFXState = m_Target.enabled; var lastBreakColorGradingState = m_Target.breakBeforeColorGrading; if (mode == ExportMode.DisablePost) m_Target.enabled = false; else if (mode == ExportMode.BreakBeforeColorGradingLinear || mode == ExportMode.BreakBeforeColorGradingLog) m_Target.breakBeforeColorGrading = true; camera.targetTexture = target; camera.Render(); camera.targetTexture = lastTargetSet; EditorUtility.DisplayProgressBar("Export EXR", "Reading...", 0.25f); m_Target.enabled = lastPostFXState; m_Target.breakBeforeColorGrading = lastBreakColorGradingState; if (mode == ExportMode.BreakBeforeColorGradingLog) { // Convert to log var material = new Material(Shader.Find("Hidden/PostProcessing/Editor/ConvertToLog")); var newTarget = RenderTexture.GetTemporary(w, h, 0, RenderTextureFormat.ARGBFloat, RenderTextureReadWrite.Linear); Graphics.Blit(target, newTarget, material, 0); RenderTexture.ReleaseTemporary(target); DestroyImmediate(material); target = newTarget; } RenderTexture.active = target; texOut.ReadPixels(new Rect(0, 0, w, h), 0, 0); texOut.Apply(); RenderTexture.active = lastActive; EditorUtility.DisplayProgressBar("Export EXR", "Encoding...", 0.5f); var bytes = texOut.EncodeToEXR(EXRFlags.OutputAsFloat | EXRFlags.CompressZIP); EditorUtility.DisplayProgressBar("Export EXR", "Saving...", 0.75f); File.WriteAllBytes(path, bytes); EditorUtility.ClearProgressBar(); AssetDatabase.Refresh(); RenderTexture.ReleaseTemporary(target); DestroyImmediate(texOut); } } }

File no 66: /colame/Assets/SineVFX/PostProcessingV2/Editor/PostProcessProfileEditor.cs
using UnityEngine.Rendering.PostProcessing; namespace UnityEditor.Rendering.PostProcessing { [CustomEditor(typeof(PostProcessProfile))] sealed class PostProcessProfileEditor : Editor { EffectListEditor m_EffectList; void OnEnable() { m_EffectList = new EffectListEditor(this); m_EffectList.Init(target as PostProcessProfile, serializedObject); } void OnDisable() { if (m_EffectList != null) m_EffectList.Clear(); } public override void OnInspectorGUI() { serializedObject.Update(); m_EffectList.OnGUI(); serializedObject.ApplyModifiedProperties(); } } }

File no 67: /colame/Assets/SineVFX/PostProcessingV2/Editor/PostProcessVolumeEditor.cs
using UnityEngine; using UnityEngine.Rendering.PostProcessing; namespace UnityEditor.Rendering.PostProcessing { [CanEditMultipleObjects, CustomEditor(typeof(PostProcessVolume))] sealed class PostProcessVolumeEditor : BaseEditor<PostProcessVolume> { SerializedProperty m_Profile; SerializedProperty m_IsGlobal; SerializedProperty m_BlendRadius; SerializedProperty m_Weight; SerializedProperty m_Priority; EffectListEditor m_EffectList; void OnEnable() { m_Profile = FindProperty(x => x.sharedProfile); m_IsGlobal = FindProperty(x => x.isGlobal); m_BlendRadius = FindProperty(x => x.blendDistance); m_Weight = FindProperty(x => x.weight); m_Priority = FindProperty(x => x.priority); m_EffectList = new EffectListEditor(this); RefreshEffectListEditor(m_Target.sharedProfile); } void OnDisable() { if (m_EffectList != null) m_EffectList.Clear(); } void RefreshEffectListEditor(PostProcessProfile asset) { m_EffectList.Clear(); if (asset != null) m_EffectList.Init(asset, new SerializedObject(asset)); } public override void OnInspectorGUI() { serializedObject.Update(); EditorGUILayout.PropertyField(m_IsGlobal); if (!m_IsGlobal.boolValue) // Blend radius is not needed for global volumes EditorGUILayout.PropertyField(m_BlendRadius); EditorGUILayout.PropertyField(m_Weight); EditorGUILayout.PropertyField(m_Priority); bool assetHasChanged = false; bool showCopy = m_Profile.objectReferenceValue != null; bool multiEdit = m_Profile.hasMultipleDifferentValues; // The layout system sort of break alignement when mixing inspector fields with custom // layouted fields, do the layout manually instead int buttonWidth = showCopy ? 45 : 60; float indentOffset = EditorGUI.indentLevel * 15f; var lineRect = GUILayoutUtility.GetRect(1, EditorGUIUtility.singleLineHeight); var labelRect = new Rect(lineRect.x, lineRect.y, EditorGUIUtility.labelWidth - indentOffset, lineRect.height); var fieldRect = new Rect(labelRect.xMax, lineRect.y, lineRect.width - labelRect.width - buttonWidth * (showCopy ? 2 : 1), lineRect.height); var buttonNewRect = new Rect(fieldRect.xMax, lineRect.y, buttonWidth, lineRect.height); var buttonCopyRect = new Rect(buttonNewRect.xMax, lineRect.y, buttonWidth, lineRect.height); EditorGUI.PrefixLabel(labelRect, EditorUtilities.GetContent(m_Target.HasInstantiatedProfile() ? "Profile (Instance)|A copy of a profile asset." : "Profile|A reference to a profile asset.")); using (var scope = new EditorGUI.ChangeCheckScope()) { EditorGUI.BeginProperty(fieldRect, GUIContent.none, m_Profile); PostProcessProfile profile = null; if (m_Target.HasInstantiatedProfile()) profile = (PostProcessProfile)EditorGUI.ObjectField(fieldRect, m_Target.profile, typeof(PostProcessProfile), false); else profile = (PostProcessProfile)EditorGUI.ObjectField(fieldRect, m_Profile.objectReferenceValue, typeof(PostProcessProfile), false); if (scope.changed) { assetHasChanged = true; m_Profile.objectReferenceValue = profile; if (m_Target.HasInstantiatedProfile()) // Clear the instantiated profile, from now on we're using shared again. m_Target.profile = null; } EditorGUI.EndProperty(); } using (new EditorGUI.DisabledScope(multiEdit)) { if (GUI.Button(buttonNewRect, EditorUtilities.GetContent("New|Create a new profile."), showCopy ? EditorStyles.miniButtonLeft : EditorStyles.miniButton)) { // By default, try to put assets in a folder next to the currently active // scene file. If the user isn't a scene, put them in root instead. var targetName = m_Target.name; var scene = m_Target.gameObject.scene; var asset = ProfileFactory.CreatePostProcessProfile(scene, targetName); m_Profile.objectReferenceValue = asset; m_Target.profile = null; // Make sure we're not using an instantiated profile anymore assetHasChanged = true; } if (showCopy && GUI.Button(buttonCopyRect, EditorUtilities.GetContent(m_Target.HasInstantiatedProfile() ? "Save|Save the instantiated profile" : "Clone|Create a new profile and copy the content of the currently assigned profile."), EditorStyles.miniButtonRight)) { // Duplicate the currently assigned profile and save it as a new profile var origin = profileRef; var path = AssetDatabase.GetAssetPath(m_Profile.objectReferenceValue); path = AssetDatabase.GenerateUniqueAssetPath(path); var asset = Instantiate(origin); asset.settings.Clear(); AssetDatabase.CreateAsset(asset, path); foreach (var item in origin.settings) { var itemCopy = Instantiate(item); itemCopy.hideFlags = HideFlags.HideInInspector | HideFlags.HideInHierarchy; itemCopy.name = item.name; asset.settings.Add(itemCopy); AssetDatabase.AddObjectToAsset(itemCopy, asset); } AssetDatabase.SaveAssets(); AssetDatabase.Refresh(); m_Profile.objectReferenceValue = asset; m_Target.profile = null; // Make sure we're not using an instantiated profile anymore assetHasChanged = true; } } EditorGUILayout.Space(); if (m_Profile.objectReferenceValue == null && !m_Target.HasInstantiatedProfile()) { if (assetHasChanged) m_EffectList.Clear(); // Asset wasn't null before, do some cleanup EditorGUILayout.HelpBox("Assign a Post-process Profile to this volume using the \"Asset\" field or create one automatically by clicking the \"New\" button.\nAssets are automatically put in a folder next to your scene file. If you scene hasn't been saved yet they will be created at the root of the Assets folder.", MessageType.Info); } else { if (assetHasChanged || profileRef != m_EffectList.asset) //Refresh when the user just dragged in a new asset, or when it was instantiated by code. RefreshEffectListEditor(profileRef); if (!multiEdit) m_EffectList.OnGUI(); } serializedObject.ApplyModifiedProperties(); } public PostProcessProfile profileRef { get { return m_Target.HasInstantiatedProfile() ? m_Target.profile : m_Target.sharedProfile; } } } }

File no 68: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Attributes/DisplayNameAttribute.cs
using System; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// Use this attribute to change the label of a field displayed in the inspector. /// </summary> [AttributeUsage(AttributeTargets.Field, AllowMultiple = false)] public sealed class DisplayNameAttribute : Attribute { /// <summary> /// The label displayed in the inspector. /// </summary> public readonly string displayName; /// <summary> /// Creates a new attribute. /// </summary> /// <param name="displayName">The label to display in the inspector</param> public DisplayNameAttribute(string displayName) { this.displayName = displayName; } } }

File no 69: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Attributes/MaxAttribute.cs
using System; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// Use this attribute to clamp floating point values to a maximum value in the inspector. /// </summary> [AttributeUsage(AttributeTargets.Field, AllowMultiple = false)] public sealed class MaxAttribute : Attribute { /// <summary> /// The maximum value the field will be clamped to. /// </summary> public readonly float max; /// <summary> /// Creates a new attribute. /// </summary> /// <param name="max">The maximum value the field will be clamped to</param> public MaxAttribute(float max) { this.max = max; } } }

File no 70: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Attributes/MinAttribute.cs
using System; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// Use this attribute to clamp floating point values to a minimum value in the inspector. /// </summary> [AttributeUsage(AttributeTargets.Field, AllowMultiple = false)] public sealed class MinAttribute : Attribute { /// <summary> /// The minimum value the field will be clamped to. /// </summary> public readonly float min; /// <summary> /// Creates a new attribute. /// </summary> /// <param name="max">The minimum value the field will be clamped to</param> public MinAttribute(float min) { this.min = min; } } }

File no 71: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Attributes/MinMaxAttribute.cs
using System; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// Use this attribute to specify a range between a min and a max value. /// </summary> [AttributeUsage(AttributeTargets.Field, AllowMultiple = false)] public sealed class MinMaxAttribute : Attribute { /// <summary> /// The minimum limit of the user defined range. /// </summary> public readonly float min; /// <summary> /// The maximum limit of the user defined range. /// </summary> public readonly float max; /// <summary> /// Creates a new attribute. /// </summary> /// <param name="min">The minimum limit of the user defined range</param> /// <param name="max">The maximum limit of the user defined range</param> public MinMaxAttribute(float min, float max) { this.min = min; this.max = max; } } }

File no 72: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Attributes/PostProcessAttribute.cs
using System; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// Use this attribute to associate a <see cref="PostProcessEffectSettings"/> to a /// <see cref="PostProcessEffectRenderer{T}"/> type. /// </summary> /// <seealso cref="PostProcessEffectSettings"/> /// <seealso cref="PostProcessEffectRenderer{T}"/> [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)] public sealed class PostProcessAttribute : Attribute { /// <summary> /// The renderer type to associate with a <see cref="PostProcessEffectSettings"/>. /// </summary> public readonly Type renderer; /// <summary> /// The injection point for the effect. /// </summary> public readonly PostProcessEvent eventType; /// <summary> /// The menu item name to set for the effect. You can use a `/` character to add sub-menus. /// </summary> public readonly string menuItem; /// <summary> /// Should this effect be allowed in the Scene View? /// </summary> public readonly bool allowInSceneView; internal readonly bool builtinEffect; /// <summary> /// Creates a new attribute. /// </summary> /// <param name="renderer">The renderer type to associate with a <see cref="PostProcessEffectSettings"/></param> /// <param name="eventType">The injection point for the effect</param> /// <param name="menuItem">The menu item name to set for the effect. You can use a `/` character to add sub-menus.</param> /// <param name="allowInSceneView">Should this effect be allowed in the Scene View?</param> public PostProcessAttribute(Type renderer, PostProcessEvent eventType, string menuItem, bool allowInSceneView = true) { this.renderer = renderer; this.eventType = eventType; this.menuItem = menuItem; this.allowInSceneView = allowInSceneView; builtinEffect = false; } internal PostProcessAttribute(Type renderer, string menuItem, bool allowInSceneView = true) { this.renderer = renderer; this.menuItem = menuItem; this.allowInSceneView = allowInSceneView; builtinEffect = true; } } }

File no 73: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Attributes/TrackballAttribute.cs
using System; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// Use this attribute to draw a trackball in the inspector. /// </summary> [AttributeUsage(AttributeTargets.Field, AllowMultiple = false)] public sealed class TrackballAttribute : Attribute { /// <summary> /// Trackball modes. These are used to compute and display pre-filtered trackball vales in /// the inspector. /// </summary> public enum Mode { /// <summary> /// Don't display pre-filtered values. /// </summary> None, /// <summary> /// Display pre-filtered lift values. /// </summary> Lift, /// <summary> /// Display pre-filtered gamma values. /// </summary> Gamma, /// <summary> /// Display pre-filtered grain values. /// </summary> Gain } /// <summary> /// The mode used to display pre-filtered values in the inspector. /// </summary> public readonly Mode mode; /// <summary> /// Creates a new attribute. /// </summary> /// <param name="mode">A mode used to display pre-filtered values in the inspector</param> public TrackballAttribute(Mode mode) { this.mode = mode; } } }

File no 74: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/AmbientOcclusion.cs
using System; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// Ambient occlusion modes. /// </summary> public enum AmbientOcclusionMode { /// <summary> /// A standard implementation of ambient obscurance that works on non modern platforms. If /// you target a compute-enabled platform we recommend that you use /// <see cref="MultiScaleVolumetricObscurance"/> instead. /// </summary> ScalableAmbientObscurance, /// <summary> /// A modern version of ambient occlusion heavily optimized for consoles and desktop /// platforms. /// </summary> MultiScaleVolumetricObscurance } /// <summary> /// Quality settings for <see cref="AmbientOcclusionMode.ScalableAmbientObscurance"/>. /// </summary> public enum AmbientOcclusionQuality { /// <summary> /// 4 samples + downsampling. /// </summary> Lowest, /// <summary> /// 6 samples + downsampling. /// </summary> Low, /// <summary> /// 10 samples + downsampling. /// </summary> Medium, /// <summary> /// 8 samples. /// </summary> High, /// <summary> /// 12 samples. /// </summary> Ultra } /// <summary> /// A volume parameter holding a <see cref="AmbientOcclusionMode"/> value. /// </summary> [Serializable] public sealed class AmbientOcclusionModeParameter : ParameterOverride<AmbientOcclusionMode> {} /// <summary> /// A volume parameter holding a <see cref="AmbientOcclusionQuality"/> value. /// </summary> [Serializable] public sealed class AmbientOcclusionQualityParameter : ParameterOverride<AmbientOcclusionQuality> {} /// <summary> /// This class holds settings for the Ambient Occlusion effect. /// </summary> [Serializable] [PostProcess(typeof(AmbientOcclusionRenderer), "Unity/Ambient Occlusion")] public sealed class AmbientOcclusion : PostProcessEffectSettings { // Shared parameters /// <summary> /// The ambient occlusion method to use. /// </summary> [Tooltip("The ambient occlusion method to use. \"Multi Scale Volumetric Obscurance\" is higher quality and faster on desktop & console platforms but requires compute shader support.")] public AmbientOcclusionModeParameter mode = new AmbientOcclusionModeParameter { value = AmbientOcclusionMode.MultiScaleVolumetricObscurance }; /// <summary> /// The degree of darkness added by ambient occlusion. /// </summary> [Range(0f, 4f), Tooltip("The degree of darkness added by ambient occlusion. Higher values produce darker areas.")] public FloatParameter intensity = new FloatParameter { value = 0f }; /// <summary> /// A custom color to use for the ambient occlusion. /// </summary> [ColorUsage(false), Tooltip("The custom color to use for the ambient occlusion. The default is black.")] public ColorParameter color = new ColorParameter { value = Color.black }; /// <summary> /// Only affects ambient lighting. This mode is only available with the Deferred rendering /// path and HDR rendering. Objects rendered with the Forward rendering path won't get any /// ambient occlusion. /// </summary> [Tooltip("Check this box to mark this Volume as to only affect ambient lighting. This mode is only available with the Deferred rendering path and HDR rendering. Objects rendered with the Forward rendering path won't get any ambient occlusion.")] public BoolParameter ambientOnly = new BoolParameter { value = true }; // MSVO-only parameters /// <summary> /// The tolerance of the noise filter to changes in the depth pyramid. /// </summary> [Range(-8f, 0f)] public FloatParameter noiseFilterTolerance = new FloatParameter { value = 0f }; // Hidden /// <summary> /// The tolerance of the bilateral blur filter to depth changes. /// </summary> [Range(-8f, -1f)] public FloatParameter blurTolerance = new FloatParameter { value = -4.6f }; // Hidden /// <summary> /// The tolerance of the upsampling pass to depth changes. /// </summary> [Range(-12f, -1f)] public FloatParameter upsampleTolerance = new FloatParameter { value = -12f }; // Hidden /// <summary> /// Modifies the thickness of occluders. This increases dark areas but also introduces dark /// halo around objects. /// </summary> [Range(1f, 10f), Tooltip("This modifies the thickness of occluders. It increases the size of dark areas and also introduces a dark halo around objects.")] public FloatParameter thicknessModifier = new FloatParameter { value = 1f }; // HDRP-only parameters /// <summary> /// Modifies he influence of direct lighting on ambient occlusion. This is only used in the /// HD Render Pipeline currently. /// </summary> [Range(0f, 1f), Tooltip("Modifies the influence of direct lighting on ambient occlusion.")] public FloatParameter directLightingStrength = new FloatParameter { value = 0f }; // SAO-only parameters /// <summary> /// Radius of sample points, which affects extent of darkened areas. /// </summary> [Tooltip("The radius of sample points. This affects the size of darkened areas.")] public FloatParameter radius = new FloatParameter { value = 0.25f }; /// <summary> /// The number of sample points, which affects quality and performance. Lowest, Low & Medium /// passes are downsampled. High and Ultra are not and should only be used on high-end /// hardware. /// </summary> [Tooltip("The number of sample points. This affects both quality and performance. For \"Lowest\", \"Low\", and \"Medium\", passes are downsampled. For \"High\" and \"Ultra\", they are not and therefore you should only \"High\" and \"Ultra\" on high-end hardware.")] public AmbientOcclusionQualityParameter quality = new AmbientOcclusionQualityParameter { value = AmbientOcclusionQuality.Medium }; // SRPs can call this method without a context set (see HDRP). // We need a better way to handle this than checking for a null context, context should // never be null. /// <inheritdoc /> public override bool IsEnabledAndSupported(PostProcessRenderContext context) { bool state = enabled.value && intensity.value > 0f; if (mode.value == AmbientOcclusionMode.ScalableAmbientObscurance) { state &= !RuntimeUtilities.scriptableRenderPipelineActive; if (context != null) { state &= context.resources.shaders.scalableAO && context.resources.shaders.scalableAO.isSupported; } } else if (mode.value == AmbientOcclusionMode.MultiScaleVolumetricObscurance) { #if UNITY_2017_1_OR_NEWER if (context != null) { state &= context.resources.shaders.multiScaleAO && context.resources.shaders.multiScaleAO.isSupported && context.resources.computeShaders.multiScaleAODownsample1 && context.resources.computeShaders.multiScaleAODownsample2 && context.resources.computeShaders.multiScaleAORender && context.resources.computeShaders.multiScaleAOUpsample; } state &= SystemInfo.supportsComputeShaders && !RuntimeUtilities.isAndroidOpenGL && RenderTextureFormat.RFloat.IsSupported() && RenderTextureFormat.RHalf.IsSupported() && RenderTextureFormat.R8.IsSupported(); #else state = false; #endif } return state; } } internal interface IAmbientOcclusionMethod { DepthTextureMode GetCameraFlags(); void RenderAfterOpaque(PostProcessRenderContext context); void RenderAmbientOnly(PostProcessRenderContext context); void CompositeAmbientOnly(PostProcessRenderContext context); void Release(); } #if UNITY_2017_1_OR_NEWER [UnityEngine.Scripting.Preserve] #endif internal sealed class AmbientOcclusionRenderer : PostProcessEffectRenderer<AmbientOcclusion> { IAmbientOcclusionMethod[] m_Methods; public override void Init() { if (m_Methods == null) { m_Methods = new IAmbientOcclusionMethod[] { new ScalableAO(settings), new MultiScaleVO(settings), }; } } public bool IsAmbientOnly(PostProcessRenderContext context) { var camera = context.camera; return settings.ambientOnly.value && camera.actualRenderingPath == RenderingPath.DeferredShading && camera.allowHDR; } public IAmbientOcclusionMethod Get() { return m_Methods[(int)settings.mode.value]; } public override DepthTextureMode GetCameraFlags() { return Get().GetCameraFlags(); } public override void Release() { foreach (var m in m_Methods) m.Release(); } public ScalableAO GetScalableAO() { return (ScalableAO)m_Methods[(int)AmbientOcclusionMode.ScalableAmbientObscurance]; } public MultiScaleVO GetMultiScaleVO() { return (MultiScaleVO)m_Methods[(int)AmbientOcclusionMode.MultiScaleVolumetricObscurance]; } // Unused public override void Render(PostProcessRenderContext context) { } } }

File no 75: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/AutoExposure.cs
using System; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// Eye adaptation modes. /// </summary> public enum EyeAdaptation { /// <summary> /// Progressive (smooth) eye adaptation. /// </summary> Progressive, /// <summary> /// Fixed (instant) eye adaptation. /// </summary> Fixed } /// <summary> /// A volume parameter holding a <see cref="EyeAdaptation"/> value. /// </summary> [Serializable] public sealed class EyeAdaptationParameter : ParameterOverride<EyeAdaptation> {} /// <summary> /// This class holds settings for the Auto Exposure effect. /// </summary> [Serializable] [PostProcess(typeof(AutoExposureRenderer), "Unity/Auto Exposure")] public sealed class AutoExposure : PostProcessEffectSettings { /// <summary> /// These values are the lower and upper percentages of the histogram that will be used to /// find a stable average luminance. Values outside of this range will be discarded and wont /// contribute to the average luminance. /// </summary> [MinMax(1f, 99f), DisplayName("Filtering (%)"), Tooltip("Filters the bright and dark parts of the histogram when computing the average luminance. This is to avoid very dark pixels and very bright pixels from contributing to the auto exposure. Unit is in percent.")] public Vector2Parameter filtering = new Vector2Parameter { value = new Vector2(50f, 95f) }; /// <summary> /// Minimum average luminance to consider for auto exposure (in EV). /// </summary> [Range(LogHistogram.rangeMin, LogHistogram.rangeMax), DisplayName("Minimum (EV)"), Tooltip("Minimum average luminance to consider for auto exposure. Unit is EV.")] public FloatParameter minLuminance = new FloatParameter { value = 0f }; /// <summary> /// Maximum average luminance to consider for auto exposure (in EV). /// </summary> [Range(LogHistogram.rangeMin, LogHistogram.rangeMax), DisplayName("Maximum (EV)"), Tooltip("Maximum average luminance to consider for auto exposure. Unit is EV.")] public FloatParameter maxLuminance = new FloatParameter { value = 0f }; /// <summary> /// Middle-grey value. Use this to compensate the global exposure of the scene. /// </summary> [Min(0f), DisplayName("Exposure Compensation"), Tooltip("Use this to scale the global exposure of the scene.")] public FloatParameter keyValue = new FloatParameter { value = 1f }; /// <summary> /// The type of eye adaptation to use. /// </summary> [DisplayName("Type"), Tooltip("Use \"Progressive\" if you want auto exposure to be animated. Use \"Fixed\" otherwise.")] public EyeAdaptationParameter eyeAdaptation = new EyeAdaptationParameter { value = EyeAdaptation.Progressive }; /// <summary> /// The adaptation speed from a dark to a light environment. /// </summary> [Min(0f), Tooltip("Adaptation speed from a dark to a light environment.")] public FloatParameter speedUp = new FloatParameter { value = 2f }; /// <summary> /// The adaptation speed from a light to a dark environment. /// </summary> [Min(0f), Tooltip("Adaptation speed from a light to a dark environment.")] public FloatParameter speedDown = new FloatParameter { value = 1f }; /// <inheritdoc /> public override bool IsEnabledAndSupported(PostProcessRenderContext context) { return enabled.value && SystemInfo.supportsComputeShaders && !RuntimeUtilities.isAndroidOpenGL && RenderTextureFormat.RFloat.IsSupported() && context.resources.computeShaders.autoExposure && context.resources.computeShaders.exposureHistogram; } } #if UNITY_2017_1_OR_NEWER [UnityEngine.Scripting.Preserve] #endif internal sealed class AutoExposureRenderer : PostProcessEffectRenderer<AutoExposure> { const int k_NumEyes = 2; const int k_NumAutoExposureTextures = 2; readonly RenderTexture[][] m_AutoExposurePool = new RenderTexture[k_NumEyes][]; int[] m_AutoExposurePingPong = new int[k_NumEyes]; RenderTexture m_CurrentAutoExposure; public AutoExposureRenderer() { for (int eye = 0; eye < k_NumEyes; eye++) { m_AutoExposurePool[eye] = new RenderTexture[k_NumAutoExposureTextures]; m_AutoExposurePingPong[eye] = 0; } } void CheckTexture(int eye, int id) { if (m_AutoExposurePool[eye][id] == null || !m_AutoExposurePool[eye][id].IsCreated()) { m_AutoExposurePool[eye][id] = new RenderTexture(1, 1, 0, RenderTextureFormat.RFloat) { enableRandomWrite = true }; m_AutoExposurePool[eye][id].Create(); } } public override void Render(PostProcessRenderContext context) { var cmd = context.command; cmd.BeginSample("AutoExposureLookup"); // Prepare autoExpo texture pool CheckTexture(context.xrActiveEye, 0); CheckTexture(context.xrActiveEye, 1); // Make sure filtering values are correct to avoid apocalyptic consequences float lowPercent = settings.filtering.value.x; float highPercent = settings.filtering.value.y; const float kMinDelta = 1e-2f; highPercent = Mathf.Clamp(highPercent, 1f + kMinDelta, 99f); lowPercent = Mathf.Clamp(lowPercent, 1f, highPercent - kMinDelta); // Clamp min/max adaptation values as well float minLum = settings.minLuminance.value; float maxLum = settings.maxLuminance.value; settings.minLuminance.value = Mathf.Min(minLum, maxLum); settings.maxLuminance.value = Mathf.Max(minLum, maxLum); // Compute average luminance & auto exposure bool firstFrame = m_ResetHistory || !Application.isPlaying; string adaptation = null; if (firstFrame || settings.eyeAdaptation.value == EyeAdaptation.Fixed) adaptation = "KAutoExposureAvgLuminance_fixed"; else adaptation = "KAutoExposureAvgLuminance_progressive"; var compute = context.resources.computeShaders.autoExposure; int kernel = compute.FindKernel(adaptation); cmd.SetComputeBufferParam(compute, kernel, "_HistogramBuffer", context.logHistogram.data); cmd.SetComputeVectorParam(compute, "_Params1", new Vector4(lowPercent * 0.01f, highPercent * 0.01f, RuntimeUtilities.Exp2(settings.minLuminance.value), RuntimeUtilities.Exp2(settings.maxLuminance.value))); cmd.SetComputeVectorParam(compute, "_Params2", new Vector4(settings.speedDown.value, settings.speedUp.value, settings.keyValue.value, Time.deltaTime)); cmd.SetComputeVectorParam(compute, "_ScaleOffsetRes", context.logHistogram.GetHistogramScaleOffsetRes(context)); if (firstFrame) { // We don't want eye adaptation when not in play mode because the GameView isn't // animated, thus making it harder to tweak. Just use the final audo exposure value. m_CurrentAutoExposure = m_AutoExposurePool[context.xrActiveEye][0]; cmd.SetComputeTextureParam(compute, kernel, "_Destination", m_CurrentAutoExposure); cmd.DispatchCompute(compute, kernel, 1, 1, 1); // Copy current exposure to the other pingpong target to avoid adapting from black RuntimeUtilities.CopyTexture(cmd, m_AutoExposurePool[context.xrActiveEye][0], m_AutoExposurePool[context.xrActiveEye][1]); m_ResetHistory = false; } else { int pp = m_AutoExposurePingPong[context.xrActiveEye]; var src = m_AutoExposurePool[context.xrActiveEye][++pp % 2]; var dst = m_AutoExposurePool[context.xrActiveEye][++pp % 2]; cmd.SetComputeTextureParam(compute, kernel, "_Source", src); cmd.SetComputeTextureParam(compute, kernel, "_Destination", dst); cmd.DispatchCompute(compute, kernel, 1, 1, 1); m_AutoExposurePingPong[context.xrActiveEye] = ++pp % 2; m_CurrentAutoExposure = dst; } cmd.EndSample("AutoExposureLookup"); context.autoExposureTexture = m_CurrentAutoExposure; context.autoExposure = settings; } public override void Release() { foreach (var rtEyeSet in m_AutoExposurePool) { foreach (var rt in rtEyeSet) RuntimeUtilities.Destroy(rt); } } } }

File no 76: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/Bloom.cs
using System; using UnityEngine.Serialization; namespace UnityEngine.Rendering.PostProcessing { // For now and by popular request, this bloom effect is geared toward artists so they have full // control over how it looks at the expense of physical correctness. // Eventually we will need a "true" natural bloom effect with proper energy conservation. /// <summary> /// This class holds settings for the Bloom effect. /// </summary> [Serializable] [PostProcess(typeof(BloomRenderer), "Unity/Bloom")] public sealed class Bloom : PostProcessEffectSettings { /// <summary> /// The strength of the bloom filter. /// </summary> [Min(0f), Tooltip("Strength of the bloom filter. Values higher than 1 will make bloom contribute more energy to the final render.")] public FloatParameter intensity = new FloatParameter { value = 0f }; /// <summary> /// Filters out pixels under this level of brightness. This value is expressed in /// gamma-space. /// </summary> [Min(0f), Tooltip("Filters out pixels under this level of brightness. Value is in gamma-space.")] public FloatParameter threshold = new FloatParameter { value = 1f }; /// <summary> /// Makes transition between under/over-threshold gradual (0 = hard threshold, 1 = soft /// threshold). /// </summary> [Range(0f, 1f), Tooltip("Makes transitions between under/over-threshold gradual. 0 for a hard threshold, 1 for a soft threshold).")] public FloatParameter softKnee = new FloatParameter { value = 0.5f }; /// <summary> /// Clamps pixels to control the bloom amount. This value is expressed in gamma-space. /// </summary> [Tooltip("Clamps pixels to control the bloom amount. Value is in gamma-space.")] public FloatParameter clamp = new FloatParameter { value = 65472f }; /// <summary> /// Changes extent of veiling effects in a screen resolution-independent fashion. For /// maximum quality stick to integer values. Because this value changes the internal /// iteration count, animating it isn't recommended as it may introduce small hiccups in /// the perceived radius. /// </summary> [Range(1f, 10f), Tooltip("Changes the extent of veiling effects. For maximum quality, use integer values. Because this value changes the internal iteration count, You should not animating it as it may introduce issues with the perceived radius.")] public FloatParameter diffusion = new FloatParameter { value = 7f }; /// <summary> /// Distorts the bloom to give an anamorphic look. Negative values distort vertically, /// positive values distort horizontally. /// </summary> [Range(-1f, 1f), Tooltip("Distorts the bloom to give an anamorphic look. Negative values distort vertically, positive values distort horizontally.")] public FloatParameter anamorphicRatio = new FloatParameter { value = 0f }; /// <summary> /// The tint of the Bloom filter. /// </summary> #if UNITY_2018_1_OR_NEWER [ColorUsage(false, true), Tooltip("Global tint of the bloom filter.")] #else [ColorUsage(false, true, 0f, 8f, 0.125f, 3f), Tooltip("Global tint of the bloom filter.")] #endif public ColorParameter color = new ColorParameter { value = Color.white }; /// <summary> /// Boost performances by lowering the effect quality. /// </summary> [FormerlySerializedAs("mobileOptimized")] [Tooltip("Boost performance by lowering the effect quality. This settings is meant to be used on mobile and other low-end platforms but can also provide a nice performance boost on desktops and consoles.")] public BoolParameter fastMode = new BoolParameter { value = false }; /// <summary> /// The dirtiness texture to add smudges or dust to the lens. /// </summary> [Tooltip("The lens dirt texture used to add smudges or dust to the bloom effect."), DisplayName("Texture")] public TextureParameter dirtTexture = new TextureParameter { value = null }; /// <summary> /// The amount of lens dirtiness. /// </summary> [Min(0f), Tooltip("The intensity of the lens dirtiness."), DisplayName("Intensity")] public FloatParameter dirtIntensity = new FloatParameter { value = 0f }; /// <inheritdoc /> public override bool IsEnabledAndSupported(PostProcessRenderContext context) { return enabled.value && intensity.value > 0f; } } #if UNITY_2017_1_OR_NEWER [UnityEngine.Scripting.Preserve] #endif internal sealed class BloomRenderer : PostProcessEffectRenderer<Bloom> { enum Pass { Prefilter13, Prefilter4, Downsample13, Downsample4, UpsampleTent, UpsampleBox, DebugOverlayThreshold, DebugOverlayTent, DebugOverlayBox } // [down,up] Level[] m_Pyramid; const int k_MaxPyramidSize = 16; // Just to make sure we handle 64k screens... Future-proof! struct Level { internal int down; internal int up; } public override void Init() { m_Pyramid = new Level[k_MaxPyramidSize]; for (int i = 0; i < k_MaxPyramidSize; i++) { m_Pyramid[i] = new Level { down = Shader.PropertyToID("_BloomMipDown" + i), up = Shader.PropertyToID("_BloomMipUp" + i) }; } } public override void Render(PostProcessRenderContext context) { var cmd = context.command; cmd.BeginSample("BloomPyramid"); var sheet = context.propertySheets.Get(context.resources.shaders.bloom); // Apply auto exposure adjustment in the prefiltering pass sheet.properties.SetTexture(ShaderIDs.AutoExposureTex, context.autoExposureTexture); // Negative anamorphic ratio values distort vertically - positive is horizontal float ratio = Mathf.Clamp(settings.anamorphicRatio, -1, 1); float rw = ratio < 0 ? -ratio : 0f; float rh = ratio > 0 ? ratio : 0f; // Do bloom on a half-res buffer, full-res doesn't bring much and kills performances on // fillrate limited platforms int tw = Mathf.FloorToInt(context.screenWidth / (2f - rw)); int th = Mathf.FloorToInt(context.screenHeight / (2f - rh)); bool singlePassDoubleWide = (context.stereoActive && (context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePass) && (context.camera.stereoTargetEye == StereoTargetEyeMask.Both)); int tw_stereo = singlePassDoubleWide ? tw * 2 : tw; // Determine the iteration count int s = Mathf.Max(tw, th); float logs = Mathf.Log(s, 2f) + Mathf.Min(settings.diffusion.value, 10f) - 10f; int logs_i = Mathf.FloorToInt(logs); int iterations = Mathf.Clamp(logs_i, 1, k_MaxPyramidSize); float sampleScale = 0.5f + logs - logs_i; sheet.properties.SetFloat(ShaderIDs.SampleScale, sampleScale); // Prefiltering parameters float lthresh = Mathf.GammaToLinearSpace(settings.threshold.value); float knee = lthresh * settings.softKnee.value + 1e-5f; var threshold = new Vector4(lthresh, lthresh - knee, knee * 2f, 0.25f / knee); sheet.properties.SetVector(ShaderIDs.Threshold, threshold); float lclamp = Mathf.GammaToLinearSpace(settings.clamp.value); sheet.properties.SetVector(ShaderIDs.Params, new Vector4(lclamp, 0f, 0f, 0f)); int qualityOffset = settings.fastMode ? 1 : 0; // Downsample var lastDown = context.source; for (int i = 0; i < iterations; i++) { int mipDown = m_Pyramid[i].down; int mipUp = m_Pyramid[i].up; int pass = i == 0 ? (int)Pass.Prefilter13 + qualityOffset : (int)Pass.Downsample13 + qualityOffset; context.GetScreenSpaceTemporaryRT(cmd, mipDown, 0, context.sourceFormat, RenderTextureReadWrite.Default, FilterMode.Bilinear, tw_stereo, th); context.GetScreenSpaceTemporaryRT(cmd, mipUp, 0, context.sourceFormat, RenderTextureReadWrite.Default, FilterMode.Bilinear, tw_stereo, th); cmd.BlitFullscreenTriangle(lastDown, mipDown, sheet, pass); lastDown = mipDown; tw_stereo = (singlePassDoubleWide && ((tw_stereo / 2) % 2 > 0)) ? 1 + tw_stereo / 2 : tw_stereo / 2; tw_stereo = Mathf.Max(tw_stereo, 1); th = Mathf.Max(th / 2, 1); } // Upsample int lastUp = m_Pyramid[iterations - 1].down; for (int i = iterations - 2; i >= 0; i--) { int mipDown = m_Pyramid[i].down; int mipUp = m_Pyramid[i].up; cmd.SetGlobalTexture(ShaderIDs.BloomTex, mipDown); cmd.BlitFullscreenTriangle(lastUp, mipUp, sheet, (int)Pass.UpsampleTent + qualityOffset); lastUp = mipUp; } var linearColor = settings.color.value.linear; float intensity = RuntimeUtilities.Exp2(settings.intensity.value / 10f) - 1f; var shaderSettings = new Vector4(sampleScale, intensity, settings.dirtIntensity.value, iterations); // Debug overlays if (context.IsDebugOverlayEnabled(DebugOverlay.BloomThreshold)) { context.PushDebugOverlay(cmd, context.source, sheet, (int)Pass.DebugOverlayThreshold); } else if (context.IsDebugOverlayEnabled(DebugOverlay.BloomBuffer)) { sheet.properties.SetVector(ShaderIDs.ColorIntensity, new Vector4(linearColor.r, linearColor.g, linearColor.b, intensity)); context.PushDebugOverlay(cmd, m_Pyramid[0].up, sheet, (int)Pass.DebugOverlayTent + qualityOffset); } // Lens dirtiness // Keep the aspect ratio correct & center the dirt texture, we don't want it to be // stretched or squashed var dirtTexture = settings.dirtTexture.value == null ? RuntimeUtilities.blackTexture : settings.dirtTexture.value; var dirtRatio = (float)dirtTexture.width / (float)dirtTexture.height; var screenRatio = (float)context.screenWidth / (float)context.screenHeight; var dirtTileOffset = new Vector4(1f, 1f, 0f, 0f); if (dirtRatio > screenRatio) { dirtTileOffset.x = screenRatio / dirtRatio; dirtTileOffset.z = (1f - dirtTileOffset.x) * 0.5f; } else if (screenRatio > dirtRatio) { dirtTileOffset.y = dirtRatio / screenRatio; dirtTileOffset.w = (1f - dirtTileOffset.y) * 0.5f; } // Shader properties var uberSheet = context.uberSheet; if (settings.fastMode) uberSheet.EnableKeyword("BLOOM_LOW"); else uberSheet.EnableKeyword("BLOOM"); uberSheet.properties.SetVector(ShaderIDs.Bloom_DirtTileOffset, dirtTileOffset); uberSheet.properties.SetVector(ShaderIDs.Bloom_Settings, shaderSettings); uberSheet.properties.SetColor(ShaderIDs.Bloom_Color, linearColor); uberSheet.properties.SetTexture(ShaderIDs.Bloom_DirtTex, dirtTexture); cmd.SetGlobalTexture(ShaderIDs.BloomTex, lastUp); // Cleanup for (int i = 0; i < iterations; i++) { if (m_Pyramid[i].down != lastUp) cmd.ReleaseTemporaryRT(m_Pyramid[i].down); if (m_Pyramid[i].up != lastUp) cmd.ReleaseTemporaryRT(m_Pyramid[i].up); } cmd.EndSample("BloomPyramid"); context.bloomBufferNameID = lastUp; } } }

File no 77: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/ChromaticAberration.cs
using System; using UnityEngine.Serialization; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// This class holds settings for the Chromatic Aberration effect. /// </summary> [Serializable] [PostProcess(typeof(ChromaticAberrationRenderer), "Unity/Chromatic Aberration")] public sealed class ChromaticAberration : PostProcessEffectSettings { /// <summary> /// A texture used for custom fringing color (it will use a default one when <c>null</c>). /// </summary> [Tooltip("Shifts the hue of chromatic aberrations.")] public TextureParameter spectralLut = new TextureParameter { value = null }; /// <summary> /// The amount of tangential distortion. /// </summary> [Range(0f, 1f), Tooltip("Amount of tangential distortion.")] public FloatParameter intensity = new FloatParameter { value = 0f }; /// <summary> /// If <c>true</c>, it will use a faster variant of the effect for improved performances. /// </summary> [FormerlySerializedAs("mobileOptimized")] [Tooltip("Boost performances by lowering the effect quality. This settings is meant to be used on mobile and other low-end platforms but can also provide a nice performance boost on desktops and consoles.")] public BoolParameter fastMode = new BoolParameter { value = false }; /// <inheritdoc /> public override bool IsEnabledAndSupported(PostProcessRenderContext context) { return enabled.value && intensity.value > 0f; } } #if UNITY_2017_1_OR_NEWER [UnityEngine.Scripting.Preserve] #endif internal sealed class ChromaticAberrationRenderer : PostProcessEffectRenderer<ChromaticAberration> { Texture2D m_InternalSpectralLut; public override void Render(PostProcessRenderContext context) { var spectralLut = settings.spectralLut.value; if (spectralLut == null) { if (m_InternalSpectralLut == null) { m_InternalSpectralLut = new Texture2D(3, 1, TextureFormat.RGB24, false) { name = "Chromatic Aberration Spectrum Lookup", filterMode = FilterMode.Bilinear, wrapMode = TextureWrapMode.Clamp, anisoLevel = 0, hideFlags = HideFlags.DontSave }; m_InternalSpectralLut.SetPixels(new [] { new Color(1f, 0f, 0f), new Color(0f, 1f, 0f), new Color(0f, 0f, 1f) }); m_InternalSpectralLut.Apply(); } spectralLut = m_InternalSpectralLut; } var sheet = context.uberSheet; bool fastMode = settings.fastMode || SystemInfo.graphicsDeviceType == GraphicsDeviceType.OpenGLES2; sheet.EnableKeyword(fastMode ? "CHROMATIC_ABERRATION_LOW" : "CHROMATIC_ABERRATION" ); sheet.properties.SetFloat(ShaderIDs.ChromaticAberration_Amount, settings.intensity * 0.05f); sheet.properties.SetTexture(ShaderIDs.ChromaticAberration_SpectralLut, spectralLut); } public override void Release() { RuntimeUtilities.Destroy(m_InternalSpectralLut); m_InternalSpectralLut = null; } } }

File no 78: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/ColorGrading.cs
using System; using UnityEngine.Experimental.Rendering; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// Color grading modes. /// </summary> public enum GradingMode { /// <summary> /// This mode is aimed at lower-end platforms but it can be used on any platform. Grading is /// applied to the final rendered frame clamped in a [0,1] range and stored in a standard /// LUT. /// </summary> LowDefinitionRange, /// <summary> /// This mode is aimed at platforms that support HDR rendering. All the color operations /// will be applied in HDR and stored into a 3D log-encoded LUT to ensure a sufficient range /// coverage and precision (Alexa LogC El1000). /// </summary> HighDefinitionRange, /// <summary> /// This mode allows you to provide a custom 3D LUT authored in an external software. /// </summary> External } /// <summary> /// Tonemapping methods. /// </summary> public enum Tonemapper { /// <summary> /// No tonemapping will be applied. /// </summary> None, /// <summary> /// This method only does range-remapping with minimal impact on color hue & saturation and /// is generally a great starting point for extensive color grading. /// </summary> Neutral, /// <summary> /// This method uses a close approximation of the reference ACES tonemapper for a more /// filmic look. Because of that, it is more contrasted than <see cref="Neutral"/>and has an /// effect on actual color hue & saturation. Note that if you enable this tonemapper all the /// grading operations will be done in the ACES color spaces for optimal precision and /// results. /// </summary> ACES, /// <summary> /// This method offers a fully parametric, artist-friendly tonemapper. /// </summary> Custom } /// <summary> /// A volume parameter holding a <see cref="GradingMode"/> value. /// </summary> [Serializable] public sealed class GradingModeParameter : ParameterOverride<GradingMode> { } /// <summary> /// A volume parameter holding a <see cref="Tonemapper"/> value. /// </summary> [Serializable] public sealed class TonemapperParameter : ParameterOverride<Tonemapper> {} /// <summary> /// This class holds settings for the Color Grading effect. /// </summary> // TODO: Could use some refactoring, too much duplicated code here [Serializable] [PostProcess(typeof(ColorGradingRenderer), "Unity/Color Grading")] public sealed class ColorGrading : PostProcessEffectSettings { /// <summary> /// The grading mode to use. /// </summary> [DisplayName("Mode"), Tooltip("Select a color grading mode that fits your dynamic range and workflow. Use HDR if your camera is set to render in HDR and your target platform supports it. Use LDR for low-end mobiles or devices that don't support HDR. Use External if you prefer authoring a Log LUT in an external software.")] public GradingModeParameter gradingMode = new GradingModeParameter { value = GradingMode.HighDefinitionRange }; /// <summary> /// A custom 3D log-encoded texture. /// </summary> /// <remarks> /// This is only used when working with <see cref="GradingMode.External"/>. /// </remarks> [DisplayName("Lookup Texture"), Tooltip("A custom 3D log-encoded texture.")] public TextureParameter externalLut = new TextureParameter { value = null }; /// <summary> /// The tonemapping algorithm to use at the end of the color grading process. /// </summary> /// <remarks> /// This is only used when working with <see cref="GradingMode.HighDefinitionRange"/>. /// </remarks> [DisplayName("Mode"), Tooltip("Select a tonemapping algorithm to use at the end of the color grading process.")] public TonemapperParameter tonemapper = new TonemapperParameter { value = Tonemapper.None }; /// <summary> /// Affects the transition between the toe and the mid section of the curve. A value of 0 /// means no toe, a value of 1 means a very hard transition. /// </summary> /// <remarks> /// This is only used when <see cref="Tonemapper.Custom"/> is active. /// </remarks> [DisplayName("Toe Strength"), Range(0f, 1f), Tooltip("Affects the transition between the toe and the mid section of the curve. A value of 0 means no toe, a value of 1 means a very hard transition.")] public FloatParameter toneCurveToeStrength = new FloatParameter { value = 0f }; /// <summary> /// Affects how much of the dynamic range is in the toe. With a small value, the toe will be /// very short and quickly transition into the linear section, and with a longer value /// having a longer toe. /// </summary> /// <remarks> /// This is only used when <see cref="Tonemapper.Custom"/> is active. /// </remarks> [DisplayName("Toe Length"), Range(0f, 1f), Tooltip("Affects how much of the dynamic range is in the toe. With a small value, the toe will be very short and quickly transition into the linear section, with a larger value, the toe will be longer.")] public FloatParameter toneCurveToeLength = new FloatParameter { value = 0.5f }; /// <summary> /// Affects the transition between the mid section and the shoulder of the curve. A value of /// 0 means no shoulder, value of 1 means a very hard transition. /// </summary> /// <remarks> /// This is only used when <see cref="Tonemapper.Custom"/> is active. /// </remarks> [DisplayName("Shoulder Strength"), Range(0f, 1f), Tooltip("Affects the transition between the mid section and the shoulder of the curve. A value of 0 means no shoulder, a value of 1 means a very hard transition.")] public FloatParameter toneCurveShoulderStrength = new FloatParameter { value = 0f }; /// <summary> /// Affects how many F-stops (EV) to add to the dynamic range of the curve. /// </summary> /// <remarks> /// This is only used when <see cref="Tonemapper.Custom"/> is active. /// </remarks> [DisplayName("Shoulder Length"), Min(0f), Tooltip("Affects how many F-stops (EV) to add to the dynamic range of the curve.")] public FloatParameter toneCurveShoulderLength = new FloatParameter { value = 0.5f }; /// <summary> /// Affects how much overshot to add to the shoulder. /// </summary> /// <remarks> /// This is only used when <see cref="Tonemapper.Custom"/> is active. /// </remarks> [DisplayName("Shoulder Angle"), Range(0f, 1f), Tooltip("Affects how much overshoot to add to the shoulder.")] public FloatParameter toneCurveShoulderAngle = new FloatParameter { value = 0f }; /// <summary> /// Applies a gamma function to the curve. /// </summary> /// <remarks> /// This is only used when <see cref="Tonemapper.Custom"/> is active. /// </remarks> [DisplayName("Gamma"), Min(0.001f), Tooltip("Applies a gamma function to the curve.")] public FloatParameter toneCurveGamma = new FloatParameter { value = 1f }; /// <summary> /// A custom lookup texture (strip format, e.g. 256x16) to apply before the rest of the /// color grading operators. If none is provided, a neutral one will be generated /// internally. /// </summary> /// <remarks> /// This is only used when working with <see cref="GradingMode.LowDefinitionRange"/>. /// </remarks> [DisplayName("Lookup Texture"), Tooltip("Custom lookup texture (strip format, for example 256x16) to apply before the rest of the color grading operators. If none is provided, a neutral one will be generated internally.")] public TextureParameter ldrLut = new TextureParameter { value = null, defaultState = TextureParameterDefault.Lut2D }; // LDR only /// <summary> /// How much of the lookup texture will contribute to the color grading. /// </summary> /// <remarks> /// This is only used when working with <see cref="GradingMode.LowDefinitionRange"/>. /// </remarks> [DisplayName("Contribution"), Range(0f, 1f), Tooltip("How much of the lookup texture will contribute to the color grading effect.")] public FloatParameter ldrLutContribution = new FloatParameter { value = 1f }; /// <summary> /// Sets the white balance to a custom color temperature. /// </summary> [DisplayName("Temperature"), Range(-100f, 100f), Tooltip("Sets the white balance to a custom color temperature.")] public FloatParameter temperature = new FloatParameter { value = 0f }; /// <summary> /// Sets the white balance to compensate for a green or magenta tint. /// </summary> [DisplayName("Tint"), Range(-100f, 100f), Tooltip("Sets the white balance to compensate for a green or magenta tint.")] public FloatParameter tint = new FloatParameter { value = 0f }; /// <summary> /// Tints the render by multiplying a color. /// </summary> #if UNITY_2018_1_OR_NEWER [DisplayName("Color Filter"), ColorUsage(false, true), Tooltip("Tint the render by multiplying a color.")] #else [DisplayName("Color Filter"), ColorUsage(false, true, 0f, 8f, 0.125f, 3f), Tooltip("Tint the render by multiplying a color.")] #endif public ColorParameter colorFilter = new ColorParameter { value = Color.white }; /// <summary> /// Shifts the hue of all colors. /// </summary> [DisplayName("Hue Shift"), Range(-180f, 180f), Tooltip("Shift the hue of all colors.")] public FloatParameter hueShift = new FloatParameter { value = 0f }; /// <summary> /// Pushes the intensity of all colors. /// </summary> [DisplayName("Saturation"), Range(-100f, 100f), Tooltip("Pushes the intensity of all colors.")] public FloatParameter saturation = new FloatParameter { value = 0f }; /// <summary> /// Makes the image brighter or darker. /// </summary> /// <remarks> /// This is only used when working with <see cref="GradingMode.LowDefinitionRange"/>. /// </remarks> [DisplayName("Brightness"), Range(-100f, 100f), Tooltip("Makes the image brighter or darker.")] public FloatParameter brightness = new FloatParameter { value = 0f }; // LDR only /// <summary> /// Adjusts the overall exposure of the scene in EV units. This is applied after HDR effect /// and right before tonemapping so it won't affect previous effects in the chain. /// </summary> /// <remarks> /// This is only used when working with <see cref="GradingMode.HighDefinitionRange"/>. /// </remarks> [DisplayName("Post-exposure (EV)"), Tooltip("Adjusts the overall exposure of the scene in EV units. This is applied after the HDR effect and right before tonemapping so it won't affect previous effects in the chain.")] public FloatParameter postExposure = new FloatParameter { value = 0f }; // HDR only /// <summary> /// Expands or shrinks the overall range of tonal values. /// </summary> [DisplayName("Contrast"), Range(-100f, 100f), Tooltip("Expands or shrinks the overall range of tonal values.")] public FloatParameter contrast = new FloatParameter { value = 0f }; /// <summary> /// Modifies the influence of the red channel within the overall mix. /// </summary> [DisplayName("Red"), Range(-200f, 200f), Tooltip("Modify influence of the red channel in the overall mix.")] public FloatParameter mixerRedOutRedIn = new FloatParameter { value = 100f }; /// <summary> /// Modifies the influence of the green channel within the overall mix. /// </summary> [DisplayName("Green"), Range(-200f, 200f), Tooltip("Modify influence of the green channel in the overall mix.")] public FloatParameter mixerRedOutGreenIn = new FloatParameter { value = 0f }; /// <summary> /// Modifies the influence of the blue channel within the overall mix. /// </summary> [DisplayName("Blue"), Range(-200f, 200f), Tooltip("Modify influence of the blue channel in the overall mix.")] public FloatParameter mixerRedOutBlueIn = new FloatParameter { value = 0f }; /// <summary> /// Modifies the influence of the red channel within the overall mix. /// </summary> [DisplayName("Red"), Range(-200f, 200f), Tooltip("Modify influence of the red channel in the overall mix.")] public FloatParameter mixerGreenOutRedIn = new FloatParameter { value = 0f }; /// <summary> /// Modifies the influence of the green channel within the overall mix. /// </summary> [DisplayName("Green"), Range(-200f, 200f), Tooltip("Modify influence of the green channel in the overall mix.")] public FloatParameter mixerGreenOutGreenIn = new FloatParameter { value = 100f }; /// <summary> /// Modifies the influence of the blue channel within the overall mix. /// </summary> [DisplayName("Blue"), Range(-200f, 200f), Tooltip("Modify influence of the blue channel in the overall mix.")] public FloatParameter mixerGreenOutBlueIn = new FloatParameter { value = 0f }; /// <summary> /// Modifies the influence of the red channel within the overall mix. /// </summary> [DisplayName("Red"), Range(-200f, 200f), Tooltip("Modify influence of the red channel in the overall mix.")] public FloatParameter mixerBlueOutRedIn = new FloatParameter { value = 0f }; /// <summary> /// Modifies the influence of the green channel within the overall mix. /// </summary> [DisplayName("Green"), Range(-200f, 200f), Tooltip("Modify influence of the green channel in the overall mix.")] public FloatParameter mixerBlueOutGreenIn = new FloatParameter { value = 0f }; /// <summary> /// Modifies the influence of the blue channel within the overall mix. /// </summary> [DisplayName("Blue"), Range(-200f, 200f), Tooltip("Modify influence of the blue channel in the overall mix.")] public FloatParameter mixerBlueOutBlueIn = new FloatParameter { value = 100f }; /// <summary> /// Controls the darkest portions of the render. /// </summary> /// <remarks> /// The neutral value is <c>(1, 1, 1, 0)</c>. /// </remarks> [DisplayName("Lift"), Tooltip("Controls the darkest portions of the render."), Trackball(TrackballAttribute.Mode.Lift)] public Vector4Parameter lift = new Vector4Parameter { value = new Vector4(1f, 1f, 1f, 0f) }; /// <summary> /// A power function that controls mid-range tones. /// </summary> /// <remarks> /// The neutral value is <c>(1, 1, 1, 0)</c>. /// </remarks> [DisplayName("Gamma"), Tooltip("Power function that controls mid-range tones."), Trackball(TrackballAttribute.Mode.Gamma)] public Vector4Parameter gamma = new Vector4Parameter { value = new Vector4(1f, 1f, 1f, 0f) }; /// <summary> /// Controls the lightest portions of the render. /// </summary> /// <remarks> /// The neutral value is <c>(1, 1, 1, 0)</c>. /// </remarks> [DisplayName("Gain"), Tooltip("Controls the lightest portions of the render."), Trackball(TrackballAttribute.Mode.Gain)] public Vector4Parameter gain = new Vector4Parameter { value = new Vector4(1f, 1f, 1f, 0f) }; /// <summary> /// Remaps the luminosity values. /// </summary> /// <remarks> /// This is only used when working with <see cref="GradingMode.LowDefinitionRange"/>. /// </remarks> public SplineParameter masterCurve = new SplineParameter { value = new Spline(new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, 1f)), 0f, false, new Vector2(0f, 1f)) }; /// <summary> /// Remaps the red channel. /// </summary> /// <remarks> /// This is only used when working with <see cref="GradingMode.LowDefinitionRange"/>. /// </remarks> public SplineParameter redCurve = new SplineParameter { value = new Spline(new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, 1f)), 0f, false, new Vector2(0f, 1f)) }; /// <summary> /// Remaps the green channel/ /// </summary> /// <remarks> /// This is only used when working with <see cref="GradingMode.LowDefinitionRange"/>. /// </remarks> public SplineParameter greenCurve = new SplineParameter { value = new Spline(new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, 1f)), 0f, false, new Vector2(0f, 1f)) }; /// <summary> /// Remaps the blue channel. /// </summary> /// <remarks> /// This is only used when working with <see cref="GradingMode.LowDefinitionRange"/>. /// </remarks> public SplineParameter blueCurve = new SplineParameter { value = new Spline(new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, 1f)), 0f, false, new Vector2(0f, 1f)) }; /// <summary> /// Remaps the hue according to the current hue. /// </summary> public SplineParameter hueVsHueCurve = new SplineParameter { value = new Spline(new AnimationCurve(), 0.5f, true, new Vector2(0f, 1f)) }; /// <summary> /// Remaps the saturation according to the current hue. /// </summary> public SplineParameter hueVsSatCurve = new SplineParameter { value = new Spline(new AnimationCurve(), 0.5f, true, new Vector2(0f, 1f)) }; /// <summary> /// Remaps the saturation according to the current saturation. /// </summary> public SplineParameter satVsSatCurve = new SplineParameter { value = new Spline(new AnimationCurve(), 0.5f, false, new Vector2(0f, 1f)) }; /// <summary> /// Remaps the saturation according to the current luminance. /// </summary> public SplineParameter lumVsSatCurve = new SplineParameter { value = new Spline(new AnimationCurve(), 0.5f, false, new Vector2(0f, 1f)) }; /// <inheritdoc /> public override bool IsEnabledAndSupported(PostProcessRenderContext context) { if (gradingMode.value == GradingMode.External) { if (!SystemInfo.supports3DRenderTextures || !SystemInfo.supportsComputeShaders) return false; } return enabled.value; } } #if UNITY_2017_1_OR_NEWER [UnityEngine.Scripting.Preserve] #endif internal sealed class ColorGradingRenderer : PostProcessEffectRenderer<ColorGrading> { enum Pass { LutGenLDRFromScratch, LutGenLDR, LutGenHDR2D } Texture2D m_GradingCurves; readonly Color[] m_Pixels = new Color[Spline.k_Precision * 2]; // Avoids GC stress RenderTexture m_InternalLdrLut; RenderTexture m_InternalLogLut; const int k_Lut2DSize = 32; const int k_Lut3DSize = 33; readonly HableCurve m_HableCurve = new HableCurve(); public override void Render(PostProcessRenderContext context) { var gradingMode = settings.gradingMode.value; var supportComputeTex3D = SystemInfo.supports3DRenderTextures && SystemInfo.supportsComputeShaders && context.resources.computeShaders.lut3DBaker != null && SystemInfo.graphicsDeviceType != GraphicsDeviceType.OpenGLCore && SystemInfo.graphicsDeviceType != GraphicsDeviceType.OpenGLES3; if (gradingMode == GradingMode.External) RenderExternalPipeline3D(context); else if (gradingMode == GradingMode.HighDefinitionRange && supportComputeTex3D) RenderHDRPipeline3D(context); else if (gradingMode == GradingMode.HighDefinitionRange) RenderHDRPipeline2D(context); else RenderLDRPipeline2D(context); } // Do color grading using an externally authored 3D lut; it requires Texture3D support and // compute shaders in case blending is required - Desktop / Consoles / Some high-end mobiles void RenderExternalPipeline3D(PostProcessRenderContext context) { var lut = settings.externalLut.value; if (lut == null) return; var uberSheet = context.uberSheet; uberSheet.EnableKeyword("COLOR_GRADING_HDR_3D"); uberSheet.properties.SetTexture(ShaderIDs.Lut3D, lut); uberSheet.properties.SetVector(ShaderIDs.Lut3D_Params, new Vector2(1f / lut.width, lut.width - 1f)); uberSheet.properties.SetFloat(ShaderIDs.PostExposure, RuntimeUtilities.Exp2(settings.postExposure.value)); context.logLut = lut; } // HDR color pipeline is rendered to a 3D lut; it requires Texture3D & compute shaders // support - Desktop / Consoles / Some high-end mobiles // TODO: Use ShaderIDs for compute once the compatible APIs go in void RenderHDRPipeline3D(PostProcessRenderContext context) { // Unfortunately because AnimationCurve doesn't implement GetHashCode and we don't have // any reliable way to figure out if a curve data is different from another one we can't // skip regenerating the Lut if nothing has changed. So it has to be done on every // frame... // It's not a very expensive operation anyway (we're talking about filling a 33x33x33 // Lut on the GPU) but every little thing helps, especially on mobile. { CheckInternalLogLut(); // Lut setup var compute = context.resources.computeShaders.lut3DBaker; int kernel = 0; switch (settings.tonemapper.value) { case Tonemapper.None: kernel = compute.FindKernel("KGenLut3D_NoTonemap"); break; case Tonemapper.Neutral: kernel = compute.FindKernel("KGenLut3D_NeutralTonemap"); break; case Tonemapper.ACES: kernel = compute.FindKernel("KGenLut3D_AcesTonemap"); break; case Tonemapper.Custom: kernel = compute.FindKernel("KGenLut3D_CustomTonemap"); break; } var cmd = context.command; cmd.SetComputeTextureParam(compute, kernel, "_Output", m_InternalLogLut); cmd.SetComputeVectorParam(compute, "_Size", new Vector4(k_Lut3DSize, 1f / (k_Lut3DSize - 1f), 0f, 0f)); var colorBalance = ColorUtilities.ComputeColorBalance(settings.temperature.value, settings.tint.value); cmd.SetComputeVectorParam(compute, "_ColorBalance", colorBalance); cmd.SetComputeVectorParam(compute, "_ColorFilter", settings.colorFilter.value); float hue = settings.hueShift.value / 360f; // Remap to [-0.5;0.5] float sat = settings.saturation.value / 100f + 1f; // Remap to [0;2] float con = settings.contrast.value / 100f + 1f; // Remap to [0;2] cmd.SetComputeVectorParam(compute, "_HueSatCon", new Vector4(hue, sat, con, 0f)); var channelMixerR = new Vector4(settings.mixerRedOutRedIn, settings.mixerRedOutGreenIn, settings.mixerRedOutBlueIn, 0f); var channelMixerG = new Vector4(settings.mixerGreenOutRedIn, settings.mixerGreenOutGreenIn, settings.mixerGreenOutBlueIn, 0f); var channelMixerB = new Vector4(settings.mixerBlueOutRedIn, settings.mixerBlueOutGreenIn, settings.mixerBlueOutBlueIn, 0f); cmd.SetComputeVectorParam(compute, "_ChannelMixerRed", channelMixerR / 100f); // Remap to [-2;2] cmd.SetComputeVectorParam(compute, "_ChannelMixerGreen", channelMixerG / 100f); cmd.SetComputeVectorParam(compute, "_ChannelMixerBlue", channelMixerB / 100f); var lift = ColorUtilities.ColorToLift(settings.lift.value * 0.2f); var gain = ColorUtilities.ColorToGain(settings.gain.value * 0.8f); var invgamma = ColorUtilities.ColorToInverseGamma(settings.gamma.value * 0.8f); cmd.SetComputeVectorParam(compute, "_Lift", new Vector4(lift.x, lift.y, lift.z, 0f)); cmd.SetComputeVectorParam(compute, "_InvGamma", new Vector4(invgamma.x, invgamma.y, invgamma.z, 0f)); cmd.SetComputeVectorParam(compute, "_Gain", new Vector4(gain.x, gain.y, gain.z, 0f)); cmd.SetComputeTextureParam(compute, kernel, "_Curves", GetCurveTexture(true)); if (settings.tonemapper.value == Tonemapper.Custom) { m_HableCurve.Init( settings.toneCurveToeStrength.value, settings.toneCurveToeLength.value, settings.toneCurveShoulderStrength.value, settings.toneCurveShoulderLength.value, settings.toneCurveShoulderAngle.value, settings.toneCurveGamma.value ); cmd.SetComputeVectorParam(compute, "_CustomToneCurve", m_HableCurve.uniforms.curve); cmd.SetComputeVectorParam(compute, "_ToeSegmentA", m_HableCurve.uniforms.toeSegmentA); cmd.SetComputeVectorParam(compute, "_ToeSegmentB", m_HableCurve.uniforms.toeSegmentB); cmd.SetComputeVectorParam(compute, "_MidSegmentA", m_HableCurve.uniforms.midSegmentA); cmd.SetComputeVectorParam(compute, "_MidSegmentB", m_HableCurve.uniforms.midSegmentB); cmd.SetComputeVectorParam(compute, "_ShoSegmentA", m_HableCurve.uniforms.shoSegmentA); cmd.SetComputeVectorParam(compute, "_ShoSegmentB", m_HableCurve.uniforms.shoSegmentB); } // Generate the lut context.command.BeginSample("HdrColorGradingLut3D"); int groupSize = Mathf.CeilToInt(k_Lut3DSize / 4f); cmd.DispatchCompute(compute, kernel, groupSize, groupSize, groupSize); context.command.EndSample("HdrColorGradingLut3D"); } var lut = m_InternalLogLut; var uberSheet = context.uberSheet; uberSheet.EnableKeyword("COLOR_GRADING_HDR_3D"); uberSheet.properties.SetTexture(ShaderIDs.Lut3D, lut); uberSheet.properties.SetVector(ShaderIDs.Lut3D_Params, new Vector2(1f / lut.width, lut.width - 1f)); uberSheet.properties.SetFloat(ShaderIDs.PostExposure, RuntimeUtilities.Exp2(settings.postExposure.value)); context.logLut = lut; } // HDR color pipeline is rendered to a 2D strip lut (works on HDR platforms without compute // and 3D texture support). Precision is sliiiiiiightly lower than when using a 3D texture // LUT (33^3 -> 32^3) but most of the time it's imperceptible. void RenderHDRPipeline2D(PostProcessRenderContext context) { // For the same reasons as in RenderHDRPipeline3D, regen LUT on every frame { CheckInternalStripLut(); // Lut setup var lutSheet = context.propertySheets.Get(context.resources.shaders.lut2DBaker); lutSheet.ClearKeywords(); lutSheet.properties.SetVector(ShaderIDs.Lut2D_Params, new Vector4(k_Lut2DSize, 0.5f / (k_Lut2DSize * k_Lut2DSize), 0.5f / k_Lut2DSize, k_Lut2DSize / (k_Lut2DSize - 1f))); var colorBalance = ColorUtilities.ComputeColorBalance(settings.temperature.value, settings.tint.value); lutSheet.properties.SetVector(ShaderIDs.ColorBalance, colorBalance); lutSheet.properties.SetVector(ShaderIDs.ColorFilter, settings.colorFilter.value); float hue = settings.hueShift.value / 360f; // Remap to [-0.5;0.5] float sat = settings.saturation.value / 100f + 1f; // Remap to [0;2] float con = settings.contrast.value / 100f + 1f; // Remap to [0;2] lutSheet.properties.SetVector(ShaderIDs.HueSatCon, new Vector3(hue, sat, con)); var channelMixerR = new Vector3(settings.mixerRedOutRedIn, settings.mixerRedOutGreenIn, settings.mixerRedOutBlueIn); var channelMixerG = new Vector3(settings.mixerGreenOutRedIn, settings.mixerGreenOutGreenIn, settings.mixerGreenOutBlueIn); var channelMixerB = new Vector3(settings.mixerBlueOutRedIn, settings.mixerBlueOutGreenIn, settings.mixerBlueOutBlueIn); lutSheet.properties.SetVector(ShaderIDs.ChannelMixerRed, channelMixerR / 100f); // Remap to [-2;2] lutSheet.properties.SetVector(ShaderIDs.ChannelMixerGreen, channelMixerG / 100f); lutSheet.properties.SetVector(ShaderIDs.ChannelMixerBlue, channelMixerB / 100f); var lift = ColorUtilities.ColorToLift(settings.lift.value * 0.2f); var gain = ColorUtilities.ColorToGain(settings.gain.value * 0.8f); var invgamma = ColorUtilities.ColorToInverseGamma(settings.gamma.value * 0.8f); lutSheet.properties.SetVector(ShaderIDs.Lift, lift); lutSheet.properties.SetVector(ShaderIDs.InvGamma, invgamma); lutSheet.properties.SetVector(ShaderIDs.Gain, gain); lutSheet.properties.SetTexture(ShaderIDs.Curves, GetCurveTexture(true)); var tonemapper = settings.tonemapper.value; if (tonemapper == Tonemapper.Custom) { lutSheet.EnableKeyword("TONEMAPPING_CUSTOM"); m_HableCurve.Init( settings.toneCurveToeStrength.value, settings.toneCurveToeLength.value, settings.toneCurveShoulderStrength.value, settings.toneCurveShoulderLength.value, settings.toneCurveShoulderAngle.value, settings.toneCurveGamma.value ); lutSheet.properties.SetVector(ShaderIDs.CustomToneCurve, m_HableCurve.uniforms.curve); lutSheet.properties.SetVector(ShaderIDs.ToeSegmentA, m_HableCurve.uniforms.toeSegmentA); lutSheet.properties.SetVector(ShaderIDs.ToeSegmentB, m_HableCurve.uniforms.toeSegmentB); lutSheet.properties.SetVector(ShaderIDs.MidSegmentA, m_HableCurve.uniforms.midSegmentA); lutSheet.properties.SetVector(ShaderIDs.MidSegmentB, m_HableCurve.uniforms.midSegmentB); lutSheet.properties.SetVector(ShaderIDs.ShoSegmentA, m_HableCurve.uniforms.shoSegmentA); lutSheet.properties.SetVector(ShaderIDs.ShoSegmentB, m_HableCurve.uniforms.shoSegmentB); } else if (tonemapper == Tonemapper.ACES) lutSheet.EnableKeyword("TONEMAPPING_ACES"); else if (tonemapper == Tonemapper.Neutral) lutSheet.EnableKeyword("TONEMAPPING_NEUTRAL"); // Generate the lut context.command.BeginSample("HdrColorGradingLut2D"); context.command.BlitFullscreenTriangle(BuiltinRenderTextureType.None, m_InternalLdrLut, lutSheet, (int)Pass.LutGenHDR2D); context.command.EndSample("HdrColorGradingLut2D"); } var lut = m_InternalLdrLut; var uberSheet = context.uberSheet; uberSheet.EnableKeyword("COLOR_GRADING_HDR_2D"); uberSheet.properties.SetVector(ShaderIDs.Lut2D_Params, new Vector3(1f / lut.width, 1f / lut.height, lut.height - 1f)); uberSheet.properties.SetTexture(ShaderIDs.Lut2D, lut); uberSheet.properties.SetFloat(ShaderIDs.PostExposure, RuntimeUtilities.Exp2(settings.postExposure.value)); } // LDR color pipeline is rendered to a 2D strip lut (works on every platform) void RenderLDRPipeline2D(PostProcessRenderContext context) { // For the same reasons as in RenderHDRPipeline3D, regen LUT on every frame { CheckInternalStripLut(); // Lut setup var lutSheet = context.propertySheets.Get(context.resources.shaders.lut2DBaker); lutSheet.ClearKeywords(); lutSheet.properties.SetVector(ShaderIDs.Lut2D_Params, new Vector4(k_Lut2DSize, 0.5f / (k_Lut2DSize * k_Lut2DSize), 0.5f / k_Lut2DSize, k_Lut2DSize / (k_Lut2DSize - 1f))); var colorBalance = ColorUtilities.ComputeColorBalance(settings.temperature.value, settings.tint.value); lutSheet.properties.SetVector(ShaderIDs.ColorBalance, colorBalance); lutSheet.properties.SetVector(ShaderIDs.ColorFilter, settings.colorFilter.value); float hue = settings.hueShift.value / 360f; // Remap to [-0.5;0.5] float sat = settings.saturation.value / 100f + 1f; // Remap to [0;2] float con = settings.contrast.value / 100f + 1f; // Remap to [0;2] lutSheet.properties.SetVector(ShaderIDs.HueSatCon, new Vector3(hue, sat, con)); var channelMixerR = new Vector3(settings.mixerRedOutRedIn, settings.mixerRedOutGreenIn, settings.mixerRedOutBlueIn); var channelMixerG = new Vector3(settings.mixerGreenOutRedIn, settings.mixerGreenOutGreenIn, settings.mixerGreenOutBlueIn); var channelMixerB = new Vector3(settings.mixerBlueOutRedIn, settings.mixerBlueOutGreenIn, settings.mixerBlueOutBlueIn); lutSheet.properties.SetVector(ShaderIDs.ChannelMixerRed, channelMixerR / 100f); // Remap to [-2;2] lutSheet.properties.SetVector(ShaderIDs.ChannelMixerGreen, channelMixerG / 100f); lutSheet.properties.SetVector(ShaderIDs.ChannelMixerBlue, channelMixerB / 100f); var lift = ColorUtilities.ColorToLift(settings.lift.value); var gain = ColorUtilities.ColorToGain(settings.gain.value); var invgamma = ColorUtilities.ColorToInverseGamma(settings.gamma.value); lutSheet.properties.SetVector(ShaderIDs.Lift, lift); lutSheet.properties.SetVector(ShaderIDs.InvGamma, invgamma); lutSheet.properties.SetVector(ShaderIDs.Gain, gain); lutSheet.properties.SetFloat(ShaderIDs.Brightness, (settings.brightness.value + 100f) / 100f); lutSheet.properties.SetTexture(ShaderIDs.Curves, GetCurveTexture(false)); // Generate the lut context.command.BeginSample("LdrColorGradingLut2D"); var userLut = settings.ldrLut.value; if (userLut == null || userLut.width != userLut.height * userLut.height) { context.command.BlitFullscreenTriangle(BuiltinRenderTextureType.None, m_InternalLdrLut, lutSheet, (int)Pass.LutGenLDRFromScratch); } else { lutSheet.properties.SetVector(ShaderIDs.UserLut2D_Params, new Vector4(1f / userLut.width, 1f / userLut.height, userLut.height - 1f, settings.ldrLutContribution)); context.command.BlitFullscreenTriangle(userLut, m_InternalLdrLut, lutSheet, (int)Pass.LutGenLDR); } context.command.EndSample("LdrColorGradingLut2D"); } var lut = m_InternalLdrLut; var uberSheet = context.uberSheet; uberSheet.EnableKeyword("COLOR_GRADING_LDR_2D"); uberSheet.properties.SetVector(ShaderIDs.Lut2D_Params, new Vector3(1f / lut.width, 1f / lut.height, lut.height - 1f)); uberSheet.properties.SetTexture(ShaderIDs.Lut2D, lut); } void CheckInternalLogLut() { // Check internal lut state, (re)create it if needed if (m_InternalLogLut == null || !m_InternalLogLut.IsCreated()) { RuntimeUtilities.Destroy(m_InternalLogLut); var format = GetLutFormat(); m_InternalLogLut = new RenderTexture(k_Lut3DSize, k_Lut3DSize, 0, format, RenderTextureReadWrite.Linear) { name = "Color Grading Log Lut", dimension = TextureDimension.Tex3D, hideFlags = HideFlags.DontSave, filterMode = FilterMode.Bilinear, wrapMode = TextureWrapMode.Clamp, anisoLevel = 0, enableRandomWrite = true, volumeDepth = k_Lut3DSize, autoGenerateMips = false, useMipMap = false }; m_InternalLogLut.Create(); } } void CheckInternalStripLut() { // Check internal lut state, (re)create it if needed if (m_InternalLdrLut == null || !m_InternalLdrLut.IsCreated()) { RuntimeUtilities.Destroy(m_InternalLdrLut); var format = GetLutFormat(); m_InternalLdrLut = new RenderTexture(k_Lut2DSize * k_Lut2DSize, k_Lut2DSize, 0, format, RenderTextureReadWrite.Linear) { name = "Color Grading Strip Lut", hideFlags = HideFlags.DontSave, filterMode = FilterMode.Bilinear, wrapMode = TextureWrapMode.Clamp, anisoLevel = 0, autoGenerateMips = false, useMipMap = false }; m_InternalLdrLut.Create(); } } Texture2D GetCurveTexture(bool hdr) { if (m_GradingCurves == null) { var format = GetCurveFormat(); m_GradingCurves = new Texture2D(Spline.k_Precision, 2, format, false, true) { name = "Internal Curves Texture", hideFlags = HideFlags.DontSave, anisoLevel = 0, wrapMode = TextureWrapMode.Clamp, filterMode = FilterMode.Bilinear }; } var hueVsHueCurve = settings.hueVsHueCurve.value; var hueVsSatCurve = settings.hueVsSatCurve.value; var satVsSatCurve = settings.satVsSatCurve.value; var lumVsSatCurve = settings.lumVsSatCurve.value; var masterCurve = settings.masterCurve.value; var redCurve = settings.redCurve.value; var greenCurve = settings.greenCurve.value; var blueCurve = settings.blueCurve.value; var pixels = m_Pixels; for (int i = 0; i < Spline.k_Precision; i++) { // Secondary/VS curves float x = hueVsHueCurve.cachedData[i]; float y = hueVsSatCurve.cachedData[i]; float z = satVsSatCurve.cachedData[i]; float w = lumVsSatCurve.cachedData[i]; pixels[i] = new Color(x, y, z, w); // YRGB if (!hdr) { float m = masterCurve.cachedData[i]; float r = redCurve.cachedData[i]; float g = greenCurve.cachedData[i]; float b = blueCurve.cachedData[i]; pixels[i + Spline.k_Precision] = new Color(r, g, b, m); } } m_GradingCurves.SetPixels(pixels); m_GradingCurves.Apply(false, false); return m_GradingCurves; } static bool IsRenderTextureFormatSupportedForLinearFiltering(RenderTextureFormat format) { #if UNITY_2019_1_OR_NEWER var gFormat = GraphicsFormatUtility.GetGraphicsFormat(format, RenderTextureReadWrite.Linear); return SystemInfo.IsFormatSupported(gFormat, FormatUsage.Linear); #else // No good/fast way to test it on pre-2019.1 return format.IsSupported(); #endif } static RenderTextureFormat GetLutFormat() { // Use ARGBHalf if possible, fallback on ARGB2101010 and ARGB32 otherwise var format = RenderTextureFormat.ARGBHalf; if (!IsRenderTextureFormatSupportedForLinearFiltering(format)) { format = RenderTextureFormat.ARGB2101010; // Note that using a log lut in ARGB32 is a *very* bad idea but we need it for // compatibility reasons (else if a platform doesn't support one of the previous // format it'll output a black screen, or worse will segfault on the user). if (!IsRenderTextureFormatSupportedForLinearFiltering(format)) format = RenderTextureFormat.ARGB32; } return format; } static TextureFormat GetCurveFormat() { // Use RGBAHalf if possible, fallback on ARGB32 otherwise var format = TextureFormat.RGBAHalf; if (!SystemInfo.SupportsTextureFormat(format)) format = TextureFormat.ARGB32; return format; } public override void Release() { RuntimeUtilities.Destroy(m_InternalLdrLut); m_InternalLdrLut = null; RuntimeUtilities.Destroy(m_InternalLogLut); m_InternalLogLut = null; RuntimeUtilities.Destroy(m_GradingCurves); m_GradingCurves = null; } } }

File no 79: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/DepthOfField.cs
using System; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// Convolution kernel size for the Depth of Field effect. /// </summary> public enum KernelSize { /// <summary> /// Small filter. /// </summary> Small, /// <summary> /// Medium filter. /// </summary> Medium, /// <summary> /// Large filter. /// </summary> Large, /// <summary> /// Very large filter. /// </summary> VeryLarge } /// <summary> /// A volume parameter holding a <see cref="KernelSize"/> value. /// </summary> [Serializable] public sealed class KernelSizeParameter : ParameterOverride<KernelSize> {} /// <summary> /// This class holds settings for the Depth of Field effect. /// </summary> [Serializable] [PostProcess(typeof(DepthOfFieldRenderer), "Unity/Depth of Field", false)] public sealed class DepthOfField : PostProcessEffectSettings { /// <summary> /// The distance to the point of focus. /// </summary> [Min(0.1f), Tooltip("Distance to the point of focus.")] public FloatParameter focusDistance = new FloatParameter { value = 10f }; /// <summary> /// The ratio of the aperture (known as f-stop or f-number). The smaller the value is, the /// shallower the depth of field is. /// </summary> [Range(0.05f, 32f), Tooltip("Ratio of aperture (known as f-stop or f-number). The smaller the value is, the shallower the depth of field is.")] public FloatParameter aperture = new FloatParameter { value = 5.6f }; /// <summary> /// The distance between the lens and the film. The larger the value is, the shallower the /// depth of field is. /// </summary> [Range(1f, 300f), Tooltip("Distance between the lens and the film. The larger the value is, the shallower the depth of field is.")] public FloatParameter focalLength = new FloatParameter { value = 50f }; /// <summary> /// The convolution kernel size of the bokeh filter, which determines the maximum radius of /// bokeh. It also affects the performance (the larger the kernel is, the longer the GPU /// time is required). /// </summary> [DisplayName("Max Blur Size"), Tooltip("Convolution kernel size of the bokeh filter, which determines the maximum radius of bokeh. It also affects performances (the larger the kernel is, the longer the GPU time is required).")] public KernelSizeParameter kernelSize = new KernelSizeParameter { value = KernelSize.Medium }; /// <inheritdoc /> public override bool IsEnabledAndSupported(PostProcessRenderContext context) { return enabled.value && SystemInfo.graphicsShaderLevel >= 35; } } #if UNITY_2017_1_OR_NEWER [UnityEngine.Scripting.Preserve] #endif // TODO: Doesn't play nice with alpha propagation, see if it can be fixed without killing performances internal sealed class DepthOfFieldRenderer : PostProcessEffectRenderer<DepthOfField> { enum Pass { CoCCalculation, CoCTemporalFilter, DownsampleAndPrefilter, BokehSmallKernel, BokehMediumKernel, BokehLargeKernel, BokehVeryLargeKernel, PostFilter, Combine, DebugOverlay } // Ping-pong between two history textures as we can't read & write the same target in the // same pass const int k_NumEyes = 2; const int k_NumCoCHistoryTextures = 2; readonly RenderTexture[][] m_CoCHistoryTextures = new RenderTexture[k_NumEyes][]; int[] m_HistoryPingPong = new int[k_NumEyes]; // Height of the 35mm full-frame format (36mm x 24mm) // TODO: Should be set by a physical camera const float k_FilmHeight = 0.024f; public DepthOfFieldRenderer() { for (int eye = 0; eye < k_NumEyes; eye++) { m_CoCHistoryTextures[eye] = new RenderTexture[k_NumCoCHistoryTextures]; m_HistoryPingPong[eye] = 0; } } public override DepthTextureMode GetCameraFlags() { return DepthTextureMode.Depth; } RenderTextureFormat SelectFormat(RenderTextureFormat primary, RenderTextureFormat secondary) { if (primary.IsSupported()) return primary; if (secondary.IsSupported()) return secondary; return RenderTextureFormat.Default; } float CalculateMaxCoCRadius(int screenHeight) { // Estimate the allowable maximum radius of CoC from the kernel // size (the equation below was empirically derived). float radiusInPixels = (float)settings.kernelSize.value * 4f + 6f; // Applying a 5% limit to the CoC radius to keep the size of // TileMax/NeighborMax small enough. return Mathf.Min(0.05f, radiusInPixels / screenHeight); } RenderTexture CheckHistory(int eye, int id, PostProcessRenderContext context, RenderTextureFormat format) { var rt = m_CoCHistoryTextures[eye][id]; if (m_ResetHistory || rt == null || !rt.IsCreated() || rt.width != context.width || rt.height != context.height) { RenderTexture.ReleaseTemporary(rt); rt = context.GetScreenSpaceTemporaryRT(0, format, RenderTextureReadWrite.Linear); rt.name = "CoC History, Eye: " + eye + ", ID: " + id; rt.filterMode = FilterMode.Bilinear; rt.Create(); m_CoCHistoryTextures[eye][id] = rt; } return rt; } public override void Render(PostProcessRenderContext context) { // The coc is stored in alpha so we need a 4 channels target. Note that using ARGB32 // will result in a very weak near-blur. var colorFormat = context.camera.allowHDR ? RenderTextureFormat.ARGBHalf : RenderTextureFormat.ARGB32; var cocFormat = SelectFormat(RenderTextureFormat.R8, RenderTextureFormat.RHalf); // Avoid using R8 on OSX with Metal. #896121, https://goo.gl/MgKqu6 #if (UNITY_EDITOR_OSX || UNITY_STANDALONE_OSX) && !UNITY_2017_1_OR_NEWER if (SystemInfo.graphicsDeviceType == UnityEngine.Rendering.GraphicsDeviceType.Metal) cocFormat = SelectFormat(RenderTextureFormat.RHalf, RenderTextureFormat.Default); #endif // Material setup float scaledFilmHeight = k_FilmHeight * (context.height / 1080f); var f = settings.focalLength.value / 1000f; var s1 = Mathf.Max(settings.focusDistance.value, f); var aspect = (float)context.screenWidth / (float)context.screenHeight; var coeff = f * f / (settings.aperture.value * (s1 - f) * scaledFilmHeight * 2f); var maxCoC = CalculateMaxCoCRadius(context.screenHeight); var sheet = context.propertySheets.Get(context.resources.shaders.depthOfField); sheet.properties.Clear(); sheet.properties.SetFloat(ShaderIDs.Distance, s1); sheet.properties.SetFloat(ShaderIDs.LensCoeff, coeff); sheet.properties.SetFloat(ShaderIDs.MaxCoC, maxCoC); sheet.properties.SetFloat(ShaderIDs.RcpMaxCoC, 1f / maxCoC); sheet.properties.SetFloat(ShaderIDs.RcpAspect, 1f / aspect); var cmd = context.command; cmd.BeginSample("DepthOfField"); // CoC calculation pass context.GetScreenSpaceTemporaryRT(cmd, ShaderIDs.CoCTex, 0, cocFormat, RenderTextureReadWrite.Linear); cmd.BlitFullscreenTriangle(BuiltinRenderTextureType.None, ShaderIDs.CoCTex, sheet, (int)Pass.CoCCalculation); // CoC temporal filter pass when TAA is enabled if (context.IsTemporalAntialiasingActive()) { float motionBlending = context.temporalAntialiasing.motionBlending; float blend = m_ResetHistory ? 0f : motionBlending; // Handles first frame blending var jitter = context.temporalAntialiasing.jitter; sheet.properties.SetVector(ShaderIDs.TaaParams, new Vector3(jitter.x, jitter.y, blend)); int pp = m_HistoryPingPong[context.xrActiveEye]; var historyRead = CheckHistory(context.xrActiveEye, ++pp % 2, context, cocFormat); var historyWrite = CheckHistory(context.xrActiveEye, ++pp % 2, context, cocFormat); m_HistoryPingPong[context.xrActiveEye] = ++pp % 2; cmd.BlitFullscreenTriangle(historyRead, historyWrite, sheet, (int)Pass.CoCTemporalFilter); cmd.ReleaseTemporaryRT(ShaderIDs.CoCTex); cmd.SetGlobalTexture(ShaderIDs.CoCTex, historyWrite); } // Downsampling and prefiltering pass context.GetScreenSpaceTemporaryRT(cmd, ShaderIDs.DepthOfFieldTex, 0, colorFormat, RenderTextureReadWrite.Default, FilterMode.Bilinear, context.width / 2, context.height / 2); cmd.BlitFullscreenTriangle(context.source, ShaderIDs.DepthOfFieldTex, sheet, (int)Pass.DownsampleAndPrefilter); // Bokeh simulation pass context.GetScreenSpaceTemporaryRT(cmd, ShaderIDs.DepthOfFieldTemp, 0, colorFormat, RenderTextureReadWrite.Default, FilterMode.Bilinear, context.width / 2, context.height / 2); cmd.BlitFullscreenTriangle(ShaderIDs.DepthOfFieldTex, ShaderIDs.DepthOfFieldTemp, sheet, (int)Pass.BokehSmallKernel + (int)settings.kernelSize.value); // Postfilter pass cmd.BlitFullscreenTriangle(ShaderIDs.DepthOfFieldTemp, ShaderIDs.DepthOfFieldTex, sheet, (int)Pass.PostFilter); cmd.ReleaseTemporaryRT(ShaderIDs.DepthOfFieldTemp); // Debug overlay pass if (context.IsDebugOverlayEnabled(DebugOverlay.DepthOfField)) context.PushDebugOverlay(cmd, context.source, sheet, (int)Pass.DebugOverlay); // Combine pass cmd.BlitFullscreenTriangle(context.source, context.destination, sheet, (int)Pass.Combine); cmd.ReleaseTemporaryRT(ShaderIDs.DepthOfFieldTex); if (!context.IsTemporalAntialiasingActive()) cmd.ReleaseTemporaryRT(ShaderIDs.CoCTex); cmd.EndSample("DepthOfField"); m_ResetHistory = false; } public override void Release() { for (int eye = 0; eye < k_NumEyes; eye++) { for (int i = 0; i < m_CoCHistoryTextures[eye].Length; i++) { RenderTexture.ReleaseTemporary(m_CoCHistoryTextures[eye][i]); m_CoCHistoryTextures[eye][i] = null; } m_HistoryPingPong[eye] = 0; } ResetHistory(); } } }

File no 80: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/Dithering.cs
using System; using UnityEngine.Assertions; namespace UnityEngine.Rendering.PostProcessing { #if UNITY_2017_1_OR_NEWER [UnityEngine.Scripting.Preserve] #endif [Serializable] internal sealed class Dithering { int m_NoiseTextureIndex = 0; internal void Render(PostProcessRenderContext context) { var blueNoise = context.resources.blueNoise64; Assert.IsTrue(blueNoise != null && blueNoise.Length > 0); #if POSTFX_DEBUG_STATIC_DITHERING // Used by QA for automated testing m_NoiseTextureIndex = 0; float rndOffsetX = 0f; float rndOffsetY = 0f; #else if (++m_NoiseTextureIndex >= blueNoise.Length) m_NoiseTextureIndex = 0; float rndOffsetX = Random.value; float rndOffsetY = Random.value; #endif var noiseTex = blueNoise[m_NoiseTextureIndex]; var uberSheet = context.uberSheet; uberSheet.properties.SetTexture(ShaderIDs.DitheringTex, noiseTex); uberSheet.properties.SetVector(ShaderIDs.Dithering_Coords, new Vector4( (float)context.screenWidth / (float)noiseTex.width, (float)context.screenHeight / (float)noiseTex.height, rndOffsetX, rndOffsetY )); } } }

File no 81: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/FastApproximateAntialiasing.cs
using System; using UnityEngine.Serialization; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// This class holds settings for the Fast Approximate Anti-aliasing (FXAA) effect. /// </summary> #if UNITY_2017_1_OR_NEWER [UnityEngine.Scripting.Preserve] #endif [Serializable] public sealed class FastApproximateAntialiasing { /// <summary> /// If <c>true</c>, it will use a slightly lower quality but faster variant of FXAA. Highly /// recommended on mobile platforms. /// </summary> [FormerlySerializedAs("mobileOptimized")] [Tooltip("Boost performances by lowering the effect quality. This setting is meant to be used on mobile and other low-end platforms but can also provide a nice performance boost on desktops and consoles.")] public bool fastMode = false; /// <summary> /// Set this to <c>true</c> if you need to keep the alpha channel untouched. Else it will /// use this channel to store internal data used to speed up and improve visual quality. /// </summary> [Tooltip("Keep alpha channel. This will slightly lower the effect quality but allows rendering against a transparent background.")] public bool keepAlpha = false; } }

File no 82: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/Fog.cs
using System; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// This class holds settings for the Fog effect with the deferred rendering path. /// </summary> #if UNITY_2017_1_OR_NEWER [UnityEngine.Scripting.Preserve] #endif [Serializable] public sealed class Fog { /// <summary> /// If <c>true</c>, enables the internal deferred fog pass. Actual fog settings should be /// set in the Lighting panel. /// </summary> [Tooltip("Enables the internal deferred fog pass. Actual fog settings should be set in the Lighting panel.")] public bool enabled = true; /// <summary> /// Should the fog affect the skybox? /// </summary> [Tooltip("Mark true for the fog to ignore the skybox")] public bool excludeSkybox = true; internal DepthTextureMode GetCameraFlags() { return DepthTextureMode.Depth; } internal bool IsEnabledAndSupported(PostProcessRenderContext context) { return enabled && RenderSettings.fog && !RuntimeUtilities.scriptableRenderPipelineActive && context.resources.shaders.deferredFog && context.resources.shaders.deferredFog.isSupported && context.camera.actualRenderingPath == RenderingPath.DeferredShading; // In forward fog is already done at shader level } internal void Render(PostProcessRenderContext context) { var sheet = context.propertySheets.Get(context.resources.shaders.deferredFog); sheet.ClearKeywords(); var fogColor = RuntimeUtilities.isLinearColorSpace ? RenderSettings.fogColor.linear : RenderSettings.fogColor; sheet.properties.SetVector(ShaderIDs.FogColor, fogColor); sheet.properties.SetVector(ShaderIDs.FogParams, new Vector3(RenderSettings.fogDensity, RenderSettings.fogStartDistance, RenderSettings.fogEndDistance)); var cmd = context.command; cmd.BlitFullscreenTriangle(context.source, context.destination, sheet, excludeSkybox ? 1 : 0); } } }

File no 83: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/Grain.cs
using System; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// This class holds settings for the Grain effect. /// </summary> [Serializable] [PostProcess(typeof(GrainRenderer), "Unity/Grain")] public sealed class Grain : PostProcessEffectSettings { /// <summary> /// Set to <c>true</c> to render colored grain, <c>false</c> for grayscale grain. /// </summary> [Tooltip("Enable the use of colored grain.")] public BoolParameter colored = new BoolParameter { value = true }; /// <summary> /// The strength (or visibility) of the Grain effect on screen. Higher values mean more visible grain. /// </summary> [Range(0f, 1f), Tooltip("Grain strength. Higher values mean more visible grain.")] public FloatParameter intensity = new FloatParameter { value = 0f }; /// <summary> /// The size of grain particle on screen. /// </summary> [Range(0.3f, 3f), Tooltip("Grain particle size.")] public FloatParameter size = new FloatParameter { value = 1f }; /// <summary> /// Controls the noisiness response curve based on scene luminance. Lower values mean less noise in dark areas. /// </summary> [Range(0f, 1f), DisplayName("Luminance Contribution"), Tooltip("Controls the noise response curve based on scene luminance. Lower values mean less noise in dark areas.")] public FloatParameter lumContrib = new FloatParameter { value = 0.8f }; /// <inheritdoc /> public override bool IsEnabledAndSupported(PostProcessRenderContext context) { return enabled.value && intensity.value > 0f; } } #if POSTFX_DEBUG_STATIC_GRAIN #pragma warning disable 414 #endif #if UNITY_2017_1_OR_NEWER [UnityEngine.Scripting.Preserve] #endif internal sealed class GrainRenderer : PostProcessEffectRenderer<Grain> { RenderTexture m_GrainLookupRT; const int k_SampleCount = 1024; int m_SampleIndex; public override void Render(PostProcessRenderContext context) { #if POSTFX_DEBUG_STATIC_GRAIN // Chosen by a fair dice roll float time = 0.4f; float rndOffsetX = 0f; float rndOffsetY = 0f; #else float time = Time.realtimeSinceStartup; float rndOffsetX = HaltonSeq.Get(m_SampleIndex & 1023, 2); float rndOffsetY = HaltonSeq.Get(m_SampleIndex & 1023, 3); if (++m_SampleIndex >= k_SampleCount) m_SampleIndex = 0; #endif // Generate the grain lut for the current frame first if (m_GrainLookupRT == null || !m_GrainLookupRT.IsCreated()) { RuntimeUtilities.Destroy(m_GrainLookupRT); m_GrainLookupRT = new RenderTexture(128, 128, 0, GetLookupFormat()) { filterMode = FilterMode.Bilinear, wrapMode = TextureWrapMode.Repeat, anisoLevel = 0, name = "Grain Lookup Texture" }; m_GrainLookupRT.Create(); } var sheet = context.propertySheets.Get(context.resources.shaders.grainBaker); sheet.properties.Clear(); sheet.properties.SetFloat(ShaderIDs.Phase, time % 10f); sheet.properties.SetVector(ShaderIDs.GrainNoiseParameters, new Vector3(12.9898f, 78.233f, 43758.5453f)); context.command.BeginSample("GrainLookup"); context.command.BlitFullscreenTriangle(BuiltinRenderTextureType.None, m_GrainLookupRT, sheet, settings.colored.value ? 1 : 0); context.command.EndSample("GrainLookup"); // Send everything to the uber shader var uberSheet = context.uberSheet; uberSheet.EnableKeyword("GRAIN"); uberSheet.properties.SetTexture(ShaderIDs.GrainTex, m_GrainLookupRT); uberSheet.properties.SetVector(ShaderIDs.Grain_Params1, new Vector2(settings.lumContrib.value, settings.intensity.value * 20f)); uberSheet.properties.SetVector(ShaderIDs.Grain_Params2, new Vector4((float)context.width / (float)m_GrainLookupRT.width / settings.size.value, (float)context.height / (float)m_GrainLookupRT.height / settings.size.value, rndOffsetX, rndOffsetY)); } RenderTextureFormat GetLookupFormat() { if (RenderTextureFormat.ARGBHalf.IsSupported()) return RenderTextureFormat.ARGBHalf; return RenderTextureFormat.ARGB32; } public override void Release() { RuntimeUtilities.Destroy(m_GrainLookupRT); m_GrainLookupRT = null; m_SampleIndex = 0; } } #if POSTFX_DEBUG_STATIC_GRAIN #pragma warning restore 414 #endif }

File no 84: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/LensDistortion.cs
using System; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// This class holds settings for the Lens Distortion effect. /// </summary> [Serializable] [PostProcess(typeof(LensDistortionRenderer), "Unity/Lens Distortion")] public sealed class LensDistortion : PostProcessEffectSettings { /// <summary> /// The total amount of distortion to apply. /// </summary> [Range(-100f, 100f), Tooltip("Total distortion amount.")] public FloatParameter intensity = new FloatParameter { value = 0f }; /// <summary> /// Multiplies the intensity value on the x-axis. Setting this value to 0 will disable distortion on this axis. /// </summary> [Range(0f, 1f), DisplayName("X Multiplier"), Tooltip("Intensity multiplier on the x-axis. Set it to 0 to disable distortion on this axis.")] public FloatParameter intensityX = new FloatParameter { value = 1f }; /// <summary> /// Multiplies the intensity value on the y-axis. Setting this value to 0 will disable distortion on this axis. /// </summary> [Range(0f, 1f), DisplayName("Y Multiplier"), Tooltip("Intensity multiplier on the y-axis. Set it to 0 to disable distortion on this axis.")] public FloatParameter intensityY = new FloatParameter { value = 1f }; /// <summary> /// The center point for the distortion (x-axis). /// </summary> [Space] [Range(-1f, 1f), Tooltip("Distortion center point (x-axis).")] public FloatParameter centerX = new FloatParameter { value = 0f }; /// <summary> /// The center point for the distortion (y-axis). /// </summary> [Range(-1f, 1f), Tooltip("Distortion center point (y-axis).")] public FloatParameter centerY = new FloatParameter { value = 0f }; /// <summary> /// A global screen scaling factor. /// </summary> [Space] [Range(0.01f, 5f), Tooltip("Global screen scaling.")] public FloatParameter scale = new FloatParameter { value = 1f }; /// <inheritdoc /> public override bool IsEnabledAndSupported(PostProcessRenderContext context) { return enabled.value && !Mathf.Approximately(intensity, 0f) && (intensityX > 0f || intensityY > 0f) && !RuntimeUtilities.isVREnabled; } } #if UNITY_2017_1_OR_NEWER [UnityEngine.Scripting.Preserve] #endif internal sealed class LensDistortionRenderer : PostProcessEffectRenderer<LensDistortion> { public override void Render(PostProcessRenderContext context) { var sheet = context.uberSheet; float amount = 1.6f * Math.Max(Mathf.Abs(settings.intensity.value), 1f); float theta = Mathf.Deg2Rad * Math.Min(160f, amount); float sigma = 2f * Mathf.Tan(theta * 0.5f); var p0 = new Vector4(settings.centerX.value, settings.centerY.value, Mathf.Max(settings.intensityX.value, 1e-4f), Mathf.Max(settings.intensityY.value, 1e-4f)); var p1 = new Vector4(settings.intensity.value >= 0f ? theta : 1f / theta, sigma, 1f / settings.scale.value, settings.intensity.value); sheet.EnableKeyword("DISTORT"); sheet.properties.SetVector(ShaderIDs.Distortion_CenterScale, p0); sheet.properties.SetVector(ShaderIDs.Distortion_Amount, p1); } } }

File no 85: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/MotionBlur.cs
using System; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// This class holds settings for the Motion Blur effect. /// </summary> [Serializable] [PostProcess(typeof(MotionBlurRenderer), "Unity/Motion Blur", false)] public sealed class MotionBlur : PostProcessEffectSettings { /// <summary> /// The angle of the rotary shutter. Larger values give longer exposure therefore a stronger /// blur effect. /// </summary> [Range(0f, 360f), Tooltip("The angle of rotary shutter. Larger values give longer exposure.")] public FloatParameter shutterAngle = new FloatParameter { value = 270f }; /// <summary> /// The amount of sample points, which affects quality and performances. /// </summary> [Range(4, 32), Tooltip("The amount of sample points. This affects quality and performance.")] public IntParameter sampleCount = new IntParameter { value = 10 }; /// <inheritdoc /> public override bool IsEnabledAndSupported(PostProcessRenderContext context) { return enabled.value && shutterAngle.value > 0f #if UNITY_EDITOR // Don't render motion blur preview when the editor is not playing as it can in some // cases results in ugly artifacts (i.e. when resizing the game view). && Application.isPlaying #endif && SystemInfo.supportsMotionVectors && RenderTextureFormat.RGHalf.IsSupported() && !RuntimeUtilities.isVREnabled; } } #if UNITY_2017_1_OR_NEWER [UnityEngine.Scripting.Preserve] #endif internal sealed class MotionBlurRenderer : PostProcessEffectRenderer<MotionBlur> { enum Pass { VelocitySetup, TileMax1, TileMax2, TileMaxV, NeighborMax, Reconstruction } public override DepthTextureMode GetCameraFlags() { return DepthTextureMode.Depth | DepthTextureMode.MotionVectors; } public override void Render(PostProcessRenderContext context) { var cmd = context.command; if (m_ResetHistory) { cmd.BlitFullscreenTriangle(context.source, context.destination); m_ResetHistory = false; return; } const float kMaxBlurRadius = 5f; var vectorRTFormat = RenderTextureFormat.RGHalf; var packedRTFormat = RenderTextureFormat.ARGB2101010.IsSupported() ? RenderTextureFormat.ARGB2101010 : RenderTextureFormat.ARGB32; var sheet = context.propertySheets.Get(context.resources.shaders.motionBlur); cmd.BeginSample("MotionBlur"); // Calculate the maximum blur radius in pixels. int maxBlurPixels = (int)(kMaxBlurRadius * context.height / 100); // Calculate the TileMax size. // It should be a multiple of 8 and larger than maxBlur. int tileSize = ((maxBlurPixels - 1) / 8 + 1) * 8; // Pass 1 - Velocity/depth packing var velocityScale = settings.shutterAngle / 360f; sheet.properties.SetFloat(ShaderIDs.VelocityScale, velocityScale); sheet.properties.SetFloat(ShaderIDs.MaxBlurRadius, maxBlurPixels); sheet.properties.SetFloat(ShaderIDs.RcpMaxBlurRadius, 1f / maxBlurPixels); int vbuffer = ShaderIDs.VelocityTex; cmd.GetTemporaryRT(vbuffer, context.width, context.height, 0, FilterMode.Point, packedRTFormat, RenderTextureReadWrite.Linear); cmd.BlitFullscreenTriangle(BuiltinRenderTextureType.None, vbuffer, sheet, (int)Pass.VelocitySetup); // Pass 2 - First TileMax filter (1/2 downsize) int tile2 = ShaderIDs.Tile2RT; cmd.GetTemporaryRT(tile2, context.width / 2, context.height / 2, 0, FilterMode.Point, vectorRTFormat, RenderTextureReadWrite.Linear); cmd.BlitFullscreenTriangle(vbuffer, tile2, sheet, (int)Pass.TileMax1); // Pass 3 - Second TileMax filter (1/2 downsize) int tile4 = ShaderIDs.Tile4RT; cmd.GetTemporaryRT(tile4, context.width / 4, context.height / 4, 0, FilterMode.Point, vectorRTFormat, RenderTextureReadWrite.Linear); cmd.BlitFullscreenTriangle(tile2, tile4, sheet, (int)Pass.TileMax2); cmd.ReleaseTemporaryRT(tile2); // Pass 4 - Third TileMax filter (1/2 downsize) int tile8 = ShaderIDs.Tile8RT; cmd.GetTemporaryRT(tile8, context.width / 8, context.height / 8, 0, FilterMode.Point, vectorRTFormat, RenderTextureReadWrite.Linear); cmd.BlitFullscreenTriangle(tile4, tile8, sheet, (int)Pass.TileMax2); cmd.ReleaseTemporaryRT(tile4); // Pass 5 - Fourth TileMax filter (reduce to tileSize) var tileMaxOffs = Vector2.one * (tileSize / 8f - 1f) * -0.5f; sheet.properties.SetVector(ShaderIDs.TileMaxOffs, tileMaxOffs); sheet.properties.SetFloat(ShaderIDs.TileMaxLoop, (int)(tileSize / 8f)); int tile = ShaderIDs.TileVRT; cmd.GetTemporaryRT(tile, context.width / tileSize, context.height / tileSize, 0, FilterMode.Point, vectorRTFormat, RenderTextureReadWrite.Linear); cmd.BlitFullscreenTriangle(tile8, tile, sheet, (int)Pass.TileMaxV); cmd.ReleaseTemporaryRT(tile8); // Pass 6 - NeighborMax filter int neighborMax = ShaderIDs.NeighborMaxTex; int neighborMaxWidth = context.width / tileSize; int neighborMaxHeight = context.height / tileSize; cmd.GetTemporaryRT(neighborMax, neighborMaxWidth, neighborMaxHeight, 0, FilterMode.Point, vectorRTFormat, RenderTextureReadWrite.Linear); cmd.BlitFullscreenTriangle(tile, neighborMax, sheet, (int)Pass.NeighborMax); cmd.ReleaseTemporaryRT(tile); // Pass 7 - Reconstruction pass sheet.properties.SetFloat(ShaderIDs.LoopCount, Mathf.Clamp(settings.sampleCount / 2, 1, 64)); cmd.BlitFullscreenTriangle(context.source, context.destination, sheet, (int)Pass.Reconstruction); cmd.ReleaseTemporaryRT(vbuffer); cmd.ReleaseTemporaryRT(neighborMax); cmd.EndSample("MotionBlur"); } } }

File no 86: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/MultiScaleVO.cs
using System; namespace UnityEngine.Rendering.PostProcessing { // Multi-scale volumetric obscurance // TODO: Fix VR support #if UNITY_2017_1_OR_NEWER [UnityEngine.Scripting.Preserve] [Serializable] internal sealed class MultiScaleVO : IAmbientOcclusionMethod { internal enum MipLevel { Original, L1, L2, L3, L4, L5, L6 } enum Pass { DepthCopy, CompositionDeferred, CompositionForward, DebugOverlay } // The arrays below are reused between frames to reduce GC allocation. readonly float[] m_SampleThickness = { Mathf.Sqrt(1f - 0.2f * 0.2f), Mathf.Sqrt(1f - 0.4f * 0.4f), Mathf.Sqrt(1f - 0.6f * 0.6f), Mathf.Sqrt(1f - 0.8f * 0.8f), Mathf.Sqrt(1f - 0.2f * 0.2f - 0.2f * 0.2f), Mathf.Sqrt(1f - 0.2f * 0.2f - 0.4f * 0.4f), Mathf.Sqrt(1f - 0.2f * 0.2f - 0.6f * 0.6f), Mathf.Sqrt(1f - 0.2f * 0.2f - 0.8f * 0.8f), Mathf.Sqrt(1f - 0.4f * 0.4f - 0.4f * 0.4f), Mathf.Sqrt(1f - 0.4f * 0.4f - 0.6f * 0.6f), Mathf.Sqrt(1f - 0.4f * 0.4f - 0.8f * 0.8f), Mathf.Sqrt(1f - 0.6f * 0.6f - 0.6f * 0.6f) }; readonly float[] m_InvThicknessTable = new float[12]; readonly float[] m_SampleWeightTable = new float[12]; readonly int[] m_Widths = new int[7]; readonly int[] m_Heights = new int[7]; AmbientOcclusion m_Settings; PropertySheet m_PropertySheet; PostProcessResources m_Resources; // Can't use a temporary because we need to share it between cmdbuffers - also fixes a weird // command buffer warning RenderTexture m_AmbientOnlyAO; readonly RenderTargetIdentifier[] m_MRT = { BuiltinRenderTextureType.GBuffer0, // Albedo, Occ BuiltinRenderTextureType.CameraTarget // Ambient }; public MultiScaleVO(AmbientOcclusion settings) { m_Settings = settings; } public DepthTextureMode GetCameraFlags() { return DepthTextureMode.Depth; } // Special case for AO [because SRPs], please don't do this in other effects, it's bad // practice in this framework public void SetResources(PostProcessResources resources) { m_Resources = resources; } void Alloc(CommandBuffer cmd, int id, MipLevel size, RenderTextureFormat format, bool uav) { int sizeId = (int)size; cmd.GetTemporaryRT(id, new RenderTextureDescriptor { width = m_Widths[sizeId], height = m_Heights[sizeId], colorFormat = format, depthBufferBits = 0, volumeDepth = 1, autoGenerateMips = false, msaaSamples = 1, enableRandomWrite = uav, dimension = TextureDimension.Tex2D, sRGB = false }, FilterMode.Point); } void AllocArray(CommandBuffer cmd, int id, MipLevel size, RenderTextureFormat format, bool uav) { int sizeId = (int)size; cmd.GetTemporaryRT(id, new RenderTextureDescriptor { width = m_Widths[sizeId], height = m_Heights[sizeId], colorFormat = format, depthBufferBits = 0, volumeDepth = 16, autoGenerateMips = false, msaaSamples = 1, enableRandomWrite = uav, dimension = TextureDimension.Tex2DArray, sRGB = false }, FilterMode.Point); } void Release(CommandBuffer cmd, int id) { cmd.ReleaseTemporaryRT(id); } // Calculate values in _ZBuferParams (built-in shader variable) // We can't use _ZBufferParams in compute shaders, so this function is // used to give the values in it to compute shaders. Vector4 CalculateZBufferParams(Camera camera) { float fpn = camera.farClipPlane / camera.nearClipPlane; if (SystemInfo.usesReversedZBuffer) return new Vector4(fpn - 1f, 1f, 0f, 0f); return new Vector4(1f - fpn, fpn, 0f, 0f); } float CalculateTanHalfFovHeight(Camera camera) { return 1f / camera.projectionMatrix[0, 0]; } Vector2 GetSize(MipLevel mip) { return new Vector2(m_Widths[(int)mip], m_Heights[(int)mip]); } Vector3 GetSizeArray(MipLevel mip) { return new Vector3(m_Widths[(int)mip], m_Heights[(int)mip], 16); } public void GenerateAOMap(CommandBuffer cmd, Camera camera, RenderTargetIdentifier destination, RenderTargetIdentifier? depthMap, bool invert, bool isMSAA) { // Base size m_Widths[0] = camera.pixelWidth * (RuntimeUtilities.isSinglePassStereoEnabled ? 2 : 1); m_Heights[0] = camera.pixelHeight; // L1 -> L6 sizes for (int i = 1; i < 7; i++) { int div = 1 << i; m_Widths[i] = (m_Widths[0] + (div - 1)) / div; m_Heights[i] = (m_Heights[0] + (div - 1)) / div; } // Allocate temporary textures PushAllocCommands(cmd, isMSAA); // Render logic PushDownsampleCommands(cmd, camera, depthMap, isMSAA); float tanHalfFovH = CalculateTanHalfFovHeight(camera); PushRenderCommands(cmd, ShaderIDs.TiledDepth1, ShaderIDs.Occlusion1, GetSizeArray(MipLevel.L3), tanHalfFovH, isMSAA); PushRenderCommands(cmd, ShaderIDs.TiledDepth2, ShaderIDs.Occlusion2, GetSizeArray(MipLevel.L4), tanHalfFovH, isMSAA); PushRenderCommands(cmd, ShaderIDs.TiledDepth3, ShaderIDs.Occlusion3, GetSizeArray(MipLevel.L5), tanHalfFovH, isMSAA); PushRenderCommands(cmd, ShaderIDs.TiledDepth4, ShaderIDs.Occlusion4, GetSizeArray(MipLevel.L6), tanHalfFovH, isMSAA); PushUpsampleCommands(cmd, ShaderIDs.LowDepth4, ShaderIDs.Occlusion4, ShaderIDs.LowDepth3, ShaderIDs.Occlusion3, ShaderIDs.Combined3, GetSize(MipLevel.L4), GetSize(MipLevel.L3), isMSAA); PushUpsampleCommands(cmd, ShaderIDs.LowDepth3, ShaderIDs.Combined3, ShaderIDs.LowDepth2, ShaderIDs.Occlusion2, ShaderIDs.Combined2, GetSize(MipLevel.L3), GetSize(MipLevel.L2), isMSAA); PushUpsampleCommands(cmd, ShaderIDs.LowDepth2, ShaderIDs.Combined2, ShaderIDs.LowDepth1, ShaderIDs.Occlusion1, ShaderIDs.Combined1, GetSize(MipLevel.L2), GetSize(MipLevel.L1), isMSAA); PushUpsampleCommands(cmd, ShaderIDs.LowDepth1, ShaderIDs.Combined1, ShaderIDs.LinearDepth, null, destination, GetSize(MipLevel.L1), GetSize(MipLevel.Original), isMSAA, invert); // Cleanup PushReleaseCommands(cmd); } void PushAllocCommands(CommandBuffer cmd, bool isMSAA) { if(isMSAA) { Alloc(cmd, ShaderIDs.LinearDepth, MipLevel.Original, RenderTextureFormat.RGHalf, true); Alloc(cmd, ShaderIDs.LowDepth1, MipLevel.L1, RenderTextureFormat.RGFloat, true); Alloc(cmd, ShaderIDs.LowDepth2, MipLevel.L2, RenderTextureFormat.RGFloat, true); Alloc(cmd, ShaderIDs.LowDepth3, MipLevel.L3, RenderTextureFormat.RGFloat, true); Alloc(cmd, ShaderIDs.LowDepth4, MipLevel.L4, RenderTextureFormat.RGFloat, true); AllocArray(cmd, ShaderIDs.TiledDepth1, MipLevel.L3, RenderTextureFormat.RGHalf, true); AllocArray(cmd, ShaderIDs.TiledDepth2, MipLevel.L4, RenderTextureFormat.RGHalf, true); AllocArray(cmd, ShaderIDs.TiledDepth3, MipLevel.L5, RenderTextureFormat.RGHalf, true); AllocArray(cmd, ShaderIDs.TiledDepth4, MipLevel.L6, RenderTextureFormat.RGHalf, true); Alloc(cmd, ShaderIDs.Occlusion1, MipLevel.L1, RenderTextureFormat.RG16, true); Alloc(cmd, ShaderIDs.Occlusion2, MipLevel.L2, RenderTextureFormat.RG16, true); Alloc(cmd, ShaderIDs.Occlusion3, MipLevel.L3, RenderTextureFormat.RG16, true); Alloc(cmd, ShaderIDs.Occlusion4, MipLevel.L4, RenderTextureFormat.RG16, true); Alloc(cmd, ShaderIDs.Combined1, MipLevel.L1, RenderTextureFormat.RG16, true); Alloc(cmd, ShaderIDs.Combined2, MipLevel.L2, RenderTextureFormat.RG16, true); Alloc(cmd, ShaderIDs.Combined3, MipLevel.L3, RenderTextureFormat.RG16, true); } else { Alloc(cmd, ShaderIDs.LinearDepth, MipLevel.Original, RenderTextureFormat.RHalf, true); Alloc(cmd, ShaderIDs.LowDepth1, MipLevel.L1, RenderTextureFormat.RFloat, true); Alloc(cmd, ShaderIDs.LowDepth2, MipLevel.L2, RenderTextureFormat.RFloat, true); Alloc(cmd, ShaderIDs.LowDepth3, MipLevel.L3, RenderTextureFormat.RFloat, true); Alloc(cmd, ShaderIDs.LowDepth4, MipLevel.L4, RenderTextureFormat.RFloat, true); AllocArray(cmd, ShaderIDs.TiledDepth1, MipLevel.L3, RenderTextureFormat.RHalf, true); AllocArray(cmd, ShaderIDs.TiledDepth2, MipLevel.L4, RenderTextureFormat.RHalf, true); AllocArray(cmd, ShaderIDs.TiledDepth3, MipLevel.L5, RenderTextureFormat.RHalf, true); AllocArray(cmd, ShaderIDs.TiledDepth4, MipLevel.L6, RenderTextureFormat.RHalf, true); Alloc(cmd, ShaderIDs.Occlusion1, MipLevel.L1, RenderTextureFormat.R8, true); Alloc(cmd, ShaderIDs.Occlusion2, MipLevel.L2, RenderTextureFormat.R8, true); Alloc(cmd, ShaderIDs.Occlusion3, MipLevel.L3, RenderTextureFormat.R8, true); Alloc(cmd, ShaderIDs.Occlusion4, MipLevel.L4, RenderTextureFormat.R8, true); Alloc(cmd, ShaderIDs.Combined1, MipLevel.L1, RenderTextureFormat.R8, true); Alloc(cmd, ShaderIDs.Combined2, MipLevel.L2, RenderTextureFormat.R8, true); Alloc(cmd, ShaderIDs.Combined3, MipLevel.L3, RenderTextureFormat.R8, true); } } void PushDownsampleCommands(CommandBuffer cmd, Camera camera, RenderTargetIdentifier? depthMap, bool isMSAA) { RenderTargetIdentifier depthMapId; bool needDepthMapRelease = false; if (depthMap != null) { depthMapId = depthMap.Value; } else { // Make a copy of the depth texture, or reuse the resolved depth // buffer (it's only available in some specific situations). if (!RuntimeUtilities.IsResolvedDepthAvailable(camera)) { Alloc(cmd, ShaderIDs.DepthCopy, MipLevel.Original, RenderTextureFormat.RFloat, false); depthMapId = new RenderTargetIdentifier(ShaderIDs.DepthCopy); cmd.BlitFullscreenTriangle(BuiltinRenderTextureType.None, depthMapId, m_PropertySheet, (int)Pass.DepthCopy); needDepthMapRelease = true; } else { depthMapId = BuiltinRenderTextureType.ResolvedDepth; } } // 1st downsampling pass. var cs = m_Resources.computeShaders.multiScaleAODownsample1; int kernel = cs.FindKernel(isMSAA ? "MultiScaleVODownsample1_MSAA" : "MultiScaleVODownsample1"); cmd.SetComputeTextureParam(cs, kernel, "LinearZ", ShaderIDs.LinearDepth); cmd.SetComputeTextureParam(cs, kernel, "DS2x", ShaderIDs.LowDepth1); cmd.SetComputeTextureParam(cs, kernel, "DS4x", ShaderIDs.LowDepth2); cmd.SetComputeTextureParam(cs, kernel, "DS2xAtlas", ShaderIDs.TiledDepth1); cmd.SetComputeTextureParam(cs, kernel, "DS4xAtlas", ShaderIDs.TiledDepth2); cmd.SetComputeVectorParam(cs, "ZBufferParams", CalculateZBufferParams(camera)); cmd.SetComputeTextureParam(cs, kernel, "Depth", depthMapId); cmd.DispatchCompute(cs, kernel, m_Widths[(int)MipLevel.L4], m_Heights[(int)MipLevel.L4], 1); if (needDepthMapRelease) Release(cmd, ShaderIDs.DepthCopy); // 2nd downsampling pass. cs = m_Resources.computeShaders.multiScaleAODownsample2; kernel = isMSAA ? cs.FindKernel("MultiScaleVODownsample2_MSAA") : cs.FindKernel("MultiScaleVODownsample2"); cmd.SetComputeTextureParam(cs, kernel, "DS4x", ShaderIDs.LowDepth2); cmd.SetComputeTextureParam(cs, kernel, "DS8x", ShaderIDs.LowDepth3); cmd.SetComputeTextureParam(cs, kernel, "DS16x", ShaderIDs.LowDepth4); cmd.SetComputeTextureParam(cs, kernel, "DS8xAtlas", ShaderIDs.TiledDepth3); cmd.SetComputeTextureParam(cs, kernel, "DS16xAtlas", ShaderIDs.TiledDepth4); cmd.DispatchCompute(cs, kernel, m_Widths[(int)MipLevel.L6], m_Heights[(int)MipLevel.L6], 1); } void PushRenderCommands(CommandBuffer cmd, int source, int destination, Vector3 sourceSize, float tanHalfFovH, bool isMSAA) { // Here we compute multipliers that convert the center depth value into (the reciprocal // of) sphere thicknesses at each sample location. This assumes a maximum sample radius // of 5 units, but since a sphere has no thickness at its extent, we don't need to // sample that far out. Only samples whole integer offsets with distance less than 25 // are used. This means that there is no sample at (3, 4) because its distance is // exactly 25 (and has a thickness of 0.) // The shaders are set up to sample a circular region within a 5-pixel radius. const float kScreenspaceDiameter = 10f; // SphereDiameter = CenterDepth * ThicknessMultiplier. This will compute the thickness // of a sphere centered at a specific depth. The ellipsoid scale can stretch a sphere // into an ellipsoid, which changes the characteristics of the AO. // TanHalfFovH: Radius of sphere in depth units if its center lies at Z = 1 // ScreenspaceDiameter: Diameter of sample sphere in pixel units // ScreenspaceDiameter / BufferWidth: Ratio of the screen width that the sphere actually covers float thicknessMultiplier = 2f * tanHalfFovH * kScreenspaceDiameter / sourceSize.x; if (RuntimeUtilities.isSinglePassStereoEnabled) thicknessMultiplier *= 2f; // This will transform a depth value from [0, thickness] to [0, 1]. float inverseRangeFactor = 1f / thicknessMultiplier; // The thicknesses are smaller for all off-center samples of the sphere. Compute // thicknesses relative to the center sample. for (int i = 0; i < 12; i++) m_InvThicknessTable[i] = inverseRangeFactor / m_SampleThickness[i]; // These are the weights that are multiplied against the samples because not all samples // are equally important. The farther the sample is from the center location, the less // they matter. We use the thickness of the sphere to determine the weight. The scalars // in front are the number of samples with this weight because we sum the samples // together before multiplying by the weight, so as an aggregate all of those samples // matter more. After generating this table, the weights are normalized. m_SampleWeightTable[ 0] = 4 * m_SampleThickness[ 0]; // Axial m_SampleWeightTable[ 1] = 4 * m_SampleThickness[ 1]; // Axial m_SampleWeightTable[ 2] = 4 * m_SampleThickness[ 2]; // Axial m_SampleWeightTable[ 3] = 4 * m_SampleThickness[ 3]; // Axial m_SampleWeightTable[ 4] = 4 * m_SampleThickness[ 4]; // Diagonal m_SampleWeightTable[ 5] = 8 * m_SampleThickness[ 5]; // L-shaped m_SampleWeightTable[ 6] = 8 * m_SampleThickness[ 6]; // L-shaped m_SampleWeightTable[ 7] = 8 * m_SampleThickness[ 7]; // L-shaped m_SampleWeightTable[ 8] = 4 * m_SampleThickness[ 8]; // Diagonal m_SampleWeightTable[ 9] = 8 * m_SampleThickness[ 9]; // L-shaped m_SampleWeightTable[10] = 8 * m_SampleThickness[10]; // L-shaped m_SampleWeightTable[11] = 4 * m_SampleThickness[11]; // Diagonal // Zero out the unused samples. // FIXME: should we support SAMPLE_EXHAUSTIVELY mode? m_SampleWeightTable[0] = 0; m_SampleWeightTable[2] = 0; m_SampleWeightTable[5] = 0; m_SampleWeightTable[7] = 0; m_SampleWeightTable[9] = 0; // Normalize the weights by dividing by the sum of all weights var totalWeight = 0f; foreach (float w in m_SampleWeightTable) totalWeight += w; for (int i = 0; i < m_SampleWeightTable.Length; i++) m_SampleWeightTable[i] /= totalWeight; // Set the arguments for the render kernel. var cs = m_Resources.computeShaders.multiScaleAORender; int kernel = isMSAA ? cs.FindKernel("MultiScaleVORender_MSAA_interleaved") : cs.FindKernel("MultiScaleVORender_interleaved"); cmd.SetComputeFloatParams(cs, "gInvThicknessTable", m_InvThicknessTable); cmd.SetComputeFloatParams(cs, "gSampleWeightTable", m_SampleWeightTable); cmd.SetComputeVectorParam(cs, "gInvSliceDimension", new Vector2(1f / sourceSize.x, 1f / sourceSize.y)); cmd.SetComputeVectorParam(cs, "AdditionalParams", new Vector2(-1f / m_Settings.thicknessModifier.value, m_Settings.intensity.value)); cmd.SetComputeTextureParam(cs, kernel, "DepthTex", source); cmd.SetComputeTextureParam(cs, kernel, "Occlusion", destination); // Calculate the thread group count and add a dispatch command with them. uint xsize, ysize, zsize; cs.GetKernelThreadGroupSizes(kernel, out xsize, out ysize, out zsize); cmd.DispatchCompute( cs, kernel, ((int)sourceSize.x + (int)xsize - 1) / (int)xsize, ((int)sourceSize.y + (int)ysize - 1) / (int)ysize, ((int)sourceSize.z + (int)zsize - 1) / (int)zsize ); } void PushUpsampleCommands(CommandBuffer cmd, int lowResDepth, int interleavedAO, int highResDepth, int? highResAO, RenderTargetIdentifier dest, Vector3 lowResDepthSize, Vector2 highResDepthSize, bool isMSAA, bool invert = false) { var cs = m_Resources.computeShaders.multiScaleAOUpsample; int kernel = 0; if (!isMSAA) { kernel = cs.FindKernel(highResAO == null ? invert ? "MultiScaleVOUpSample_invert" : "MultiScaleVOUpSample" : "MultiScaleVOUpSample_blendout"); } else { kernel = cs.FindKernel(highResAO == null ? invert ? "MultiScaleVOUpSample_MSAA_invert" : "MultiScaleVOUpSample_MSAA" : "MultiScaleVOUpSample_MSAA_blendout"); } float stepSize = 1920f / lowResDepthSize.x; float bTolerance = 1f - Mathf.Pow(10f, m_Settings.blurTolerance.value) * stepSize; bTolerance *= bTolerance; float uTolerance = Mathf.Pow(10f, m_Settings.upsampleTolerance.value); float noiseFilterWeight = 1f / (Mathf.Pow(10f, m_Settings.noiseFilterTolerance.value) + uTolerance); cmd.SetComputeVectorParam(cs, "InvLowResolution", new Vector2(1f / lowResDepthSize.x, 1f / lowResDepthSize.y)); cmd.SetComputeVectorParam(cs, "InvHighResolution", new Vector2(1f / highResDepthSize.x, 1f / highResDepthSize.y)); cmd.SetComputeVectorParam(cs, "AdditionalParams", new Vector4(noiseFilterWeight, stepSize, bTolerance, uTolerance)); cmd.SetComputeTextureParam(cs, kernel, "LoResDB", lowResDepth); cmd.SetComputeTextureParam(cs, kernel, "HiResDB", highResDepth); cmd.SetComputeTextureParam(cs, kernel, "LoResAO1", interleavedAO); if (highResAO != null) cmd.SetComputeTextureParam(cs, kernel, "HiResAO", highResAO.Value); cmd.SetComputeTextureParam(cs, kernel, "AoResult", dest); int xcount = ((int)highResDepthSize.x + 17) / 16; int ycount = ((int)highResDepthSize.y + 17) / 16; cmd.DispatchCompute(cs, kernel, xcount, ycount, 1); } void PushReleaseCommands(CommandBuffer cmd) { Release(cmd, ShaderIDs.LinearDepth); Release(cmd, ShaderIDs.LowDepth1); Release(cmd, ShaderIDs.LowDepth2); Release(cmd, ShaderIDs.LowDepth3); Release(cmd, ShaderIDs.LowDepth4); Release(cmd, ShaderIDs.TiledDepth1); Release(cmd, ShaderIDs.TiledDepth2); Release(cmd, ShaderIDs.TiledDepth3); Release(cmd, ShaderIDs.TiledDepth4); Release(cmd, ShaderIDs.Occlusion1); Release(cmd, ShaderIDs.Occlusion2); Release(cmd, ShaderIDs.Occlusion3); Release(cmd, ShaderIDs.Occlusion4); Release(cmd, ShaderIDs.Combined1); Release(cmd, ShaderIDs.Combined2); Release(cmd, ShaderIDs.Combined3); } void PreparePropertySheet(PostProcessRenderContext context) { var sheet = context.propertySheets.Get(m_Resources.shaders.multiScaleAO); sheet.ClearKeywords(); sheet.properties.SetVector(ShaderIDs.AOColor, Color.white - m_Settings.color.value); m_PropertySheet = sheet; } void CheckAOTexture(PostProcessRenderContext context) { if (m_AmbientOnlyAO == null || !m_AmbientOnlyAO.IsCreated() || m_AmbientOnlyAO.width != context.width || m_AmbientOnlyAO.height != context.height) { RuntimeUtilities.Destroy(m_AmbientOnlyAO); m_AmbientOnlyAO = new RenderTexture(context.width, context.height, 0, RenderTextureFormat.R8, RenderTextureReadWrite.Linear) { hideFlags = HideFlags.DontSave, filterMode = FilterMode.Point, enableRandomWrite = true }; m_AmbientOnlyAO.Create(); } } void PushDebug(PostProcessRenderContext context) { if (context.IsDebugOverlayEnabled(DebugOverlay.AmbientOcclusion)) context.PushDebugOverlay(context.command, m_AmbientOnlyAO, m_PropertySheet, (int)Pass.DebugOverlay); } public void RenderAfterOpaque(PostProcessRenderContext context) { var cmd = context.command; cmd.BeginSample("Ambient Occlusion"); SetResources(context.resources); PreparePropertySheet(context); CheckAOTexture(context); // In Forward mode, fog is applied at the object level in the grometry pass so we need // to apply it to AO as well or it'll drawn on top of the fog effect. if (context.camera.actualRenderingPath == RenderingPath.Forward && RenderSettings.fog) { m_PropertySheet.EnableKeyword("APPLY_FORWARD_FOG"); m_PropertySheet.properties.SetVector( ShaderIDs.FogParams, new Vector3(RenderSettings.fogDensity, RenderSettings.fogStartDistance, RenderSettings.fogEndDistance) ); } GenerateAOMap(cmd, context.camera, m_AmbientOnlyAO, null, false, false); PushDebug(context); cmd.SetGlobalTexture(ShaderIDs.MSVOcclusionTexture, m_AmbientOnlyAO); cmd.BlitFullscreenTriangle(BuiltinRenderTextureType.None, BuiltinRenderTextureType.CameraTarget, m_PropertySheet, (int)Pass.CompositionForward, RenderBufferLoadAction.Load); cmd.EndSample("Ambient Occlusion"); } public void RenderAmbientOnly(PostProcessRenderContext context) { var cmd = context.command; cmd.BeginSample("Ambient Occlusion Render"); SetResources(context.resources); PreparePropertySheet(context); CheckAOTexture(context); GenerateAOMap(cmd, context.camera, m_AmbientOnlyAO, null, false, false); PushDebug(context); cmd.EndSample("Ambient Occlusion Render"); } public void CompositeAmbientOnly(PostProcessRenderContext context) { var cmd = context.command; cmd.BeginSample("Ambient Occlusion Composite"); cmd.SetGlobalTexture(ShaderIDs.MSVOcclusionTexture, m_AmbientOnlyAO); cmd.BlitFullscreenTriangle(BuiltinRenderTextureType.None, m_MRT, BuiltinRenderTextureType.CameraTarget, m_PropertySheet, (int)Pass.CompositionDeferred); cmd.EndSample("Ambient Occlusion Composite"); } public void Release() { RuntimeUtilities.Destroy(m_AmbientOnlyAO); m_AmbientOnlyAO = null; } } #else [Serializable] public sealed class MultiScaleVO : IAmbientOcclusionMethod { public MultiScaleVO(AmbientOcclusion settings) { } public void SetResources(PostProcessResources resources) { } public DepthTextureMode GetCameraFlags() { return DepthTextureMode.None; } public void GenerateAOMap(CommandBuffer cmd, Camera camera, RenderTargetIdentifier destination, RenderTargetIdentifier? depthMap, bool invert, bool isMSAA) { } public void RenderAfterOpaque(PostProcessRenderContext context) { } public void RenderAmbientOnly(PostProcessRenderContext context) { } public void CompositeAmbientOnly(PostProcessRenderContext context) { } public void Release() { } } #endif }

File no 87: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/ScalableAO.cs
using System; namespace UnityEngine.Rendering.PostProcessing { // Scalable ambient obscurance #if UNITY_2017_1_OR_NEWER [UnityEngine.Scripting.Preserve] #endif [Serializable] internal sealed class ScalableAO : IAmbientOcclusionMethod { RenderTexture m_Result; PropertySheet m_PropertySheet; AmbientOcclusion m_Settings; readonly RenderTargetIdentifier[] m_MRT = { BuiltinRenderTextureType.GBuffer0, // Albedo, Occ BuiltinRenderTextureType.CameraTarget // Ambient }; readonly int[] m_SampleCount = { 4, 6, 10, 8, 12 }; enum Pass { OcclusionEstimationForward, OcclusionEstimationDeferred, HorizontalBlurForward, HorizontalBlurDeferred, VerticalBlur, CompositionForward, CompositionDeferred, DebugOverlay } public ScalableAO(AmbientOcclusion settings) { m_Settings = settings; } public DepthTextureMode GetCameraFlags() { return DepthTextureMode.Depth | DepthTextureMode.DepthNormals; } void DoLazyInitialization(PostProcessRenderContext context) { m_PropertySheet = context.propertySheets.Get(context.resources.shaders.scalableAO); bool reset = false; if (m_Result == null || !m_Result.IsCreated()) { // Initial allocation m_Result = context.GetScreenSpaceTemporaryRT(0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear); m_Result.hideFlags = HideFlags.DontSave; m_Result.filterMode = FilterMode.Bilinear; reset = true; } else if (m_Result.width != context.width || m_Result.height != context.height) { // Release and reallocate m_Result.Release(); m_Result.width = context.width; m_Result.height = context.height; reset = true; } if (reset) m_Result.Create(); } void Render(PostProcessRenderContext context, CommandBuffer cmd, int occlusionSource) { DoLazyInitialization(context); m_Settings.radius.value = Mathf.Max(m_Settings.radius.value, 1e-4f); // Material setup // Always use a quater-res AO buffer unless High/Ultra quality is set. bool downsampling = (int)m_Settings.quality.value < (int)AmbientOcclusionQuality.High; float px = m_Settings.intensity.value; float py = m_Settings.radius.value; float pz = downsampling ? 0.5f : 1f; float pw = m_SampleCount[(int)m_Settings.quality.value]; var sheet = m_PropertySheet; sheet.ClearKeywords(); sheet.properties.SetVector(ShaderIDs.AOParams, new Vector4(px, py, pz, pw)); sheet.properties.SetVector(ShaderIDs.AOColor, Color.white - m_Settings.color.value); // In forward fog is applied at the object level in the grometry pass so we need to // apply it to AO as well or it'll drawn on top of the fog effect. // Not needed in Deferred. if (context.camera.actualRenderingPath == RenderingPath.Forward && RenderSettings.fog) { sheet.EnableKeyword("APPLY_FORWARD_FOG"); sheet.properties.SetVector( ShaderIDs.FogParams, new Vector3(RenderSettings.fogDensity, RenderSettings.fogStartDistance, RenderSettings.fogEndDistance) ); } // Texture setup int ts = downsampling ? 2 : 1; const RenderTextureFormat kFormat = RenderTextureFormat.ARGB32; const RenderTextureReadWrite kRWMode = RenderTextureReadWrite.Linear; const FilterMode kFilter = FilterMode.Bilinear; // AO buffer var rtMask = ShaderIDs.OcclusionTexture1; int scaledWidth = context.width / ts; int scaledHeight = context.height / ts; context.GetScreenSpaceTemporaryRT(cmd, rtMask, 0, kFormat, kRWMode, kFilter, scaledWidth, scaledHeight); // AO estimation cmd.BlitFullscreenTriangle(BuiltinRenderTextureType.None, rtMask, sheet, (int)Pass.OcclusionEstimationForward + occlusionSource); // Blur buffer var rtBlur = ShaderIDs.OcclusionTexture2; context.GetScreenSpaceTemporaryRT(cmd, rtBlur, 0, kFormat, kRWMode, kFilter); // Separable blur (horizontal pass) cmd.BlitFullscreenTriangle(rtMask, rtBlur, sheet, (int)Pass.HorizontalBlurForward + occlusionSource); cmd.ReleaseTemporaryRT(rtMask); // Separable blur (vertical pass) cmd.BlitFullscreenTriangle(rtBlur, m_Result, sheet, (int)Pass.VerticalBlur); cmd.ReleaseTemporaryRT(rtBlur); if (context.IsDebugOverlayEnabled(DebugOverlay.AmbientOcclusion)) context.PushDebugOverlay(cmd, m_Result, sheet, (int)Pass.DebugOverlay); } public void RenderAfterOpaque(PostProcessRenderContext context) { var cmd = context.command; cmd.BeginSample("Ambient Occlusion"); Render(context, cmd, 0); cmd.SetGlobalTexture(ShaderIDs.SAOcclusionTexture, m_Result); cmd.BlitFullscreenTriangle(BuiltinRenderTextureType.None, BuiltinRenderTextureType.CameraTarget, m_PropertySheet, (int)Pass.CompositionForward, RenderBufferLoadAction.Load); cmd.EndSample("Ambient Occlusion"); } public void RenderAmbientOnly(PostProcessRenderContext context) { var cmd = context.command; cmd.BeginSample("Ambient Occlusion Render"); Render(context, cmd, 1); cmd.EndSample("Ambient Occlusion Render"); } public void CompositeAmbientOnly(PostProcessRenderContext context) { var cmd = context.command; cmd.BeginSample("Ambient Occlusion Composite"); cmd.SetGlobalTexture(ShaderIDs.SAOcclusionTexture, m_Result); cmd.BlitFullscreenTriangle(BuiltinRenderTextureType.None, m_MRT, BuiltinRenderTextureType.CameraTarget, m_PropertySheet, (int)Pass.CompositionDeferred); cmd.EndSample("Ambient Occlusion Composite"); } public void Release() { RuntimeUtilities.Destroy(m_Result); m_Result = null; } } }

File no 88: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/ScreenSpaceReflections.cs
using System; using UnityEngine.Assertions; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// Screen-space Reflections quality presets. /// </summary> public enum ScreenSpaceReflectionPreset { Lower, Low, Medium, High, Higher, Ultra, Overkill, Custom } /// <summary> /// Screen-space Reflections buffer sizes. /// </summary> public enum ScreenSpaceReflectionResolution { /// <summary> /// Downsampled buffer. Faster but lower quality. /// </summary> Downsampled, /// <summary> /// Full-sized buffer. Slower but higher quality. /// </summary> FullSize, /// <summary> /// Supersampled buffer. Very slow but much higher quality. /// </summary> Supersampled } /// <summary> /// A volume parameter holding a <see cref="ScreenSpaceReflectionPreset"/> value. /// </summary> [Serializable] public sealed class ScreenSpaceReflectionPresetParameter : ParameterOverride<ScreenSpaceReflectionPreset> { } /// <summary> /// A volume parameter holding a <see cref="ScreenSpaceReflectionResolution"/> value. /// </summary> [Serializable] public sealed class ScreenSpaceReflectionResolutionParameter : ParameterOverride<ScreenSpaceReflectionResolution> { } /// <summary> /// This class holds settings for the Screen-space Reflections effect. /// </summary> [Serializable] [PostProcess(typeof(ScreenSpaceReflectionsRenderer), "Unity/Screen-space reflections")] public sealed class ScreenSpaceReflections : PostProcessEffectSettings { /// <summary> /// The quality preset to use for rendering. Use <see cref="ScreenSpaceReflectionPreset.Custom"/> /// to tweak settings. /// </summary> [Tooltip("Choose a quality preset, or use \"Custom\" to create your own custom preset. Don't use a preset higher than \"Medium\" if you desire good performance on consoles.")] public ScreenSpaceReflectionPresetParameter preset = new ScreenSpaceReflectionPresetParameter { value = ScreenSpaceReflectionPreset.Medium }; /// <summary> /// The maximum number of steps in the raymarching pass. Higher values mean more reflections. /// </summary> [Range(0, 256), Tooltip("Maximum number of steps in the raymarching pass. Higher values mean more reflections.")] public IntParameter maximumIterationCount = new IntParameter { value = 16 }; /// <summary> /// Changes the size of the internal buffer. Downsample it to maximize performances or /// supersample it to get slow but higher quality results. /// </summary> [Tooltip("Changes the size of the SSR buffer. Downsample it to maximize performances or supersample it for higher quality results with reduced performance.")] public ScreenSpaceReflectionResolutionParameter resolution = new ScreenSpaceReflectionResolutionParameter { value = ScreenSpaceReflectionResolution.Downsampled }; /// <summary> /// The ray thickness. Lower values are more expensive but allow the effect to detect /// smaller details. /// </summary> [Range(1f, 64f), Tooltip("Ray thickness. Lower values are more expensive but allow the effect to detect smaller details.")] public FloatParameter thickness = new FloatParameter { value = 8f }; /// <summary> /// The maximum distance to traverse in the scene after which it will stop drawing /// reflections. /// </summary> [Tooltip("Maximum distance to traverse after which it will stop drawing reflections.")] public FloatParameter maximumMarchDistance = new FloatParameter { value = 100f }; /// <summary> /// Fades reflections close to the near plane. This is useful to hide common artifacts. /// </summary> [Range(0f, 1f), Tooltip("Fades reflections close to the near planes.")] public FloatParameter distanceFade = new FloatParameter { value = 0.5f }; /// <summary> /// Fades reflections close to the screen edges. /// </summary> [Range(0f, 1f), Tooltip("Fades reflections close to the screen edges.")] public FloatParameter vignette = new FloatParameter { value = 0.5f }; /// <inheritdoc /> public override bool IsEnabledAndSupported(PostProcessRenderContext context) { return enabled && context.camera.actualRenderingPath == RenderingPath.DeferredShading && SystemInfo.supportsMotionVectors && SystemInfo.supportsComputeShaders && SystemInfo.copyTextureSupport > CopyTextureSupport.None && context.resources.shaders.screenSpaceReflections && context.resources.shaders.screenSpaceReflections.isSupported && context.resources.computeShaders.gaussianDownsample; } } #if UNITY_2017_1_OR_NEWER [UnityEngine.Scripting.Preserve] #endif internal sealed class ScreenSpaceReflectionsRenderer : PostProcessEffectRenderer<ScreenSpaceReflections> { RenderTexture m_Resolve; RenderTexture m_History; int[] m_MipIDs; class QualityPreset { public int maximumIterationCount; public float thickness; public ScreenSpaceReflectionResolution downsampling; } readonly QualityPreset[] m_Presets = { new QualityPreset { maximumIterationCount = 10, thickness = 32, downsampling = ScreenSpaceReflectionResolution.Downsampled }, // Lower new QualityPreset { maximumIterationCount = 16, thickness = 32, downsampling = ScreenSpaceReflectionResolution.Downsampled }, // Low new QualityPreset { maximumIterationCount = 32, thickness = 16, downsampling = ScreenSpaceReflectionResolution.Downsampled }, // Medium new QualityPreset { maximumIterationCount = 48, thickness = 8, downsampling = ScreenSpaceReflectionResolution.Downsampled }, // High new QualityPreset { maximumIterationCount = 16, thickness = 32, downsampling = ScreenSpaceReflectionResolution.FullSize }, // Higher new QualityPreset { maximumIterationCount = 48, thickness = 16, downsampling = ScreenSpaceReflectionResolution.FullSize }, // Ultra new QualityPreset { maximumIterationCount = 128, thickness = 12, downsampling = ScreenSpaceReflectionResolution.Supersampled }, // Overkill }; enum Pass { Test, Resolve, Reproject, Composite } public override DepthTextureMode GetCameraFlags() { return DepthTextureMode.Depth | DepthTextureMode.MotionVectors; } internal void CheckRT(ref RenderTexture rt, int width, int height, FilterMode filterMode, bool useMipMap) { if (rt == null || !rt.IsCreated() || rt.width != width || rt.height != height) { if (rt != null) { rt.Release(); RuntimeUtilities.Destroy(rt); } rt = new RenderTexture(width, height, 0, RuntimeUtilities.defaultHDRRenderTextureFormat) { filterMode = filterMode, useMipMap = useMipMap, autoGenerateMips = false, hideFlags = HideFlags.HideAndDontSave }; rt.Create(); } } public override void Render(PostProcessRenderContext context) { var cmd = context.command; cmd.BeginSample("Screen-space Reflections"); // Get quality settings if (settings.preset.value != ScreenSpaceReflectionPreset.Custom) { int id = (int)settings.preset.value; settings.maximumIterationCount.value = m_Presets[id].maximumIterationCount; settings.thickness.value = m_Presets[id].thickness; settings.resolution.value = m_Presets[id].downsampling; } settings.maximumMarchDistance.value = Mathf.Max(0f, settings.maximumMarchDistance.value); // Square POT target int size = Mathf.ClosestPowerOfTwo(Mathf.Min(context.width, context.height)); if (settings.resolution.value == ScreenSpaceReflectionResolution.Downsampled) size >>= 1; else if (settings.resolution.value == ScreenSpaceReflectionResolution.Supersampled) size <<= 1; // The gaussian pyramid compute works in blocks of 8x8 so make sure the last lod has a // minimum size of 8x8 const int kMaxLods = 12; int lodCount = Mathf.FloorToInt(Mathf.Log(size, 2f) - 3f); lodCount = Mathf.Min(lodCount, kMaxLods); CheckRT(ref m_Resolve, size, size, FilterMode.Trilinear, true); var noiseTex = context.resources.blueNoise256[0]; var sheet = context.propertySheets.Get(context.resources.shaders.screenSpaceReflections); sheet.properties.SetTexture(ShaderIDs.Noise, noiseTex); var screenSpaceProjectionMatrix = new Matrix4x4(); screenSpaceProjectionMatrix.SetRow(0, new Vector4(size * 0.5f, 0f, 0f, size * 0.5f)); screenSpaceProjectionMatrix.SetRow(1, new Vector4(0f, size * 0.5f, 0f, size * 0.5f)); screenSpaceProjectionMatrix.SetRow(2, new Vector4(0f, 0f, 1f, 0f)); screenSpaceProjectionMatrix.SetRow(3, new Vector4(0f, 0f, 0f, 1f)); var projectionMatrix = GL.GetGPUProjectionMatrix(context.camera.projectionMatrix, false); screenSpaceProjectionMatrix *= projectionMatrix; sheet.properties.SetMatrix(ShaderIDs.ViewMatrix, context.camera.worldToCameraMatrix); sheet.properties.SetMatrix(ShaderIDs.InverseViewMatrix, context.camera.worldToCameraMatrix.inverse); sheet.properties.SetMatrix(ShaderIDs.InverseProjectionMatrix, projectionMatrix.inverse); sheet.properties.SetMatrix(ShaderIDs.ScreenSpaceProjectionMatrix, screenSpaceProjectionMatrix); sheet.properties.SetVector(ShaderIDs.Params, new Vector4((float)settings.vignette.value, settings.distanceFade.value, settings.maximumMarchDistance.value, lodCount)); sheet.properties.SetVector(ShaderIDs.Params2, new Vector4((float)context.width / (float)context.height, (float)size / (float)noiseTex.width, settings.thickness.value, settings.maximumIterationCount.value)); cmd.GetTemporaryRT(ShaderIDs.Test, size, size, 0, FilterMode.Point, context.sourceFormat); cmd.BlitFullscreenTriangle(context.source, ShaderIDs.Test, sheet, (int)Pass.Test); if (context.isSceneView) { cmd.BlitFullscreenTriangle(context.source, m_Resolve, sheet, (int)Pass.Resolve); } else { CheckRT(ref m_History, size, size, FilterMode.Bilinear, false); if (m_ResetHistory) { context.command.BlitFullscreenTriangle(context.source, m_History); m_ResetHistory = false; } cmd.GetTemporaryRT(ShaderIDs.SSRResolveTemp, size, size, 0, FilterMode.Bilinear, context.sourceFormat); cmd.BlitFullscreenTriangle(context.source, ShaderIDs.SSRResolveTemp, sheet, (int)Pass.Resolve); sheet.properties.SetTexture(ShaderIDs.History, m_History); cmd.BlitFullscreenTriangle(ShaderIDs.SSRResolveTemp, m_Resolve, sheet, (int)Pass.Reproject); cmd.CopyTexture(m_Resolve, 0, 0, m_History, 0, 0); cmd.ReleaseTemporaryRT(ShaderIDs.SSRResolveTemp); } cmd.ReleaseTemporaryRT(ShaderIDs.Test); // Pre-cache mipmaps ids if (m_MipIDs == null || m_MipIDs.Length == 0) { m_MipIDs = new int[kMaxLods]; for (int i = 0; i < kMaxLods; i++) m_MipIDs[i] = Shader.PropertyToID("_SSRGaussianMip" + i); } var compute = context.resources.computeShaders.gaussianDownsample; int kernel = compute.FindKernel("KMain"); var last = new RenderTargetIdentifier(m_Resolve); for (int i = 0; i < lodCount; i++) { size >>= 1; Assert.IsTrue(size > 0); cmd.GetTemporaryRT(m_MipIDs[i], size, size, 0, FilterMode.Bilinear, context.sourceFormat, RenderTextureReadWrite.Default, 1, true); cmd.SetComputeTextureParam(compute, kernel, "_Source", last); cmd.SetComputeTextureParam(compute, kernel, "_Result", m_MipIDs[i]); cmd.SetComputeVectorParam(compute, "_Size", new Vector4(size, size, 1f / size, 1f / size)); cmd.DispatchCompute(compute, kernel, size / 8, size / 8, 1); cmd.CopyTexture(m_MipIDs[i], 0, 0, m_Resolve, 0, i + 1); last = m_MipIDs[i]; } for (int i = 0; i < lodCount; i++) cmd.ReleaseTemporaryRT(m_MipIDs[i]); sheet.properties.SetTexture(ShaderIDs.Resolve, m_Resolve); cmd.BlitFullscreenTriangle(context.source, context.destination, sheet, (int)Pass.Composite); cmd.EndSample("Screen-space Reflections"); } public override void Release() { RuntimeUtilities.Destroy(m_Resolve); RuntimeUtilities.Destroy(m_History); m_Resolve = null; m_History = null; } } }

File no 89: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/SubpixelMorphologicalAntialiasing.cs
using System; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// This class holds settings for the Subpixel Morphological Anti-aliasing (SMAA) effect. /// </summary> #if UNITY_2017_1_OR_NEWER [UnityEngine.Scripting.Preserve] #endif [Serializable] public sealed class SubpixelMorphologicalAntialiasing { enum Pass { EdgeDetection = 0, BlendWeights = 3, NeighborhoodBlending = 6 } /// <summary> /// Quality presets. /// </summary> public enum Quality { /// <summary> /// Low quality. /// </summary> Low = 0, /// <summary> /// Medium quality. /// </summary> Medium = 1, /// <summary> /// High quality. /// </summary> High = 2 } /// <summary> /// The quality preset to use for the anti-aliasing filter. /// </summary> [Tooltip("Lower quality is faster at the expense of visual quality (Low = ~60%, Medium = ~80%).")] public Quality quality = Quality.High; /// <summary> /// Checks if the effect is supported on the target platform. /// </summary> /// <returns><c>true</c> if the anti-aliasing filter is supported, <c>false</c> otherwise</returns> public bool IsSupported() { return !RuntimeUtilities.isSinglePassStereoEnabled; } internal void Render(PostProcessRenderContext context) { var sheet = context.propertySheets.Get(context.resources.shaders.subpixelMorphologicalAntialiasing); sheet.properties.SetTexture("_AreaTex", context.resources.smaaLuts.area); sheet.properties.SetTexture("_SearchTex", context.resources.smaaLuts.search); var cmd = context.command; cmd.BeginSample("SubpixelMorphologicalAntialiasing"); cmd.GetTemporaryRT(ShaderIDs.SMAA_Flip, context.width, context.height, 0, FilterMode.Bilinear, context.sourceFormat, RenderTextureReadWrite.Linear); cmd.GetTemporaryRT(ShaderIDs.SMAA_Flop, context.width, context.height, 0, FilterMode.Bilinear, context.sourceFormat, RenderTextureReadWrite.Linear); cmd.BlitFullscreenTriangle(context.source, ShaderIDs.SMAA_Flip, sheet, (int)Pass.EdgeDetection + (int)quality, true); cmd.BlitFullscreenTriangle(ShaderIDs.SMAA_Flip, ShaderIDs.SMAA_Flop, sheet, (int)Pass.BlendWeights + (int)quality); cmd.SetGlobalTexture("_BlendTex", ShaderIDs.SMAA_Flop); cmd.BlitFullscreenTriangle(context.source, context.destination, sheet, (int)Pass.NeighborhoodBlending); cmd.ReleaseTemporaryRT(ShaderIDs.SMAA_Flip); cmd.ReleaseTemporaryRT(ShaderIDs.SMAA_Flop); cmd.EndSample("SubpixelMorphologicalAntialiasing"); } } }

File no 90: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/TemporalAntialiasing.cs
using System; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// This class holds settings for the Temporal Anti-aliasing (TAA) effect. /// </summary> #if UNITY_2017_1_OR_NEWER [UnityEngine.Scripting.Preserve] #endif [Serializable] public sealed class TemporalAntialiasing { /// <summary> /// The diameter (in texels) inside which jitter samples are spread. Smaller values result /// in crisper but more aliased output, while larger values result in more stable but /// blurrier output. /// </summary> [Tooltip("The diameter (in texels) inside which jitter samples are spread. Smaller values result in crisper but more aliased output, while larger values result in more stable, but blurrier, output.")] [Range(0.1f, 1f)] public float jitterSpread = 0.75f; /// <summary> /// Controls the amount of sharpening applied to the color buffer. High values may introduce /// dark-border artifacts. /// </summary> [Tooltip("Controls the amount of sharpening applied to the color buffer. High values may introduce dark-border artifacts.")] [Range(0f, 3f)] public float sharpness = 0.25f; /// <summary> /// The blend coefficient for a stationary fragment. Controls the percentage of history /// sample blended into the final color. /// </summary> [Tooltip("The blend coefficient for a stationary fragment. Controls the percentage of history sample blended into the final color.")] [Range(0f, 0.99f)] public float stationaryBlending = 0.95f; /// <summary> /// The blend coefficient for a fragment with significant motion. Controls the percentage of /// history sample blended into the final color. /// </summary> [Tooltip("The blend coefficient for a fragment with significant motion. Controls the percentage of history sample blended into the final color.")] [Range(0f, 0.99f)] public float motionBlending = 0.85f; // For custom jittered matrices - use at your own risks public Func<Camera, Vector2, Matrix4x4> jitteredMatrixFunc; public Vector2 jitter { get; private set; } enum Pass { SolverDilate, SolverNoDilate } readonly RenderTargetIdentifier[] m_Mrt = new RenderTargetIdentifier[2]; bool m_ResetHistory = true; const int k_SampleCount = 8; public int sampleIndex { get; private set; } // Ping-pong between two history textures as we can't read & write the same target in the // same pass const int k_NumEyes = 2; const int k_NumHistoryTextures = 2; readonly RenderTexture[][] m_HistoryTextures = new RenderTexture[k_NumEyes][]; readonly int[] m_HistoryPingPong = new int [k_NumEyes]; public bool IsSupported() { return SystemInfo.supportedRenderTargetCount >= 2 && SystemInfo.supportsMotionVectors #if !UNITY_2017_3_OR_NEWER && !RuntimeUtilities.isVREnabled #endif && SystemInfo.graphicsDeviceType != GraphicsDeviceType.OpenGLES2; } internal DepthTextureMode GetCameraFlags() { return DepthTextureMode.Depth | DepthTextureMode.MotionVectors; } internal void ResetHistory() { m_ResetHistory = true; } Vector2 GenerateRandomOffset() { // The variance between 0 and the actual halton sequence values reveals noticeable instability // in Unity's shadow maps, so we avoid index 0. var offset = new Vector2( HaltonSeq.Get((sampleIndex & 1023) + 1, 2) - 0.5f, HaltonSeq.Get((sampleIndex & 1023) + 1, 3) - 0.5f ); if (++sampleIndex >= k_SampleCount) sampleIndex = 0; return offset; } public Matrix4x4 GetJitteredProjectionMatrix(Camera camera) { Matrix4x4 cameraProj; jitter = GenerateRandomOffset(); jitter *= jitterSpread; if (jitteredMatrixFunc != null) { cameraProj = jitteredMatrixFunc(camera, jitter); } else { cameraProj = camera.orthographic ? RuntimeUtilities.GetJitteredOrthographicProjectionMatrix(camera, jitter) : RuntimeUtilities.GetJitteredPerspectiveProjectionMatrix(camera, jitter); } jitter = new Vector2(jitter.x / camera.pixelWidth, jitter.y / camera.pixelHeight); return cameraProj; } public void ConfigureJitteredProjectionMatrix(PostProcessRenderContext context) { var camera = context.camera; camera.nonJitteredProjectionMatrix = camera.projectionMatrix; camera.projectionMatrix = GetJitteredProjectionMatrix(camera); camera.useJitteredProjectionMatrixForTransparentRendering = false; } // TODO: We'll probably need to isolate most of this for SRPs public void ConfigureStereoJitteredProjectionMatrices(PostProcessRenderContext context) { #if UNITY_2017_3_OR_NEWER var camera = context.camera; jitter = GenerateRandomOffset(); jitter *= jitterSpread; for (var eye = Camera.StereoscopicEye.Left; eye <= Camera.StereoscopicEye.Right; eye++) { // This saves off the device generated projection matrices as non-jittered context.camera.CopyStereoDeviceProjectionMatrixToNonJittered(eye); var originalProj = context.camera.GetStereoNonJitteredProjectionMatrix(eye); // Currently no support for custom jitter func, as VR devices would need to provide // original projection matrix as input along with jitter var jitteredMatrix = RuntimeUtilities.GenerateJitteredProjectionMatrixFromOriginal(context, originalProj, jitter); context.camera.SetStereoProjectionMatrix(eye, jitteredMatrix); } // jitter has to be scaled for the actual eye texture size, not just the intermediate texture size // which could be double-wide in certain stereo rendering scenarios jitter = new Vector2(jitter.x / context.screenWidth, jitter.y / context.screenHeight); camera.useJitteredProjectionMatrixForTransparentRendering = false; #endif } void GenerateHistoryName(RenderTexture rt, int id, PostProcessRenderContext context) { rt.name = "Temporal Anti-aliasing History id #" + id; if (context.stereoActive) rt.name += " for eye " + context.xrActiveEye; } RenderTexture CheckHistory(int id, PostProcessRenderContext context) { int activeEye = context.xrActiveEye; if (m_HistoryTextures[activeEye] == null) m_HistoryTextures[activeEye] = new RenderTexture[k_NumHistoryTextures]; var rt = m_HistoryTextures[activeEye][id]; if (m_ResetHistory || rt == null || !rt.IsCreated()) { RenderTexture.ReleaseTemporary(rt); rt = context.GetScreenSpaceTemporaryRT(0, context.sourceFormat); GenerateHistoryName(rt, id, context); rt.filterMode = FilterMode.Bilinear; m_HistoryTextures[activeEye][id] = rt; context.command.BlitFullscreenTriangle(context.source, rt); } else if (rt.width != context.width || rt.height != context.height) { // On size change, simply copy the old history to the new one. This looks better // than completely discarding the history and seeing a few aliased frames. var rt2 = context.GetScreenSpaceTemporaryRT(0, context.sourceFormat); GenerateHistoryName(rt2, id, context); rt2.filterMode = FilterMode.Bilinear; m_HistoryTextures[activeEye][id] = rt2; context.command.BlitFullscreenTriangle(rt, rt2); RenderTexture.ReleaseTemporary(rt); } return m_HistoryTextures[activeEye][id]; } internal void Render(PostProcessRenderContext context) { var sheet = context.propertySheets.Get(context.resources.shaders.temporalAntialiasing); var cmd = context.command; cmd.BeginSample("TemporalAntialiasing"); int pp = m_HistoryPingPong[context.xrActiveEye]; var historyRead = CheckHistory(++pp % 2, context); var historyWrite = CheckHistory(++pp % 2, context); m_HistoryPingPong[context.xrActiveEye] = ++pp % 2; const float kMotionAmplification = 100f * 60f; sheet.properties.SetVector(ShaderIDs.Jitter, jitter); sheet.properties.SetFloat(ShaderIDs.Sharpness, sharpness); sheet.properties.SetVector(ShaderIDs.FinalBlendParameters, new Vector4(stationaryBlending, motionBlending, kMotionAmplification, 0f)); sheet.properties.SetTexture(ShaderIDs.HistoryTex, historyRead); // TODO: Account for different possible RenderViewportScale value from previous frame... int pass = context.camera.orthographic ? (int)Pass.SolverNoDilate : (int)Pass.SolverDilate; m_Mrt[0] = context.destination; m_Mrt[1] = historyWrite; cmd.BlitFullscreenTriangle(context.source, m_Mrt, context.source, sheet, pass); cmd.EndSample("TemporalAntialiasing"); m_ResetHistory = false; } internal void Release() { if (m_HistoryTextures != null) { for (int i = 0; i < m_HistoryTextures.Length; i++) { if (m_HistoryTextures[i] == null) continue; for (int j = 0; j < m_HistoryTextures[i].Length; j++) { RenderTexture.ReleaseTemporary(m_HistoryTextures[i][j]); m_HistoryTextures[i][j] = null; } m_HistoryTextures[i] = null; } } sampleIndex = 0; m_HistoryPingPong[0] = 0; m_HistoryPingPong[1] = 0; ResetHistory(); } } }

File no 91: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Effects/Vignette.cs
using System; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// A list of available render modes for the Vignette effect. /// </summary> public enum VignetteMode { /// <summary> /// This mode offers parametric controls for the position, shape and intensity of the Vignette. /// </summary> Classic, /// <summary> /// This mode multiplies a custom texture mask over the screen to create a Vignette effect. /// </summary> Masked } /// <summary> /// A volume parameter holding a <see cref="VignetteMode"/> value. /// </summary> [Serializable] public sealed class VignetteModeParameter : ParameterOverride<VignetteMode> {} /// <summary> /// This class holds settings for the Vignette effect. /// </summary> [Serializable] [PostProcess(typeof(VignetteRenderer), "Unity/Vignette")] public sealed class Vignette : PostProcessEffectSettings { /// <summary> /// Use the \"Classic\" mode for parametric controls. Use the \"Masked\" mode to use your own texture mask. /// </summary> [Tooltip("Use the \"Classic\" mode for parametric controls. Use the \"Masked\" mode to use your own texture mask.")] public VignetteModeParameter mode = new VignetteModeParameter { value = VignetteMode.Classic }; /// <summary> /// The color to use to tint the vignette. /// </summary> [Tooltip("Vignette color.")] public ColorParameter color = new ColorParameter { value = new Color(0f, 0f, 0f, 1f) }; /// <summary> /// Sets the vignette center point (screen center is <c>[0.5,0.5]</c>). /// </summary> [Tooltip("Sets the vignette center point (screen center is [0.5, 0.5]).")] public Vector2Parameter center = new Vector2Parameter { value = new Vector2(0.5f, 0.5f) }; /// <summary> /// The amount of vignetting on screen. /// </summary> [Range(0f, 1f), Tooltip("Amount of vignetting on screen.")] public FloatParameter intensity = new FloatParameter { value = 0f }; /// <summary> /// The smoothness of the vignette borders. /// </summary> [Range(0.01f, 1f), Tooltip("Smoothness of the vignette borders.")] public FloatParameter smoothness = new FloatParameter { value = 0.2f }; /// <summary> /// Lower values will make a square-ish vignette. /// </summary> [Range(0f, 1f), Tooltip("Lower values will make a square-ish vignette.")] public FloatParameter roundness = new FloatParameter { value = 1f }; /// <summary> /// Should the vignette be perfectly round or be dependent on the current aspect ratio? /// </summary> [Tooltip("Set to true to mark the vignette to be perfectly round. False will make its shape dependent on the current aspect ratio.")] public BoolParameter rounded = new BoolParameter { value = false }; /// <summary> /// A black and white mask to use as a vignette. /// </summary> [Tooltip("A black and white mask to use as a vignette.")] public TextureParameter mask = new TextureParameter { value = null }; /// <summary> /// Mask opacity. /// </summary> [Range(0f, 1f), Tooltip("Mask opacity.")] public FloatParameter opacity = new FloatParameter { value = 1f }; /// <inheritdoc /> public override bool IsEnabledAndSupported(PostProcessRenderContext context) { return enabled.value && ((mode.value == VignetteMode.Classic && intensity.value > 0f) || (mode.value == VignetteMode.Masked && opacity.value > 0f && mask.value != null)); } } #if UNITY_2017_1_OR_NEWER [UnityEngine.Scripting.Preserve] #endif internal sealed class VignetteRenderer : PostProcessEffectRenderer<Vignette> { public override void Render(PostProcessRenderContext context) { var sheet = context.uberSheet; sheet.EnableKeyword("VIGNETTE"); sheet.properties.SetColor(ShaderIDs.Vignette_Color, settings.color.value); if (settings.mode == VignetteMode.Classic) { sheet.properties.SetFloat(ShaderIDs.Vignette_Mode, 0f); sheet.properties.SetVector(ShaderIDs.Vignette_Center, settings.center.value); float roundness = (1f - settings.roundness.value) * 6f + settings.roundness.value; sheet.properties.SetVector(ShaderIDs.Vignette_Settings, new Vector4(settings.intensity.value * 3f, settings.smoothness.value * 5f, roundness, settings.rounded.value ? 1f : 0f)); } else // Masked { sheet.properties.SetFloat(ShaderIDs.Vignette_Mode, 1f); sheet.properties.SetTexture(ShaderIDs.Vignette_Mask, settings.mask.value); sheet.properties.SetFloat(ShaderIDs.Vignette_Opacity, Mathf.Clamp01(settings.opacity.value)); } } } }

File no 92: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Monitors/HistogramMonitor.cs
using System; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// This class holds settings for the Histogram monitor. /// </summary> [Serializable] public sealed class HistogramMonitor : Monitor { /// <summary> /// Displayable channels. /// </summary> public enum Channel { /// <summary> /// The red channel. /// </summary> Red, /// <summary> /// The green channel. /// </summary> Green, /// <summary> /// The blue channel. /// </summary> Blue, /// <summary> /// The master (luminance) channel. /// </summary> Master } /// <summary> /// The width of the rendered histogram. /// </summary> public int width = 512; /// <summary> /// The height of the rendered histogram. /// </summary> public int height = 256; /// <summary> /// The channel to render. /// </summary> public Channel channel = Channel.Master; ComputeBuffer m_Data; const int k_NumBins = 256; const int k_ThreadGroupSizeX = 16; const int k_ThreadGroupSizeY = 16; internal override void OnDisable() { base.OnDisable(); if (m_Data != null) m_Data.Release(); m_Data = null; } internal override bool NeedsHalfRes() { return true; } internal override bool ShaderResourcesAvailable(PostProcessRenderContext context) { return context.resources.computeShaders.gammaHistogram; } internal override void Render(PostProcessRenderContext context) { CheckOutput(width, height); if (m_Data == null) m_Data = new ComputeBuffer(k_NumBins, sizeof(uint)); var compute = context.resources.computeShaders.gammaHistogram; var cmd = context.command; cmd.BeginSample("GammaHistogram"); // Clear the buffer on every frame as we use it to accumulate values on every frame int kernel = compute.FindKernel("KHistogramClear"); cmd.SetComputeBufferParam(compute, kernel, "_HistogramBuffer", m_Data); cmd.DispatchCompute(compute, kernel, Mathf.CeilToInt(k_NumBins / (float)k_ThreadGroupSizeX), 1, 1); // Gather all pixels and fill in our histogram kernel = compute.FindKernel("KHistogramGather"); var parameters = new Vector4( context.width / 2, context.height / 2, RuntimeUtilities.isLinearColorSpace ? 1 : 0, (int)channel ); cmd.SetComputeVectorParam(compute, "_Params", parameters); cmd.SetComputeTextureParam(compute, kernel, "_Source", ShaderIDs.HalfResFinalCopy); cmd.SetComputeBufferParam(compute, kernel, "_HistogramBuffer", m_Data); cmd.DispatchCompute(compute, kernel, Mathf.CeilToInt(parameters.x / k_ThreadGroupSizeX), Mathf.CeilToInt(parameters.y / k_ThreadGroupSizeY), 1 ); // Generate the histogram texture var sheet = context.propertySheets.Get(context.resources.shaders.gammaHistogram); sheet.properties.SetVector(ShaderIDs.Params, new Vector4(width, height, 0f, 0f)); sheet.properties.SetBuffer(ShaderIDs.HistogramBuffer, m_Data); cmd.BlitFullscreenTriangle(BuiltinRenderTextureType.None, output, sheet, 0); cmd.EndSample("GammaHistogram"); } } }

File no 93: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Monitors/LightMeterMonitor.cs
﻿using System; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// This class holds settings for the Light Meter monitor. /// </summary> [Serializable] public sealed class LightMeterMonitor : Monitor { /// <summary> /// The width of the rendered light meter. /// </summary> public int width = 512; /// <summary> /// The height of the rendered light meter. /// </summary> public int height = 256; /// <summary> /// Should we display grading and tonemapping curves on top? /// </summary> /// <remarks> /// This only works when <see cref="GradingMode.HighDefinitionRange"/> is active. /// </remarks> public bool showCurves = true; internal override bool ShaderResourcesAvailable(PostProcessRenderContext context) { return context.resources.shaders.lightMeter && context.resources.shaders.lightMeter.isSupported; } internal override void Render(PostProcessRenderContext context) { CheckOutput(width, height); var histogram = context.logHistogram; var sheet = context.propertySheets.Get(context.resources.shaders.lightMeter); sheet.ClearKeywords(); sheet.properties.SetBuffer(ShaderIDs.HistogramBuffer, histogram.data); var scaleOffsetRes = histogram.GetHistogramScaleOffsetRes(context); scaleOffsetRes.z = 1f / width; scaleOffsetRes.w = 1f / height; sheet.properties.SetVector(ShaderIDs.ScaleOffsetRes, scaleOffsetRes); if (context.logLut != null && showCurves) { sheet.EnableKeyword("COLOR_GRADING_HDR"); sheet.properties.SetTexture(ShaderIDs.Lut3D, context.logLut); } var autoExpo = context.autoExposure; if (autoExpo != null) { // Make sure filtering values are correct to avoid apocalyptic consequences float lowPercent = autoExpo.filtering.value.x; float highPercent = autoExpo.filtering.value.y; const float kMinDelta = 1e-2f; highPercent = Mathf.Clamp(highPercent, 1f + kMinDelta, 99f); lowPercent = Mathf.Clamp(lowPercent, 1f, highPercent - kMinDelta); var parameters = new Vector4( lowPercent * 0.01f, highPercent * 0.01f, RuntimeUtilities.Exp2(autoExpo.minLuminance.value), RuntimeUtilities.Exp2(autoExpo.maxLuminance.value) ); sheet.EnableKeyword("AUTO_EXPOSURE"); sheet.properties.SetVector(ShaderIDs.Params, parameters); } var cmd = context.command; cmd.BeginSample("LightMeter"); cmd.BlitFullscreenTriangle(BuiltinRenderTextureType.None, output, sheet, 0); cmd.EndSample("LightMeter"); } } }

File no 94: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Monitors/Monitor.cs
namespace UnityEngine.Rendering.PostProcessing { public enum MonitorType { LightMeter, Histogram, Waveform, Vectorscope } public abstract class Monitor { public RenderTexture output { get; protected set; } internal bool requested = false; public bool IsRequestedAndSupported(PostProcessRenderContext context) { return requested && SystemInfo.supportsComputeShaders && !RuntimeUtilities.isAndroidOpenGL && ShaderResourcesAvailable(context); } internal abstract bool ShaderResourcesAvailable(PostProcessRenderContext context); internal virtual bool NeedsHalfRes() { return false; } protected void CheckOutput(int width, int height) { if (output == null || !output.IsCreated() || output.width != width || output.height != height) { RuntimeUtilities.Destroy(output); output = new RenderTexture(width, height, 0, RenderTextureFormat.ARGB32) { anisoLevel = 0, filterMode = FilterMode.Bilinear, wrapMode = TextureWrapMode.Clamp, useMipMap = false }; } } internal virtual void OnEnable() { } internal virtual void OnDisable() { RuntimeUtilities.Destroy(output); } internal abstract void Render(PostProcessRenderContext context); } }

File no 95: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Monitors/VectorscopeMonitor.cs
using System; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// This class holds settings for the Vectorscope monitor. /// </summary> [Serializable] public sealed class VectorscopeMonitor : Monitor { /// <summary> /// The width and height of the rendered vectorscope. /// </summary> public int size = 256; /// <summary> /// The exposure multiplier applied to the vectorscope values. /// </summary> public float exposure = 0.12f; ComputeBuffer m_Data; const int k_ThreadGroupSizeX = 16; const int k_ThreadGroupSizeY = 16; internal override void OnDisable() { base.OnDisable(); if (m_Data != null) m_Data.Release(); m_Data = null; } internal override bool NeedsHalfRes() { return true; } internal override bool ShaderResourcesAvailable(PostProcessRenderContext context) { return context.resources.computeShaders.vectorscope; } internal override void Render(PostProcessRenderContext context) { CheckOutput(size, size); exposure = Mathf.Max(0f, exposure); int count = size * size; if (m_Data == null) m_Data = new ComputeBuffer(count, sizeof(uint)); else if (m_Data.count != count) { m_Data.Release(); m_Data = new ComputeBuffer(count, sizeof(uint)); } var compute = context.resources.computeShaders.vectorscope; var cmd = context.command; cmd.BeginSample("Vectorscope"); var parameters = new Vector4( context.width / 2, context.height / 2, size, RuntimeUtilities.isLinearColorSpace ? 1 : 0 ); // Clear the buffer on every frame as we use it to accumulate values on every frame int kernel = compute.FindKernel("KVectorscopeClear"); cmd.SetComputeBufferParam(compute, kernel, "_VectorscopeBuffer", m_Data); cmd.SetComputeVectorParam(compute, "_Params", parameters); cmd.DispatchCompute(compute, kernel, Mathf.CeilToInt(size / (float)k_ThreadGroupSizeX), Mathf.CeilToInt(size / (float)k_ThreadGroupSizeY), 1 ); // Gather all pixels and fill in our histogram kernel = compute.FindKernel("KVectorscopeGather"); cmd.SetComputeBufferParam(compute, kernel, "_VectorscopeBuffer", m_Data); cmd.SetComputeTextureParam(compute, kernel, "_Source", ShaderIDs.HalfResFinalCopy); cmd.DispatchCompute(compute, kernel, Mathf.CeilToInt(parameters.x / k_ThreadGroupSizeX), Mathf.CeilToInt(parameters.y / k_ThreadGroupSizeY), 1 ); // Generate the histogram texture var sheet = context.propertySheets.Get(context.resources.shaders.vectorscope); sheet.properties.SetVector(ShaderIDs.Params, new Vector4(size, size, exposure, 0f)); sheet.properties.SetBuffer(ShaderIDs.VectorscopeBuffer, m_Data); cmd.BlitFullscreenTriangle(BuiltinRenderTextureType.None, output, sheet, 0); cmd.EndSample("Vectorscope"); } } }

File no 96: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Monitors/WaveformMonitor.cs
using System; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// This class holds settings for the Waveform monitor. /// </summary> [Serializable] public sealed class WaveformMonitor : Monitor { /// <summary> /// The exposure multiplier applied to the waveform values. /// </summary> public float exposure = 0.12f; /// <summary> /// The height of the rendered waveform. /// </summary> /// <remarks> /// Waveforms display localized values so the width is dynamic and depends on the current /// aspect ratio. /// </remarks> public int height = 256; ComputeBuffer m_Data; const int k_ThreadGroupSize = 256; const int k_ThreadGroupSizeX = 16; const int k_ThreadGroupSizeY = 16; internal override void OnDisable() { base.OnDisable(); if (m_Data != null) m_Data.Release(); m_Data = null; } internal override bool NeedsHalfRes() { return true; } internal override bool ShaderResourcesAvailable(PostProcessRenderContext context) { return context.resources.computeShaders.waveform; } internal override void Render(PostProcessRenderContext context) { // Waveform show localized data, so width depends on the aspect ratio float ratio = (context.width / 2f) / (context.height / 2f); int width = Mathf.FloorToInt(height * ratio); CheckOutput(width, height); exposure = Mathf.Max(0f, exposure); int count = width * height; if (m_Data == null) { m_Data = new ComputeBuffer(count, sizeof(uint) << 2); } else if (m_Data.count < count) { m_Data.Release(); m_Data = new ComputeBuffer(count, sizeof(uint) << 2); } var compute = context.resources.computeShaders.waveform; var cmd = context.command; cmd.BeginSample("Waveform"); var parameters = new Vector4( width, height, RuntimeUtilities.isLinearColorSpace ? 1 : 0, 0f ); // Clear the buffer on every frame int kernel = compute.FindKernel("KWaveformClear"); cmd.SetComputeBufferParam(compute, kernel, "_WaveformBuffer", m_Data); cmd.SetComputeVectorParam(compute, "_Params", parameters); cmd.DispatchCompute(compute, kernel, Mathf.CeilToInt(width / (float)k_ThreadGroupSizeX), Mathf.CeilToInt(height / (float)k_ThreadGroupSizeY), 1); // For performance reasons, especially on consoles, we'll just downscale the source // again to reduce VMEM stalls. Eventually the whole algorithm needs to be rewritten as // it's currently pretty naive. cmd.GetTemporaryRT(ShaderIDs.WaveformSource, width, height, 0, FilterMode.Bilinear, context.sourceFormat); cmd.BlitFullscreenTriangle(ShaderIDs.HalfResFinalCopy, ShaderIDs.WaveformSource); // Gather all pixels and fill in our waveform kernel = compute.FindKernel("KWaveformGather"); cmd.SetComputeBufferParam(compute, kernel, "_WaveformBuffer", m_Data); cmd.SetComputeTextureParam(compute, kernel, "_Source", ShaderIDs.WaveformSource); cmd.SetComputeVectorParam(compute, "_Params", parameters); cmd.DispatchCompute(compute, kernel, width, Mathf.CeilToInt(height / (float)k_ThreadGroupSize), 1); cmd.ReleaseTemporaryRT(ShaderIDs.WaveformSource); // Generate the waveform texture var sheet = context.propertySheets.Get(context.resources.shaders.waveform); sheet.properties.SetVector(ShaderIDs.Params, new Vector4(width, height, exposure, 0f)); sheet.properties.SetBuffer(ShaderIDs.WaveformBuffer, m_Data); cmd.BlitFullscreenTriangle(BuiltinRenderTextureType.None, output, sheet, 0); cmd.EndSample("Waveform"); } } }

File no 97: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Utils/ColorUtilities.cs
namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// A set of utilities to manipulate color values. /// </summary> public static class ColorUtilities { /// <summary> /// Gets the Y coordinate for the chromaticity of the standard illuminant. /// </summary> /// <param name="x">The X coordinate</param> /// <returns>The Y coordinate for the chromaticity of the standard illuminant</returns> /// <remarks> /// Based on: "An analytical model of chromaticity of the standard illuminant" by Judd et al. /// http://en.wikipedia.org/wiki/Standard_illuminant#Illuminant_series_D /// Slightly modified to adjust it with the D65 white point (x=0.31271, y=0.32902). /// </remarks> public static float StandardIlluminantY(float x) { return 2.87f * x - 3f * x * x - 0.27509507f; } /// <summary> /// Converts CIExy chromaticity to CAT02 LMS. /// </summary> /// <param name="x">The X coordinate</param> /// <param name="y">The Y coordinate</param> /// <returns>The CIExy chromaticity converted to CAT02 LMS</returns> /// <remarks> /// See: http://en.wikipedia.org/wiki/LMS_color_space#CAT02 /// </remarks> public static Vector3 CIExyToLMS(float x, float y) { float Y = 1f; float X = Y * x / y; float Z = Y * (1f - x - y) / y; float L = 0.7328f * X + 0.4296f * Y - 0.1624f * Z; float M = -0.7036f * X + 1.6975f * Y + 0.0061f * Z; float S = 0.0030f * X + 0.0136f * Y + 0.9834f * Z; return new Vector3(L, M, S); } /// <summary> /// Computes the color balance coefficients in the CAT02 LMS space. /// </summary> /// <param name="temperature">The color temperature offset</param> /// <param name="tint">The color tint offset (green/magenta)</param> /// <returns>The color balance coefficients in the CAT02 LMS space.</returns> public static Vector3 ComputeColorBalance(float temperature, float tint) { // Range ~[-1.67;1.67] works best float t1 = temperature / 60f; float t2 = tint / 60f; // Get the CIE xy chromaticity of the reference white point. // Note: 0.31271 = x value on the D65 white point float x = 0.31271f - t1 * (t1 < 0f ? 0.1f : 0.05f); float y = StandardIlluminantY(x) + t2 * 0.05f; // Calculate the coefficients in the LMS space. var w1 = new Vector3(0.949237f, 1.03542f, 1.08728f); // D65 white point var w2 = CIExyToLMS(x, y); return new Vector3(w1.x / w2.x, w1.y / w2.y, w1.z / w2.z); } /// <summary> /// Converts trackball values to Lift coefficients. /// </summary> /// <param name="color">The trackball color value (with offset in the W component)</param> /// <returns>The converted trackball value</returns> public static Vector3 ColorToLift(Vector4 color) { // Shadows var S = new Vector3(color.x, color.y, color.z); float lumLift = S.x * 0.2126f + S.y * 0.7152f + S.z * 0.0722f; S = new Vector3(S.x - lumLift, S.y - lumLift, S.z - lumLift); float liftOffset = color.w; return new Vector3(S.x + liftOffset, S.y + liftOffset, S.z + liftOffset); } /// <summary> /// Converts trackball values to inverted Gamma coefficients. /// </summary> /// <param name="color">The trackball color value (with offset in the W component)</param> /// <returns>The converted trackball value</returns> public static Vector3 ColorToInverseGamma(Vector4 color) { // Midtones var M = new Vector3(color.x, color.y, color.z); float lumGamma = M.x * 0.2126f + M.y * 0.7152f + M.z * 0.0722f; M = new Vector3(M.x - lumGamma, M.y - lumGamma, M.z - lumGamma); float gammaOffset = color.w + 1f; return new Vector3( 1f / Mathf.Max(M.x + gammaOffset, 1e-03f), 1f / Mathf.Max(M.y + gammaOffset, 1e-03f), 1f / Mathf.Max(M.z + gammaOffset, 1e-03f) ); } /// <summary> /// Converts trackball values to Gain coefficients. /// </summary> /// <param name="color">The trackball color value (with offset in the W component)</param> /// <returns>The converted trackball value</returns> public static Vector3 ColorToGain(Vector4 color) { // Highlights var H = new Vector3(color.x, color.y, color.z); float lumGain = H.x * 0.2126f + H.y * 0.7152f + H.z * 0.0722f; H = new Vector3(H.x - lumGain, H.y - lumGain, H.z - lumGain); float gainOffset = color.w + 1f; return new Vector3(H.x + gainOffset, H.y + gainOffset, H.z + gainOffset); } // Alexa LogC converters (El 1000) // See http://www.vocas.nl/webfm_send/964 const float logC_cut = 0.011361f; const float logC_a = 5.555556f; const float logC_b = 0.047996f; const float logC_c = 0.244161f; const float logC_d = 0.386036f; const float logC_e = 5.301883f; const float logC_f = 0.092819f; /// <summary> /// Converts a LogC (Alexa El 1000) value to linear. /// </summary> /// <param name="x">A LogC (Alexa El 1000) value</param> /// <returns>The input convert to linear</returns> public static float LogCToLinear(float x) { return x > logC_e * logC_cut + logC_f ? (Mathf.Pow(10f, (x - logC_d) / logC_c) - logC_b) / logC_a : (x - logC_f) / logC_e; } /// <summary> /// Converts a linear value to LogC (Alexa El 1000). /// </summary> /// <param name="x">A linear value</param> /// <returns>The input value converted to LogC</returns> public static float LinearToLogC(float x) { return x > logC_cut ? logC_c * Mathf.Log10(logC_a * x + logC_b) + logC_d : logC_e * x + logC_f; } /// <summary> /// Converts a color to its ARGB hexadecimal representation. /// </summary> /// <param name="c">The color to convert</param> /// <returns>The color converted to its ARGB hexadecimal representation</returns> public static uint ToHex(Color c) { return ((uint)(c.a * 255) << 24) | ((uint)(c.r * 255) << 16) | ((uint)(c.g * 255) << 8) | ((uint)(c.b * 255)); } /// <summary> /// Converts an ARGB hexadecimal input to a color structure. /// </summary> /// <param name="hex">The hexadecimal input</param> /// <returns>The ARGB hexadecimal input converted to a color structure.</returns> public static Color ToRGBA(uint hex) { return new Color( ((hex >> 16) & 0xff) / 255f, // r ((hex >> 8) & 0xff) / 255f, // g ((hex ) & 0xff) / 255f, // b ((hex >> 24) & 0xff) / 255f // a ); } } }

File no 98: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Utils/HableCurve.cs
namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// A raw implementation of John Hable's artist-friendly tonemapping curve. /// See http://filmicworlds.com/blog/filmic-tonemapping-with-piecewise-power-curves/ /// </summary> public class HableCurve { class Segment { public float offsetX; public float offsetY; public float scaleX; public float scaleY; public float lnA; public float B; public float Eval(float x) { float x0 = (x - offsetX) * scaleX; float y0 = 0f; // log(0) is undefined but our function should evaluate to 0. There are better ways to handle this, // but it's doing it the slow way here for clarity. if (x0 > 0) y0 = Mathf.Exp(lnA + B * Mathf.Log(x0)); return y0 * scaleY + offsetY; } } struct DirectParams { internal float x0; internal float y0; internal float x1; internal float y1; internal float W; internal float overshootX; internal float overshootY; internal float gamma; } /// <summary> /// The curve's white point. /// </summary> public float whitePoint { get; private set; } /// <summary> /// The inverse of the curve's white point. /// </summary> public float inverseWhitePoint { get; private set; } internal float x0 { get; private set; } internal float x1 { get; private set; } // Toe, mid, shoulder readonly Segment[] m_Segments = new Segment[3]; /// <summary> /// Creates a new curve. /// </summary> public HableCurve() { for (int i = 0; i < 3; i++) m_Segments[i] = new Segment(); uniforms = new Uniforms(this); } /// <summary> /// Evaluates a given point on the curve. /// </summary> /// <param name="x">The point within the curve to evaluate (on the horizontal axis)</param> /// <returns>The value of the curve, at the point specified</returns> public float Eval(float x) { float normX = x * inverseWhitePoint; int index = (normX < x0) ? 0 : ((normX < x1) ? 1 : 2); var segment = m_Segments[index]; float ret = segment.Eval(normX); return ret; } /// <summary> /// Initializes the curve with given settings. /// </summary> /// <param name="toeStrength">Affects the transition between the toe and the mid section of /// the curve. A value of 0 means no toe, a value of 1 means a very hard transition</param> /// <param name="toeLength">Affects how much of the dynamic range is in the toe. With a /// small value, the toe will be very short and quickly transition into the linear section, /// and with a longer value having a longer toe</param> /// <param name="shoulderStrength">Affects the transition between the mid section and the /// shoulder of the curve. A value of 0 means no shoulder, a value of 1 means a very hard /// transition</param> /// <param name="shoulderLength">Affects how many F-stops (EV) to add to the dynamic range /// of the curve</param> /// <param name="shoulderAngle">Affects how much overshoot to add to the shoulder</param> /// <param name="gamma">Applies a gamma function to the curve</param> public void Init(float toeStrength, float toeLength, float shoulderStrength, float shoulderLength, float shoulderAngle, float gamma) { var dstParams = new DirectParams(); // This is not actually the display gamma. It's just a UI space to avoid having to // enter small numbers for the input. const float kPerceptualGamma = 2.2f; // Constraints { toeLength = Mathf.Pow(Mathf.Clamp01(toeLength), kPerceptualGamma); toeStrength = Mathf.Clamp01(toeStrength); shoulderAngle = Mathf.Clamp01(shoulderAngle); shoulderStrength = Mathf.Clamp(shoulderStrength, 1e-5f, 1f - 1e-5f); shoulderLength = Mathf.Max(0f, shoulderLength); gamma = Mathf.Max(1e-5f, gamma); } // Apply base params { // Toe goes from 0 to 0.5 float x0 = toeLength * 0.5f; float y0 = (1f - toeStrength) * x0; // Lerp from 0 to x0 float remainingY = 1f - y0; float initialW = x0 + remainingY; float y1_offset = (1f - shoulderStrength) * remainingY; float x1 = x0 + y1_offset; float y1 = y0 + y1_offset; // Filmic shoulder strength is in F stops float extraW = RuntimeUtilities.Exp2(shoulderLength) - 1f; float W = initialW + extraW; dstParams.x0 = x0; dstParams.y0 = y0; dstParams.x1 = x1; dstParams.y1 = y1; dstParams.W = W; // Bake the linear to gamma space conversion dstParams.gamma = gamma; } dstParams.overshootX = (dstParams.W * 2f) * shoulderAngle * shoulderLength; dstParams.overshootY = 0.5f * shoulderAngle * shoulderLength; InitSegments(dstParams); } void InitSegments(DirectParams srcParams) { var paramsCopy = srcParams; whitePoint = srcParams.W; inverseWhitePoint = 1f / srcParams.W; // normalize params to 1.0 range paramsCopy.W = 1f; paramsCopy.x0 /= srcParams.W; paramsCopy.x1 /= srcParams.W; paramsCopy.overshootX = srcParams.overshootX / srcParams.W; float toeM = 0f; float shoulderM = 0f; { float m, b; AsSlopeIntercept(out m, out b, paramsCopy.x0, paramsCopy.x1, paramsCopy.y0, paramsCopy.y1); float g = srcParams.gamma; // Base function of linear section plus gamma is // y = (mx+b)^g // // which we can rewrite as // y = exp(g*ln(m) + g*ln(x+b/m)) // // and our evaluation function is (skipping the if parts): /* float x0 = (x - offsetX) * scaleX; y0 = exp(m_lnA + m_B*log(x0)); return y0*scaleY + m_offsetY; */ var midSegment = m_Segments[1]; midSegment.offsetX = -(b / m); midSegment.offsetY = 0f; midSegment.scaleX = 1f; midSegment.scaleY = 1f; midSegment.lnA = g * Mathf.Log(m); midSegment.B = g; toeM = EvalDerivativeLinearGamma(m, b, g, paramsCopy.x0); shoulderM = EvalDerivativeLinearGamma(m, b, g, paramsCopy.x1); // apply gamma to endpoints paramsCopy.y0 = Mathf.Max(1e-5f, Mathf.Pow(paramsCopy.y0, paramsCopy.gamma)); paramsCopy.y1 = Mathf.Max(1e-5f, Mathf.Pow(paramsCopy.y1, paramsCopy.gamma)); paramsCopy.overshootY = Mathf.Pow(1f + paramsCopy.overshootY, paramsCopy.gamma) - 1f; } this.x0 = paramsCopy.x0; this.x1 = paramsCopy.x1; // Toe section { var toeSegment = m_Segments[0]; toeSegment.offsetX = 0; toeSegment.offsetY = 0f; toeSegment.scaleX = 1f; toeSegment.scaleY = 1f; float lnA, B; SolveAB(out lnA, out B, paramsCopy.x0, paramsCopy.y0, toeM); toeSegment.lnA = lnA; toeSegment.B = B; } // Shoulder section { // Use the simple version that is usually too flat var shoulderSegment = m_Segments[2]; float x0 = (1f + paramsCopy.overshootX) - paramsCopy.x1; float y0 = (1f + paramsCopy.overshootY) - paramsCopy.y1; float lnA, B; SolveAB(out lnA, out B, x0, y0, shoulderM); shoulderSegment.offsetX = (1f + paramsCopy.overshootX); shoulderSegment.offsetY = (1f + paramsCopy.overshootY); shoulderSegment.scaleX = -1f; shoulderSegment.scaleY = -1f; shoulderSegment.lnA = lnA; shoulderSegment.B = B; } // Normalize so that we hit 1.0 at our white point. We wouldn't have do this if we // skipped the overshoot part. { // Evaluate shoulder at the end of the curve float scale = m_Segments[2].Eval(1f); float invScale = 1f / scale; m_Segments[0].offsetY *= invScale; m_Segments[0].scaleY *= invScale; m_Segments[1].offsetY *= invScale; m_Segments[1].scaleY *= invScale; m_Segments[2].offsetY *= invScale; m_Segments[2].scaleY *= invScale; } } // Find a function of the form: // f(x) = e^(lnA + Bln(x)) // where // f(0) = 0; not really a constraint // f(x0) = y0 // f'(x0) = m void SolveAB(out float lnA, out float B, float x0, float y0, float m) { B = (m * x0) / y0; lnA = Mathf.Log(y0) - B * Mathf.Log(x0); } // Convert to y=mx+b void AsSlopeIntercept(out float m, out float b, float x0, float x1, float y0, float y1) { float dy = (y1 - y0); float dx = (x1 - x0); if (dx == 0) m = 1f; else m = dy / dx; b = y0 - x0 * m; } // f(x) = (mx+b)^g // f'(x) = gm(mx+b)^(g-1) float EvalDerivativeLinearGamma(float m, float b, float g, float x) { float ret = g * m * Mathf.Pow(m * x + b, g - 1f); return ret; } /// <summary> /// Utility class to retrieve curve values for shader evaluation. /// </summary> public class Uniforms { HableCurve parent; internal Uniforms(HableCurve parent) { this.parent = parent; } /// <summary> /// A pre-built <see cref="Vector4"/> holding: <c>(inverseWhitePoint, x0, x1, 0)</c>. /// </summary> public Vector4 curve { get { return new Vector4(parent.inverseWhitePoint, parent.x0, parent.x1, 0f); } } /// <summary> /// A pre-built <see cref="Vector4"/> holding: <c>(toe.offsetX, toe.offsetY, toe.scaleX, toe.scaleY)</c>. /// </summary> public Vector4 toeSegmentA { get { var toe = parent.m_Segments[0]; return new Vector4(toe.offsetX, toe.offsetY, toe.scaleX, toe.scaleY); } } /// <summary> /// A pre-built <see cref="Vector4"/> holding: <c>(toe.lnA, toe.B, 0, 0)</c>. /// </summary> public Vector4 toeSegmentB { get { var toe = parent.m_Segments[0]; return new Vector4(toe.lnA, toe.B, 0f, 0f); } } /// <summary> /// A pre-built <see cref="Vector4"/> holding: <c>(mid.offsetX, mid.offsetY, mid.scaleX, mid.scaleY)</c>. /// </summary> public Vector4 midSegmentA { get { var mid = parent.m_Segments[1]; return new Vector4(mid.offsetX, mid.offsetY, mid.scaleX, mid.scaleY); } } /// <summary> /// A pre-built <see cref="Vector4"/> holding: <c>(mid.lnA, mid.B, 0, 0)</c>. /// </summary> public Vector4 midSegmentB { get { var mid = parent.m_Segments[1]; return new Vector4(mid.lnA, mid.B, 0f, 0f); } } /// <summary> /// A pre-built <see cref="Vector4"/> holding: <c>(toe.offsetX, toe.offsetY, toe.scaleX, toe.scaleY)</c>. /// </summary> public Vector4 shoSegmentA { get { var sho = parent.m_Segments[2]; return new Vector4(sho.offsetX, sho.offsetY, sho.scaleX, sho.scaleY); } } /// <summary> /// A pre-built <see cref="Vector4"/> holding: <c>(sho.lnA, sho.B, 0, 0)</c>. /// </summary> public Vector4 shoSegmentB { get { var sho = parent.m_Segments[2]; return new Vector4(sho.lnA, sho.B, 0f, 0f); } } } /// <summary> /// The builtin <see cref="Uniforms"/> instance for this curve. /// </summary> public readonly Uniforms uniforms; } }

File no 99: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Utils/HaltonSeq.cs
namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// Halton sequence utility. /// </summary> public static class HaltonSeq { /// <summary> /// Gets a value from the Halton sequence for a given index and radix. /// </summary> /// <param name="index">The sequence index</param> /// <param name="radix">The sequence base</param> /// <returns>A number from the Halton sequence between 0 and 1.</returns> public static float Get(int index, int radix) { float result = 0f; float fraction = 1f / (float)radix; while (index > 0) { result += (float)(index % radix) * fraction; index /= radix; fraction /= (float)radix; } return result; } } }

File no 100: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Utils/LogHistogram.cs
namespace UnityEngine.Rendering.PostProcessing { internal sealed class LogHistogram { public const int rangeMin = -9; // ev public const int rangeMax = 9; // ev // Don't forget to update 'ExposureHistogram.hlsl' if you change these values ! const int k_Bins = 128; public ComputeBuffer data { get; private set; } public void Generate(PostProcessRenderContext context) { if (data == null) data = new ComputeBuffer(k_Bins, sizeof(uint)); uint threadX, threadY, threadZ; var scaleOffsetRes = GetHistogramScaleOffsetRes(context); var compute = context.resources.computeShaders.exposureHistogram; var cmd = context.command; cmd.BeginSample("LogHistogram"); // Clear the buffer on every frame as we use it to accumulate luminance values on each frame int kernel = compute.FindKernel("KEyeHistogramClear"); cmd.SetComputeBufferParam(compute, kernel, "_HistogramBuffer", data); compute.GetKernelThreadGroupSizes(kernel, out threadX, out threadY, out threadZ); cmd.DispatchCompute(compute, kernel, Mathf.CeilToInt(k_Bins / (float)threadX), 1, 1); // Get a log histogram kernel = compute.FindKernel("KEyeHistogram"); cmd.SetComputeBufferParam(compute, kernel, "_HistogramBuffer", data); cmd.SetComputeTextureParam(compute, kernel, "_Source", context.source); cmd.SetComputeVectorParam(compute, "_ScaleOffsetRes", scaleOffsetRes); compute.GetKernelThreadGroupSizes(kernel, out threadX, out threadY, out threadZ); cmd.DispatchCompute(compute, kernel, Mathf.CeilToInt(scaleOffsetRes.z / 2f / threadX), Mathf.CeilToInt(scaleOffsetRes.w / 2f / threadY), 1 ); cmd.EndSample("LogHistogram"); } public Vector4 GetHistogramScaleOffsetRes(PostProcessRenderContext context) { float diff = rangeMax - rangeMin; float scale = 1f / diff; float offset = -rangeMin * scale; return new Vector4(scale, offset, context.width, context.height); } public void Release() { if (data != null) data.Release(); data = null; } } }

File no 101: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Utils/MeshUtilities.cs
using System; using System.Collections.Generic; using UnityEngine.Assertions; namespace UnityEngine.Rendering.PostProcessing { static class MeshUtilities { static Dictionary<PrimitiveType, Mesh> s_Primitives; static Dictionary<Type, PrimitiveType> s_ColliderPrimitives; static MeshUtilities() { s_Primitives = new Dictionary<PrimitiveType, Mesh>(); s_ColliderPrimitives = new Dictionary<Type, PrimitiveType> { { typeof(BoxCollider), PrimitiveType.Cube }, { typeof(SphereCollider), PrimitiveType.Sphere }, { typeof(CapsuleCollider), PrimitiveType.Capsule } }; } internal static Mesh GetColliderMesh(Collider collider) { var type = collider.GetType(); if (type == typeof(MeshCollider)) return ((MeshCollider)collider).sharedMesh; Assert.IsTrue(s_ColliderPrimitives.ContainsKey(type), "Unknown collider"); return GetPrimitive(s_ColliderPrimitives[type]); } internal static Mesh GetPrimitive(PrimitiveType primitiveType) { Mesh mesh; if (!s_Primitives.TryGetValue(primitiveType, out mesh)) { mesh = GetBuiltinMesh(primitiveType); s_Primitives.Add(primitiveType, mesh); } return mesh; } // (Not pretty) hack to get meshes from `unity default resources` in user land // What it does is create a new GameObject using the CreatePrimitive utility, retrieve its // mesh and discard it... static Mesh GetBuiltinMesh(PrimitiveType primitiveType) { var gameObject = GameObject.CreatePrimitive(primitiveType); var mesh = gameObject.GetComponent<MeshFilter>().sharedMesh; RuntimeUtilities.Destroy(gameObject); return mesh; } } }

File no 102: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Utils/PropertySheet.cs
namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// The post-processing stack is entirely built around the use of <see cref="CommandBuffer"/> /// and as such requires the use of <see cref="MaterialPropertyBlock"/> to properly deal with /// the deferred nature of <see cref="CommandBuffer"/>. /// This wrapper abstracts the creation and destruction of <see cref="MaterialPropertyBlock"/> /// and <see cref="Material"/> to make the process easier. /// </summary> /// <seealso cref="PropertySheetFactory"/> public sealed class PropertySheet { /// <summary> /// The actual <see cref="MaterialPropertyBlock"/> to fill. /// </summary> public MaterialPropertyBlock properties { get; private set; } internal Material material { get; private set; } internal PropertySheet(Material material) { this.material = material; properties = new MaterialPropertyBlock(); } /// <summary> /// Clears all keywords set on the source material. /// </summary> public void ClearKeywords() { material.shaderKeywords = null; } /// <summary> /// Enableds a given keyword on the source material. /// </summary> /// <param name="keyword">The keyword to enable</param> public void EnableKeyword(string keyword) { material.EnableKeyword(keyword); } /// <summary> /// Disables a given keyword on the source material. /// </summary> /// <param name="keyword">The keyword to disable</param> public void DisableKeyword(string keyword) { material.DisableKeyword(keyword); } internal void Release() { RuntimeUtilities.Destroy(material); material = null; } } }

File no 103: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Utils/PropertySheetFactory.cs
using System; using System.Collections.Generic; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// A <see cref="PropertySheet"/> factory for easy creation and destruction of <see cref="Material"/> /// and <see cref="MaterialPropertyBlock"/>. /// </summary> /// <seealso cref="PropertySheet"/> public sealed class PropertySheetFactory { readonly Dictionary<Shader, PropertySheet> m_Sheets; /// <summary> /// Creates a new factory. /// </summary> public PropertySheetFactory() { m_Sheets = new Dictionary<Shader, PropertySheet>(); } /// <summary> /// Gets a <see cref="PropertySheet"/> for a given shader identifier. Sheets are recycled /// so you can safely call this method on every frame. /// </summary> /// <param name="shaderName">The name of the shader to retrieve a sheet for</param> /// <returns>A sheet for the given shader</returns> /// <remarks> /// This method will not work when loading post-processing from an asset bundle. For this /// reason it is recommended to use <see cref="Get(Shader)"/> instead. /// </remarks> /// <exception cref="ArgumentException">Thrown if the shader is invalid</exception> [Obsolete("Use PropertySheet.Get(Shader) with a direct reference to the Shader instead.")] public PropertySheet Get(string shaderName) { var shader = Shader.Find(shaderName); if (shader == null) throw new ArgumentException(string.Format("Invalid shader ({0})", shaderName)); return Get(shader); } /// <summary> /// Gets a <see cref="PropertySheet"/> for a given shader instance. Sheets are recycled so /// you can safely call this method on every frame. /// </summary> /// <param name="shader">A shader instance to retrieve a sheet for</param> /// <returns>A sheet for the given shader</returns> /// <exception cref="ArgumentException">Thrown if the shader is invalid</exception> public PropertySheet Get(Shader shader) { PropertySheet sheet; if (shader == null) throw new ArgumentException(string.Format("Invalid shader ({0})", shader)); if (m_Sheets.TryGetValue(shader, out sheet)) return sheet; var shaderName = shader.name; var material = new Material(shader) { name = string.Format("PostProcess - {0}", shaderName.Substring(shaderName.LastIndexOf('/') + 1)), hideFlags = HideFlags.DontSave }; sheet = new PropertySheet(material); m_Sheets.Add(shader, sheet); return sheet; } /// <summary> /// Releases all resources used by this factory. /// </summary> /// <remarks> /// You don't need to call this method when using the builtin factory from /// <see cref="PostProcessRenderContext"/>. /// </remarks> public void Release() { foreach (var sheet in m_Sheets.Values) sheet.Release(); m_Sheets.Clear(); } } }

File no 104: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Utils/RuntimeUtilities.cs
using System; using System.Collections.Generic; using System.Linq; using System.Linq.Expressions; using System.Reflection; using System.Text; using UnityEngine.Assertions; #if UNITY_EDITOR using UnityEditor; #endif namespace UnityEngine.Rendering.PostProcessing { using SceneManagement; using UnityObject = UnityEngine.Object; using LoadAction = RenderBufferLoadAction; using StoreAction = RenderBufferStoreAction; /// <summary> /// A set of runtime utilities used by the post-processing stack. /// </summary> public static class RuntimeUtilities { #region Textures static Texture2D m_WhiteTexture; /// <summary> /// A 1x1 white texture. /// </summary> /// <remarks> /// This texture is only created once and recycled afterward. You shouldn't modify it. /// </remarks> public static Texture2D whiteTexture { get { if (m_WhiteTexture == null) { m_WhiteTexture = new Texture2D(1, 1, TextureFormat.ARGB32, false) { name = "White Texture" }; m_WhiteTexture.SetPixel(0, 0, Color.white); m_WhiteTexture.Apply(); } return m_WhiteTexture; } } static Texture3D m_WhiteTexture3D; /// <summary> /// A 1x1x1 white texture. /// </summary> /// <remarks> /// This texture is only created once and recycled afterward. You shouldn't modify it. /// </remarks> public static Texture3D whiteTexture3D { get { if (m_WhiteTexture3D == null) { m_WhiteTexture3D = new Texture3D(1, 1, 1, TextureFormat.ARGB32, false) { name = "White Texture 3D" }; m_WhiteTexture3D.SetPixels(new Color[] { Color.white }); m_WhiteTexture3D.Apply(); } return m_WhiteTexture3D; } } static Texture2D m_BlackTexture; /// <summary> /// A 1x1 black texture. /// </summary> /// <remarks> /// This texture is only created once and recycled afterward. You shouldn't modify it. /// </remarks> public static Texture2D blackTexture { get { if (m_BlackTexture == null) { m_BlackTexture = new Texture2D(1, 1, TextureFormat.ARGB32, false) { name = "Black Texture" }; m_BlackTexture.SetPixel(0, 0, Color.black); m_BlackTexture.Apply(); } return m_BlackTexture; } } static Texture3D m_BlackTexture3D; /// <summary> /// A 1x1x1 black texture. /// </summary> /// <remarks> /// This texture is only created once and recycled afterward. You shouldn't modify it. /// </remarks> public static Texture3D blackTexture3D { get { if (m_BlackTexture3D == null) { m_BlackTexture3D = new Texture3D(1, 1, 1, TextureFormat.ARGB32, false) { name = "Black Texture 3D" }; m_BlackTexture3D.SetPixels(new Color[] { Color.black }); m_BlackTexture3D.Apply(); } return m_BlackTexture3D; } } static Texture2D m_TransparentTexture; /// <summary> /// A 1x1 transparent texture. /// </summary> /// <remarks> /// This texture is only created once and recycled afterward. You shouldn't modify it. /// </remarks> public static Texture2D transparentTexture { get { if (m_TransparentTexture == null) { m_TransparentTexture = new Texture2D(1, 1, TextureFormat.ARGB32, false) { name = "Transparent Texture" }; m_TransparentTexture.SetPixel(0, 0, Color.clear); m_TransparentTexture.Apply(); } return m_TransparentTexture; } } static Texture3D m_TransparentTexture3D; /// <summary> /// A 1x1x1 transparent texture. /// </summary> /// <remarks> /// This texture is only created once and recycled afterward. You shouldn't modify it. /// </remarks> public static Texture3D transparentTexture3D { get { if (m_TransparentTexture3D == null) { m_TransparentTexture3D = new Texture3D(1, 1, 1, TextureFormat.ARGB32, false) { name = "Transparent Texture 3D" }; m_TransparentTexture3D.SetPixels(new Color[] { Color.clear }); m_TransparentTexture3D.Apply(); } return m_TransparentTexture3D; } } static Dictionary<int, Texture2D> m_LutStrips = new Dictionary<int, Texture2D>(); /// <summary> /// Gets a 2D lookup table for color grading use. Its size will be <c>width = height * height</c>. /// </summary> /// <param name="size">The height of the lookup table</param> /// <returns>A 2D lookup table</returns> /// <remarks> /// Lookup tables are recycled and only created once per size. You shouldn't modify them. /// </remarks> public static Texture2D GetLutStrip(int size) { Texture2D texture; if (!m_LutStrips.TryGetValue(size, out texture)) { int width = size * size; int height = size; var pixels = new Color[width * height]; float inv = 1f / (size - 1f); for (int z = 0; z < size; z++) { var offset = z * size; var b = z * inv; for (int y = 0; y < size; y++) { var g = y * inv; for (int x = 0; x < size; x++) { var r = x * inv; pixels[y * width + offset + x] = new Color(r, g, b); } } } var format = TextureFormat.RGBAHalf; if (!format.IsSupported()) format = TextureFormat.ARGB32; texture = new Texture2D(size * size, size, format, false, true) { name = "Strip Lut" + size, hideFlags = HideFlags.DontSave, filterMode = FilterMode.Bilinear, wrapMode = TextureWrapMode.Clamp, anisoLevel = 0 }; texture.SetPixels(pixels); texture.Apply(); m_LutStrips.Add(size, texture); } return texture; } #endregion #region Rendering static PostProcessResources s_Resources; static Mesh s_FullscreenTriangle; /// <summary> /// A fullscreen triangle mesh. /// </summary> public static Mesh fullscreenTriangle { get { if (s_FullscreenTriangle != null) return s_FullscreenTriangle; s_FullscreenTriangle = new Mesh { name = "Fullscreen Triangle" }; // Because we have to support older platforms (GLES2/3, DX9 etc) we can't do all of // this directly in the vertex shader using vertex ids :( s_FullscreenTriangle.SetVertices(new List<Vector3> { new Vector3(-1f, -1f, 0f), new Vector3(-1f, 3f, 0f), new Vector3( 3f, -1f, 0f) }); s_FullscreenTriangle.SetIndices(new [] { 0, 1, 2 }, MeshTopology.Triangles, 0, false); s_FullscreenTriangle.UploadMeshData(false); return s_FullscreenTriangle; } } static Material s_CopyStdMaterial; /// <summary> /// A simple copy material to use with the builtin pipelines. /// </summary> public static Material copyStdMaterial { get { if (s_CopyStdMaterial != null) return s_CopyStdMaterial; Assert.IsNotNull(s_Resources); var shader = s_Resources.shaders.copyStd; s_CopyStdMaterial = new Material(shader) { name = "PostProcess - CopyStd", hideFlags = HideFlags.HideAndDontSave }; return s_CopyStdMaterial; } } static Material s_CopyStdFromDoubleWideMaterial; /// <summary> /// A double-wide copy material to use with VR and the builtin pipelines. /// </summary> public static Material copyStdFromDoubleWideMaterial { get { if (s_CopyStdFromDoubleWideMaterial != null) return s_CopyStdFromDoubleWideMaterial; Assert.IsNotNull(s_Resources); var shader = s_Resources.shaders.copyStdFromDoubleWide; s_CopyStdFromDoubleWideMaterial = new Material(shader) { name = "PostProcess - CopyStdFromDoubleWide", hideFlags = HideFlags.HideAndDontSave }; return s_CopyStdFromDoubleWideMaterial; } } static Material s_CopyMaterial; /// <summary> /// A simple copy material independent from the rendering pipeline. /// </summary> public static Material copyMaterial { get { if (s_CopyMaterial != null) return s_CopyMaterial; Assert.IsNotNull(s_Resources); var shader = s_Resources.shaders.copy; s_CopyMaterial = new Material(shader) { name = "PostProcess - Copy", hideFlags = HideFlags.HideAndDontSave }; return s_CopyMaterial; } } static Material s_CopyFromTexArrayMaterial; /// <summary> /// A copy material with a texture array slice as a source for the builtin pipelines. /// </summary> public static Material copyFromTexArrayMaterial { get { if (s_CopyFromTexArrayMaterial != null) return s_CopyFromTexArrayMaterial; Assert.IsNotNull(s_Resources); var shader = s_Resources.shaders.copyStdFromTexArray; s_CopyFromTexArrayMaterial = new Material(shader) { name = "PostProcess - CopyFromTexArray", hideFlags = HideFlags.HideAndDontSave }; return s_CopyFromTexArrayMaterial; } } static PropertySheet s_CopySheet; /// <summary> /// A pre-configured <see cref="PropertySheet"/> for <see cref="copyMaterial"/>. /// </summary> public static PropertySheet copySheet { get { if (s_CopySheet == null) s_CopySheet = new PropertySheet(copyMaterial); return s_CopySheet; } } static PropertySheet s_CopyFromTexArraySheet; /// <summary> /// A pre-configured <see cref="PropertySheet"/> for <see cref="copyFromTexArrayMaterial"/>. /// </summary> public static PropertySheet copyFromTexArraySheet { get { if (s_CopyFromTexArraySheet == null) s_CopyFromTexArraySheet = new PropertySheet(copyFromTexArrayMaterial); return s_CopyFromTexArraySheet; } } internal static void UpdateResources(PostProcessResources resources) { Destroy(s_CopyMaterial); Destroy(s_CopyStdMaterial); Destroy(s_CopyFromTexArrayMaterial); Destroy(s_CopyStdFromDoubleWideMaterial); s_CopyMaterial = null; s_CopyStdMaterial = null; s_CopyFromTexArrayMaterial = null; s_CopyStdFromDoubleWideMaterial = null; s_CopySheet = null; s_CopyFromTexArraySheet = null; s_Resources = resources; } /// <summary> /// Sets the current render target using specified <see cref="RenderBufferLoadAction"/>. /// </summary> /// <param name="cmd">The command buffer to set the render target on</param> /// <param name="rt">The render target to set</param> /// <param name="loadAction">The load action</param> /// <param name="storeAction">The store action</param> /// <remarks> /// <see cref="RenderBufferLoadAction"/> are only used on Unity 2018.2 or newer. /// </remarks> public static void SetRenderTargetWithLoadStoreAction(this CommandBuffer cmd, RenderTargetIdentifier rt, RenderBufferLoadAction loadAction, RenderBufferStoreAction storeAction) { #if UNITY_2018_2_OR_NEWER cmd.SetRenderTarget(rt, loadAction, storeAction); #else cmd.SetRenderTarget(rt); #endif } /// <summary> /// Sets the current render target and its depth using specified <see cref="RenderBufferLoadAction"/>. /// </summary> /// <param name="cmd">The command buffer to set the render target on</param> /// <param name="color">The render target to set as color</param> /// <param name="colorLoadAction">The load action for the color render target</param> /// <param name="colorStoreAction">The store action for the color render target</param> /// <param name="depth">The render target to set as depth</param> /// <param name="depthLoadAction">The load action for the depth render target</param> /// <param name="depthStoreAction">The store action for the depth render target</param> public static void SetRenderTargetWithLoadStoreAction(this CommandBuffer cmd, RenderTargetIdentifier color, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderTargetIdentifier depth, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction) { #if UNITY_2018_2_OR_NEWER cmd.SetRenderTarget(color, colorLoadAction, colorStoreAction, depth, depthLoadAction, depthStoreAction); #else cmd.SetRenderTarget(color, depth); #endif } /// <summary> /// Does a copy of source to destination using a fullscreen triangle. /// </summary> /// <param name="cmd">The command buffer to use</param> /// <param name="source">The source render target</param> /// <param name="destination">The destination render target</param> /// <param name="clear">Should the destination target be cleared?</param> /// <param name="viewport">An optional viewport to consider for the blit</param> public static void BlitFullscreenTriangle(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, bool clear = false, Rect? viewport = null) { cmd.SetGlobalTexture(ShaderIDs.MainTex, source); cmd.SetRenderTargetWithLoadStoreAction(destination, viewport == null ? LoadAction.DontCare : LoadAction.Load, StoreAction.Store); if (viewport != null) cmd.SetViewport(viewport.Value); if (clear) cmd.ClearRenderTarget(true, true, Color.clear); cmd.DrawMesh(fullscreenTriangle, Matrix4x4.identity, copyMaterial, 0, 0); } /// <summary> /// Blits a fullscreen triangle using a given material. /// </summary> /// <param name="cmd">The command buffer to use</param> /// <param name="source">The source render target</param> /// <param name="destination">The destination render target</param> /// <param name="propertySheet">The property sheet to use</param> /// <param name="pass">The pass from the material to use</param> /// <param name="loadAction">The load action for this blit</param> /// <param name="viewport">An optional viewport to consider for the blit</param> public static void BlitFullscreenTriangle(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, PropertySheet propertySheet, int pass, RenderBufferLoadAction loadAction, Rect? viewport = null) { cmd.SetGlobalTexture(ShaderIDs.MainTex, source); #if UNITY_2018_2_OR_NEWER bool clear = (loadAction == LoadAction.Clear); if(clear) loadAction = LoadAction.DontCare; #else bool clear = false; #endif cmd.SetRenderTargetWithLoadStoreAction(destination, viewport == null ? loadAction : LoadAction.Load, StoreAction.Store); if (viewport != null) cmd.SetViewport(viewport.Value); if (clear) cmd.ClearRenderTarget(true, true, Color.clear); cmd.DrawMesh(fullscreenTriangle, Matrix4x4.identity, propertySheet.material, 0, pass, propertySheet.properties); } /// <summary> /// Blits a fullscreen triangle using a given material. /// </summary> /// <param name="cmd">The command buffer to use</param> /// <param name="source">The source render target</param> /// <param name="destination">The destination render target</param> /// <param name="propertySheet">The property sheet to use</param> /// <param name="pass">The pass from the material to use</param> /// <param name="clear">Should the destination target be cleared?</param> /// <param name="viewport">An optional viewport to consider for the blit</param> public static void BlitFullscreenTriangle(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, PropertySheet propertySheet, int pass, bool clear = false, Rect? viewport = null) { #if UNITY_2018_2_OR_NEWER cmd.BlitFullscreenTriangle(source, destination, propertySheet, pass, clear ? LoadAction.Clear : LoadAction.DontCare, viewport); #else cmd.SetGlobalTexture(ShaderIDs.MainTex, source); cmd.SetRenderTargetWithLoadStoreAction(destination, viewport == null ? LoadAction.DontCare : LoadAction.Load, StoreAction.Store); if (viewport != null) cmd.SetViewport(viewport.Value); if (clear) cmd.ClearRenderTarget(true, true, Color.clear); cmd.DrawMesh(fullscreenTriangle, Matrix4x4.identity, propertySheet.material, 0, pass, propertySheet.properties); #endif } /// <summary> /// Blits a fullscreen triangle from a double-wide source. /// </summary> /// <param name="cmd">The command buffer to use</param> /// <param name="source">The source render target</param> /// <param name="destination">The destination render target</param> /// <param name="material">The material to use for the blit</param> /// <param name="pass">The pass from the material to use</param> /// <param name="eye">The target eye</param> public static void BlitFullscreenTriangleFromDoubleWide(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, Material material, int pass, int eye) { Vector4 uvScaleOffset = new Vector4(0.5f, 1.0f, 0, 0); if (eye == 1) uvScaleOffset.z = 0.5f; cmd.SetGlobalVector(ShaderIDs.UVScaleOffset, uvScaleOffset); cmd.BuiltinBlit(source, destination, material, pass); } /// <summary> /// Blits a fullscreen triangle to a double-wide destination. /// </summary> /// <param name="cmd">The command buffer to use</param> /// <param name="source">The source render target</param> /// <param name="destination">The destination render target</param> /// <param name="propertySheet">The property sheet to use</param> /// <param name="pass">The pass from the material to use</param> /// <param name="eye">The target eye</param> public static void BlitFullscreenTriangleToDoubleWide(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, PropertySheet propertySheet, int pass, int eye) { Vector4 posScaleOffset = new Vector4(0.5f, 1.0f, -0.5f, 0); if (eye == 1) posScaleOffset.z = 0.5f; propertySheet.EnableKeyword("STEREO_DOUBLEWIDE_TARGET"); propertySheet.properties.SetVector(ShaderIDs.PosScaleOffset, posScaleOffset); cmd.BlitFullscreenTriangle(source, destination, propertySheet, 0); } /// <summary> /// Blits a fullscreen triangle using a given material. /// </summary> /// <param name="cmd">The command buffer to use</param> /// <param name="source">The source texture array</param> /// <param name="destination">The destination render target</param> /// <param name="propertySheet">The property sheet to use</param> /// <param name="pass">The pass from the material to use</param> /// <param name="clear">Should the destination target be cleared?</param> /// <param name="depthSlice">The slice to use for the texture array</param> public static void BlitFullscreenTriangleFromTexArray(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, PropertySheet propertySheet, int pass, bool clear = false, int depthSlice = -1) { cmd.SetGlobalTexture(ShaderIDs.MainTex, source); cmd.SetGlobalFloat(ShaderIDs.DepthSlice, depthSlice); cmd.SetRenderTargetWithLoadStoreAction(destination, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store); if (clear) cmd.ClearRenderTarget(true, true, Color.clear); cmd.DrawMesh(fullscreenTriangle, Matrix4x4.identity, propertySheet.material, 0, pass, propertySheet.properties); } /// <summary> /// Blits a fullscreen triangle using a given material. /// </summary> /// <param name="cmd">The command buffer to use</param> /// <param name="source">The source render target</param> /// <param name="destination">The destination render target</param> /// <param name="depth">The depth render target</param> /// <param name="propertySheet">The property sheet to use</param> /// <param name="pass">The pass from the material to use</param> /// <param name="clear">Should the destination target be cleared?</param> /// <param name="depthSlice">The array slice to consider as a source</param> public static void BlitFullscreenTriangleToTexArray(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, PropertySheet propertySheet, int pass, bool clear = false, int depthSlice = -1) { cmd.SetGlobalTexture(ShaderIDs.MainTex, source); cmd.SetGlobalFloat(ShaderIDs.DepthSlice, depthSlice); cmd.SetRenderTarget(destination, 0, CubemapFace.Unknown, -1); if (clear) cmd.ClearRenderTarget(true, true, Color.clear); cmd.DrawMesh(fullscreenTriangle, Matrix4x4.identity, propertySheet.material, 0, pass, propertySheet.properties); } /// <summary> /// Blits a fullscreen triangle using a given material. /// </summary> /// <param name="cmd">The command buffer to use</param> /// <param name="source">The source render target</param> /// <param name="destination">The destination render target</param> /// <param name="depth">The depth render target</param> /// <param name="propertySheet">The property sheet to use</param> /// <param name="pass">The pass from the material to use</param> /// <param name="clear">Should the destination target be cleared?</param> /// <param name="viewport">An optional viewport to consider for the blit</param> public static void BlitFullscreenTriangle(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, RenderTargetIdentifier depth, PropertySheet propertySheet, int pass, bool clear = false, Rect? viewport = null) { cmd.SetGlobalTexture(ShaderIDs.MainTex, source); LoadAction loadAction = viewport == null ? LoadAction.DontCare : LoadAction.Load; if (clear) { cmd.SetRenderTargetWithLoadStoreAction(destination, loadAction, StoreAction.Store, depth, loadAction, StoreAction.Store); cmd.ClearRenderTarget(true, true, Color.clear); } else { cmd.SetRenderTargetWithLoadStoreAction(destination, loadAction, StoreAction.Store, depth, LoadAction.Load, StoreAction.Store); } if (viewport != null) cmd.SetViewport(viewport.Value); cmd.DrawMesh(fullscreenTriangle, Matrix4x4.identity, propertySheet.material, 0, pass, propertySheet.properties); } /// <summary> /// Blits a fullscreen triangle using a given material. /// </summary> /// <param name="cmd">The command buffer to use</param> /// <param name="source">The source render target</param> /// <param name="destinations">An array of destinations render targets</param> /// <param name="depth">The depth render target</param> /// <param name="propertySheet">The property sheet to use</param> /// <param name="pass">The pass from the material to use</param> /// <param name="clear">Should the destination target be cleared?</param> /// <param name="viewport">An optional viewport to consider for the blit</param> public static void BlitFullscreenTriangle(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier[] destinations, RenderTargetIdentifier depth, PropertySheet propertySheet, int pass, bool clear = false, Rect? viewport = null) { cmd.SetGlobalTexture(ShaderIDs.MainTex, source); cmd.SetRenderTarget(destinations, depth); if (viewport != null) cmd.SetViewport(viewport.Value); if (clear) cmd.ClearRenderTarget(true, true, Color.clear); cmd.DrawMesh(fullscreenTriangle, Matrix4x4.identity, propertySheet.material, 0, pass, propertySheet.properties); } /// <summary> /// Does a copy of source to destination using the builtin blit command. /// </summary> /// <param name="cmd">The command buffer to use</param> /// <param name="source">The source render target</param> /// <param name="destination">The destination render target</param> public static void BuiltinBlit(this CommandBuffer cmd, Rendering.RenderTargetIdentifier source, RenderTargetIdentifier destination) { #if UNITY_2018_2_OR_NEWER cmd.SetRenderTarget(destination, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store); destination = BuiltinRenderTextureType.CurrentActive; #endif cmd.Blit(source, destination); } /// <summary> /// Blits a fullscreen quad using the builtin blit command and a given material. /// </summary> /// <param name="cmd">The command buffer to use</param> /// <param name="source">The source render target</param> /// <param name="destination">The destination render target</param> /// <param name="mat">The material to use for the blit</param> /// <param name="pass">The pass from the material to use</param> public static void BuiltinBlit(this CommandBuffer cmd, Rendering.RenderTargetIdentifier source, RenderTargetIdentifier destination, Material mat, int pass = 0) { #if UNITY_2018_2_OR_NEWER cmd.SetRenderTarget(destination, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store); destination = BuiltinRenderTextureType.CurrentActive; #endif cmd.Blit(source, destination, mat, pass); } // Fast basic copy texture if available, falls back to blit copy if not // Assumes that both textures have the exact same type and format /// <summary> /// Copies the content of a texture into the other. Both textures must have the same size /// and format or this method will fail. /// </summary> /// <param name="cmd">The command buffer to use</param> /// <param name="source">The source render target</param> /// <param name="destination">The destination render target</param> /// <remarks> /// If the CopyTexture command isn't supported on the target platform it will revert to a /// fullscreen blit command instead. /// </remarks> public static void CopyTexture(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination) { if (SystemInfo.copyTextureSupport > CopyTextureSupport.None) { cmd.CopyTexture(source, destination); return; } cmd.BlitFullscreenTriangle(source, destination); } // TODO: Generalize the GetTemporaryRT and Blit commands in order to support // RT Arrays for Stereo Instancing/MultiView #endregion #region Unity specifics & misc methods /// <summary> /// Returns <c>true</c> if a scriptable render pipeline is currently in use, <c>false</c> /// otherwise. /// </summary> public static bool scriptableRenderPipelineActive { get { return GraphicsSettings.renderPipelineAsset != null; } // 5.6+ only } /// <summary> /// Returns <c>true</c> if deferred shading is supported on the target platform, /// <c>false</c> otherwise. /// </summary> public static bool supportsDeferredShading { get { return scriptableRenderPipelineActive || GraphicsSettings.GetShaderMode(BuiltinShaderType.DeferredShading) != BuiltinShaderMode.Disabled; } } /// <summary> /// Returns <c>true</c> if <see cref="DepthTextureMode.DepthNormals"/> is supported on the /// target platform, <c>false</c> otherwise. /// </summary> public static bool supportsDepthNormals { get { return scriptableRenderPipelineActive || GraphicsSettings.GetShaderMode(BuiltinShaderType.DepthNormals) != BuiltinShaderMode.Disabled; } } #if UNITY_EDITOR /// <summary> /// Returns <c>true</c> if single-pass stereo rendering is selected, <c>false</c> otherwise. /// </summary> /// <remarks> /// This property only works in the editor. /// </remarks> public static bool isSinglePassStereoSelected { get { return PlayerSettings.virtualRealitySupported && PlayerSettings.stereoRenderingPath == UnityEditor.StereoRenderingPath.SinglePass; } } #endif /// <summary> /// Returns <c>true</c> if single-pass stereo rendering is active, <c>false</c> otherwise. /// </summary> /// <remarks> /// This property only works in the editor. /// </remarks> // TODO: Check for SPSR support at runtime public static bool isSinglePassStereoEnabled { get { #if UNITY_EDITOR return isSinglePassStereoSelected && Application.isPlaying; #elif !ENABLE_VR return false; #elif UNITY_2017_2_OR_NEWER return UnityEngine.XR.XRSettings.eyeTextureDesc.vrUsage == VRTextureUsage.TwoEyes; #else return false; #endif } } /// <summary> /// Returns <c>true</c> if VR is enabled, <c>false</c> otherwise. /// </summary> public static bool isVREnabled { get { #if UNITY_EDITOR return UnityEditor.PlayerSettings.virtualRealitySupported; #elif UNITY_XBOXONE || !ENABLE_VR return false; #elif UNITY_2017_2_OR_NEWER return UnityEngine.XR.XRSettings.enabled; #elif UNITY_5_6_OR_NEWER return UnityEngine.VR.VRSettings.enabled; #endif } } /// <summary> /// Returns <c>true</c> if the target platform is Android and the selected API is OpenGL, /// <c>false</c> otherwise. /// </summary> public static bool isAndroidOpenGL { get { return Application.platform == RuntimePlatform.Android && SystemInfo.graphicsDeviceType != GraphicsDeviceType.Vulkan; } } /// <summary> /// Gets the default HDR render texture format for the current target platform. /// </summary> public static RenderTextureFormat defaultHDRRenderTextureFormat { get { #if UNITY_ANDROID || UNITY_IPHONE || UNITY_TVOS || UNITY_SWITCH || UNITY_EDITOR RenderTextureFormat format = RenderTextureFormat.RGB111110Float; #if UNITY_EDITOR var target = EditorUserBuildSettings.activeBuildTarget; if (target != BuildTarget.Android && target != BuildTarget.iOS && target != BuildTarget.tvOS && target != BuildTarget.Switch) return RenderTextureFormat.DefaultHDR; #endif // UNITY_EDITOR if (format.IsSupported()) return format; #endif // UNITY_ANDROID || UNITY_IPHONE || UNITY_TVOS || UNITY_SWITCH || UNITY_EDITOR return RenderTextureFormat.DefaultHDR; } } /// <summary> /// Checks if a given render texture format is a floating-point format. /// </summary> /// <param name="format">The format to test</param> /// <returns><c>true</c> if the format is floating-point, <c>false</c> otherwise</returns> public static bool isFloatingPointFormat(RenderTextureFormat format) { return format == RenderTextureFormat.DefaultHDR || format == RenderTextureFormat.ARGBHalf || format == RenderTextureFormat.ARGBFloat || format == RenderTextureFormat.RGFloat || format == RenderTextureFormat.RGHalf || format == RenderTextureFormat.RFloat || format == RenderTextureFormat.RHalf || format == RenderTextureFormat.RGB111110Float; } /// <summary> /// Properly destroys a given Unity object. /// </summary> /// <param name="obj">The object to destroy</param> public static void Destroy(UnityObject obj) { if (obj != null) { #if UNITY_EDITOR if (Application.isPlaying) UnityObject.Destroy(obj); else UnityObject.DestroyImmediate(obj); #else UnityObject.Destroy(obj); #endif } } /// <summary> /// Returns <c>true</c> if the current color space setting is set to <c>Linear</c>, /// <c>false</c> otherwise. /// </summary> public static bool isLinearColorSpace { get { return QualitySettings.activeColorSpace == ColorSpace.Linear; } } /// <summary> /// Checks if resolved depth is available on the current target platform. /// </summary> /// <param name="camera">A rendering camera</param> /// <returns><c>true</c> if resolved depth is available, <c>false</c> otherwise</returns> public static bool IsResolvedDepthAvailable(Camera camera) { // AFAIK resolved depth is only available on D3D11/12 via BuiltinRenderTextureType.ResolvedDepth // TODO: Is there more proper way to determine this? What about SRPs? var gtype = SystemInfo.graphicsDeviceType; return camera.actualRenderingPath == RenderingPath.DeferredShading && (gtype == GraphicsDeviceType.Direct3D11 || gtype == GraphicsDeviceType.Direct3D12 || gtype == GraphicsDeviceType.XboxOne); } /// <summary> /// Properly destroys a given profile. /// </summary> /// <param name="profile">The profile to destroy</param> /// <param name="destroyEffects">Should we destroy all the embedded settings?</param> public static void DestroyProfile(PostProcessProfile profile, bool destroyEffects) { if (destroyEffects) { foreach (var effect in profile.settings) Destroy(effect); } Destroy(profile); } /// <summary> /// Properly destroys a volume. /// </summary> /// <param name="volume">The volume to destroy</param> /// <param name="destroyProfile">Should we destroy the attached profile?</param> /// <param name="destroyGameObject">Should we destroy the volume Game Object?</param> public static void DestroyVolume(PostProcessVolume volume, bool destroyProfile, bool destroyGameObject = false) { if (destroyProfile) DestroyProfile(volume.profileRef, true); var gameObject = volume.gameObject; Destroy(volume); if (destroyGameObject) Destroy(gameObject); } /// <summary> /// Checks if a post-processing layer is active. /// </summary> /// <param name="layer">The layer to check; can be <c>null</c></param> /// <returns><c>true</c> if the layer is enabled, <c>false</c> otherwise</returns> public static bool IsPostProcessingActive(PostProcessLayer layer) { return layer != null && layer.enabled; } /// <summary> /// Checks if temporal anti-aliasing is active on a given post-process layer. /// </summary> /// <param name="layer">The layer to check</param> /// <returns><c>true</c> if temporal anti-aliasing is active, <c>false</c> otherwise</returns> public static bool IsTemporalAntialiasingActive(PostProcessLayer layer) { return IsPostProcessingActive(layer) && layer.antialiasingMode == PostProcessLayer.Antialiasing.TemporalAntialiasing && layer.temporalAntialiasing.IsSupported(); } /// <summary> /// Gets all scene objects in the hierarchy, including inactive objects. This method is slow /// on large scenes and should be used with extreme caution. /// </summary> /// <typeparam name="T">The component to look for</typeparam> /// <returns>A list of all components of type <c>T</c> in the scene</returns> public static IEnumerable<T> GetAllSceneObjects<T>() where T : Component { var queue = new Queue<Transform>(); var roots = SceneManager.GetActiveScene().GetRootGameObjects(); foreach (var root in roots) { queue.Enqueue(root.transform); var comp = root.GetComponent<T>(); if (comp != null) yield return comp; } while (queue.Count > 0) { foreach (Transform child in queue.Dequeue()) { queue.Enqueue(child); var comp = child.GetComponent<T>(); if (comp != null) yield return comp; } } } /// <summary> /// Creates an instance of a class if it's <c>null</c>. /// </summary> /// <typeparam name="T">The type to create</typeparam> /// <param name="obj">A reference to an instance to check and create if needed</param> public static void CreateIfNull<T>(ref T obj) where T : class, new() { if (obj == null) obj = new T(); } #endregion #region Maths /// <summary> /// Returns the base-2 exponential function of <paramref name="x"/>, which is <c>2</c> /// raised to the power <paramref name="x"/>. /// </summary> /// <param name="x">Value of the exponent</param> /// <returns>The base-2 exponential function of <paramref name="x"/></returns> public static float Exp2(float x) { return Mathf.Exp(x * 0.69314718055994530941723212145818f); } /// <summary> /// Gets a jittered perspective projection matrix for a given camera. /// </summary> /// <param name="camera">The camera to build the projection matrix for</param> /// <param name="offset">The jitter offset</param> /// <returns>A jittered projection matrix</returns> public static Matrix4x4 GetJitteredPerspectiveProjectionMatrix(Camera camera, Vector2 offset) { float near = camera.nearClipPlane; float far = camera.farClipPlane; float vertical = Mathf.Tan(0.5f * Mathf.Deg2Rad * camera.fieldOfView) * near; float horizontal = vertical * camera.aspect; offset.x *= horizontal / (0.5f * camera.pixelWidth); offset.y *= vertical / (0.5f * camera.pixelHeight); var matrix = camera.projectionMatrix; matrix[0, 2] += offset.x / horizontal; matrix[1, 2] += offset.y / vertical; return matrix; } /// <summary> /// Gets a jittered orthographic projection matrix for a given camera. /// </summary> /// <param name="camera">The camera to build the orthographic matrix for</param> /// <param name="offset">The jitter offset</param> /// <returns>A jittered projection matrix</returns> public static Matrix4x4 GetJitteredOrthographicProjectionMatrix(Camera camera, Vector2 offset) { float vertical = camera.orthographicSize; float horizontal = vertical * camera.aspect; offset.x *= horizontal / (0.5f * camera.pixelWidth); offset.y *= vertical / (0.5f * camera.pixelHeight); float left = offset.x - horizontal; float right = offset.x + horizontal; float top = offset.y + vertical; float bottom = offset.y - vertical; return Matrix4x4.Ortho(left, right, bottom, top, camera.nearClipPlane, camera.farClipPlane); } /// <summary> /// Gets a jittered perspective projection matrix from an original projection matrix. /// </summary> /// <param name="context">The current render context</param> /// <param name="origProj">The original projection matrix</param> /// <param name="jitter">The jitter offset</param> /// <returns>A jittered projection matrix</returns> public static Matrix4x4 GenerateJitteredProjectionMatrixFromOriginal(PostProcessRenderContext context, Matrix4x4 origProj, Vector2 jitter) { #if UNITY_2017_2_OR_NEWER var planes = origProj.decomposeProjection; float vertFov = Math.Abs(planes.top) + Math.Abs(planes.bottom); float horizFov = Math.Abs(planes.left) + Math.Abs(planes.right); var planeJitter = new Vector2(jitter.x * horizFov / context.screenWidth, jitter.y * vertFov / context.screenHeight); planes.left += planeJitter.x; planes.right += planeJitter.x; planes.top += planeJitter.y; planes.bottom += planeJitter.y; var jitteredMatrix = Matrix4x4.Frustum(planes); return jitteredMatrix; #else var rTan = (1.0f + origProj[0, 2]) / origProj[0, 0]; var lTan = (-1.0f + origProj[0, 2]) / origProj[0, 0]; var tTan = (1.0f + origProj[1, 2]) / origProj[1, 1]; var bTan = (-1.0f + origProj[1, 2]) / origProj[1, 1]; float tanVertFov = Math.Abs(tTan) + Math.Abs(bTan); float tanHorizFov = Math.Abs(lTan) + Math.Abs(rTan); jitter.x *= tanHorizFov / context.screenWidth; jitter.y *= tanVertFov / context.screenHeight; float left = jitter.x + lTan; float right = jitter.x + rTan; float top = jitter.y + tTan; float bottom = jitter.y + bTan; var jitteredMatrix = new Matrix4x4(); jitteredMatrix[0, 0] = 2f / (right - left); jitteredMatrix[0, 1] = 0f; jitteredMatrix[0, 2] = (right + left) / (right - left); jitteredMatrix[0, 3] = 0f; jitteredMatrix[1, 0] = 0f; jitteredMatrix[1, 1] = 2f / (top - bottom); jitteredMatrix[1, 2] = (top + bottom) / (top - bottom); jitteredMatrix[1, 3] = 0f; jitteredMatrix[2, 0] = 0f; jitteredMatrix[2, 1] = 0f; jitteredMatrix[2, 2] = origProj[2, 2]; jitteredMatrix[2, 3] = origProj[2, 3]; jitteredMatrix[3, 0] = 0f; jitteredMatrix[3, 1] = 0f; jitteredMatrix[3, 2] = -1f; jitteredMatrix[3, 3] = 0f; return jitteredMatrix; #endif } #endregion #region Reflection static IEnumerable<Type> m_AssemblyTypes; /// <summary> /// Gets all currently available assembly types. /// </summary> /// <returns>A list of all currently available assembly types</returns> /// <remarks> /// This method is slow and should be use with extreme caution. /// </remarks> public static IEnumerable<Type> GetAllAssemblyTypes() { if (m_AssemblyTypes == null) { m_AssemblyTypes = AppDomain.CurrentDomain.GetAssemblies() .SelectMany(t => { // Ugly hack to handle mis-versioned dlls var innerTypes = new Type[0]; try { innerTypes = t.GetTypes(); } catch { } return innerTypes; }); } return m_AssemblyTypes; } /// <summary> /// Helper method to get the first attribute of type <c>T</c> on a given type. /// </summary> /// <typeparam name="T">The attribute type to look for</typeparam> /// <param name="type">The type to explore</param> /// <returns>The attribute found</returns> public static T GetAttribute<T>(this Type type) where T : Attribute { Assert.IsTrue(type.IsDefined(typeof(T), false), "Attribute not found"); return (T)type.GetCustomAttributes(typeof(T), false)[0]; } /// <summary> /// Returns all attributes set on a specific member. /// </summary> /// <typeparam name="TType">The class type where the member is defined</typeparam> /// <typeparam name="TValue">The member type</typeparam> /// <param name="expr">An expression path to the member</param> /// <returns>An array of attributes</returns> /// <remarks> /// This method doesn't return inherited attributes, only explicit ones. /// </remarks> public static Attribute[] GetMemberAttributes<TType, TValue>(Expression<Func<TType, TValue>> expr) { Expression body = expr; if (body is LambdaExpression) body = ((LambdaExpression)body).Body; switch (body.NodeType) { case ExpressionType.MemberAccess: var fi = (FieldInfo)((MemberExpression)body).Member; return fi.GetCustomAttributes(false).Cast<Attribute>().ToArray(); default: throw new InvalidOperationException(); } } /// <summary> /// Returns a string path from an expression. This is mostly used to retrieve serialized /// properties without hardcoding the field path as a string and thus allowing proper /// refactoring features. /// </summary> /// <typeparam name="TType">The class type where the member is defined</typeparam> /// <typeparam name="TValue">The member type</typeparam> /// <param name="expr">An expression path fo the member</param> /// <returns>A string representation of the expression path</returns> public static string GetFieldPath<TType, TValue>(Expression<Func<TType, TValue>> expr) { MemberExpression me; switch (expr.Body.NodeType) { case ExpressionType.MemberAccess: me = expr.Body as MemberExpression; break; default: throw new InvalidOperationException(); } var members = new List<string>(); while (me != null) { members.Add(me.Member.Name); me = me.Expression as MemberExpression; } var sb = new StringBuilder(); for (int i = members.Count - 1; i >= 0; i--) { sb.Append(members[i]); if (i > 0) sb.Append('.'); } return sb.ToString(); } #endregion } }

File no 105: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Utils/ShaderIDs.cs
namespace UnityEngine.Rendering.PostProcessing { // Pre-hashed shader ids - naming conventions are a bit off in this file as we use the same // fields names as in the shaders for ease of use... Would be nice to clean this up at some // point. static class ShaderIDs { internal static readonly int MainTex = Shader.PropertyToID("_MainTex"); internal static readonly int Jitter = Shader.PropertyToID("_Jitter"); internal static readonly int Sharpness = Shader.PropertyToID("_Sharpness"); internal static readonly int FinalBlendParameters = Shader.PropertyToID("_FinalBlendParameters"); internal static readonly int HistoryTex = Shader.PropertyToID("_HistoryTex"); internal static readonly int SMAA_Flip = Shader.PropertyToID("_SMAA_Flip"); internal static readonly int SMAA_Flop = Shader.PropertyToID("_SMAA_Flop"); internal static readonly int AOParams = Shader.PropertyToID("_AOParams"); internal static readonly int AOColor = Shader.PropertyToID("_AOColor"); internal static readonly int OcclusionTexture1 = Shader.PropertyToID("_OcclusionTexture1"); internal static readonly int OcclusionTexture2 = Shader.PropertyToID("_OcclusionTexture2"); internal static readonly int SAOcclusionTexture = Shader.PropertyToID("_SAOcclusionTexture"); internal static readonly int MSVOcclusionTexture = Shader.PropertyToID("_MSVOcclusionTexture"); internal static readonly int DepthCopy = Shader.PropertyToID("DepthCopy"); internal static readonly int LinearDepth = Shader.PropertyToID("LinearDepth"); internal static readonly int LowDepth1 = Shader.PropertyToID("LowDepth1"); internal static readonly int LowDepth2 = Shader.PropertyToID("LowDepth2"); internal static readonly int LowDepth3 = Shader.PropertyToID("LowDepth3"); internal static readonly int LowDepth4 = Shader.PropertyToID("LowDepth4"); internal static readonly int TiledDepth1 = Shader.PropertyToID("TiledDepth1"); internal static readonly int TiledDepth2 = Shader.PropertyToID("TiledDepth2"); internal static readonly int TiledDepth3 = Shader.PropertyToID("TiledDepth3"); internal static readonly int TiledDepth4 = Shader.PropertyToID("TiledDepth4"); internal static readonly int Occlusion1 = Shader.PropertyToID("Occlusion1"); internal static readonly int Occlusion2 = Shader.PropertyToID("Occlusion2"); internal static readonly int Occlusion3 = Shader.PropertyToID("Occlusion3"); internal static readonly int Occlusion4 = Shader.PropertyToID("Occlusion4"); internal static readonly int Combined1 = Shader.PropertyToID("Combined1"); internal static readonly int Combined2 = Shader.PropertyToID("Combined2"); internal static readonly int Combined3 = Shader.PropertyToID("Combined3"); internal static readonly int SSRResolveTemp = Shader.PropertyToID("_SSRResolveTemp"); internal static readonly int Noise = Shader.PropertyToID("_Noise"); internal static readonly int Test = Shader.PropertyToID("_Test"); internal static readonly int Resolve = Shader.PropertyToID("_Resolve"); internal static readonly int History = Shader.PropertyToID("_History"); internal static readonly int ViewMatrix = Shader.PropertyToID("_ViewMatrix"); internal static readonly int InverseViewMatrix = Shader.PropertyToID("_InverseViewMatrix"); internal static readonly int InverseProjectionMatrix = Shader.PropertyToID("_InverseProjectionMatrix"); internal static readonly int ScreenSpaceProjectionMatrix = Shader.PropertyToID("_ScreenSpaceProjectionMatrix"); internal static readonly int Params2 = Shader.PropertyToID("_Params2"); internal static readonly int FogColor = Shader.PropertyToID("_FogColor"); internal static readonly int FogParams = Shader.PropertyToID("_FogParams"); internal static readonly int VelocityScale = Shader.PropertyToID("_VelocityScale"); internal static readonly int MaxBlurRadius = Shader.PropertyToID("_MaxBlurRadius"); internal static readonly int RcpMaxBlurRadius = Shader.PropertyToID("_RcpMaxBlurRadius"); internal static readonly int VelocityTex = Shader.PropertyToID("_VelocityTex"); internal static readonly int Tile2RT = Shader.PropertyToID("_Tile2RT"); internal static readonly int Tile4RT = Shader.PropertyToID("_Tile4RT"); internal static readonly int Tile8RT = Shader.PropertyToID("_Tile8RT"); internal static readonly int TileMaxOffs = Shader.PropertyToID("_TileMaxOffs"); internal static readonly int TileMaxLoop = Shader.PropertyToID("_TileMaxLoop"); internal static readonly int TileVRT = Shader.PropertyToID("_TileVRT"); internal static readonly int NeighborMaxTex = Shader.PropertyToID("_NeighborMaxTex"); internal static readonly int LoopCount = Shader.PropertyToID("_LoopCount"); internal static readonly int DepthOfFieldTemp = Shader.PropertyToID("_DepthOfFieldTemp"); internal static readonly int DepthOfFieldTex = Shader.PropertyToID("_DepthOfFieldTex"); internal static readonly int Distance = Shader.PropertyToID("_Distance"); internal static readonly int LensCoeff = Shader.PropertyToID("_LensCoeff"); internal static readonly int MaxCoC = Shader.PropertyToID("_MaxCoC"); internal static readonly int RcpMaxCoC = Shader.PropertyToID("_RcpMaxCoC"); internal static readonly int RcpAspect = Shader.PropertyToID("_RcpAspect"); internal static readonly int CoCTex = Shader.PropertyToID("_CoCTex"); internal static readonly int TaaParams = Shader.PropertyToID("_TaaParams"); internal static readonly int AutoExposureTex = Shader.PropertyToID("_AutoExposureTex"); internal static readonly int HistogramBuffer = Shader.PropertyToID("_HistogramBuffer"); internal static readonly int Params = Shader.PropertyToID("_Params"); internal static readonly int ScaleOffsetRes = Shader.PropertyToID("_ScaleOffsetRes"); internal static readonly int BloomTex = Shader.PropertyToID("_BloomTex"); internal static readonly int SampleScale = Shader.PropertyToID("_SampleScale"); internal static readonly int Threshold = Shader.PropertyToID("_Threshold"); internal static readonly int ColorIntensity = Shader.PropertyToID("_ColorIntensity"); internal static readonly int Bloom_DirtTex = Shader.PropertyToID("_Bloom_DirtTex"); internal static readonly int Bloom_Settings = Shader.PropertyToID("_Bloom_Settings"); internal static readonly int Bloom_Color = Shader.PropertyToID("_Bloom_Color"); internal static readonly int Bloom_DirtTileOffset = Shader.PropertyToID("_Bloom_DirtTileOffset"); internal static readonly int ChromaticAberration_Amount = Shader.PropertyToID("_ChromaticAberration_Amount"); internal static readonly int ChromaticAberration_SpectralLut = Shader.PropertyToID("_ChromaticAberration_SpectralLut"); internal static readonly int Distortion_CenterScale = Shader.PropertyToID("_Distortion_CenterScale"); internal static readonly int Distortion_Amount = Shader.PropertyToID("_Distortion_Amount"); internal static readonly int Lut2D = Shader.PropertyToID("_Lut2D"); internal static readonly int Lut3D = Shader.PropertyToID("_Lut3D"); internal static readonly int Lut3D_Params = Shader.PropertyToID("_Lut3D_Params"); internal static readonly int Lut2D_Params = Shader.PropertyToID("_Lut2D_Params"); internal static readonly int UserLut2D_Params = Shader.PropertyToID("_UserLut2D_Params"); internal static readonly int PostExposure = Shader.PropertyToID("_PostExposure"); internal static readonly int ColorBalance = Shader.PropertyToID("_ColorBalance"); internal static readonly int ColorFilter = Shader.PropertyToID("_ColorFilter"); internal static readonly int HueSatCon = Shader.PropertyToID("_HueSatCon"); internal static readonly int Brightness = Shader.PropertyToID("_Brightness"); internal static readonly int ChannelMixerRed = Shader.PropertyToID("_ChannelMixerRed"); internal static readonly int ChannelMixerGreen = Shader.PropertyToID("_ChannelMixerGreen"); internal static readonly int ChannelMixerBlue = Shader.PropertyToID("_ChannelMixerBlue"); internal static readonly int Lift = Shader.PropertyToID("_Lift"); internal static readonly int InvGamma = Shader.PropertyToID("_InvGamma"); internal static readonly int Gain = Shader.PropertyToID("_Gain"); internal static readonly int Curves = Shader.PropertyToID("_Curves"); internal static readonly int CustomToneCurve = Shader.PropertyToID("_CustomToneCurve"); internal static readonly int ToeSegmentA = Shader.PropertyToID("_ToeSegmentA"); internal static readonly int ToeSegmentB = Shader.PropertyToID("_ToeSegmentB"); internal static readonly int MidSegmentA = Shader.PropertyToID("_MidSegmentA"); internal static readonly int MidSegmentB = Shader.PropertyToID("_MidSegmentB"); internal static readonly int ShoSegmentA = Shader.PropertyToID("_ShoSegmentA"); internal static readonly int ShoSegmentB = Shader.PropertyToID("_ShoSegmentB"); internal static readonly int Vignette_Color = Shader.PropertyToID("_Vignette_Color"); internal static readonly int Vignette_Center = Shader.PropertyToID("_Vignette_Center"); internal static readonly int Vignette_Settings = Shader.PropertyToID("_Vignette_Settings"); internal static readonly int Vignette_Mask = Shader.PropertyToID("_Vignette_Mask"); internal static readonly int Vignette_Opacity = Shader.PropertyToID("_Vignette_Opacity"); internal static readonly int Vignette_Mode = Shader.PropertyToID("_Vignette_Mode"); internal static readonly int Grain_Params1 = Shader.PropertyToID("_Grain_Params1"); internal static readonly int Grain_Params2 = Shader.PropertyToID("_Grain_Params2"); internal static readonly int GrainTex = Shader.PropertyToID("_GrainTex"); internal static readonly int Phase = Shader.PropertyToID("_Phase"); internal static readonly int GrainNoiseParameters = Shader.PropertyToID("_NoiseParameters"); internal static readonly int LumaInAlpha = Shader.PropertyToID("_LumaInAlpha"); internal static readonly int DitheringTex = Shader.PropertyToID("_DitheringTex"); internal static readonly int Dithering_Coords = Shader.PropertyToID("_Dithering_Coords"); internal static readonly int From = Shader.PropertyToID("_From"); internal static readonly int To = Shader.PropertyToID("_To"); internal static readonly int Interp = Shader.PropertyToID("_Interp"); internal static readonly int TargetColor = Shader.PropertyToID("_TargetColor"); internal static readonly int HalfResFinalCopy = Shader.PropertyToID("_HalfResFinalCopy"); internal static readonly int WaveformSource = Shader.PropertyToID("_WaveformSource"); internal static readonly int WaveformBuffer = Shader.PropertyToID("_WaveformBuffer"); internal static readonly int VectorscopeBuffer = Shader.PropertyToID("_VectorscopeBuffer"); internal static readonly int RenderViewportScaleFactor = Shader.PropertyToID("_RenderViewportScaleFactor"); internal static readonly int UVTransform = Shader.PropertyToID("_UVTransform"); internal static readonly int DepthSlice = Shader.PropertyToID("_DepthSlice"); internal static readonly int UVScaleOffset = Shader.PropertyToID("_UVScaleOffset"); internal static readonly int PosScaleOffset = Shader.PropertyToID("_PosScaleOffset"); } }

File no 106: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Utils/Spline.cs
using System; using UnityEngine.Assertions; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// A wrapper on top of <see cref="AnimationCurve"/> to handle zero-key curves and keyframe /// loops. /// </summary> [Serializable] public sealed class Spline { /// <summary> /// Precision of the curve. /// </summary> public const int k_Precision = 128; /// <summary> /// The inverse of the precision of the curve. /// </summary> public const float k_Step = 1f / k_Precision; /// <summary> /// The underlying animation curve instance. /// </summary> public AnimationCurve curve; [SerializeField] bool m_Loop; [SerializeField] float m_ZeroValue; [SerializeField] float m_Range; AnimationCurve m_InternalLoopingCurve; // Used to track frame changes for data caching int frameCount = -1; /// <summary> /// An array holding pre-computed curve values. /// </summary> public float[] cachedData; /// <summary> /// Creates a new spline. /// </summary> /// <param name="curve">The animation curve to base this spline off</param> /// <param name="zeroValue">The value to return when the curve has no keyframe</param> /// <param name="loop">Should this curve loop?</param> /// <param name="bounds">The curve bounds</param> public Spline(AnimationCurve curve, float zeroValue, bool loop, Vector2 bounds) { Assert.IsNotNull(curve); this.curve = curve; m_ZeroValue = zeroValue; m_Loop = loop; m_Range = bounds.magnitude; cachedData = new float[k_Precision]; } /// <summary> /// Caches the curve data at a given frame. The curve data will only be cached once per /// frame. /// </summary> /// <param name="frame">A frame number</param> public void Cache(int frame) { // Note: it would be nice to have a way to check if a curve has changed in any way, that // would save quite a few CPU cycles instead of having to force cache it once per frame :/ // Only cache once per frame if (frame == frameCount) return; var length = curve.length; if (m_Loop && length > 1) { if (m_InternalLoopingCurve == null) m_InternalLoopingCurve = new AnimationCurve(); var prev = curve[length - 1]; prev.time -= m_Range; var next = curve[0]; next.time += m_Range; m_InternalLoopingCurve.keys = curve.keys; m_InternalLoopingCurve.AddKey(prev); m_InternalLoopingCurve.AddKey(next); } for (int i = 0; i < k_Precision; i++) cachedData[i] = Evaluate((float)i * k_Step, length); frameCount = Time.renderedFrameCount; } /// <summary> /// Evaluates the curve at a point in time. /// </summary> /// <param name="t">The time to evaluate</param> /// <param name="length">The number of keyframes in the curve</param> /// <returns>The value of the curve at time <paramref name="t"/></returns> public float Evaluate(float t, int length) { if (length == 0) return m_ZeroValue; if (!m_Loop || length == 1) return curve.Evaluate(t); return m_InternalLoopingCurve.Evaluate(t); } /// <summary> /// Evaluates the curve at a point in time. /// </summary> /// <param name="t">The time to evaluate</param> /// <returns>The value of the curve at time <paramref name="t"/></returns> /// <remarks> /// Calling the length getter on a curve is expensive to it's better to cache its length and /// call <see cref="Evaluate(float,int)"/> instead of getting the length for every call. /// </remarks> public float Evaluate(float t) { // Calling the length getter on a curve is expensive (!?) so it's better to cache its // length and call Evaluate(t, length) instead of getting the length for every call to // Evaluate(t) return Evaluate(t, curve.length); } /// <summary> /// Returns the computed hash code for this parameter. /// </summary> /// <returns>A computed hash code</returns> public override int GetHashCode() { unchecked { int hash = 17; hash = hash * 23 + curve.GetHashCode(); // Not implemented in Unity, so it'll always return the same value :( return hash; } } } }

File no 107: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Utils/TargetPool.cs
using System.Collections.Generic; namespace UnityEngine.Rendering.PostProcessing { class TargetPool { readonly List<int> m_Pool; int m_Current; internal TargetPool() { m_Pool = new List<int>(); Get(); // Pre-warm with a default target to avoid black frame on first frame } internal int Get() { int ret = Get(m_Current); m_Current++; return ret; } int Get(int i) { int ret; if (m_Pool.Count > i) { ret = m_Pool[i]; } else { // Avoid discontinuities while (m_Pool.Count <= i) m_Pool.Add(Shader.PropertyToID("_TargetPool" + i)); ret = m_Pool[i]; } return ret; } internal void Reset() { m_Current = 0; } } }

File no 108: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Utils/TextureFormatUtilities.cs
using System; using System.Collections.Generic; using UnityEngine.Assertions; namespace UnityEngine.Rendering.PostProcessing { // Temporary code dump until the texture format refactor goes into trunk... /// <summary> /// A set of utilities to deal with texture formats. /// </summary> public static class TextureFormatUtilities { static Dictionary<int, RenderTextureFormat> s_FormatAliasMap; static Dictionary<int, bool> s_SupportedRenderTextureFormats; static Dictionary<int, bool> s_SupportedTextureFormats; static TextureFormatUtilities() { s_FormatAliasMap = new Dictionary<int, RenderTextureFormat> { { (int)TextureFormat.Alpha8, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.ARGB4444, RenderTextureFormat.ARGB4444 }, { (int)TextureFormat.RGB24, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.RGBA32, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.ARGB32, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.RGB565, RenderTextureFormat.RGB565 }, { (int)TextureFormat.R16, RenderTextureFormat.RHalf }, { (int)TextureFormat.DXT1, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.DXT5, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.RGBA4444, RenderTextureFormat.ARGB4444 }, { (int)TextureFormat.BGRA32, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.RHalf, RenderTextureFormat.RHalf }, { (int)TextureFormat.RGHalf, RenderTextureFormat.RGHalf }, { (int)TextureFormat.RGBAHalf, RenderTextureFormat.ARGBHalf }, { (int)TextureFormat.RFloat, RenderTextureFormat.RFloat }, { (int)TextureFormat.RGFloat, RenderTextureFormat.RGFloat }, { (int)TextureFormat.RGBAFloat, RenderTextureFormat.ARGBFloat }, { (int)TextureFormat.RGB9e5Float, RenderTextureFormat.ARGBHalf }, { (int)TextureFormat.BC4, RenderTextureFormat.R8 }, { (int)TextureFormat.BC5, RenderTextureFormat.RGHalf }, { (int)TextureFormat.BC6H, RenderTextureFormat.ARGBHalf }, { (int)TextureFormat.BC7, RenderTextureFormat.ARGB32 }, #if !UNITY_IOS && !UNITY_TVOS { (int)TextureFormat.DXT1Crunched, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.DXT5Crunched, RenderTextureFormat.ARGB32 }, #endif { (int)TextureFormat.PVRTC_RGB2, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.PVRTC_RGBA2, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.PVRTC_RGB4, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.PVRTC_RGBA4, RenderTextureFormat.ARGB32 }, #if !UNITY_2018_1_OR_NEWER { (int)TextureFormat.ATC_RGB4, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.ATC_RGBA8, RenderTextureFormat.ARGB32 }, #endif { (int)TextureFormat.ETC_RGB4, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.ETC2_RGB, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.ETC2_RGBA1, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.ETC2_RGBA8, RenderTextureFormat.ARGB32 }, #if UNITY_2019_1_OR_NEWER { (int)TextureFormat.ASTC_4x4, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.ASTC_5x5, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.ASTC_6x6, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.ASTC_8x8, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.ASTC_10x10, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.ASTC_12x12, RenderTextureFormat.ARGB32 }, #else { (int)TextureFormat.ASTC_RGB_4x4, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.ASTC_RGB_5x5, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.ASTC_RGB_6x6, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.ASTC_RGB_8x8, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.ASTC_RGB_10x10, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.ASTC_RGB_12x12, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.ASTC_RGBA_4x4, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.ASTC_RGBA_5x5, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.ASTC_RGBA_6x6, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.ASTC_RGBA_8x8, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.ASTC_RGBA_10x10, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.ASTC_RGBA_12x12, RenderTextureFormat.ARGB32 }, #endif #if !UNITY_2018_3_OR_NEWER { (int)TextureFormat.ETC_RGB4_3DS, RenderTextureFormat.ARGB32 }, { (int)TextureFormat.ETC_RGBA8_3DS, RenderTextureFormat.ARGB32 } #endif }; // TODO: refactor the next two scopes in a generic function once we have support for enum constraints on generics // In 2018.1 SystemInfo.SupportsRenderTextureFormat() generates garbage so we need to // cache its calls to avoid that... { s_SupportedRenderTextureFormats = new Dictionary<int, bool>(); var values = Enum.GetValues(typeof(RenderTextureFormat)); foreach (var format in values) { if ((int)format < 0) // Safe guard, negative values are deprecated stuff continue; if (IsObsolete(format)) continue; bool supported = SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)format); s_SupportedRenderTextureFormats[(int)format] = supported; } } // Same for TextureFormat { s_SupportedTextureFormats = new Dictionary<int, bool>(); var values = Enum.GetValues(typeof(TextureFormat)); foreach (var format in values) { if ((int)format < 0) // Crashes the runtime otherwise (!) continue; if (IsObsolete(format)) continue; bool supported = SystemInfo.SupportsTextureFormat((TextureFormat)format); s_SupportedTextureFormats[(int)format] = supported; } } } static bool IsObsolete(object value) { var fieldInfo = value.GetType().GetField(value.ToString()); var attributes = (ObsoleteAttribute[])fieldInfo.GetCustomAttributes(typeof(ObsoleteAttribute), false); return attributes != null && attributes.Length > 0; } /// <summary> /// Returns a <see cref="RenderTextureFormat"/> compatible with the given texture's format. /// </summary> /// <param name="texture">A texture to get a compatible format from</param> /// <returns>A compatible render texture format</returns> public static RenderTextureFormat GetUncompressedRenderTextureFormat(Texture texture) { Assert.IsNotNull(texture); if (texture is RenderTexture) return (texture as RenderTexture).format; if (texture is Texture2D) { var inFormat = ((Texture2D)texture).format; RenderTextureFormat outFormat; if (!s_FormatAliasMap.TryGetValue((int)inFormat, out outFormat)) throw new NotSupportedException("Texture format not supported"); return outFormat; } return RenderTextureFormat.Default; } internal static bool IsSupported(this RenderTextureFormat format) { bool supported; s_SupportedRenderTextureFormats.TryGetValue((int)format, out supported); return supported; } internal static bool IsSupported(this TextureFormat format) { bool supported; s_SupportedTextureFormats.TryGetValue((int)format, out supported); return supported; } } }

File no 109: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Utils/TextureLerper.cs
using System.Collections.Generic; using UnityEngine.Assertions; namespace UnityEngine.Rendering.PostProcessing { class TextureLerper { static TextureLerper m_Instance; internal static TextureLerper instance { get { if (m_Instance == null) m_Instance = new TextureLerper(); return m_Instance; } } CommandBuffer m_Command; PropertySheetFactory m_PropertySheets; PostProcessResources m_Resources; List<RenderTexture> m_Recycled; List<RenderTexture> m_Actives; TextureLerper() { m_Recycled = new List<RenderTexture>(); m_Actives = new List<RenderTexture>(); } internal void BeginFrame(PostProcessRenderContext context) { m_Command = context.command; m_PropertySheets = context.propertySheets; m_Resources = context.resources; } internal void EndFrame() { // Release any remaining RT in the recycled list if (m_Recycled.Count > 0) { foreach (var rt in m_Recycled) RuntimeUtilities.Destroy(rt); m_Recycled.Clear(); } // There's a high probability that RTs will be requested in the same order on next // frame so keep them in the same order if (m_Actives.Count > 0) { foreach (var rt in m_Actives) m_Recycled.Add(rt); m_Actives.Clear(); } } RenderTexture Get(RenderTextureFormat format, int w, int h, int d = 1, bool enableRandomWrite = false, bool force3D = false) { RenderTexture rt = null; int i, len = m_Recycled.Count; for (i = 0; i < len; i++) { var r = m_Recycled[i]; if (r.width == w && r.height == h && r.volumeDepth == d && r.format == format && r.enableRandomWrite == enableRandomWrite && (!force3D || (r.dimension == TextureDimension.Tex3D))) { rt = r; break; } } if (rt == null) { var dimension = (d > 1) || force3D ? TextureDimension.Tex3D : TextureDimension.Tex2D; rt = new RenderTexture(w, h, 0, format) { dimension = dimension, filterMode = FilterMode.Bilinear, wrapMode = TextureWrapMode.Clamp, anisoLevel = 0, volumeDepth = d, enableRandomWrite = enableRandomWrite }; rt.Create(); } else m_Recycled.RemoveAt(i); m_Actives.Add(rt); return rt; } internal Texture Lerp(Texture from, Texture to, float t) { Assert.IsNotNull(from); Assert.IsNotNull(to); Assert.AreEqual(from.width, to.width); Assert.AreEqual(from.height, to.height); // Saves a potentially expensive fullscreen blit when using dirt textures & the likes if (from == to) return from; // Don't need to lerp boundary conditions if (t <= 0f) return from; if (t >= 1f) return to; bool is3D = from is Texture3D || (from is RenderTexture && ((RenderTexture)from).volumeDepth > 1); RenderTexture rt; // 3D texture blending is a special case and only works on compute enabled platforms if (is3D) { int dpth = @from is Texture3D ? ((Texture3D) @from).depth : ((RenderTexture) @from).volumeDepth; int size = Mathf.Max(from.width, from.height); size = Mathf.Max(size, dpth); rt = Get(RenderTextureFormat.ARGBHalf, from.width, from.height, dpth, true, true); var compute = m_Resources.computeShaders.texture3dLerp; int kernel = compute.FindKernel("KTexture3DLerp"); m_Command.SetComputeVectorParam(compute, "_DimensionsAndLerp", new Vector4(from.width, from.height, dpth, t)); m_Command.SetComputeTextureParam(compute, kernel, "_Output", rt); m_Command.SetComputeTextureParam(compute, kernel, "_From", from); m_Command.SetComputeTextureParam(compute, kernel, "_To", to); uint tgsX, tgsY, tgsZ; compute.GetKernelThreadGroupSizes(kernel, out tgsX, out tgsY, out tgsZ); Assert.AreEqual(tgsX, tgsY); int groupSizeXY = Mathf.CeilToInt(size / (float)tgsX); int groupSizeZ = Mathf.CeilToInt(size / (float)tgsZ); m_Command.DispatchCompute(compute, kernel, groupSizeXY, groupSizeXY, groupSizeZ); return rt; } // 2D texture blending // We could handle textures with different sizes by picking the biggest one to avoid // popping effects. This would work in most cases but will still pop if one texture is // wider but shorter than the other. Generally speaking you're expected to use same-size // textures anyway so we decided not to handle this case at the moment, especially since // it would waste a lot of texture memory as soon as you start using bigger textures // (snow ball effect). var format = TextureFormatUtilities.GetUncompressedRenderTextureFormat(to); rt = Get(format, to.width, to.height); var sheet = m_PropertySheets.Get(m_Resources.shaders.texture2dLerp); sheet.properties.SetTexture(ShaderIDs.To, to); sheet.properties.SetFloat(ShaderIDs.Interp, t); m_Command.BlitFullscreenTriangle(from, rt, sheet, 0); return rt; } internal Texture Lerp(Texture from, Color to, float t) { Assert.IsNotNull(from); if (t < 0.00001) return from; bool is3D = from is Texture3D || (from is RenderTexture && ((RenderTexture)from).volumeDepth > 1); RenderTexture rt; // 3D texture blending is a special case and only works on compute enabled platforms if (is3D) { int dpth = @from is Texture3D ? ((Texture3D) @from).depth : ((RenderTexture) @from).volumeDepth; int size = Mathf.Max(from.width, from.height); size = Mathf.Max(size, dpth); rt = Get(RenderTextureFormat.ARGBHalf, from.width, from.height, dpth, true, true); var compute = m_Resources.computeShaders.texture3dLerp; int kernel = compute.FindKernel("KTexture3DLerpToColor"); m_Command.SetComputeVectorParam(compute, "_DimensionsAndLerp", new Vector4(from.width, from.height, dpth, t)); m_Command.SetComputeVectorParam(compute, "_TargetColor", new Vector4(to.r, to.g, to.b, to.a)); m_Command.SetComputeTextureParam(compute, kernel, "_Output", rt); m_Command.SetComputeTextureParam(compute, kernel, "_From", from); int groupSize = Mathf.CeilToInt(size / 4f); m_Command.DispatchCompute(compute, kernel, groupSize, groupSize, groupSize); return rt; } // 2D texture blending // We could handle textures with different sizes by picking the biggest one to avoid // popping effects. This would work in most cases but will still pop if one texture is // wider but shorter than the other. Generally speaking you're expected to use same-size // textures anyway so we decided not to handle this case at the moment, especially since // it would waste a lot of texture memory as soon as you start using bigger textures // (snow ball effect). var format = TextureFormatUtilities.GetUncompressedRenderTextureFormat(from); rt = Get(format, from.width, from.height); var sheet = m_PropertySheets.Get(m_Resources.shaders.texture2dLerp); sheet.properties.SetVector(ShaderIDs.TargetColor, new Vector4(to.r, to.g, to.b, to.a)); sheet.properties.SetFloat(ShaderIDs.Interp, t); m_Command.BlitFullscreenTriangle(from, rt, sheet, 1); return rt; } internal void Clear() { foreach (var rt in m_Actives) RuntimeUtilities.Destroy(rt); foreach (var rt in m_Recycled) RuntimeUtilities.Destroy(rt); m_Actives.Clear(); m_Recycled.Clear(); } } }

File no 110: /colame/Assets/SineVFX/PostProcessingV2/Runtime/Utils/XRSettings.cs
// Small shim for VRSettings/XRSettings on XboxOne, Switch and PS Vita #if ((UNITY_XBOXONE || UNITY_SWITCH || UNITY_PSP2) && !UNITY_2018_3_OR_NEWER) && !UNITY_EDITOR using System; #if UNITY_2017_2_OR_NEWER namespace UnityEngine.XR #else namespace UnityEngine.VR #endif { #if UNITY_2017_2_OR_NEWER public static class XRSettings #elif UNITY_5_6_OR_NEWER public static class VRSettings #endif { public static bool enabled { get; set; } public static bool isDeviceActive { get; private set; } public static bool showDeviceView { get; set; } [Obsolete("renderScale is deprecated, use XRSettings.eyeTextureResolutionScale instead (UnityUpgradable) -> eyeTextureResolutionScale")] public static float renderScale { get; set; } public static float eyeTextureResolutionScale { get; set; } public static int eyeTextureWidth { get; private set; } public static int eyeTextureHeight { get; private set; } public static RenderTextureDescriptor eyeTextureDesc { get; private set; } public static float renderViewportScale { get; set; } public static float occlusionMaskScale { get; set; } public static bool useOcclusionMesh { get; set; } public static string loadedDeviceName { get; private set; } public static string[] supportedDevices { get; private set; } public static void LoadDeviceByName(string deviceName) { } public static void LoadDeviceByName(string[] prioritizedDeviceNameList) { } } } #endif

File no 111: /colame/Assets/SineVFX/PostProcessingV2/Runtime/ParameterOverride.cs
using System; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// The base abstract class for all parameter override types. /// </summary> /// <seealso cref="ParameterOverride{T}"/> public abstract class ParameterOverride { /// <summary> /// The override state of this parameter. /// </summary> public bool overrideState; internal abstract void Interp(ParameterOverride from, ParameterOverride to, float t); /// <summary> /// Returns the computed hash code for this parameter. /// </summary> /// <returns>A computed hash code</returns> public abstract int GetHash(); /// <summary> /// Casts and returns the value stored in this parameter. /// </summary> /// <typeparam name="T">The type to cast to</typeparam> /// <returns>The value stored in this parameter</returns> public T GetValue<T>() { return ((ParameterOverride<T>)this).value; } /// <summary> /// This method is called right after the parent <see cref="PostProcessEffectSettings"/> has /// been initialized. This is used in case you need to access fields or properties that /// can't be accessed in the constructor of a <see cref="ScriptableObject"/> /// (<c>ParameterOverride</c> objects are generally declared and initialized in a /// <see cref="PostProcessEffectSettings"/>). /// </summary> /// <seealso cref="OnDisable"/> protected internal virtual void OnEnable() { } /// <summary> /// This method is called right before the parent <see cref="PostProcessEffectSettings"/> /// gets de-initialized. /// </summary> /// <seealso cref="OnEnable"/> protected internal virtual void OnDisable() { } internal abstract void SetValue(ParameterOverride parameter); } /// <summary> /// The base typed class for all parameter override types. /// </summary> /// <typeparam name="T">The type of value to store in this <c>ParameterOverride</c></typeparam> /// <remarks> /// Due to limitations with the serialization system in Unity you shouldn't use this class /// directly. Use one of the pre-flatten types (like <see cref="FloatParameter"/> or make your /// own by extending this class. /// </remarks> /// <example> /// This sample code shows how to make a custom parameter holding a <c>float</c>. /// <code> /// [Serializable] /// public sealed class FloatParameter : ParameterOverride&lt;float&gt; /// { /// public override void Interp(float from, float to, float t) /// { /// value = from + (to - from) * t; /// } /// } /// </code> /// </example> [Serializable] public class ParameterOverride<T> : ParameterOverride { /// <summary> /// The value stored in this parameter. /// </summary> public T value; /// <summary> /// Creates a <c>ParameterOverride</c> with a default <see cref="value"/> and /// <see cref="ParameterOverride.overrideState"/> set to <c>false</c>. /// </summary> public ParameterOverride() : this(default(T), false) { } /// <summary> /// Creates a <c>ParameterOverride</c> with a given value and /// <see cref="ParameterOverride.overrideState"/> set to <c>false</c>. /// </summary> /// <param name="value">The value to set this parameter to</param> public ParameterOverride(T value) : this(value, false) { } /// <summary> /// Creates a <c>ParameterOverride</c> with a given value and override state. /// </summary> /// <param name="value">The value to set this parameter to</param> /// <param name="overrideState">The override state for this value</param> public ParameterOverride(T value, bool overrideState) { this.value = value; this.overrideState = overrideState; } internal override void Interp(ParameterOverride from, ParameterOverride to, float t) { // Note: this isn't completely safe but it'll do fine Interp(from.GetValue<T>(), to.GetValue<T>(), t); } /// <summary> /// Interpolates between two values given an interpolation factor <paramref name="t"/>. /// </summary> /// <param name="from">The value to interpolate from</param> /// <param name="to">The value to interpolate to</param> /// <param name="t">An interpolation factor (generally in range <c>[0,1]</c>)</param> /// <remarks> /// By default this method does a "snap" interpolation, meaning it will return the value /// <paramref name="to"/> if <paramref name="t"/> is higher than 0, <paramref name="from"/> /// otherwise. /// </remarks> public virtual void Interp(T from, T to, float t) { // Returns `to` if `dt > 0` by default so we don't have to write overrides for bools and // enumerations. value = t > 0f ? to : from; } /// <summary> /// Sets the value for this parameter to <paramref name="x"/> and mark the override state /// to <c>true</c>. /// </summary> /// <param name="x"></param> public void Override(T x) { overrideState = true; value = x; } internal override void SetValue(ParameterOverride parameter) { value = parameter.GetValue<T>(); } /// <inheritdoc /> public override int GetHash() { unchecked { int hash = 17; hash = hash * 23 + overrideState.GetHashCode(); hash = hash * 23 + value.GetHashCode(); return hash; } } /// <summary> /// Implicit conversion between <see cref="ParameterOverride{T}"/> and its value type. /// </summary> /// <param name="prop">The parameter to implicitly cast</param> public static implicit operator T(ParameterOverride<T> prop) { return prop.value; } } // Bypassing the limited unity serialization system... /// <summary> /// A <see cref="ParameterOverride{T}"/> that holds a <c>float</c> value. /// </summary> /// <remarks> /// The interpolation method for this parameter is the same as <see cref="Mathf.LerpUnclamped"/>. /// </remarks> [Serializable] public sealed class FloatParameter : ParameterOverride<float> { /// <inheritdoc /> public override void Interp(float from, float to, float t) { value = from + (to - from) * t; } } /// <summary> /// A <see cref="ParameterOverride{T}"/> that holds a <c>int</c> value. /// </summary> /// <remarks> /// The interpolation method for this parameter is the same as <see cref="Mathf.LerpUnclamped"/> /// casted to <c>int</c>. /// </remarks> [Serializable] public sealed class IntParameter : ParameterOverride<int> { /// <inheritdoc /> public override void Interp(int from, int to, float t) { // Int snapping interpolation. Don't use this for enums as they don't necessarily have // contiguous values. Use the default interpolator instead (same as bool). value = (int)(from + (to - from) * t); } } /// <summary> /// A <see cref="ParameterOverride{T}"/> that holds a <c>bool</c> value. /// </summary> [Serializable] public sealed class BoolParameter : ParameterOverride<bool> {} /// <summary> /// A <see cref="ParameterOverride{T}"/> that holds a <see cref="Color"/> value. /// </summary> /// <remarks> /// The interpolation method for this parameter is the same as <see cref="Mathf.LerpUnclamped"/> /// for each channel. /// </remarks> [Serializable] public sealed class ColorParameter : ParameterOverride<Color> { /// <inheritdoc /> public override void Interp(Color from, Color to, float t) { // Lerping color values is a sensitive subject... We looked into lerping colors using // HSV and LCH but they have some downsides that make them not work correctly in all // situations, so we stick with RGB lerping for now, at least its behavior is // predictable despite looking desaturated when `t ~= 0.5` and it's faster anyway. value.r = from.r + (to.r - from.r) * t; value.g = from.g + (to.g - from.g) * t; value.b = from.b + (to.b - from.b) * t; value.a = from.a + (to.a - from.a) * t; } /// <summary> /// Implicit conversion between <see cref="ColorParameter"/> and a <see cref="Vector4"/>. /// </summary> /// <param name="prop">The parameter to implicitly cast</param> public static implicit operator Vector4(ColorParameter prop) { return prop.value; } } /// <summary> /// A <see cref="ParameterOverride{T}"/> that holds a <see cref="Vector2"/> value. /// </summary> /// <remarks> /// The interpolation method for this parameter is the same as <see cref="Mathf.LerpUnclamped"/> /// for each axis. /// </remarks> [Serializable] public sealed class Vector2Parameter : ParameterOverride<Vector2> { /// <inheritdoc /> public override void Interp(Vector2 from, Vector2 to, float t) { value.x = from.x + (to.x - from.x) * t; value.y = from.y + (to.y - from.y) * t; } /// <summary> /// Implicit conversion between <see cref="Vector2Parameter"/> and a <see cref="Vector3"/>. /// </summary> /// <param name="prop">The parameter to implicitly cast</param> public static implicit operator Vector3(Vector2Parameter prop) { return prop.value; } /// <summary> /// Implicit conversion between <see cref="Vector2Parameter"/> and a <see cref="Vector4"/>. /// </summary> /// <param name="prop">The parameter to implicitly cast</param> public static implicit operator Vector4(Vector2Parameter prop) { return prop.value; } } /// <summary> /// A <see cref="ParameterOverride{T}"/> that holds a <see cref="Vector3"/> value. /// </summary> /// <remarks> /// The interpolation method for this parameter is the same as <see cref="Mathf.LerpUnclamped"/> /// for each axis. /// </remarks> [Serializable] public sealed class Vector3Parameter : ParameterOverride<Vector3> { /// <inheritdoc /> public override void Interp(Vector3 from, Vector3 to, float t) { value.x = from.x + (to.x - from.x) * t; value.y = from.y + (to.y - from.y) * t; value.z = from.z + (to.z - from.z) * t; } /// <summary> /// Implicit conversion between <see cref="Vector3Parameter"/> and a <see cref="Vector2"/>. /// </summary> /// <param name="prop">The parameter to implicitly cast</param> public static implicit operator Vector2(Vector3Parameter prop) { return prop.value; } /// <summary> /// Implicit conversion between <see cref="Vector3Parameter"/> and a <see cref="Vector4"/>. /// </summary> /// <param name="prop">The parameter to implicitly cast</param> public static implicit operator Vector4(Vector3Parameter prop) { return prop.value; } } /// <summary> /// A <see cref="ParameterOverride{T}"/> that holds a <see cref="Vector4"/> value. /// </summary> /// <remarks> /// The interpolation method for this parameter is the same as <see cref="Mathf.LerpUnclamped"/> /// for each axis. /// </remarks> [Serializable] public sealed class Vector4Parameter : ParameterOverride<Vector4> { /// <inheritdoc /> public override void Interp(Vector4 from, Vector4 to, float t) { value.x = from.x + (to.x - from.x) * t; value.y = from.y + (to.y - from.y) * t; value.z = from.z + (to.z - from.z) * t; value.w = from.w + (to.w - from.w) * t; } /// <summary> /// Implicit conversion between <see cref="Vector4Parameter"/> and a <see cref="Vector2"/>. /// </summary> /// <param name="prop">The parameter to implicitly cast</param> public static implicit operator Vector2(Vector4Parameter prop) { return prop.value; } /// <summary> /// Implicit conversion between <see cref="Vector4Parameter"/> and a <see cref="Vector3"/>. /// </summary> /// <param name="prop">The parameter to implicitly cast</param> public static implicit operator Vector3(Vector4Parameter prop) { return prop.value; } } /// <summary> /// A <see cref="ParameterOverride{T}"/> that holds a <see cref="Spline"/> value. /// </summary> /// <remarks> /// The interpolation method for this parameter is the same as <see cref="Mathf.LerpUnclamped"/> /// for each point on the curve. /// </remarks> [Serializable] public sealed class SplineParameter : ParameterOverride<Spline> { /// <inheritdoc /> protected internal override void OnEnable() { if (value != null) value.Cache(int.MinValue); } internal override void SetValue(ParameterOverride parameter) { base.SetValue(parameter); if (value != null) value.Cache(Time.renderedFrameCount); } /// <inheritdoc /> public override void Interp(Spline from, Spline to, float t) { if (from == null || to == null) { base.Interp(from, to, t); return; } int frameCount = Time.renderedFrameCount; from.Cache(frameCount); to.Cache(frameCount); for (int i = 0; i < Spline.k_Precision; i++) { float a = from.cachedData[i]; float b = to.cachedData[i]; value.cachedData[i] = a + (b - a) * t; } } } /// <summary> /// A set of default textures to use as default values for <see cref="TextureParameter"/>. /// </summary> public enum TextureParameterDefault { /// <summary> /// No texture, or <c>null</c>. /// </summary> None, /// <summary> /// A black texture. /// </summary> Black, /// <summary> /// A white texture. /// </summary> White, /// <summary> /// A transparent texture. /// </summary> Transparent, /// <summary> /// A 2D lookup table in strip format with <c>width = height * height</c>. /// </summary> Lut2D } /// <summary> /// A <see cref="ParameterOverride{T}"/> that holds a <see cref="Texture"/> value. /// </summary> /// <remarks> /// Texture interpolation is done using a classic linear interpolation method. /// </remarks> [Serializable] public sealed class TextureParameter : ParameterOverride<Texture> { public TextureParameterDefault defaultState = TextureParameterDefault.Black; /// <inheritdoc /> public override void Interp(Texture from, Texture to, float t) { // Both are null, do nothing if (from == null && to == null) { value = null; return; } // Both aren't null we're ready to blend if (from != null && to != null) { value = TextureLerper.instance.Lerp(from, to, t); return; } // One of them is null, blend to/from a default value is applicable { if (defaultState == TextureParameterDefault.Lut2D) { int size = from != null ? from.height : to.height; Texture defaultTexture = RuntimeUtilities.GetLutStrip(size); if (from == null) from = defaultTexture; if (to == null) to = defaultTexture; } Color tgtColor; switch (defaultState) { case TextureParameterDefault.Black: tgtColor = Color.black; break; case TextureParameterDefault.White: tgtColor = Color.white; break; case TextureParameterDefault.Transparent: tgtColor = Color.clear; break; case TextureParameterDefault.Lut2D: { // Find the current lut size int size = from != null ? from.height : to.height; Texture defaultTexture = RuntimeUtilities.GetLutStrip(size); if (from == null) from = defaultTexture; if (to == null) to = defaultTexture; // Fail safe in case the lut size is incorrect if (from.width != to.width || from.height != to.height) { value = null; return; } value = TextureLerper.instance.Lerp(from, to, t); // All done, return return; } default: // defaultState is none, so just interpolate the base and return base.Interp(from, to, t); return; } // If we made it this far, tgtColor contains the color we'll be lerping into (or out of) if (from == null) { // color -> texture lerp, invert ratio value = TextureLerper.instance.Lerp(to, tgtColor, 1f - t); } else { value = TextureLerper.instance.Lerp(from, tgtColor, t); } } } } }

File no 112: /colame/Assets/SineVFX/PostProcessingV2/Runtime/PostProcessBundle.cs
using System; using UnityEngine.Assertions; namespace UnityEngine.Rendering.PostProcessing { public sealed class PostProcessBundle { public PostProcessAttribute attribute { get; private set; } public PostProcessEffectSettings settings { get; private set; } internal PostProcessEffectRenderer renderer { get { if (m_Renderer == null) { Assert.IsNotNull(attribute.renderer); var rendererType = attribute.renderer; m_Renderer = (PostProcessEffectRenderer)Activator.CreateInstance(rendererType); m_Renderer.SetSettings(settings); m_Renderer.Init(); } return m_Renderer; } } PostProcessEffectRenderer m_Renderer; internal PostProcessBundle(PostProcessEffectSettings settings) { // If settings is null, it means that at some point a null element has been added to // the volume effect list or there was a deserialization error and a reference to // the settings scriptableobject was lost Assert.IsNotNull(settings); this.settings = settings; attribute = settings.GetType().GetAttribute<PostProcessAttribute>(); } internal void Release() { if (m_Renderer != null) m_Renderer.Release(); RuntimeUtilities.Destroy(settings); } internal void ResetHistory() { if (m_Renderer != null) m_Renderer.ResetHistory(); } internal T CastSettings<T>() where T : PostProcessEffectSettings { return (T)settings; } internal T CastRenderer<T>() where T : PostProcessEffectRenderer { return (T)renderer; } } }

File no 113: /colame/Assets/SineVFX/PostProcessingV2/Runtime/PostProcessDebug.cs
namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// This component holds a set of debugging utilities related to post-processing. /// </summary> /// <remarks> /// These utilities can be used at runtime to debug on device. /// </remarks> #if UNITY_2018_3_OR_NEWER [ExecuteAlways] #else [ExecuteInEditMode] #endif [AddComponentMenu("Rendering/Post-process Debug", 1002)] public sealed class PostProcessDebug : MonoBehaviour { /// <summary> /// A reference to a <see cref="PostProcessLayer"/> to debug. /// </summary> public PostProcessLayer postProcessLayer; PostProcessLayer m_PreviousPostProcessLayer; /// <summary> /// Holds settings for the light meter. /// </summary> public bool lightMeter; /// <summary> /// Holds settings for the histogram. /// </summary> public bool histogram; /// <summary> /// Holds settings for the waveform. /// </summary> public bool waveform; /// <summary> /// Holds settings for the vectorscope. /// </summary> public bool vectorscope; /// <summary> /// The currently set overlay. /// </summary> public DebugOverlay debugOverlay = DebugOverlay.None; Camera m_CurrentCamera; CommandBuffer m_CmdAfterEverything; void OnEnable() { m_CmdAfterEverything = new CommandBuffer { name = "Post-processing Debug Overlay" }; #if UNITY_EDITOR // Update is only called on object change when ExecuteInEditMode is set, but we need it // to execute on every frame no matter what when not in play mode, so we'll use the // editor update loop instead... UnityEditor.EditorApplication.update += UpdateStates; #endif } void OnDisable() { #if UNITY_EDITOR UnityEditor.EditorApplication.update -= UpdateStates; #endif if (m_CurrentCamera != null) m_CurrentCamera.RemoveCommandBuffer(CameraEvent.AfterImageEffects, m_CmdAfterEverything); m_CurrentCamera = null; m_PreviousPostProcessLayer = null; } #if !UNITY_EDITOR void Update() { UpdateStates(); } #endif void Reset() { postProcessLayer = GetComponent<PostProcessLayer>(); } void UpdateStates() { if (m_PreviousPostProcessLayer != postProcessLayer) { // Remove cmdbuffer from previously set camera if (m_CurrentCamera != null) { m_CurrentCamera.RemoveCommandBuffer(CameraEvent.AfterImageEffects, m_CmdAfterEverything); m_CurrentCamera = null; } m_PreviousPostProcessLayer = postProcessLayer; // Add cmdbuffer to the currently set camera if (postProcessLayer != null) { m_CurrentCamera = postProcessLayer.GetComponent<Camera>(); m_CurrentCamera.AddCommandBuffer(CameraEvent.AfterImageEffects, m_CmdAfterEverything); } } if (postProcessLayer == null || !postProcessLayer.enabled) return; // Monitors if (lightMeter) postProcessLayer.debugLayer.RequestMonitorPass(MonitorType.LightMeter); if (histogram) postProcessLayer.debugLayer.RequestMonitorPass(MonitorType.Histogram); if (waveform) postProcessLayer.debugLayer.RequestMonitorPass(MonitorType.Waveform); if (vectorscope) postProcessLayer.debugLayer.RequestMonitorPass(MonitorType.Vectorscope); // Overlay postProcessLayer.debugLayer.RequestDebugOverlay(debugOverlay); } void OnPostRender() { m_CmdAfterEverything.Clear(); if (postProcessLayer == null || !postProcessLayer.enabled || !postProcessLayer.debugLayer.debugOverlayActive) return; m_CmdAfterEverything.Blit(postProcessLayer.debugLayer.debugOverlayTarget, BuiltinRenderTextureType.CameraTarget); } void OnGUI() { if (postProcessLayer == null || !postProcessLayer.enabled) return; // Some SRPs don't unbind render targets and leave them as-is RenderTexture.active = null; var rect = new Rect(5, 5, 0, 0); var debugLayer = postProcessLayer.debugLayer; DrawMonitor(ref rect, debugLayer.lightMeter, lightMeter); DrawMonitor(ref rect, debugLayer.histogram, histogram); DrawMonitor(ref rect, debugLayer.waveform, waveform); DrawMonitor(ref rect, debugLayer.vectorscope, vectorscope); } void DrawMonitor(ref Rect rect, Monitor monitor, bool enabled) { if (!enabled || monitor.output == null) return; rect.width = monitor.output.width; rect.height = monitor.output.height; GUI.DrawTexture(rect, monitor.output); rect.x += monitor.output.width + 5f; } } }

File no 114: /colame/Assets/SineVFX/PostProcessingV2/Runtime/PostProcessDebugLayer.cs
using System; using System.Collections.Generic; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// A list of debug overlays. /// </summary> public enum DebugOverlay { /// <summary> /// No overlay. /// </summary> None, /// <summary> /// Displays the depth buffer. /// </summary> Depth, /// <summary> /// Displays the screen-space normals buffer. /// </summary> Normals, /// <summary> /// Displays the screen-space motion vectors. /// </summary> MotionVectors, /// <summary> /// Dims the screen and displays NaN and Inf pixels with a bright pink color. /// </summary> NANTracker, /// <summary> /// A color blindness simulator. /// </summary> ColorBlindnessSimulation, // Menu item separator for the inspector _, /// <summary> /// Displays the raw ambient occlusion map. /// </summary> AmbientOcclusion, /// <summary> /// Displays the bloom buffer. /// </summary> BloomBuffer, /// <summary> /// Displays the thresholded buffer used to generate bloom. /// </summary> BloomThreshold, /// <summary> /// Displays depth of field helpers. /// </summary> DepthOfField } /// <summary> /// A list of color blindness types. /// </summary> public enum ColorBlindnessType { /// <summary> /// Deuteranopia (red-green color blindness). /// </summary> Deuteranopia, /// <summary> /// Protanopia (red-green color blindness). /// </summary> Protanopia, /// <summary> /// Tritanopia (blue-yellow color blindness). /// </summary> Tritanopia } /// <summary> /// This class centralizes rendering commands for debug modes. /// </summary> [Serializable] public sealed class PostProcessDebugLayer { /// <summary> /// Light meter renderer. /// </summary> public LightMeterMonitor lightMeter; /// <summary> /// Histogram renderer. /// </summary> public HistogramMonitor histogram; /// <summary> /// Waveform renderer. /// </summary> public WaveformMonitor waveform; /// <summary> /// Vectorscope monitor. /// </summary> public VectorscopeMonitor vectorscope; Dictionary<MonitorType, Monitor> m_Monitors; // Current frame size int frameWidth; int frameHeight; /// <summary> /// The render target used to render debug overlays in. /// </summary> public RenderTexture debugOverlayTarget { get; private set; } /// <summary> /// Returns <c>true</c> if the frame that was just drawn had an active debug overlay. /// </summary> public bool debugOverlayActive { get; private set; } /// <summary> /// The debug overlay requested for the current frame. It is reset to <c>None</c> once the /// frame has finished rendering. /// </summary> public DebugOverlay debugOverlay { get; private set; } /// <summary> /// Debug overlay settings wrapper. /// </summary> [Serializable] public class OverlaySettings { /// <summary> /// Should we remap depth to a linear range? /// </summary> public bool linearDepth = false; /// <summary> /// The intensity of motion vector colors. /// </summary> [Range(0f, 16f)] public float motionColorIntensity = 4f; /// <summary> /// The size of the motion vector grid. /// </summary> [Range(4, 128)] public int motionGridSize = 64; /// <summary> /// The color blindness type to simulate. /// </summary> public ColorBlindnessType colorBlindnessType = ColorBlindnessType.Deuteranopia; /// <summary> /// The strength of the selected color blindness type. /// </summary> [Range(0f, 1f)] public float colorBlindnessStrength = 1f; } /// <summary> /// Debug overlay settings. /// </summary> public OverlaySettings overlaySettings; internal void OnEnable() { RuntimeUtilities.CreateIfNull(ref lightMeter); RuntimeUtilities.CreateIfNull(ref histogram); RuntimeUtilities.CreateIfNull(ref waveform); RuntimeUtilities.CreateIfNull(ref vectorscope); RuntimeUtilities.CreateIfNull(ref overlaySettings); m_Monitors = new Dictionary<MonitorType, Monitor> { { MonitorType.LightMeter, lightMeter }, { MonitorType.Histogram, histogram }, { MonitorType.Waveform, waveform }, { MonitorType.Vectorscope, vectorscope } }; foreach (var kvp in m_Monitors) kvp.Value.OnEnable(); } internal void OnDisable() { foreach (var kvp in m_Monitors) kvp.Value.OnDisable(); DestroyDebugOverlayTarget(); } void DestroyDebugOverlayTarget() { RuntimeUtilities.Destroy(debugOverlayTarget); debugOverlayTarget = null; } /// <summary> /// Requests the drawing of a monitor for the current frame. /// </summary> /// <param name="monitor">The monitor to request</param> public void RequestMonitorPass(MonitorType monitor) { m_Monitors[monitor].requested = true; } /// <summary> /// Requests the drawing of a debug overlay for the current frame. /// </summary> /// <param name="mode">The debug overlay to request</param> public void RequestDebugOverlay(DebugOverlay mode) { debugOverlay = mode; } // Sets the current frame size - used to make sure the debug overlay target is always the // correct size - mostly useful in the editor as the user can easily resize the gameview. internal void SetFrameSize(int width, int height) { frameWidth = width; frameHeight = height; debugOverlayActive = false; } /// <summary> /// Blit a source render target to the debug overlay target. /// </summary> /// <param name="cmd">The command buffer to send render commands to</param> /// <param name="source">The source target</param> /// <param name="sheet">The property sheet to use for the blit</param> /// <param name="pass">The pass to use for the property sheet</param> public void PushDebugOverlay(CommandBuffer cmd, RenderTargetIdentifier source, PropertySheet sheet, int pass) { if (debugOverlayTarget == null || !debugOverlayTarget.IsCreated() || debugOverlayTarget.width != frameWidth || debugOverlayTarget.height != frameHeight) { RuntimeUtilities.Destroy(debugOverlayTarget); debugOverlayTarget = new RenderTexture(frameWidth, frameHeight, 0, RenderTextureFormat.ARGB32) { name = "Debug Overlay Target", anisoLevel = 1, filterMode = FilterMode.Bilinear, wrapMode = TextureWrapMode.Clamp, hideFlags = HideFlags.HideAndDontSave }; debugOverlayTarget.Create(); } cmd.BlitFullscreenTriangle(source, debugOverlayTarget, sheet, pass); debugOverlayActive = true; } internal DepthTextureMode GetCameraFlags() { if (debugOverlay == DebugOverlay.Depth) return DepthTextureMode.Depth; if (debugOverlay == DebugOverlay.Normals) return DepthTextureMode.DepthNormals; if (debugOverlay == DebugOverlay.MotionVectors) return DepthTextureMode.MotionVectors | DepthTextureMode.Depth; return DepthTextureMode.None; } internal void RenderMonitors(PostProcessRenderContext context) { // Monitors bool anyActive = false; bool needsHalfRes = false; foreach (var kvp in m_Monitors) { bool active = kvp.Value.IsRequestedAndSupported(context); anyActive |= active; needsHalfRes |= active && kvp.Value.NeedsHalfRes(); } if (!anyActive) return; var cmd = context.command; cmd.BeginSample("Monitors"); if (needsHalfRes) { cmd.GetTemporaryRT(ShaderIDs.HalfResFinalCopy, context.width / 2, context.height / 2, 0, FilterMode.Bilinear, context.sourceFormat); cmd.Blit(context.destination, ShaderIDs.HalfResFinalCopy); } foreach (var kvp in m_Monitors) { var monitor = kvp.Value; if (monitor.requested) monitor.Render(context); } if (needsHalfRes) cmd.ReleaseTemporaryRT(ShaderIDs.HalfResFinalCopy); cmd.EndSample("Monitors"); } internal void RenderSpecialOverlays(PostProcessRenderContext context) { if (debugOverlay == DebugOverlay.Depth) { var sheet = context.propertySheets.Get(context.resources.shaders.debugOverlays); sheet.properties.SetVector(ShaderIDs.Params, new Vector4(overlaySettings.linearDepth ? 1f : 0f, 0f, 0f, 0f)); PushDebugOverlay(context.command, BuiltinRenderTextureType.None, sheet, 0); } else if (debugOverlay == DebugOverlay.Normals) { var sheet = context.propertySheets.Get(context.resources.shaders.debugOverlays); sheet.ClearKeywords(); if (context.camera.actualRenderingPath == RenderingPath.DeferredLighting) sheet.EnableKeyword("SOURCE_GBUFFER"); PushDebugOverlay(context.command, BuiltinRenderTextureType.None, sheet, 1); } else if (debugOverlay == DebugOverlay.MotionVectors) { var sheet = context.propertySheets.Get(context.resources.shaders.debugOverlays); sheet.properties.SetVector(ShaderIDs.Params, new Vector4(overlaySettings.motionColorIntensity, overlaySettings.motionGridSize, 0f, 0f)); PushDebugOverlay(context.command, context.source, sheet, 2); } else if (debugOverlay == DebugOverlay.NANTracker) { var sheet = context.propertySheets.Get(context.resources.shaders.debugOverlays); PushDebugOverlay(context.command, context.source, sheet, 3); } else if (debugOverlay == DebugOverlay.ColorBlindnessSimulation) { var sheet = context.propertySheets.Get(context.resources.shaders.debugOverlays); sheet.properties.SetVector(ShaderIDs.Params, new Vector4(overlaySettings.colorBlindnessStrength, 0f, 0f, 0f)); PushDebugOverlay(context.command, context.source, sheet, 4 + (int)overlaySettings.colorBlindnessType); } } internal void EndFrame() { foreach (var kvp in m_Monitors) kvp.Value.requested = false; if (!debugOverlayActive) DestroyDebugOverlayTarget(); debugOverlay = DebugOverlay.None; } } }

File no 115: /colame/Assets/SineVFX/PostProcessingV2/Runtime/PostProcessEffectRenderer.cs
namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// The base abstract class for all effect renderer types. If you're writing your own effect you /// should rather use <see cref="PostProcessEffectRenderer{T}"/>. /// </summary> /// <seealso cref="PostProcessEffectRenderer{T}"/> public abstract class PostProcessEffectRenderer { /// <summary> /// This member is set to <c>true</c> when <see cref="PostProcessLayer.ResetHistory"/> is /// called by the user to reset temporal effects and other history-based effects. /// </summary> protected bool m_ResetHistory = true; /// <summary> /// Called when the renderer is created and its associated settings have been set. /// </summary> /// <seealso cref="PostProcessEffectRenderer{T}.settings"/> public virtual void Init() { } /// <summary> /// Override this method if your renderer needs access to any of the buffers defined in /// <see cref="DepthTextureMode"/>. /// </summary> /// <returns>The currently set depth texture modes</returns> /// <seealso cref="DepthTextureMode"/> public virtual DepthTextureMode GetCameraFlags() { return DepthTextureMode.None; } /// <summary> /// Resets the history state for this renderer. This is automatically called when /// <see cref="PostProcessLayer.ResetHistory"/> is called by the user. /// </summary> public virtual void ResetHistory() { m_ResetHistory = true; } /// <summary> /// Override this method to release any resource allocated by your renderer. /// </summary> public virtual void Release() { ResetHistory(); } /// <summary> /// The render method called by <see cref="PostProcessLayer"/> when the effect is rendered. /// </summary> /// <param name="context">A context object</param> public abstract void Render(PostProcessRenderContext context); internal abstract void SetSettings(PostProcessEffectSettings settings); } /// <summary> /// The base abstract class for all effect renderer types. /// </summary> /// <typeparam name="T">The associated type of settings for this renderer</typeparam> public abstract class PostProcessEffectRenderer<T> : PostProcessEffectRenderer where T : PostProcessEffectSettings { /// <summary> /// The current state of the effect settings associated with this renderer. /// </summary> public T settings { get; internal set; } internal override void SetSettings(PostProcessEffectSettings settings) { this.settings = (T)settings; } } }

File no 116: /colame/Assets/SineVFX/PostProcessingV2/Runtime/PostProcessEffectSettings.cs
using System; using System.Collections.ObjectModel; using System.Reflection; using System.Linq; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// The base class for all post-processing effect settings. Any <see cref="ParameterOverride"/> /// members found in this class will be automatically handled and interpolated by the volume /// framework. /// </summary> /// <example> /// <code> /// [Serializable] /// [PostProcess(typeof(ExampleRenderer), "Custom/ExampleEffect")] /// public sealed class ExampleEffect : PostProcessEffectSettings /// { /// [Range(0f, 1f), Tooltip("Effect intensity.")] /// public FloatParameter intensity = new FloatParameter { value = 0f }; /// /// public override bool IsEnabledAndSupported(PostProcessRenderContext context) /// { /// return enabled.value /// &amp;&amp; intensity.value > 0f; // Only render the effect if intensity is greater than 0 /// } /// } /// </code> /// </example> [Serializable] public class PostProcessEffectSettings : ScriptableObject { /// <summary> /// The active state of the set of parameter defined in this class. /// </summary> /// <seealso cref="enabled"/> public bool active = true; /// <summary> /// The true state of the effect override in the stack. Setting this to <c>false</c> will /// disable rendering for this effect assuming a volume with a higher priority doesn't /// override it to <c>true</c>. /// </summary> public BoolParameter enabled = new BoolParameter { overrideState = true, value = false }; internal ReadOnlyCollection<ParameterOverride> parameters; void OnEnable() { // Automatically grab all fields of type ParameterOverride for this instance parameters = GetType() .GetFields(BindingFlags.Public | BindingFlags.Instance) .Where(t => t.FieldType.IsSubclassOf(typeof(ParameterOverride))) .OrderBy(t => t.MetadataToken) // Guaranteed order .Select(t => (ParameterOverride)t.GetValue(this)) .ToList() .AsReadOnly(); foreach (var parameter in parameters) parameter.OnEnable(); } void OnDisable() { if (parameters == null) return; foreach (var parameter in parameters) parameter.OnDisable(); } /// <summary> /// Sets all the overrides for this effect to a given value. /// </summary> /// <param name="state">The value to set the override states to</param> /// <param name="excludeEnabled">If <c>false</c>, the <see cref="enabled"/> field will also /// be set to the given <see cref="state"/> value.</param> public void SetAllOverridesTo(bool state, bool excludeEnabled = true) { foreach (var prop in parameters) { if (excludeEnabled && prop == enabled) continue; prop.overrideState = state; } } /// <summary> /// Returns <c>true</c> if the effect is currently enabled and supported. /// </summary> /// <param name="context">The current post-processing render context</param> /// <returns><c>true</c> if the effect is currently enabled and supported</returns> public virtual bool IsEnabledAndSupported(PostProcessRenderContext context) { return enabled.value; } /// <summary> /// Returns the computed hash code for this parameter. /// </summary> /// <returns>A computed hash code</returns> public int GetHash() { // Custom hashing function used to compare the state of settings (it's not meant to be // unique but to be a quick way to check if two setting sets have the same state or not). // Hash collision rate should be pretty low. unchecked { //return parameters.Aggregate(17, (i, p) => i * 23 + p.GetHash()); int hash = 17; foreach (var p in parameters) hash = hash * 23 + p.GetHash(); return hash; } } } }

File no 117: /colame/Assets/SineVFX/PostProcessingV2/Runtime/PostProcessEvent.cs
using System.Collections.Generic; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// Injection points for custom effects. /// </summary> public enum PostProcessEvent { /// <summary> /// Effects at this injection points will execute before transparent objects are rendered. /// </summary> BeforeTransparent = 0, /// <summary> /// Effects at this injection points will execute after temporal anti-aliasing and before /// builtin effects are rendered. /// </summary> BeforeStack = 1, /// <summary> /// Effects at this injection points will execute after builtin effects have been rendered /// and before the final pass that does FXAA and applies dithering. /// </summary> AfterStack = 2, } // Box free comparer for our `PostProcessEvent` enum, else the runtime will box the type when // used as a key in a dictionary, thus leading to garbage generation... *sigh* internal struct PostProcessEventComparer : IEqualityComparer<PostProcessEvent> { public bool Equals(PostProcessEvent x, PostProcessEvent y) { return x == y; } public int GetHashCode(PostProcessEvent obj) { return (int)obj; } } }

File no 118: /colame/Assets/SineVFX/PostProcessingV2/Runtime/PostProcessLayer.cs
using System; using System.Collections.Generic; using System.Linq; using UnityEngine.Assertions; namespace UnityEngine.Rendering.PostProcessing { #if UNITY_2017_2_OR_NEWER && ENABLE_VR using XRSettings = UnityEngine.XR.XRSettings; #elif UNITY_5_6_OR_NEWER && ENABLE_VR using XRSettings = UnityEngine.VR.VRSettings; #endif /// <summary> /// This is the component responsible for rendering post-processing effects. It must be put on /// every camera you want post-processing to be applied to. /// </summary> #if UNITY_2018_3_OR_NEWER [ExecuteAlways] #else [ExecuteInEditMode] #endif [DisallowMultipleComponent, ImageEffectAllowedInSceneView] [AddComponentMenu("Rendering/Post-process Layer", 1000)] [RequireComponent(typeof(Camera))] public sealed class PostProcessLayer : MonoBehaviour { /// <summary> /// Builtin anti-aliasing methods. /// </summary> public enum Antialiasing { /// <summary> /// No anti-aliasing. /// </summary> None, /// <summary> /// Fast Approximate Anti-aliasing (FXAA). Fast but low quality. /// </summary> FastApproximateAntialiasing, /// <summary> /// Subpixel Morphological Anti-aliasing (SMAA). Slower but higher quality than FXAA. /// </summary> SubpixelMorphologicalAntialiasing, /// <summary> /// Temporal Anti-aliasing (TAA). As fast as SMAA but generally higher quality. Because /// of it's temporal nature, it can introduce ghosting artifacts on fast moving objects /// in highly contrasted areas. /// </summary> TemporalAntialiasing } /// <summary> /// This is transform that will be drive the volume blending feature. In some cases you may /// want to use a transform other than the camera, e.g. for a top down game you'll want the /// player character to drive the blending instead of the actual camera transform. /// Setting this field to <c>null</c> will disable local volumes for this layer (global ones /// will still work). /// </summary> public Transform volumeTrigger; /// <summary> /// A mask of layers to consider for volume blending. It allows you to do volume filtering /// and is especially useful to optimize volume traversal. You should always have your /// volumes in dedicated layers instead of the default one for best performances. /// </summary> public LayerMask volumeLayer; /// <summary> /// If <c>true</c>, it will kill any invalid / NaN pixel and replace it with a black color /// before post-processing is applied. It's generally a good idea to keep this enabled to /// avoid post-processing artifacts cause by broken data in the scene. /// </summary> public bool stopNaNPropagation = true; /// <summary> /// If <c>true</c>, it will render straight to the backbuffer and save the final blit done /// by the engine. This has less overhead and will improve performance on lower-end platforms /// (like mobiles) but breaks compatibility with legacy image effect that use OnRenderImage. /// </summary> public bool finalBlitToCameraTarget = false; /// <summary> /// The anti-aliasing method to use for this camera. By default it's set to <c>None</c>. /// </summary> public Antialiasing antialiasingMode = Antialiasing.None; /// <summary> /// Temporal Anti-aliasing settings for this camera. /// </summary> public TemporalAntialiasing temporalAntialiasing; /// <summary> /// Subpixel Morphological Anti-aliasing settings for this camera. /// </summary> public SubpixelMorphologicalAntialiasing subpixelMorphologicalAntialiasing; /// <summary> /// Fast Approximate Anti-aliasing settings for this camera. /// </summary> public FastApproximateAntialiasing fastApproximateAntialiasing; /// <summary> /// Fog settings for this camera. /// </summary> public Fog fog; Dithering dithering; /// <summary> /// The debug layer is reponsible for rendering debugging information on the screen. It will /// only be used if this layer is referenced in a <see cref="PostProcessDebug"/> component. /// </summary> /// <seealso cref="PostProcessDebug"/> public PostProcessDebugLayer debugLayer; [SerializeField] PostProcessResources m_Resources; // UI states #if UNITY_2017_1_OR_NEWER [UnityEngine.Scripting.Preserve] #endif [SerializeField] bool m_ShowToolkit; #if UNITY_2017_1_OR_NEWER [UnityEngine.Scripting.Preserve] #endif [SerializeField] bool m_ShowCustomSorter; /// <summary> /// If <c>true</c>, it will stop applying post-processing effects just before color grading /// is applied. This is used internally to export to EXR without color grading. /// </summary> public bool breakBeforeColorGrading = false; // Pre-ordered custom user effects // These are automatically populated and made to work properly with the serialization // system AND the editor. Modify at your own risk. [Serializable] public sealed class SerializedBundleRef { // We can't serialize Type so use assemblyQualifiedName instead, we only need this at // init time anyway so it's fine public string assemblyQualifiedName; // Not serialized, is set/reset when deserialization kicks in public PostProcessBundle bundle; } [SerializeField] List<SerializedBundleRef> m_BeforeTransparentBundles; [SerializeField] List<SerializedBundleRef> m_BeforeStackBundles; [SerializeField] List<SerializedBundleRef> m_AfterStackBundles; public Dictionary<PostProcessEvent, List<SerializedBundleRef>> sortedBundles { get; private set; } public DepthTextureMode cameraDepthFlags { get; private set; } // We need to keep track of bundle initialization because for some obscure reason, on // assembly reload a MonoBehavior's Editor OnEnable will be called BEFORE the MonoBehavior's // own OnEnable... So we'll use it to pre-init bundles if the layer inspector is opened and // the component hasn't been enabled yet. public bool haveBundlesBeenInited { get; private set; } // Settings/Renderer bundles mapped to settings types Dictionary<Type, PostProcessBundle> m_Bundles; PropertySheetFactory m_PropertySheetFactory; CommandBuffer m_LegacyCmdBufferBeforeReflections; CommandBuffer m_LegacyCmdBufferBeforeLighting; CommandBuffer m_LegacyCmdBufferOpaque; CommandBuffer m_LegacyCmdBuffer; Camera m_Camera; PostProcessRenderContext m_CurrentContext; LogHistogram m_LogHistogram; bool m_SettingsUpdateNeeded = true; bool m_IsRenderingInSceneView = false; TargetPool m_TargetPool; bool m_NaNKilled = false; // Recycled list - used to reduce GC stress when gathering active effects in a bundle list // on each frame readonly List<PostProcessEffectRenderer> m_ActiveEffects = new List<PostProcessEffectRenderer>(); readonly List<RenderTargetIdentifier> m_Targets = new List<RenderTargetIdentifier>(); void OnEnable() { Init(null); if (!haveBundlesBeenInited) InitBundles(); m_LogHistogram = new LogHistogram(); m_PropertySheetFactory = new PropertySheetFactory(); m_TargetPool = new TargetPool(); debugLayer.OnEnable(); if (RuntimeUtilities.scriptableRenderPipelineActive) return; InitLegacy(); } void InitLegacy() { m_LegacyCmdBufferBeforeReflections = new CommandBuffer { name = "Deferred Ambient Occlusion" }; m_LegacyCmdBufferBeforeLighting = new CommandBuffer { name = "Deferred Ambient Occlusion" }; m_LegacyCmdBufferOpaque = new CommandBuffer { name = "Opaque Only Post-processing" }; m_LegacyCmdBuffer = new CommandBuffer { name = "Post-processing" }; m_Camera = GetComponent<Camera>(); #if !UNITY_2019_1_OR_NEWER // OnRenderImage (below) implies forceIntoRenderTexture m_Camera.forceIntoRenderTexture = true; // Needed when running Forward / LDR / No MSAA #endif m_Camera.AddCommandBuffer(CameraEvent.BeforeReflections, m_LegacyCmdBufferBeforeReflections); m_Camera.AddCommandBuffer(CameraEvent.BeforeLighting, m_LegacyCmdBufferBeforeLighting); m_Camera.AddCommandBuffer(CameraEvent.BeforeImageEffectsOpaque, m_LegacyCmdBufferOpaque); m_Camera.AddCommandBuffer(CameraEvent.BeforeImageEffects, m_LegacyCmdBuffer); // Internal context used if no SRP is set m_CurrentContext = new PostProcessRenderContext(); } #if UNITY_2019_1_OR_NEWER // We always use a CommandBuffer to blit to the final render target // OnRenderImage is used only to avoid the automatic blit from the RenderTexture of Camera.forceIntoRenderTexture to the actual target [ImageEffectUsesCommandBuffer] void OnRenderImage(RenderTexture src, RenderTexture dst) { if (finalBlitToCameraTarget) RenderTexture.active = dst; // silence warning else Graphics.Blit(src, dst); } #endif /// <summary> /// Initializes this layer. If you create the layer via scripting you should always call /// this method. /// </summary> /// <param name="resources">A reference to the resource asset</param> public void Init(PostProcessResources resources) { if (resources != null) m_Resources = resources; RuntimeUtilities.CreateIfNull(ref temporalAntialiasing); RuntimeUtilities.CreateIfNull(ref subpixelMorphologicalAntialiasing); RuntimeUtilities.CreateIfNull(ref fastApproximateAntialiasing); RuntimeUtilities.CreateIfNull(ref dithering); RuntimeUtilities.CreateIfNull(ref fog); RuntimeUtilities.CreateIfNull(ref debugLayer); } public void InitBundles() { if (haveBundlesBeenInited) return; // Create these lists only once, the serialization system will take over after that RuntimeUtilities.CreateIfNull(ref m_BeforeTransparentBundles); RuntimeUtilities.CreateIfNull(ref m_BeforeStackBundles); RuntimeUtilities.CreateIfNull(ref m_AfterStackBundles); // Create a bundle for each effect type m_Bundles = new Dictionary<Type, PostProcessBundle>(); foreach (var type in PostProcessManager.instance.settingsTypes.Keys) { var settings = (PostProcessEffectSettings)ScriptableObject.CreateInstance(type); var bundle = new PostProcessBundle(settings); m_Bundles.Add(type, bundle); } // Update sorted lists with newly added or removed effects in the assemblies UpdateBundleSortList(m_BeforeTransparentBundles, PostProcessEvent.BeforeTransparent); UpdateBundleSortList(m_BeforeStackBundles, PostProcessEvent.BeforeStack); UpdateBundleSortList(m_AfterStackBundles, PostProcessEvent.AfterStack); // Push all sorted lists in a dictionary for easier access sortedBundles = new Dictionary<PostProcessEvent, List<SerializedBundleRef>>(new PostProcessEventComparer()) { { PostProcessEvent.BeforeTransparent, m_BeforeTransparentBundles }, { PostProcessEvent.BeforeStack, m_BeforeStackBundles }, { PostProcessEvent.AfterStack, m_AfterStackBundles } }; // Done haveBundlesBeenInited = true; } void UpdateBundleSortList(List<SerializedBundleRef> sortedList, PostProcessEvent evt) { // First get all effects associated with the injection point var effects = m_Bundles.Where(kvp => kvp.Value.attribute.eventType == evt && !kvp.Value.attribute.builtinEffect) .Select(kvp => kvp.Value) .ToList(); // Remove types that don't exist anymore sortedList.RemoveAll(x => { string searchStr = x.assemblyQualifiedName; return !effects.Exists(b => b.settings.GetType().AssemblyQualifiedName == searchStr); }); // Add new ones foreach (var effect in effects) { string typeName = effect.settings.GetType().AssemblyQualifiedName; if (!sortedList.Exists(b => b.assemblyQualifiedName == typeName)) { var sbr = new SerializedBundleRef { assemblyQualifiedName = typeName }; sortedList.Add(sbr); } } // Link internal references foreach (var effect in sortedList) { string typeName = effect.assemblyQualifiedName; var bundle = effects.Find(b => b.settings.GetType().AssemblyQualifiedName == typeName); effect.bundle = bundle; } } void OnDisable() { // Have to check for null camera in case the user is doing back'n'forth between SRP and // legacy if (m_Camera != null) { if (m_LegacyCmdBufferBeforeReflections != null) m_Camera.RemoveCommandBuffer(CameraEvent.BeforeReflections, m_LegacyCmdBufferBeforeReflections); if (m_LegacyCmdBufferBeforeLighting != null) m_Camera.RemoveCommandBuffer(CameraEvent.BeforeLighting, m_LegacyCmdBufferBeforeLighting); if (m_LegacyCmdBufferOpaque != null) m_Camera.RemoveCommandBuffer(CameraEvent.BeforeImageEffectsOpaque, m_LegacyCmdBufferOpaque); if (m_LegacyCmdBuffer != null) m_Camera.RemoveCommandBuffer(CameraEvent.BeforeImageEffects, m_LegacyCmdBuffer); } temporalAntialiasing.Release(); m_LogHistogram.Release(); foreach (var bundle in m_Bundles.Values) bundle.Release(); m_Bundles.Clear(); m_PropertySheetFactory.Release(); if (debugLayer != null) debugLayer.OnDisable(); // Might be an issue if several layers are blending in the same frame... TextureLerper.instance.Clear(); haveBundlesBeenInited = false; } // Called everytime the user resets the component from the inspector and more importantly // the first time it's added to a GameObject. As we don't have added/removed event for // components, this will do fine void Reset() { volumeTrigger = transform; } void OnPreCull() { // Unused in scriptable render pipelines if (RuntimeUtilities.scriptableRenderPipelineActive) return; if (m_Camera == null || m_CurrentContext == null) InitLegacy(); // Postprocessing does tweak load/store actions when it uses render targets. // But when using builtin render pipeline, Camera will silently apply viewport when setting render target, // meaning that Postprocessing might think that it is rendering to fullscreen RT // and use LoadAction.DontCare freely, which will ruin the RT if we are using viewport. // It should actually check for having tiled architecture but this is not exposed to script, // so we are checking for mobile as a good substitute if(Application.isMobilePlatform) { Rect r = m_Camera.rect; if(Mathf.Abs(r.x) > 1e-6f || Mathf.Abs(r.y) > 1e-6f || Mathf.Abs(1.0f - r.width) > 1e-6f || Mathf.Abs(1.0f - r.height) > 1e-6f) { Debug.LogWarning("When used with builtin render pipeline, Postprocessing package expects to be used on a fullscreen Camera.\nPlease note that using Camera viewport may result in visual artefacts or some things not working.", m_Camera); } } // Resets the projection matrix from previous frame in case TAA was enabled. // We also need to force reset the non-jittered projection matrix here as it's not done // when ResetProjectionMatrix() is called and will break transparent rendering if TAA // is switched off and the FOV or any other camera property changes. #if UNITY_2018_2_OR_NEWER if (!m_Camera.usePhysicalProperties) #endif m_Camera.ResetProjectionMatrix(); m_Camera.nonJitteredProjectionMatrix = m_Camera.projectionMatrix; #if ENABLE_VR if (m_Camera.stereoEnabled) { m_Camera.ResetStereoProjectionMatrices(); Shader.SetGlobalFloat(ShaderIDs.RenderViewportScaleFactor, XRSettings.renderViewportScale); } else #endif { Shader.SetGlobalFloat(ShaderIDs.RenderViewportScaleFactor, 1.0f); } BuildCommandBuffers(); } void OnPreRender() { // Unused in scriptable render pipelines // Only needed for multi-pass stereo right eye if (RuntimeUtilities.scriptableRenderPipelineActive || (m_Camera.stereoActiveEye != Camera.MonoOrStereoscopicEye.Right)) return; BuildCommandBuffers(); } static bool RequiresInitialBlit(Camera camera, PostProcessRenderContext context) { #if UNITY_2019_1_OR_NEWER if (camera.allowMSAA) // this shouldn't be necessary, but until re-tested on older Unity versions just do the blits return true; if (RuntimeUtilities.scriptableRenderPipelineActive) // Should never be called from SRP return true; return false; #else return true; #endif } void UpdateSrcDstForOpaqueOnly(ref int src, ref int dst, PostProcessRenderContext context, RenderTargetIdentifier cameraTarget, int opaqueOnlyEffectsRemaining) { if (src > -1) context.command.ReleaseTemporaryRT(src); context.source = context.destination; src = dst; if (opaqueOnlyEffectsRemaining == 1) { context.destination = cameraTarget; } else { dst = m_TargetPool.Get(); context.destination = dst; context.GetScreenSpaceTemporaryRT(context.command, dst, 0, context.sourceFormat); } } void BuildCommandBuffers() { var context = m_CurrentContext; var sourceFormat = m_Camera.allowHDR ? RuntimeUtilities.defaultHDRRenderTextureFormat : RenderTextureFormat.Default; if (!RuntimeUtilities.isFloatingPointFormat(sourceFormat)) m_NaNKilled = true; context.Reset(); context.camera = m_Camera; context.sourceFormat = sourceFormat; // TODO: Investigate retaining command buffers on XR multi-pass right eye m_LegacyCmdBufferBeforeReflections.Clear(); m_LegacyCmdBufferBeforeLighting.Clear(); m_LegacyCmdBufferOpaque.Clear(); m_LegacyCmdBuffer.Clear(); SetupContext(context); context.command = m_LegacyCmdBufferOpaque; TextureLerper.instance.BeginFrame(context); UpdateVolumeSystem(context.camera, context.command); // Lighting & opaque-only effects var aoBundle = GetBundle<AmbientOcclusion>(); var aoSettings = aoBundle.CastSettings<AmbientOcclusion>(); var aoRenderer = aoBundle.CastRenderer<AmbientOcclusionRenderer>(); bool aoSupported = aoSettings.IsEnabledAndSupported(context); bool aoAmbientOnly = aoRenderer.IsAmbientOnly(context); bool isAmbientOcclusionDeferred = aoSupported && aoAmbientOnly; bool isAmbientOcclusionOpaque = aoSupported && !aoAmbientOnly; var ssrBundle = GetBundle<ScreenSpaceReflections>(); var ssrSettings = ssrBundle.settings; var ssrRenderer = ssrBundle.renderer; bool isScreenSpaceReflectionsActive = ssrSettings.IsEnabledAndSupported(context); // Ambient-only AO is a special case and has to be done in separate command buffers if (isAmbientOcclusionDeferred) { var ao = aoRenderer.Get(); // Render as soon as possible - should be done async in SRPs when available context.command = m_LegacyCmdBufferBeforeReflections; ao.RenderAmbientOnly(context); // Composite with GBuffer right before the lighting pass context.command = m_LegacyCmdBufferBeforeLighting; ao.CompositeAmbientOnly(context); } else if (isAmbientOcclusionOpaque) { context.command = m_LegacyCmdBufferOpaque; aoRenderer.Get().RenderAfterOpaque(context); } bool isFogActive = fog.IsEnabledAndSupported(context); bool hasCustomOpaqueOnlyEffects = HasOpaqueOnlyEffects(context); int opaqueOnlyEffects = 0; opaqueOnlyEffects += isScreenSpaceReflectionsActive ? 1 : 0; opaqueOnlyEffects += isFogActive ? 1 : 0; opaqueOnlyEffects += hasCustomOpaqueOnlyEffects ? 1 : 0; // This works on right eye because it is resolved/populated at runtime var cameraTarget = new RenderTargetIdentifier(BuiltinRenderTextureType.CameraTarget); if (opaqueOnlyEffects > 0) { var cmd = m_LegacyCmdBufferOpaque; context.command = cmd; context.source = cameraTarget; context.destination = cameraTarget; int srcTarget = -1; int dstTarget = -1; UpdateSrcDstForOpaqueOnly(ref srcTarget, ref dstTarget, context, cameraTarget, opaqueOnlyEffects + 1); // + 1 for blit if (RequiresInitialBlit(m_Camera, context) || opaqueOnlyEffects == 1) { cmd.BuiltinBlit(context.source, context.destination, RuntimeUtilities.copyStdMaterial, stopNaNPropagation ? 1 : 0); UpdateSrcDstForOpaqueOnly(ref srcTarget, ref dstTarget, context, cameraTarget, opaqueOnlyEffects); } if (isScreenSpaceReflectionsActive) { ssrRenderer.Render(context); opaqueOnlyEffects--; UpdateSrcDstForOpaqueOnly(ref srcTarget, ref dstTarget, context, cameraTarget, opaqueOnlyEffects); } if (isFogActive) { fog.Render(context); opaqueOnlyEffects--; UpdateSrcDstForOpaqueOnly(ref srcTarget, ref dstTarget, context, cameraTarget, opaqueOnlyEffects); } if (hasCustomOpaqueOnlyEffects) RenderOpaqueOnly(context); cmd.ReleaseTemporaryRT(srcTarget); } // Post-transparency stack int tempRt = -1; bool forceNanKillPass = (!m_NaNKilled && stopNaNPropagation && RuntimeUtilities.isFloatingPointFormat(sourceFormat)); if (RequiresInitialBlit(m_Camera, context) || forceNanKillPass) { tempRt = m_TargetPool.Get(); context.GetScreenSpaceTemporaryRT(m_LegacyCmdBuffer, tempRt, 0, sourceFormat, RenderTextureReadWrite.sRGB); m_LegacyCmdBuffer.BuiltinBlit(cameraTarget, tempRt, RuntimeUtilities.copyStdMaterial, stopNaNPropagation ? 1 : 0); if (!m_NaNKilled) m_NaNKilled = stopNaNPropagation; context.source = tempRt; } else { context.source = cameraTarget; } context.destination = cameraTarget; #if UNITY_2019_1_OR_NEWER if (finalBlitToCameraTarget && !RuntimeUtilities.scriptableRenderPipelineActive) { if (m_Camera.targetTexture) { context.destination = m_Camera.targetTexture.colorBuffer; } else { context.flip = true; context.destination = Display.main.colorBuffer; } } #endif context.command = m_LegacyCmdBuffer; Render(context); if (tempRt > -1) m_LegacyCmdBuffer.ReleaseTemporaryRT(tempRt); } void OnPostRender() { // Unused in scriptable render pipelines if (RuntimeUtilities.scriptableRenderPipelineActive) return; if (m_CurrentContext.IsTemporalAntialiasingActive()) { #if UNITY_2018_2_OR_NEWER // TAA calls SetProjectionMatrix so if the camera projection mode was physical, it gets set to explicit. So we set it back to physical. if (m_CurrentContext.physicalCamera) m_Camera.usePhysicalProperties = true; else #endif m_Camera.ResetProjectionMatrix(); if (m_CurrentContext.stereoActive) { if (RuntimeUtilities.isSinglePassStereoEnabled || m_Camera.stereoActiveEye == Camera.MonoOrStereoscopicEye.Right) m_Camera.ResetStereoProjectionMatrices(); } } } public PostProcessBundle GetBundle<T>() where T : PostProcessEffectSettings { return GetBundle(typeof(T)); } public PostProcessBundle GetBundle(Type settingsType) { Assert.IsTrue(m_Bundles.ContainsKey(settingsType), "Invalid type"); return m_Bundles[settingsType]; } /// <summary> /// Gets the current settings for a given effect. /// </summary> /// <typeparam name="T">The type of effect to look for</typeparam> /// <returns>The current state of an effect</returns> public T GetSettings<T>() where T : PostProcessEffectSettings { return GetBundle<T>().CastSettings<T>(); } /// <summary> /// Utility method to bake a multi-scale volumetric obscurance map for the current camera. /// This will only work if ambient occlusion is active in the scene. /// </summary> /// <param name="cmd">The command buffer to use for rendering steps</param> /// <param name="camera">The camera to render ambient occlusion for</param> /// <param name="destination">The destination render target</param> /// <param name="depthMap">The depth map to use. If <c>null</c>, it will use the depth map /// from the given camera</param> /// <param name="invert">Should the result be inverted?</param> /// <param name="isMSAA">Should use MSAA?</param> public void BakeMSVOMap(CommandBuffer cmd, Camera camera, RenderTargetIdentifier destination, RenderTargetIdentifier? depthMap, bool invert, bool isMSAA = false) { var bundle = GetBundle<AmbientOcclusion>(); var renderer = bundle.CastRenderer<AmbientOcclusionRenderer>().GetMultiScaleVO(); renderer.SetResources(m_Resources); renderer.GenerateAOMap(cmd, camera, destination, depthMap, invert, isMSAA); } internal void OverrideSettings(List<PostProcessEffectSettings> baseSettings, float interpFactor) { // Go through all settings & overriden parameters for the given volume and lerp values foreach (var settings in baseSettings) { if (!settings.active) continue; var target = GetBundle(settings.GetType()).settings; int count = settings.parameters.Count; for (int i = 0; i < count; i++) { var toParam = settings.parameters[i]; if (toParam.overrideState) { var fromParam = target.parameters[i]; fromParam.Interp(fromParam, toParam, interpFactor); } } } } // In the legacy render loop you have to explicitely set flags on camera to tell that you // need depth, depth+normals or motion vectors... This won't have any effect with most // scriptable render pipelines. void SetLegacyCameraFlags(PostProcessRenderContext context) { var flags = DepthTextureMode.None; foreach (var bundle in m_Bundles) { if (bundle.Value.settings.IsEnabledAndSupported(context)) flags |= bundle.Value.renderer.GetCameraFlags(); } // Special case for AA & lighting effects if (context.IsTemporalAntialiasingActive()) flags |= temporalAntialiasing.GetCameraFlags(); if (fog.IsEnabledAndSupported(context)) flags |= fog.GetCameraFlags(); if (debugLayer.debugOverlay != DebugOverlay.None) flags |= debugLayer.GetCameraFlags(); context.camera.depthTextureMode |= flags; cameraDepthFlags = flags; } /// <summary> /// This method should be called whenever you need to reset any temporal effect, e.g. when /// doing camera cuts. /// </summary> public void ResetHistory() { foreach (var bundle in m_Bundles) bundle.Value.ResetHistory(); temporalAntialiasing.ResetHistory(); } /// <summary> /// Checks if this layer has any active opaque-only effect. /// </summary> /// <param name="context">The current render context</param> /// <returns><c>true</c> if opaque-only effects are active, <c>false</c> otherwise</returns> public bool HasOpaqueOnlyEffects(PostProcessRenderContext context) { return HasActiveEffects(PostProcessEvent.BeforeTransparent, context); } /// <summary> /// Checks if this layer has any active effect at the given injection point. /// </summary> /// <param name="evt">The injection point to look for</param> /// <param name="context">The current render context</param> /// <returns><c>true</c> if any effect at the given injection point is active, <c>false</c> /// otherwise</returns> public bool HasActiveEffects(PostProcessEvent evt, PostProcessRenderContext context) { var list = sortedBundles[evt]; foreach (var item in list) { bool enabledAndSupported = item.bundle.settings.IsEnabledAndSupported(context); if (context.isSceneView) { if (item.bundle.attribute.allowInSceneView && enabledAndSupported) return true; } else if (enabledAndSupported) { return true; } } return false; } void SetupContext(PostProcessRenderContext context) { RuntimeUtilities.UpdateResources(m_Resources); m_IsRenderingInSceneView = context.camera.cameraType == CameraType.SceneView; context.isSceneView = m_IsRenderingInSceneView; context.resources = m_Resources; context.propertySheets = m_PropertySheetFactory; context.debugLayer = debugLayer; context.antialiasing = antialiasingMode; context.temporalAntialiasing = temporalAntialiasing; context.logHistogram = m_LogHistogram; #if UNITY_2018_2_OR_NEWER context.physicalCamera = context.camera.usePhysicalProperties; #endif SetLegacyCameraFlags(context); // Prepare debug overlay debugLayer.SetFrameSize(context.width, context.height); // Unsafe to keep this around but we need it for OnGUI events for debug views // Will be removed eventually m_CurrentContext = context; } /// <summary> /// Updates the state of the volume system. This should be called before any other /// post-processing method when running in a scriptable render pipeline. You don't need to /// call this method when running in one of the builtin pipelines. /// </summary> /// <param name="cam">The currently rendering camera.</param> /// <param name="cmd">A command buffer to fill.</param> public void UpdateVolumeSystem(Camera cam, CommandBuffer cmd) { if (m_SettingsUpdateNeeded) { cmd.BeginSample("VolumeBlending"); PostProcessManager.instance.UpdateSettings(this, cam); cmd.EndSample("VolumeBlending"); m_TargetPool.Reset(); // TODO: fix me once VR support is in SRP // Needed in SRP so that _RenderViewportScaleFactor isn't 0 if (RuntimeUtilities.scriptableRenderPipelineActive) Shader.SetGlobalFloat(ShaderIDs.RenderViewportScaleFactor, 1f); } m_SettingsUpdateNeeded = false; } /// <summary> /// Renders effects in the <see cref="PostProcessEvent.BeforeTransparent"/> bucket. You /// should call <see cref="HasOpaqueOnlyEffects"/> before calling this method as it won't /// automatically blit source into destination if no opaque-only effect is active. /// </summary> /// <param name="context">The current post-processing context.</param> public void RenderOpaqueOnly(PostProcessRenderContext context) { if (RuntimeUtilities.scriptableRenderPipelineActive) SetupContext(context); TextureLerper.instance.BeginFrame(context); // Update & override layer settings first (volume blending), will only be done once per // frame, either here or in Render() if there isn't any opaque-only effect to render. // TODO: should be removed, keeping this here for older SRPs UpdateVolumeSystem(context.camera, context.command); RenderList(sortedBundles[PostProcessEvent.BeforeTransparent], context, "OpaqueOnly"); } /// <summary> /// Renders all effects not in the <see cref="PostProcessEvent.BeforeTransparent"/> bucket. /// </summary> /// <param name="context">The current post-processing context.</param> public void Render(PostProcessRenderContext context) { if (RuntimeUtilities.scriptableRenderPipelineActive) SetupContext(context); TextureLerper.instance.BeginFrame(context); var cmd = context.command; // Update & override layer settings first (volume blending) if the opaque only pass // hasn't been called this frame. // TODO: should be removed, keeping this here for older SRPs UpdateVolumeSystem(context.camera, context.command); // Do a NaN killing pass if needed int lastTarget = -1; RenderTargetIdentifier cameraTexture = context.source; #if UNITY_2019_1_OR_NEWER if (context.stereoActive && context.numberOfEyes > 1 && context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePass) { cmd.SetSinglePassStereo(SinglePassStereoMode.None); cmd.DisableShaderKeyword("UNITY_SINGLE_PASS_STEREO"); } #endif for (int eye = 0; eye < context.numberOfEyes; eye++) { bool preparedStereoSource = false; if (stopNaNPropagation && !m_NaNKilled) { lastTarget = m_TargetPool.Get(); context.GetScreenSpaceTemporaryRT(cmd, lastTarget, 0, context.sourceFormat); if (context.stereoActive && context.numberOfEyes > 1) { if (context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePassInstanced) { cmd.BlitFullscreenTriangleFromTexArray(context.source, lastTarget, RuntimeUtilities.copyFromTexArraySheet, 1, false, eye); preparedStereoSource = true; } else if (context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePass) { cmd.BlitFullscreenTriangleFromDoubleWide(context.source, lastTarget, RuntimeUtilities.copyStdFromDoubleWideMaterial, 1, eye); preparedStereoSource = true; } } else cmd.BlitFullscreenTriangle(context.source, lastTarget, RuntimeUtilities.copySheet, 1); context.source = lastTarget; m_NaNKilled = true; } if (!preparedStereoSource && context.numberOfEyes > 1) { lastTarget = m_TargetPool.Get(); context.GetScreenSpaceTemporaryRT(cmd, lastTarget, 0, context.sourceFormat); if (context.stereoActive) { if (context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePassInstanced) { cmd.BlitFullscreenTriangleFromTexArray(context.source, lastTarget, RuntimeUtilities.copyFromTexArraySheet, 1, false, eye); preparedStereoSource = true; } else if (context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePass) { cmd.BlitFullscreenTriangleFromDoubleWide(context.source, lastTarget, RuntimeUtilities.copyStdFromDoubleWideMaterial, stopNaNPropagation ? 1 : 0, eye); preparedStereoSource = true; } } context.source = lastTarget; } // Do temporal anti-aliasing first if (context.IsTemporalAntialiasingActive()) { if (!RuntimeUtilities.scriptableRenderPipelineActive) { if (context.stereoActive) { // We only need to configure all of this once for stereo, during OnPreCull if (context.camera.stereoActiveEye != Camera.MonoOrStereoscopicEye.Right) temporalAntialiasing.ConfigureStereoJitteredProjectionMatrices(context); } else { temporalAntialiasing.ConfigureJitteredProjectionMatrix(context); } } var taaTarget = m_TargetPool.Get(); var finalDestination = context.destination; context.GetScreenSpaceTemporaryRT(cmd, taaTarget, 0, context.sourceFormat); context.destination = taaTarget; temporalAntialiasing.Render(context); context.source = taaTarget; context.destination = finalDestination; if (lastTarget > -1) cmd.ReleaseTemporaryRT(lastTarget); lastTarget = taaTarget; } bool hasBeforeStackEffects = HasActiveEffects(PostProcessEvent.BeforeStack, context); bool hasAfterStackEffects = HasActiveEffects(PostProcessEvent.AfterStack, context) && !breakBeforeColorGrading; bool needsFinalPass = (hasAfterStackEffects || (antialiasingMode == Antialiasing.FastApproximateAntialiasing) || (antialiasingMode == Antialiasing.SubpixelMorphologicalAntialiasing && subpixelMorphologicalAntialiasing.IsSupported())) && !breakBeforeColorGrading; // Right before the builtin stack if (hasBeforeStackEffects) lastTarget = RenderInjectionPoint(PostProcessEvent.BeforeStack, context, "BeforeStack", lastTarget); // Builtin stack lastTarget = RenderBuiltins(context, !needsFinalPass, lastTarget, eye); // After the builtin stack but before the final pass (before FXAA & Dithering) if (hasAfterStackEffects) lastTarget = RenderInjectionPoint(PostProcessEvent.AfterStack, context, "AfterStack", lastTarget); // And close with the final pass if (needsFinalPass) RenderFinalPass(context, lastTarget, eye); if (context.stereoActive) context.source = cameraTexture; } #if UNITY_2019_1_OR_NEWER if (context.stereoActive && context.numberOfEyes > 1 && context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePass) { cmd.SetSinglePassStereo(SinglePassStereoMode.SideBySide); cmd.EnableShaderKeyword("UNITY_SINGLE_PASS_STEREO"); } #endif // Render debug monitors & overlay if requested debugLayer.RenderSpecialOverlays(context); debugLayer.RenderMonitors(context); // End frame cleanup TextureLerper.instance.EndFrame(); debugLayer.EndFrame(); m_SettingsUpdateNeeded = true; m_NaNKilled = false; } int RenderInjectionPoint(PostProcessEvent evt, PostProcessRenderContext context, string marker, int releaseTargetAfterUse = -1) { int tempTarget = m_TargetPool.Get(); var finalDestination = context.destination; var cmd = context.command; context.GetScreenSpaceTemporaryRT(cmd, tempTarget, 0, context.sourceFormat); context.destination = tempTarget; RenderList(sortedBundles[evt], context, marker); context.source = tempTarget; context.destination = finalDestination; if (releaseTargetAfterUse > -1) cmd.ReleaseTemporaryRT(releaseTargetAfterUse); return tempTarget; } void RenderList(List<SerializedBundleRef> list, PostProcessRenderContext context, string marker) { var cmd = context.command; cmd.BeginSample(marker); // First gather active effects - we need this to manage render targets more efficiently m_ActiveEffects.Clear(); for (int i = 0; i < list.Count; i++) { var effect = list[i].bundle; if (effect.settings.IsEnabledAndSupported(context)) { if (!context.isSceneView || (context.isSceneView && effect.attribute.allowInSceneView)) m_ActiveEffects.Add(effect.renderer); } } int count = m_ActiveEffects.Count; // If there's only one active effect, we can simply execute it and skip the rest if (count == 1) { m_ActiveEffects[0].Render(context); } else { // Else create the target chain m_Targets.Clear(); m_Targets.Add(context.source); // First target is always source int tempTarget1 = m_TargetPool.Get(); int tempTarget2 = m_TargetPool.Get(); for (int i = 0; i < count - 1; i++) m_Targets.Add(i % 2 == 0 ? tempTarget1 : tempTarget2); m_Targets.Add(context.destination); // Last target is always destination // Render context.GetScreenSpaceTemporaryRT(cmd, tempTarget1, 0, context.sourceFormat); if (count > 2) context.GetScreenSpaceTemporaryRT(cmd, tempTarget2, 0, context.sourceFormat); for (int i = 0; i < count; i++) { context.source = m_Targets[i]; context.destination = m_Targets[i + 1]; m_ActiveEffects[i].Render(context); } cmd.ReleaseTemporaryRT(tempTarget1); if (count > 2) cmd.ReleaseTemporaryRT(tempTarget2); } cmd.EndSample(marker); } void ApplyFlip(PostProcessRenderContext context, MaterialPropertyBlock properties) { if (context.flip && !context.isSceneView) properties.SetVector(ShaderIDs.UVTransform, new Vector4(1.0f, 1.0f, 0.0f, 0.0f)); else ApplyDefaultFlip(properties); } void ApplyDefaultFlip(MaterialPropertyBlock properties) { properties.SetVector(ShaderIDs.UVTransform, SystemInfo.graphicsUVStartsAtTop ? new Vector4(1.0f, -1.0f, 0.0f, 1.0f) : new Vector4(1.0f, 1.0f, 0.0f, 0.0f)); } int RenderBuiltins(PostProcessRenderContext context, bool isFinalPass, int releaseTargetAfterUse = -1, int eye = -1) { var uberSheet = context.propertySheets.Get(context.resources.shaders.uber); uberSheet.ClearKeywords(); uberSheet.properties.Clear(); context.uberSheet = uberSheet; context.autoExposureTexture = RuntimeUtilities.whiteTexture; context.bloomBufferNameID = -1; if (isFinalPass && context.stereoActive && context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePassInstanced) uberSheet.EnableKeyword("STEREO_INSTANCING_ENABLED"); var cmd = context.command; cmd.BeginSample("BuiltinStack"); int tempTarget = -1; var finalDestination = context.destination; if (!isFinalPass) { // Render to an intermediate target as this won't be the final pass tempTarget = m_TargetPool.Get(); context.GetScreenSpaceTemporaryRT(cmd, tempTarget, 0, context.sourceFormat); context.destination = tempTarget; // Handle FXAA's keep alpha mode if (antialiasingMode == Antialiasing.FastApproximateAntialiasing && !fastApproximateAntialiasing.keepAlpha) uberSheet.properties.SetFloat(ShaderIDs.LumaInAlpha, 1f); } // Depth of field final combination pass used to be done in Uber which led to artifacts // when used at the same time as Bloom (because both effects used the same source, so // the stronger bloom was, the more DoF was eaten away in out of focus areas) int depthOfFieldTarget = RenderEffect<DepthOfField>(context, true); // Motion blur is a separate pass - could potentially be done after DoF depending on the // kind of results you're looking for... int motionBlurTarget = RenderEffect<MotionBlur>(context, true); // Prepare exposure histogram if needed if (ShouldGenerateLogHistogram(context)) m_LogHistogram.Generate(context); // Uber effects RenderEffect<AutoExposure>(context); uberSheet.properties.SetTexture(ShaderIDs.AutoExposureTex, context.autoExposureTexture); RenderEffect<LensDistortion>(context); RenderEffect<ChromaticAberration>(context); RenderEffect<Bloom>(context); RenderEffect<Vignette>(context); RenderEffect<Grain>(context); if (!breakBeforeColorGrading) RenderEffect<ColorGrading>(context); if (isFinalPass) { uberSheet.EnableKeyword("FINALPASS"); dithering.Render(context); ApplyFlip(context, uberSheet.properties); } else { ApplyDefaultFlip(uberSheet.properties); } if (context.stereoActive && context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePassInstanced) { uberSheet.properties.SetFloat(ShaderIDs.DepthSlice, eye); cmd.BlitFullscreenTriangleToTexArray(context.source, context.destination, uberSheet, 0, false, eye); } else if (isFinalPass && context.stereoActive && context.numberOfEyes > 1 && context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePass) { cmd.BlitFullscreenTriangleToDoubleWide(context.source, context.destination, uberSheet, 0, eye); } #if LWRP_1_0_0_OR_NEWER else if (isFinalPass) cmd.BlitFullscreenTriangle(context.source, context.destination, uberSheet, 0, false, context.camera.pixelRect); #endif else cmd.BlitFullscreenTriangle(context.source, context.destination, uberSheet, 0); context.source = context.destination; context.destination = finalDestination; if (releaseTargetAfterUse > -1) cmd.ReleaseTemporaryRT(releaseTargetAfterUse); if (motionBlurTarget > -1) cmd.ReleaseTemporaryRT(motionBlurTarget); if (depthOfFieldTarget > -1) cmd.ReleaseTemporaryRT(depthOfFieldTarget); if (context.bloomBufferNameID > -1) cmd.ReleaseTemporaryRT(context.bloomBufferNameID); cmd.EndSample("BuiltinStack"); return tempTarget; } // This pass will have to be disabled for HDR screen output as it's an LDR pass void RenderFinalPass(PostProcessRenderContext context, int releaseTargetAfterUse = -1, int eye = -1) { var cmd = context.command; cmd.BeginSample("FinalPass"); if (breakBeforeColorGrading) { var sheet = context.propertySheets.Get(context.resources.shaders.discardAlpha); if (context.stereoActive && context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePassInstanced) sheet.EnableKeyword("STEREO_INSTANCING_ENABLED"); if (context.stereoActive && context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePassInstanced) { sheet.properties.SetFloat(ShaderIDs.DepthSlice, eye); cmd.BlitFullscreenTriangleToTexArray(context.source, context.destination, sheet, 0, false, eye); } else if (context.stereoActive && context.numberOfEyes > 1 && context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePass) { cmd.BlitFullscreenTriangleToDoubleWide(context.source, context.destination, sheet, 0, eye); } else cmd.BlitFullscreenTriangle(context.source, context.destination, sheet, 0); } else { var uberSheet = context.propertySheets.Get(context.resources.shaders.finalPass); uberSheet.ClearKeywords(); uberSheet.properties.Clear(); context.uberSheet = uberSheet; int tempTarget = -1; if (context.stereoActive && context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePassInstanced) uberSheet.EnableKeyword("STEREO_INSTANCING_ENABLED"); if (antialiasingMode == Antialiasing.FastApproximateAntialiasing) { uberSheet.EnableKeyword(fastApproximateAntialiasing.fastMode ? "FXAA_LOW" : "FXAA" ); if (fastApproximateAntialiasing.keepAlpha) uberSheet.EnableKeyword("FXAA_KEEP_ALPHA"); } else if (antialiasingMode == Antialiasing.SubpixelMorphologicalAntialiasing && subpixelMorphologicalAntialiasing.IsSupported()) { tempTarget = m_TargetPool.Get(); var finalDestination = context.destination; context.GetScreenSpaceTemporaryRT(context.command, tempTarget, 0, context.sourceFormat); context.destination = tempTarget; subpixelMorphologicalAntialiasing.Render(context); context.source = tempTarget; context.destination = finalDestination; } dithering.Render(context); ApplyFlip(context, uberSheet.properties); if (context.stereoActive && context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePassInstanced) { uberSheet.properties.SetFloat(ShaderIDs.DepthSlice, eye); cmd.BlitFullscreenTriangleToTexArray(context.source, context.destination, uberSheet, 0, false, eye); } else if (context.stereoActive && context.numberOfEyes > 1 && context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePass) { cmd.BlitFullscreenTriangleToDoubleWide(context.source, context.destination, uberSheet, 0, eye); } else #if LWRP_1_0_0_OR_NEWER cmd.BlitFullscreenTriangle(context.source, context.destination, uberSheet, 0, false, context.camera.pixelRect); #else cmd.BlitFullscreenTriangle(context.source, context.destination, uberSheet, 0); #endif if (tempTarget > -1) cmd.ReleaseTemporaryRT(tempTarget); } if (releaseTargetAfterUse > -1) cmd.ReleaseTemporaryRT(releaseTargetAfterUse); cmd.EndSample("FinalPass"); } int RenderEffect<T>(PostProcessRenderContext context, bool useTempTarget = false) where T : PostProcessEffectSettings { var effect = GetBundle<T>(); if (!effect.settings.IsEnabledAndSupported(context)) return -1; if (m_IsRenderingInSceneView && !effect.attribute.allowInSceneView) return -1; if (!useTempTarget) { effect.renderer.Render(context); return -1; } var finalDestination = context.destination; var tempTarget = m_TargetPool.Get(); context.GetScreenSpaceTemporaryRT(context.command, tempTarget, 0, context.sourceFormat); context.destination = tempTarget; effect.renderer.Render(context); context.source = tempTarget; context.destination = finalDestination; return tempTarget; } bool ShouldGenerateLogHistogram(PostProcessRenderContext context) { bool autoExpo = GetBundle<AutoExposure>().settings.IsEnabledAndSupported(context); bool lightMeter = debugLayer.lightMeter.IsRequestedAndSupported(context); return autoExpo || lightMeter; } } }

File no 119: /colame/Assets/SineVFX/PostProcessingV2/Runtime/PostProcessManager.cs
using System; using System.Collections.Generic; using System.Linq; using UnityEngine.Assertions; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// This manager tracks all volumes in the scene and does all the interpolation work. It is /// automatically created as soon as Post-processing is active in a scene. /// </summary> public sealed class PostProcessManager { static PostProcessManager s_Instance; /// <summary> /// The current singleton instance of <see cref="PostProcessManager"/>. /// </summary> public static PostProcessManager instance { get { if (s_Instance == null) s_Instance = new PostProcessManager(); return s_Instance; } } const int k_MaxLayerCount = 32; // Max amount of layers available in Unity readonly Dictionary<int, List<PostProcessVolume>> m_SortedVolumes; readonly List<PostProcessVolume> m_Volumes; readonly Dictionary<int, bool> m_SortNeeded; readonly List<PostProcessEffectSettings> m_BaseSettings; readonly List<Collider> m_TempColliders; /// <summary> /// This dictionary maps all <see cref="PostProcessEffectSettings"/> available to their /// corresponding <see cref="PostProcessAttribute"/>. It can be used to list all loaded /// builtin and custom effects. /// </summary> public readonly Dictionary<Type, PostProcessAttribute> settingsTypes; PostProcessManager() { m_SortedVolumes = new Dictionary<int, List<PostProcessVolume>>(); m_Volumes = new List<PostProcessVolume>(); m_SortNeeded = new Dictionary<int, bool>(); m_BaseSettings = new List<PostProcessEffectSettings>(); m_TempColliders = new List<Collider>(5); settingsTypes = new Dictionary<Type, PostProcessAttribute>(); ReloadBaseTypes(); } #if UNITY_EDITOR // Called every time Unity recompile scripts in the editor. We need this to keep track of // any new custom effect the user might add to the project [UnityEditor.Callbacks.DidReloadScripts] static void OnEditorReload() { instance.ReloadBaseTypes(); } #endif void CleanBaseTypes() { settingsTypes.Clear(); foreach (var settings in m_BaseSettings) RuntimeUtilities.Destroy(settings); m_BaseSettings.Clear(); } // This will be called only once at runtime and everytime script reload kicks-in in the // editor as we need to keep track of any compatible post-processing effects in the project void ReloadBaseTypes() { CleanBaseTypes(); // Rebuild the base type map var types = RuntimeUtilities.GetAllAssemblyTypes() .Where( t => t.IsSubclassOf(typeof(PostProcessEffectSettings)) && t.IsDefined(typeof(PostProcessAttribute), false) && !t.IsAbstract ); foreach (var type in types) { settingsTypes.Add(type, type.GetAttribute<PostProcessAttribute>()); // Create an instance for each effect type, these will be used for the lowest // priority global volume as we need a default state when exiting volume ranges var inst = (PostProcessEffectSettings)ScriptableObject.CreateInstance(type); inst.SetAllOverridesTo(true, false); m_BaseSettings.Add(inst); } } /// <summary> /// Gets a list of all volumes currently affecting the given layer. Results aren't sorted /// and the list isn't cleared. /// </summary> /// <param name="layer">The layer to look for</param> /// <param name="results">A list to store the volumes found</param> /// <param name="skipDisabled">Should we skip disabled volumes?</param> /// <param name="skipZeroWeight">Should we skip 0-weight volumes?</param> public void GetActiveVolumes(PostProcessLayer layer, List<PostProcessVolume> results, bool skipDisabled = true, bool skipZeroWeight = true) { // If no trigger is set, only global volumes will have influence int mask = layer.volumeLayer.value; var volumeTrigger = layer.volumeTrigger; bool onlyGlobal = volumeTrigger == null; var triggerPos = onlyGlobal ? Vector3.zero : volumeTrigger.position; // Sort the cached volume list(s) for the given layer mask if needed and return it var volumes = GrabVolumes(mask); // Traverse all volumes foreach (var volume in volumes) { // Skip disabled volumes and volumes without any data or weight if ((skipDisabled && !volume.enabled) || volume.profileRef == null || (skipZeroWeight && volume.weight <= 0f)) continue; // Global volume always have influence if (volume.isGlobal) { results.Add(volume); continue; } if (onlyGlobal) continue; // If volume isn't global and has no collider, skip it as it's useless var colliders = m_TempColliders; volume.GetComponents(colliders); if (colliders.Count == 0) continue; // Find closest distance to volume, 0 means it's inside it float closestDistanceSqr = float.PositiveInfinity; foreach (var collider in colliders) { if (!collider.enabled) continue; var closestPoint = collider.ClosestPoint(triggerPos); // 5.6-only API var d = ((closestPoint - triggerPos) / 2f).sqrMagnitude; if (d < closestDistanceSqr) closestDistanceSqr = d; } colliders.Clear(); float blendDistSqr = volume.blendDistance * volume.blendDistance; // Check for influence if (closestDistanceSqr <= blendDistSqr) results.Add(volume); } } /// <summary> /// Gets the highest priority volume affecting a given layer. /// </summary> /// <param name="layer">The layer to look for</param> /// <returns>The highest priority volume affecting the layer</returns> public PostProcessVolume GetHighestPriorityVolume(PostProcessLayer layer) { if (layer == null) throw new ArgumentNullException("layer"); return GetHighestPriorityVolume(layer.volumeLayer); } /// <summary> /// Gets the highest priority volume affecting <see cref="PostProcessLayer"/> in a given /// <see cref="LayerMask"/>. /// </summary> /// <param name="mask">The layer mask to look for</param> /// <returns>The highest priority volume affecting the layer mask</returns> /// <seealso cref="PostProcessLayer.volumeLayer"/> public PostProcessVolume GetHighestPriorityVolume(LayerMask mask) { float highestPriority = float.NegativeInfinity; PostProcessVolume output = null; List<PostProcessVolume> volumes; if (m_SortedVolumes.TryGetValue(mask, out volumes)) { foreach (var volume in volumes) { if (volume.priority > highestPriority) { highestPriority = volume.priority; output = volume; } } } return output; } /// <summary> /// Helper method to spawn a new volume in the scene. /// </summary> /// <param name="layer">The unity layer to put the volume in</param> /// <param name="priority">The priority to set this volume to</param> /// <param name="settings">A list of effects to put in this volume</param> /// <returns></returns> public PostProcessVolume QuickVolume(int layer, float priority, params PostProcessEffectSettings[] settings) { var gameObject = new GameObject() { name = "Quick Volume", layer = layer, hideFlags = HideFlags.HideAndDontSave }; var volume = gameObject.AddComponent<PostProcessVolume>(); volume.priority = priority; volume.isGlobal = true; var profile = volume.profile; foreach (var s in settings) { Assert.IsNotNull(s, "Trying to create a volume with null effects"); profile.AddSettings(s); } return volume; } internal void SetLayerDirty(int layer) { Assert.IsTrue(layer >= 0 && layer <= k_MaxLayerCount, "Invalid layer bit"); foreach (var kvp in m_SortedVolumes) { var mask = kvp.Key; if ((mask & (1 << layer)) != 0) m_SortNeeded[mask] = true; } } internal void UpdateVolumeLayer(PostProcessVolume volume, int prevLayer, int newLayer) { Assert.IsTrue(prevLayer >= 0 && prevLayer <= k_MaxLayerCount, "Invalid layer bit"); Unregister(volume, prevLayer); Register(volume, newLayer); } void Register(PostProcessVolume volume, int layer) { m_Volumes.Add(volume); // Look for existing cached layer masks and add it there if needed foreach (var kvp in m_SortedVolumes) { var mask = kvp.Key; if ((mask & (1 << layer)) != 0) kvp.Value.Add(volume); } SetLayerDirty(layer); } internal void Register(PostProcessVolume volume) { int layer = volume.gameObject.layer; Register(volume, layer); } void Unregister(PostProcessVolume volume, int layer) { m_Volumes.Remove(volume); foreach (var kvp in m_SortedVolumes) { var mask = kvp.Key; // Skip layer masks this volume doesn't belong to if ((mask & (1 << layer)) == 0) continue; kvp.Value.Remove(volume); } } internal void Unregister(PostProcessVolume volume) { int layer = volume.gameObject.layer; Unregister(volume, layer); } // Faster version of OverrideSettings to force replace values in the global state void ReplaceData(PostProcessLayer postProcessLayer) { foreach (var settings in m_BaseSettings) { var target = postProcessLayer.GetBundle(settings.GetType()).settings; int count = settings.parameters.Count; for (int i = 0; i < count; i++) target.parameters[i].SetValue(settings.parameters[i]); } } internal void UpdateSettings(PostProcessLayer postProcessLayer, Camera camera) { // Reset to base state ReplaceData(postProcessLayer); // If no trigger is set, only global volumes will have influence int mask = postProcessLayer.volumeLayer.value; var volumeTrigger = postProcessLayer.volumeTrigger; bool onlyGlobal = volumeTrigger == null; var triggerPos = onlyGlobal ? Vector3.zero : volumeTrigger.position; // Sort the cached volume list(s) for the given layer mask if needed and return it var volumes = GrabVolumes(mask); // Traverse all volumes foreach (var volume in volumes) { #if UNITY_EDITOR // Skip volumes that aren't in the scene currently displayed in the scene view if (!IsVolumeRenderedByCamera(volume, camera)) continue; #endif // Skip disabled volumes and volumes without any data or weight if (!volume.enabled || volume.profileRef == null || volume.weight <= 0f) continue; var settings = volume.profileRef.settings; // Global volume always have influence if (volume.isGlobal) { postProcessLayer.OverrideSettings(settings, Mathf.Clamp01(volume.weight)); continue; } if (onlyGlobal) continue; // If volume isn't global and has no collider, skip it as it's useless var colliders = m_TempColliders; volume.GetComponents(colliders); if (colliders.Count == 0) continue; // Find closest distance to volume, 0 means it's inside it float closestDistanceSqr = float.PositiveInfinity; foreach (var collider in colliders) { if (!collider.enabled) continue; var closestPoint = collider.ClosestPoint(triggerPos); // 5.6-only API var d = ((closestPoint - triggerPos) / 2f).sqrMagnitude; if (d < closestDistanceSqr) closestDistanceSqr = d; } colliders.Clear(); float blendDistSqr = volume.blendDistance * volume.blendDistance; // Volume has no influence, ignore it // Note: Volume doesn't do anything when `closestDistanceSqr = blendDistSqr` but // we can't use a >= comparison as blendDistSqr could be set to 0 in which // case volume would have total influence if (closestDistanceSqr > blendDistSqr) continue; // Volume has influence float interpFactor = 1f; if (blendDistSqr > 0f) interpFactor = 1f - (closestDistanceSqr / blendDistSqr); // No need to clamp01 the interpolation factor as it'll always be in [0;1[ range postProcessLayer.OverrideSettings(settings, interpFactor * Mathf.Clamp01(volume.weight)); } } List<PostProcessVolume> GrabVolumes(LayerMask mask) { List<PostProcessVolume> list; if (!m_SortedVolumes.TryGetValue(mask, out list)) { // New layer mask detected, create a new list and cache all the volumes that belong // to this mask in it list = new List<PostProcessVolume>(); foreach (var volume in m_Volumes) { if ((mask & (1 << volume.gameObject.layer)) == 0) continue; list.Add(volume); m_SortNeeded[mask] = true; } m_SortedVolumes.Add(mask, list); } // Check sorting state bool sortNeeded; if (m_SortNeeded.TryGetValue(mask, out sortNeeded) && sortNeeded) { m_SortNeeded[mask] = false; SortByPriority(list); } return list; } // Custom insertion sort. First sort will be slower but after that it'll be faster than // using List<T>.Sort() which is also unstable by nature. // Sort order is ascending. static void SortByPriority(List<PostProcessVolume> volumes) { Assert.IsNotNull(volumes, "Trying to sort volumes of non-initialized layer"); for (int i = 1; i < volumes.Count; i++) { var temp = volumes[i]; int j = i - 1; while (j >= 0 && volumes[j].priority > temp.priority) { volumes[j + 1] = volumes[j]; j--; } volumes[j + 1] = temp; } } static bool IsVolumeRenderedByCamera(PostProcessVolume volume, Camera camera) { #if UNITY_2018_3_OR_NEWER && UNITY_EDITOR return UnityEditor.SceneManagement.StageUtility.IsGameObjectRenderedByCamera(volume.gameObject, camera); #else return true; #endif } } }

File no 120: /colame/Assets/SineVFX/PostProcessingV2/Runtime/PostProcessProfile.cs
using System; using System.Collections.Generic; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// An asset holding a set of post-processing settings to use with a <see cref="PostProcessVolume"/>. /// </summary> /// <seealso cref="PostProcessVolume"/> public sealed class PostProcessProfile : ScriptableObject { /// <summary> /// A list of all settings stored in this profile. /// </summary> [Tooltip("A list of all settings currently stored in this profile.")] public List<PostProcessEffectSettings> settings = new List<PostProcessEffectSettings>(); // Editor only, doesn't have any use outside of it [NonSerialized] public bool isDirty = true; void OnEnable() { // Make sure every setting is valid. If a profile holds a script that doesn't exist // anymore, nuke it to keep the profile clean. Note that if you delete a script that is // currently in use in a profile you'll still get a one-time error in the console, it's // harmless and happens because Unity does a redraw of the editor (and thus the current // frame) before the recompilation step. settings.RemoveAll(x => x == null); } /// <summary> /// Adds settings for an effect to the profile. /// </summary> /// <typeparam name="T">A type of <see cref="PostProcessEffectSettings"/></typeparam> /// <returns>The instance created from the given type</returns> /// <seealso cref="PostProcessEffectSettings"/> public T AddSettings<T>() where T : PostProcessEffectSettings { return (T)AddSettings(typeof(T)); } /// <summary> /// Adds settings for an effect to the profile. /// </summary> /// <param name="type">A type of <see cref="PostProcessEffectSettings"/></param> /// <returns>The instance created from the given type</returns> /// <seealso cref="PostProcessEffectSettings"/> public PostProcessEffectSettings AddSettings(Type type) { if (HasSettings(type)) throw new InvalidOperationException("Effect already exists in the stack"); var effect = (PostProcessEffectSettings)CreateInstance(type); effect.hideFlags = HideFlags.HideInInspector | HideFlags.HideInHierarchy; effect.name = type.Name; effect.enabled.value = true; settings.Add(effect); isDirty = true; return effect; } /// <summary> /// Adds settings for an effect to the profile. /// </summary> /// <param name="effect">An instance of <see cref="PostProcessEffectSettings"/></param> /// <returns>The given effect instance</returns> /// <seealso cref="PostProcessEffectSettings"/> public PostProcessEffectSettings AddSettings(PostProcessEffectSettings effect) { if (HasSettings(settings.GetType())) throw new InvalidOperationException("Effect already exists in the stack"); settings.Add(effect); isDirty = true; return effect; } /// <summary> /// Removes settings for an effect from the profile. /// </summary> /// <typeparam name="T">The type to look for and remove from the profile</typeparam> /// <exception cref="InvalidOperationException">Thrown if the effect doesn't exist in the /// profile</exception> public void RemoveSettings<T>() where T : PostProcessEffectSettings { RemoveSettings(typeof(T)); } /// <summary> /// Removes settings for an effect from the profile. /// </summary> /// <param name="type">The type to look for and remove from the profile</param> /// <exception cref="InvalidOperationException">Thrown if the effect doesn't exist in the /// profile</exception> public void RemoveSettings(Type type) { int toRemove = -1; for (int i = 0; i < settings.Count; i++) { if (settings[i].GetType() == type) { toRemove = i; break; } } if (toRemove < 0) throw new InvalidOperationException("Effect doesn't exist in the profile"); settings.RemoveAt(toRemove); isDirty = true; } /// <summary> /// Checks if an effect has been added to the profile. /// </summary> /// <typeparam name="T">The type to look for</typeparam> /// <returns><c>true</c> if the effect exists in the profile, <c>false</c> otherwise</returns> public bool HasSettings<T>() where T : PostProcessEffectSettings { return HasSettings(typeof(T)); } /// <summary> /// Checks if an effect has been added to the profile. /// </summary> /// <param name="type">The type to look for</param> /// <returns><c>true</c> if the effect exists in the profile, <c>false</c> otherwise</returns> public bool HasSettings(Type type) { foreach (var setting in settings) { if (setting.GetType() == type) return true; } return false; } /// <summary> /// Returns settings for a given effect type. /// </summary> /// <typeparam name="T">The type to look for</typeparam> /// <returns>Settings for the given effect type, <c>null</c> otherwise</returns> public T GetSetting<T>() where T : PostProcessEffectSettings { foreach (var setting in settings) { if (setting is T) return setting as T; } return null; } /// <summary> /// Gets settings for a given effect type. /// </summary> /// <typeparam name="T">The type to look for</typeparam> /// <param name="outSetting">When this method returns, contains the value associated with /// the specified type, if the type is found; otherwise, this parameter will be <c>null</c>. /// This parameter is passed uninitialized.</param> /// <returns><c>true</c> if the effect exists in the profile, <c>false</c> otherwise</returns> public bool TryGetSettings<T>(out T outSetting) where T : PostProcessEffectSettings { var type = typeof(T); outSetting = null; foreach (var setting in settings) { if (setting.GetType() == type) { outSetting = (T)setting; return true; } } return false; } } }

File no 121: /colame/Assets/SineVFX/PostProcessingV2/Runtime/PostProcessRenderContext.cs
using System.Collections.Generic; namespace UnityEngine.Rendering.PostProcessing { #if UNITY_2017_2_OR_NEWER && ENABLE_VR using XRSettings = UnityEngine.XR.XRSettings; #elif UNITY_5_6_OR_NEWER && ENABLE_VR using XRSettings = UnityEngine.VR.VRSettings; #endif /// <summary> /// A context object passed around all post-processing effects in a frame. /// </summary> public sealed class PostProcessRenderContext { // ----------------------------------------------------------------------------------------- // The following should be filled by the render pipeline Camera m_Camera; /// <summary> /// The camera currently being rendered. /// </summary> public Camera camera { get { return m_Camera; } set { m_Camera = value; #if !UNITY_SWITCH && ENABLE_VR if (m_Camera.stereoEnabled) { #if UNITY_2017_2_OR_NEWER var xrDesc = XRSettings.eyeTextureDesc; stereoRenderingMode = StereoRenderingMode.SinglePass; #if UNITY_STANDALONE || UNITY_EDITOR if (xrDesc.dimension == TextureDimension.Tex2DArray) stereoRenderingMode = StereoRenderingMode.SinglePassInstanced; #endif if (stereoRenderingMode == StereoRenderingMode.SinglePassInstanced) numberOfEyes = 2; #if UNITY_2019_1_OR_NEWER if (stereoRenderingMode == StereoRenderingMode.SinglePass) { numberOfEyes = 2; xrDesc.width /= 2; xrDesc.vrUsage = VRTextureUsage.None; } #else //before 2019.1 double-wide still issues two drawcalls if (stereoRenderingMode == StereoRenderingMode.SinglePass) { numberOfEyes = 1; } #endif width = xrDesc.width; height = xrDesc.height; m_sourceDescriptor = xrDesc; #else // Single-pass is only supported with 2017.2+ because // that is when XRSettings.eyeTextureDesc is available. // Without it, we don't have a robust method of determining // if we are in single-pass. Users can just double the width // here if they KNOW they are using single-pass. width = XRSettings.eyeTextureWidth; height = XRSettings.eyeTextureHeight; #endif if (m_Camera.stereoActiveEye == Camera.MonoOrStereoscopicEye.Right) xrActiveEye = (int)Camera.StereoscopicEye.Right; screenWidth = XRSettings.eyeTextureWidth; screenHeight = XRSettings.eyeTextureHeight; #if UNITY_2019_1_OR_NEWER if (stereoRenderingMode == StereoRenderingMode.SinglePass) screenWidth /= 2; #endif stereoActive = true; } else #endif { width = m_Camera.pixelWidth; height = m_Camera.pixelHeight; #if UNITY_2017_2_OR_NEWER m_sourceDescriptor.width = width; m_sourceDescriptor.height = height; #endif screenWidth = width; screenHeight = height; stereoActive = false; numberOfEyes = 1; } } } /// <summary> /// The command buffer to fill render commands in. /// </summary> public CommandBuffer command { get; set; } /// <summary> /// The source target for this pass (can't be the same as <see cref="destination"/>). /// </summary> public RenderTargetIdentifier source { get; set; } /// <summary> /// The destination target for this pass (can't be the same as <see cref="source"/>). /// </summary> public RenderTargetIdentifier destination { get; set; } /// <summary> /// The texture format used for the source target. /// </summary> // We need this to be set explictely as we don't have any way of knowing if we're rendering // using HDR or not as scriptable render pipelines may ignore the HDR toggle on camera // completely public RenderTextureFormat sourceFormat { get; set; } /// <summary> /// Should we flip the last pass? /// </summary> public bool flip { get; set; } // ----------------------------------------------------------------------------------------- // The following is auto-populated by the post-processing stack /// <summary> /// The resource asset contains reference to external resources (shaders, textures...). /// </summary> public PostProcessResources resources { get; internal set; } /// <summary> /// The property sheet factory handled by the currently active <see cref="PostProcessLayer"/>. /// </summary> public PropertySheetFactory propertySheets { get; internal set; } /// <summary> /// A dictionary to store custom user data objects. This is handy to share data between /// custom effects. /// </summary> public Dictionary<string, object> userData { get; private set; } /// <summary> /// A reference to the internal debug layer. /// </summary> public PostProcessDebugLayer debugLayer { get; internal set; } /// <summary> /// The current camera width (in pixels). /// </summary> public int width { get; private set; } /// <summary> /// The current camera height (in pixels). /// </summary> public int height { get; private set; } /// <summary> /// Is stereo rendering active? /// </summary> public bool stereoActive { get; private set; } /// <summary> /// The current active rendering eye (for XR). /// </summary> public int xrActiveEye { get; private set; } /// <summary> /// The number of eyes for XR outputs. /// </summary> public int numberOfEyes { get; private set; } /// <summary> /// Available XR rendering modes. /// </summary> public enum StereoRenderingMode { MultiPass = 0, SinglePass, SinglePassInstanced, SinglePassMultiview } /// <summary> /// The current rendering mode for XR. /// </summary> public StereoRenderingMode stereoRenderingMode { get; private set; } /// <summary> /// The width of the logical screen size. /// </summary> public int screenWidth { get; private set; } /// <summary> /// The height of the logical screen size. /// </summary> public int screenHeight { get; private set; } /// <summary> /// Are we currently rendering in the scene view? /// </summary> public bool isSceneView { get; internal set; } /// <summary> /// The current anti-aliasing method used by the camera. /// </summary> public PostProcessLayer.Antialiasing antialiasing { get; internal set; } /// <summary> /// A reference to the temporal anti-aliasing settings for the rendering layer. This is /// mostly used to grab the jitter vector and other TAA-related values when an effect needs /// to do temporal reprojection. /// </summary> public TemporalAntialiasing temporalAntialiasing { get; internal set; } // Internal values used for builtin effects // Beware, these may not have been set before a specific builtin effect has been executed internal PropertySheet uberSheet; internal Texture autoExposureTexture; internal LogHistogram logHistogram; internal Texture logLut; internal AutoExposure autoExposure; internal int bloomBufferNameID; #if UNITY_2018_2_OR_NEWER internal bool physicalCamera; #endif /// <summary> /// Resets the state of this context object. This is called by the render pipeline on every /// frame and allows re-using the same context object between frames without having to /// recreate a new one. /// </summary> public void Reset() { m_Camera = null; width = 0; height = 0; #if UNITY_2017_2_OR_NEWER m_sourceDescriptor = new RenderTextureDescriptor(0, 0); #endif #if UNITY_2018_2_OR_NEWER physicalCamera = false; #endif stereoActive = false; xrActiveEye = (int)Camera.StereoscopicEye.Left; screenWidth = 0; screenHeight = 0; command = null; source = 0; destination = 0; sourceFormat = RenderTextureFormat.ARGB32; flip = false; resources = null; propertySheets = null; debugLayer = null; isSceneView = false; antialiasing = PostProcessLayer.Antialiasing.None; temporalAntialiasing = null; uberSheet = null; autoExposureTexture = null; logLut = null; autoExposure = null; bloomBufferNameID = -1; if (userData == null) userData = new Dictionary<string, object>(); userData.Clear(); } /// <summary> /// Checks if temporal anti-aliasing is supported and enabled. /// </summary> /// <returns><c>true</c> if temporal anti-aliasing is supported and enabled, <c>false</c> /// otherwise</returns> public bool IsTemporalAntialiasingActive() { return antialiasing == PostProcessLayer.Antialiasing.TemporalAntialiasing && !isSceneView && temporalAntialiasing.IsSupported(); } /// <summary> /// Checks if a specific debug overlay is enabled. /// </summary> /// <param name="overlay">The debug overlay to look for</param> /// <returns><c>true</c> if the specified debug overlay is enable, <c>false</c> /// otherwise</returns> public bool IsDebugOverlayEnabled(DebugOverlay overlay) { return debugLayer.debugOverlay == overlay; } /// <summary> /// Blit a source render target to the debug overlay target. This is a direct shortcut to /// <see cref="PostProcessDebugLayer.PushDebugOverlay"/>. /// </summary> /// <param name="cmd">The command buffer to send render commands to</param> /// <param name="source">The source target</param> /// <param name="sheet">The property sheet to use for the blit</param> /// <param name="pass">The pass to use for the property sheet</param> /// <seealso cref="PostProcessDebugLayer.PushDebugOverlay"/> public void PushDebugOverlay(CommandBuffer cmd, RenderTargetIdentifier source, PropertySheet sheet, int pass) { debugLayer.PushDebugOverlay(cmd, source, sheet, pass); } // TODO: Change w/h name to texture w/h in order to make // size usages explicit #if UNITY_2017_2_OR_NEWER RenderTextureDescriptor m_sourceDescriptor; RenderTextureDescriptor GetDescriptor(int depthBufferBits = 0, RenderTextureFormat colorFormat = RenderTextureFormat.Default, RenderTextureReadWrite readWrite = RenderTextureReadWrite.Default) { var modifiedDesc = new RenderTextureDescriptor(m_sourceDescriptor.width, m_sourceDescriptor.height, m_sourceDescriptor.colorFormat, depthBufferBits); modifiedDesc.dimension = m_sourceDescriptor.dimension; modifiedDesc.volumeDepth = m_sourceDescriptor.volumeDepth; modifiedDesc.vrUsage = m_sourceDescriptor.vrUsage; modifiedDesc.msaaSamples = m_sourceDescriptor.msaaSamples; modifiedDesc.memoryless = m_sourceDescriptor.memoryless; modifiedDesc.useMipMap = m_sourceDescriptor.useMipMap; modifiedDesc.autoGenerateMips = m_sourceDescriptor.autoGenerateMips; modifiedDesc.enableRandomWrite = m_sourceDescriptor.enableRandomWrite; modifiedDesc.shadowSamplingMode = m_sourceDescriptor.shadowSamplingMode; if (colorFormat != RenderTextureFormat.Default) modifiedDesc.colorFormat = colorFormat; #if UNITY_2019_1_OR_NEWER if (readWrite == RenderTextureReadWrite.sRGB) modifiedDesc.sRGB = true; else if (readWrite == RenderTextureReadWrite.Linear) modifiedDesc.sRGB = false; else if (readWrite == RenderTextureReadWrite.Default) modifiedDesc.sRGB = QualitySettings.activeColorSpace != ColorSpace.Gamma; #else modifiedDesc.sRGB = readWrite != RenderTextureReadWrite.Linear; #endif return modifiedDesc; } #endif /// <summary> /// Grabs a temporary render target with the current display size. /// </summary> /// <param name="cmd">The command buffer to grab a render target from</param> /// <param name="nameID">The shader property name for this texture</param> /// <param name="depthBufferBits">The number of bits to use for the depth buffer</param> /// <param name="colorFormat">The render texture format</param> /// <param name="readWrite">The color space conversion mode</param> /// <param name="filter">The texture filtering mode</param> /// <param name="widthOverride">Override the display width; use <c>0</c> to disable the override</param> /// <param name="heightOverride">Override the display height; use <c>0</c> to disable the override</param> public void GetScreenSpaceTemporaryRT(CommandBuffer cmd, int nameID, int depthBufferBits = 0, RenderTextureFormat colorFormat = RenderTextureFormat.Default, RenderTextureReadWrite readWrite = RenderTextureReadWrite.Default, FilterMode filter = FilterMode.Bilinear, int widthOverride = 0, int heightOverride = 0) { #if UNITY_2017_2_OR_NEWER var desc = GetDescriptor(depthBufferBits, colorFormat, readWrite); if (widthOverride > 0) desc.width = widthOverride; if (heightOverride > 0) desc.height = heightOverride; //intermediates in VR are unchanged if (stereoActive && desc.dimension == Rendering.TextureDimension.Tex2DArray) desc.dimension = Rendering.TextureDimension.Tex2D; cmd.GetTemporaryRT(nameID, desc, filter); #else int actualWidth = width; int actualHeight = height; if (widthOverride > 0) actualWidth = widthOverride; if (heightOverride > 0) actualHeight = heightOverride; cmd.GetTemporaryRT(nameID, actualWidth, actualHeight, depthBufferBits, filter, colorFormat, readWrite); // TODO: How to handle MSAA for XR in older versions? Query cam? // TODO: Pass in vrUsage into the args #endif } /// <summary> /// Grabs a temporary render target with the current display size. /// </summary> /// <param name="depthBufferBits">The number of bits to use for the depth buffer</param> /// <param name="colorFormat">The render texture format</param> /// <param name="readWrite">The color space conversion mode</param> /// <param name="widthOverride">Override the display width; use <c>0</c> to disable the override</param> /// <param name="heightOverride">Override the display height; use <c>0</c> to disable the override</param> /// <returns>A temporary render target</returns> public RenderTexture GetScreenSpaceTemporaryRT(int depthBufferBits = 0, RenderTextureFormat colorFormat = RenderTextureFormat.Default, RenderTextureReadWrite readWrite = RenderTextureReadWrite.Default, int widthOverride = 0, int heightOverride = 0) { #if UNITY_2017_2_OR_NEWER var desc = GetDescriptor(depthBufferBits, colorFormat, readWrite); if (widthOverride > 0) desc.width = widthOverride; if (heightOverride > 0) desc.height = heightOverride; return RenderTexture.GetTemporary(desc); #else int actualWidth = width; int actualHeight = height; if (widthOverride > 0) actualWidth = widthOverride; if (heightOverride > 0) actualHeight = heightOverride; return RenderTexture.GetTemporary(actualWidth, actualHeight, depthBufferBits, colorFormat, readWrite); #endif } } }

File no 122: /colame/Assets/SineVFX/PostProcessingV2/Runtime/PostProcessResources.cs
using System; namespace UnityEngine.Rendering.PostProcessing { /// <summary> /// This asset is used to store references to shaders and other resources we might need at /// runtime without having to use a `Resources` folder. This allows for better memory management, /// better dependency tracking and better interoperability with asset bundles. /// </summary> public sealed class PostProcessResources : ScriptableObject { [Serializable] public sealed class Shaders { public Shader bloom; public Shader copy; public Shader copyStd; public Shader copyStdFromTexArray; public Shader copyStdFromDoubleWide; public Shader discardAlpha; public Shader depthOfField; public Shader finalPass; public Shader grainBaker; public Shader motionBlur; public Shader temporalAntialiasing; public Shader subpixelMorphologicalAntialiasing; public Shader texture2dLerp; public Shader uber; public Shader lut2DBaker; public Shader lightMeter; public Shader gammaHistogram; public Shader waveform; public Shader vectorscope; public Shader debugOverlays; public Shader deferredFog; public Shader scalableAO; public Shader multiScaleAO; public Shader screenSpaceReflections; public Shaders Clone() { return (Shaders)MemberwiseClone(); } } [Serializable] public sealed class ComputeShaders { public ComputeShader autoExposure; public ComputeShader exposureHistogram; public ComputeShader lut3DBaker; public ComputeShader texture3dLerp; public ComputeShader gammaHistogram; public ComputeShader waveform; public ComputeShader vectorscope; public ComputeShader multiScaleAODownsample1; public ComputeShader multiScaleAODownsample2; public ComputeShader multiScaleAORender; public ComputeShader multiScaleAOUpsample; public ComputeShader gaussianDownsample; public ComputeShaders Clone() { return (ComputeShaders)MemberwiseClone(); } } [Serializable] public sealed class SMAALuts { public Texture2D area; public Texture2D search; } public Texture2D[] blueNoise64; public Texture2D[] blueNoise256; public SMAALuts smaaLuts; public Shaders shaders; public ComputeShaders computeShaders; #if UNITY_EDITOR public delegate void ChangeHandler(); public ChangeHandler changeHandler; void OnValidate() { if (changeHandler != null) changeHandler(); } #endif } }

File no 123: /colame/Assets/SineVFX/PostProcessingV2/Runtime/PostProcessVolume.cs
using System.Collections.Generic; namespace UnityEngine.Rendering.PostProcessing { // // Here's a quick look at the architecture of this framework and how it's integrated into Unity // (written between versions 5.6 and 2017.1): // // Users have to be able to plug in their own effects without having to modify the codebase and // these custom effects should work out-of-the-box with all the other features we provide // (volume blending etc). This relies on heavy use of polymorphism, but the only way to get // the serialization system to work well with polymorphism in Unity is to use ScriptableObjects. // // Users can push their custom effects at different (hardcoded) injection points. // // Each effect consists of at least two classes (+ shaders): a POD "Settings" class which only // stores parameters, and a "Renderer" class that holds the rendering logic. Settings are linked // to renderers using a PostProcessAttribute. These are automatically collected at init time // using reflection. Settings in this case are ScriptableObjects, we only need to serialize // these. // // We could store these settings object straight into each volume and call it a day, but // unfortunately there's one feature of Unity that doesn't work well with scene-stored assets: // prefabs. So we need to store all of these settings in a disk-asset and treat them as // sub-assets. // // Note: We have to use ScriptableObject for everything but these don't work with the Animator // tool. It's unfortunate but it's the only way to make it easily extensible. On the other // hand, users can animate post-processing effects using Volumes or straight up scripting. // // Volume blending leverages the physics system for distance checks to the nearest point on // volume colliders. Each volume can have several colliders or any type (cube, mesh...), making // it quite a powerful feature to use. // // Volumes & blending are handled by a singleton manager (see PostProcessManager). // // Rendering is handled by a PostProcessLayer component living on the camera, which mean you // can easily toggle post-processing on & off or change the anti-aliasing type per-camera, // which is very useful when doing multi-layered camera rendering or any other technique that // involves multiple-camera setups. This PostProcessLayer component can also filters volumes // by layers (as in Unity layers) so you can easily choose which volumes should affect the // camera. // // All post-processing shaders MUST use the custom Standard Shader Library bundled with the // framework. The reason for that is because the codebase is meant to work without any // modification on the Classic Render Pipelines (Forward, Deferred...) and the upcoming // Scriptable Render Pipelines (HDPipe, LDPipe...). But these don't have compatible shader // libraries so instead of writing two code paths we chose to provide a minimalist, generic // Standard Library geared toward post-processing use. An added bonus to that if users create // their own post-processing effects using this framework, then they'll work without any // modification on both Classic and Scriptable Render Pipelines. // /// <summary> /// A post-process volume component holding a post-process profile. /// </summary> /// <seealso cref="RuntimeUtilities.DestroyVolume"/> #if UNITY_2018_3_OR_NEWER [ExecuteAlways] #else [ExecuteInEditMode] #endif [AddComponentMenu("Rendering/Post-process Volume", 1001)] public sealed class PostProcessVolume : MonoBehaviour { /// <summary> /// The shared profile of this volume. /// Modifying <c>sharedProfile</c> will change all volumes using this profile, and change /// profile settings that are stored in the project too. /// </summary> /// <remarks> /// It is not recommended to modify profiles returned by <c>sharedProfile</c>. If you want /// to modify the profile of a volume use <see cref="profile"/> instead. /// </remarks> /// <seealso cref="profile"/> public PostProcessProfile sharedProfile; /// <summary> /// Should this volume be applied to the whole scene? /// </summary> [Tooltip("Check this box to mark this volume as global. This volume's Profile will be applied to the whole Scene.")] public bool isGlobal = false; /// <summary> /// The outer distance to start blending from. A value of 0 means no blending and the volume /// overrides will be applied immediatly upon entry. /// </summary> [Min(0f), Tooltip("The distance (from the attached Collider) to start blending from. A value of 0 means there will be no blending and the Volume overrides will be applied immediatly upon entry to the attached Collider.")] public float blendDistance = 0f; /// <summary> /// The total weight of this volume in the scene. 0 means it won't do anything, 1 means full /// effect. /// </summary> [Range(0f, 1f), Tooltip("The total weight of this Volume in the Scene. A value of 0 signifies that it will have no effect, 1 signifies full effect.")] public float weight = 1f; /// <summary> /// The volume priority in the stack. Higher number means higher priority. Negative values /// are supported. /// </summary> [Tooltip("The volume priority in the stack. A higher value means higher priority. Negative values are supported.")] public float priority = 0f; /// <summary> /// Returns the first instantiated <see cref="PostProcessProfile"/> assigned to the volume. /// Modifying <paramref name="profile"/> will change the profile for this volume only. If /// the profile is used by any other volume, this will clone the shared profile and start /// using it from now on. /// </summary> /// <remarks> /// This property automatically instantiates the profile and make it unique to this volume /// so you can safely edit it via scripting at runtime without changing the original asset /// in the project. /// Note that if you pass in your own profile, it is your responsibility to destroy it once /// it's not in use anymore. /// </remarks> /// <seealso cref="sharedProfile"/> /// <seealso cref="RuntimeUtilities.DestroyProfile"/> public PostProcessProfile profile { get { if (m_InternalProfile == null) { m_InternalProfile = ScriptableObject.CreateInstance<PostProcessProfile>(); if (sharedProfile != null) { foreach (var item in sharedProfile.settings) { var itemCopy = Instantiate(item); m_InternalProfile.settings.Add(itemCopy); } } } return m_InternalProfile; } set { m_InternalProfile = value; } } internal PostProcessProfile profileRef { get { return m_InternalProfile == null ? sharedProfile : m_InternalProfile; } } /// <summary> /// Checks if the volume has an intantiated profile or is using a shared profile. /// </summary> /// <returns><c>true</c> if the profile has been intantiated</returns> /// <seealso cref="profile"/> /// <seealso cref="sharedProfile"/> public bool HasInstantiatedProfile() { return m_InternalProfile != null; } int m_PreviousLayer; float m_PreviousPriority; List<Collider> m_TempColliders; PostProcessProfile m_InternalProfile; void OnEnable() { PostProcessManager.instance.Register(this); m_PreviousLayer = gameObject.layer; m_TempColliders = new List<Collider>(); } void OnDisable() { PostProcessManager.instance.Unregister(this); } void Update() { // Unfortunately we need to track the current layer to update the volume manager in // real-time as the user could change it at any time in the editor or at runtime. // Because no event is raised when the layer changes, we have to track it on every // frame :/ int layer = gameObject.layer; if (layer != m_PreviousLayer) { PostProcessManager.instance.UpdateVolumeLayer(this, m_PreviousLayer, layer); m_PreviousLayer = layer; } // Same for `priority`. We could use a property instead, but it doesn't play nice with // the serialization system. Using a custom Attribute/PropertyDrawer for a property is // possible but it doesn't work with Undo/Redo in the editor, which makes it useless. if (priority != m_PreviousPriority) { PostProcessManager.instance.SetLayerDirty(layer); m_PreviousPriority = priority; } } // TODO: Look into a better volume previsualization system void OnDrawGizmos() { var colliders = m_TempColliders; GetComponents(colliders); if (isGlobal || colliders == null) return; #if UNITY_EDITOR // Can't access the UnityEditor.Rendering.PostProcessing namespace from here, so // we'll get the preferred color manually unchecked { int value = UnityEditor.EditorPrefs.GetInt("PostProcessing.Volume.GizmoColor", (int)0x8033cc1a); Gizmos.color = ColorUtilities.ToRGBA((uint)value); } #endif var scale = transform.lossyScale; var invScale = new Vector3(1f / scale.x, 1f / scale.y, 1f / scale.z); Gizmos.matrix = Matrix4x4.TRS(transform.position, transform.rotation, scale); // Draw a separate gizmo for each collider foreach (var collider in colliders) { if (!collider.enabled) continue; // We'll just use scaling as an approximation for volume skin. It's far from being // correct (and is completely wrong in some cases). Ultimately we'd use a distance // field or at least a tesselate + push modifier on the collider's mesh to get a // better approximation, but the current Gizmo system is a bit limited and because // everything is dynamic in Unity and can be changed at anytime, it's hard to keep // track of changes in an elegant way (which we'd need to implement a nice cache // system for generated volume meshes). var type = collider.GetType(); if (type == typeof(BoxCollider)) { var c = (BoxCollider)collider; Gizmos.DrawCube(c.center, c.size); Gizmos.DrawWireCube(c.center, c.size + invScale * blendDistance * 4f); } else if (type == typeof(SphereCollider)) { var c = (SphereCollider)collider; Gizmos.DrawSphere(c.center, c.radius); Gizmos.DrawWireSphere(c.center, c.radius + invScale.x * blendDistance * 2f); } else if (type == typeof(MeshCollider)) { var c = (MeshCollider)collider; // Only convex mesh colliders are allowed if (!c.convex) c.convex = true; // Mesh pivot should be centered or this won't work Gizmos.DrawMesh(c.sharedMesh); Gizmos.DrawWireMesh(c.sharedMesh, Vector3.zero, Quaternion.identity, Vector3.one + invScale * blendDistance * 4f); } // Nothing for capsule (DrawCapsule isn't exposed in Gizmo), terrain, wheel and // other colliders... } colliders.Clear(); } } }

File no 124: /colame/Assets/SineVFX/TranslucentCrystals/_SRP/!!!_ReadBeforeImport_!!!.txt
- This is SRP Patch Packages, if you using HDRP or URP, pick the right package and unpack it into your project. - Unpacking the SRP packages will replace shaders, materials, and a DemoScene to new ones. - Make a backup of the materials before unpacking if you already made some changes to them. Support email: sinevfx@gmail.com

File no 125: /colame/Assets/SineVFX/TranslucentCrystals/Readme.txt
Translucent Crystals Version 1.1 (02.08.2020) v1.1: - Updated PostProcessing - URP and HDRP support added IMPORTANT NOTES: - Turn on "HDR" on your Camera, Shaders requires it - This VFX Asset looks much better in "Linear Rendering", but there is also optimized Prefabs for "Gamma Rendering" Mode - Image Effects are necessary in order to make a great looking game, as well as our asset. Be sure you using "Tone Mapping" and "Bloom" - We also recommend using Deferred Rendering for better performance HOW TO USE: First of all, check for Demo Scene in Scenes folder. Also, there is a Prefabs folder with complete effects. Just Drag and Drop prefabs from "Prefabs" folder into your scene, they come with simple lighting. We made all Shaders very tweakable, so you can create your own unique effects. SHADERS CONTROL: Albedo Mask - Mask for coloring Albedo map Color Tint 1 and 2 - Colors used in Albedo Mask, 1 for black 2 for white areas of the mask Ramp - Use Ramp Gradient texture for coloring your Crystal Ramp Mask - Mask for coloring Emission map Translucency - control overall translucency of object Strength - power of the translucent effect Normal Distortion - defines the amount of normal distortion on the translucency effect Scattering Falloff - light scattering Direct and Ambient - controls how much lighting of these types affects translucency Translucency Mask - thickness mask of the mesh for better effect Translucency Mask Power - power of the Translucency Mask Support email "sinevfx@gmail.com"

File no 126: /colame/Assets/TextMesh Pro/Documentation/TextMesh Pro User Guide 2016.pdf
COLAME/colame/Assets/TextMesh Pro/Documentation/TextMesh Pro User Guide 2016.pdf at main · ar8372/COLAME · GitHub Skip to content Toggle navigation Sign up In this repository All GitHub ↵ Jump to ↵ No suggested jump to results In this repository All GitHub ↵ Jump to ↵ In this user All GitHub ↵ Jump to ↵ In this repository All GitHub ↵ Jump to ↵ Sign in Sign up You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session. You switched accounts on another tab or window. Reload to refresh your session. ar8372 / COLAME Public Notifications Fork 0 Star 1 Permalink main Switch branches/tags Branches Tags Name already in use A tag already exists with the provided branch name. Many Git commands accept both tag and branch names, so creating this branch may cause unexpected behavior. Are you sure you want to create this branch? COLAME/colame/Assets/TextMesh Pro/Documentation/TextMesh Pro User Guide 2016.pdf Go to file Go to file T Go to line L Copy path Copy permalink This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository. Cannot retrieve contributors at this time 678 KB Download Open with Desktop Download Delete file Sorry, something went wrong. Reload? Sorry, we cannot display this file. Sorry, this file is invalid so it cannot be displayed. Viewer requires iframe. Go You can’t perform that action at this time.

File no 127: /colame/Assets/TextMesh Pro/Examples & Extras/Fonts/Anton OFL.txt
Copyright (c) 2011, Vernon Adams (vern@newtypography.co.uk), with Reserved Font Name Anton. This Font Software is licensed under the SIL Open Font License, Version 1.1. This license is copied below, and is also available with a FAQ at: http://scripts.sil.org/OFL ----------------------------------------------------------- SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007 ----------------------------------------------------------- PREAMBLE The goals of the Open Font License (OFL) are to stimulate worldwide development of collaborative font projects, to support the font creation efforts of academic and linguistic communities, and to provide a free and open framework in which fonts may be shared and improved in partnership with others. The OFL allows the licensed fonts to be used, studied, modified and redistributed freely as long as they are not sold by themselves. The fonts, including any derivative works, can be bundled, embedded, redistributed and/or sold with any software provided that any reserved names are not used by derivative works. The fonts and derivatives, however, cannot be released under any other type of license. The requirement for fonts to remain under this license does not apply to any document created using the fonts or their derivatives. DEFINITIONS "Font Software" refers to the set of files released by the Copyright Holder(s) under this license and clearly marked as such. This may include source files, build scripts and documentation. "Reserved Font Name" refers to any names specified as such after the copyright statement(s). "Original Version" refers to the collection of Font Software components as distributed by the Copyright Holder(s). "Modified Version" refers to any derivative made by adding to, deleting, or substituting -- in part or in whole -- any of the components of the Original Version, by changing formats or by porting the Font Software to a new environment. "Author" refers to any designer, engineer, programmer, technical writer or other person who contributed to the Font Software. PERMISSION & CONDITIONS Permission is hereby granted, free of charge, to any person obtaining a copy of the Font Software, to use, study, copy, merge, embed, modify, redistribute, and sell modified and unmodified copies of the Font Software, subject to the following conditions: 1) Neither the Font Software nor any of its individual components, in Original or Modified Versions, may be sold by itself. 2) Original or Modified Versions of the Font Software may be bundled, redistributed and/or sold with any software, provided that each copy contains the above copyright notice and this license. These can be included either as stand-alone text files, human-readable headers or in the appropriate machine-readable metadata fields within text or binary files as long as those fields can be easily viewed by the user. 3) No Modified Version of the Font Software may use the Reserved Font Name(s) unless explicit written permission is granted by the corresponding Copyright Holder. This restriction only applies to the primary font name as presented to the users. 4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font Software shall not be used to promote, endorse or advertise any Modified Version, except to acknowledge the contribution(s) of the Copyright Holder(s) and the Author(s) or with their explicit written permission. 5) The Font Software, modified or unmodified, in part or in whole, must be distributed entirely under this license, and must not be distributed under any other license. The requirement for fonts to remain under this license does not apply to any document created using the Font Software. TERMINATION This license becomes null and void if any of the above conditions are not met. DISCLAIMER THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.

File no 128: /colame/Assets/TextMesh Pro/Examples & Extras/Fonts/Bangers - OFL.txt
Copyright (c) 2010 by vernon adams (vern@newtypography.co.uk), with Reserved Font Name Bangers. This Font Software is licensed under the SIL Open Font License, Version 1.1. This license is copied below, and is also available with a FAQ at: http://scripts.sil.org/OFL ----------------------------------------------------------- SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007 ----------------------------------------------------------- PREAMBLE The goals of the Open Font License (OFL) are to stimulate worldwide development of collaborative font projects, to support the font creation efforts of academic and linguistic communities, and to provide a free and open framework in which fonts may be shared and improved in partnership with others. The OFL allows the licensed fonts to be used, studied, modified and redistributed freely as long as they are not sold by themselves. The fonts, including any derivative works, can be bundled, embedded, redistributed and/or sold with any software provided that any reserved names are not used by derivative works. The fonts and derivatives, however, cannot be released under any other type of license. The requirement for fonts to remain under this license does not apply to any document created using the fonts or their derivatives. DEFINITIONS "Font Software" refers to the set of files released by the Copyright Holder(s) under this license and clearly marked as such. This may include source files, build scripts and documentation. "Reserved Font Name" refers to any names specified as such after the copyright statement(s). "Original Version" refers to the collection of Font Software components as distributed by the Copyright Holder(s). "Modified Version" refers to any derivative made by adding to, deleting, or substituting -- in part or in whole -- any of the components of the Original Version, by changing formats or by porting the Font Software to a new environment. "Author" refers to any designer, engineer, programmer, technical writer or other person who contributed to the Font Software. PERMISSION & CONDITIONS Permission is hereby granted, free of charge, to any person obtaining a copy of the Font Software, to use, study, copy, merge, embed, modify, redistribute, and sell modified and unmodified copies of the Font Software, subject to the following conditions: 1) Neither the Font Software nor any of its individual components, in Original or Modified Versions, may be sold by itself. 2) Original or Modified Versions of the Font Software may be bundled, redistributed and/or sold with any software, provided that each copy contains the above copyright notice and this license. These can be included either as stand-alone text files, human-readable headers or in the appropriate machine-readable metadata fields within text or binary files as long as those fields can be easily viewed by the user. 3) No Modified Version of the Font Software may use the Reserved Font Name(s) unless explicit written permission is granted by the corresponding Copyright Holder. This restriction only applies to the primary font name as presented to the users. 4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font Software shall not be used to promote, endorse or advertise any Modified Version, except to acknowledge the contribution(s) of the Copyright Holder(s) and the Author(s) or with their explicit written permission. 5) The Font Software, modified or unmodified, in part or in whole, must be distributed entirely under this license, and must not be distributed under any other license. The requirement for fonts to remain under this license does not apply to any document created using the Font Software. TERMINATION This license becomes null and void if any of the above conditions are not met. DISCLAIMER THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.

File no 129: /colame/Assets/TextMesh Pro/Examples & Extras/Fonts/Oswald-Bold - OFL.txt
Copyright (c) 2011-2012, Vernon Adams (vern@newtypography.co.uk), with Reserved Font Names 'Oswald' This Font Software is licensed under the SIL Open Font License, Version 1.1. This license is copied below, and is also available with a FAQ at: http://scripts.sil.org/OFL ----------------------------------------------------------- SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007 ----------------------------------------------------------- PREAMBLE The goals of the Open Font License (OFL) are to stimulate worldwide development of collaborative font projects, to support the font creation efforts of academic and linguistic communities, and to provide a free and open framework in which fonts may be shared and improved in partnership with others. The OFL allows the licensed fonts to be used, studied, modified and redistributed freely as long as they are not sold by themselves. The fonts, including any derivative works, can be bundled, embedded, redistributed and/or sold with any software provided that any reserved names are not used by derivative works. The fonts and derivatives, however, cannot be released under any other type of license. The requirement for fonts to remain under this license does not apply to any document created using the fonts or their derivatives. DEFINITIONS "Font Software" refers to the set of files released by the Copyright Holder(s) under this license and clearly marked as such. This may include source files, build scripts and documentation. "Reserved Font Name" refers to any names specified as such after the copyright statement(s). "Original Version" refers to the collection of Font Software components as distributed by the Copyright Holder(s). "Modified Version" refers to any derivative made by adding to, deleting, or substituting -- in part or in whole -- any of the components of the Original Version, by changing formats or by porting the Font Software to a new environment. "Author" refers to any designer, engineer, programmer, technical writer or other person who contributed to the Font Software. PERMISSION & CONDITIONS Permission is hereby granted, free of charge, to any person obtaining a copy of the Font Software, to use, study, copy, merge, embed, modify, redistribute, and sell modified and unmodified copies of the Font Software, subject to the following conditions: 1) Neither the Font Software nor any of its individual components, in Original or Modified Versions, may be sold by itself. 2) Original or Modified Versions of the Font Software may be bundled, redistributed and/or sold with any software, provided that each copy contains the above copyright notice and this license. These can be included either as stand-alone text files, human-readable headers or in the appropriate machine-readable metadata fields within text or binary files as long as those fields can be easily viewed by the user. 3) No Modified Version of the Font Software may use the Reserved Font Name(s) unless explicit written permission is granted by the corresponding Copyright Holder. This restriction only applies to the primary font name as presented to the users. 4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font Software shall not be used to promote, endorse or advertise any Modified Version, except to acknowledge the contribution(s) of the Copyright Holder(s) and the Author(s) or with their explicit written permission. 5) The Font Software, modified or unmodified, in part or in whole, must be distributed entirely under this license, and must not be distributed under any other license. The requirement for fonts to remain under this license does not apply to any document created using the Font Software. TERMINATION This license becomes null and void if any of the above conditions are not met. DISCLAIMER THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.

File no 130: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/Benchmark01.cs
using UnityEngine; using System.Collections; namespace TMPro.Examples { public class Benchmark01 : MonoBehaviour { public int BenchmarkType = 0; public TMP_FontAsset TMProFont; public Font TextMeshFont; private TextMeshPro m_textMeshPro; private TextContainer m_textContainer; private TextMesh m_textMesh; private const string label01 = "The <#0050FF>count is: </color>{0}"; private const string label02 = "The <color=#0050FF>count is: </color>"; //private string m_string; //private int m_frame; private Material m_material01; private Material m_material02; IEnumerator Start() { if (BenchmarkType == 0) // TextMesh Pro Component { m_textMeshPro = gameObject.AddComponent<TextMeshPro>(); m_textMeshPro.autoSizeTextContainer = true; //m_textMeshPro.anchorDampening = true; if (TMProFont != null) m_textMeshPro.font = TMProFont; //m_textMeshPro.font = Resources.Load("Fonts & Materials/Anton SDF", typeof(TextMeshProFont)) as TextMeshProFont; // Make sure the Anton SDF exists before calling this... //m_textMeshPro.fontSharedMaterial = Resources.Load("Fonts & Materials/Anton SDF", typeof(Material)) as Material; // Same as above make sure this material exists. m_textMeshPro.fontSize = 48; m_textMeshPro.alignment = TextAlignmentOptions.Center; //m_textMeshPro.anchor = AnchorPositions.Center; m_textMeshPro.extraPadding = true; //m_textMeshPro.outlineWidth = 0.25f; //m_textMeshPro.fontSharedMaterial.SetFloat("_OutlineWidth", 0.2f); //m_textMeshPro.fontSharedMaterial.EnableKeyword("UNDERLAY_ON"); //m_textMeshPro.lineJustification = LineJustificationTypes.Center; m_textMeshPro.enableWordWrapping = false; //m_textMeshPro.lineLength = 60; //m_textMeshPro.characterSpacing = 0.2f; //m_textMeshPro.fontColor = new Color32(255, 255, 255, 255); m_material01 = m_textMeshPro.font.material; m_material02 = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - Drop Shadow"); // Make sure the LiberationSans SDF exists before calling this... } else if (BenchmarkType == 1) // TextMesh { m_textMesh = gameObject.AddComponent<TextMesh>(); if (TextMeshFont != null) { m_textMesh.font = TextMeshFont; m_textMesh.GetComponent<Renderer>().sharedMaterial = m_textMesh.font.material; } else { m_textMesh.font = Resources.Load("Fonts/ARIAL", typeof(Font)) as Font; m_textMesh.GetComponent<Renderer>().sharedMaterial = m_textMesh.font.material; } m_textMesh.fontSize = 48; m_textMesh.anchor = TextAnchor.MiddleCenter; //m_textMesh.color = new Color32(255, 255, 0, 255); } for (int i = 0; i <= 1000000; i++) { if (BenchmarkType == 0) { m_textMeshPro.SetText(label01, i % 1000); if (i % 1000 == 999) m_textMeshPro.fontSharedMaterial = m_textMeshPro.fontSharedMaterial == m_material01 ? m_textMeshPro.fontSharedMaterial = m_material02 : m_textMeshPro.fontSharedMaterial = m_material01; } else if (BenchmarkType == 1) m_textMesh.text = label02 + (i % 1000).ToString(); yield return null; } yield return null; } /* void Update() { if (BenchmarkType == 0) { m_textMeshPro.text = (m_frame % 1000).ToString(); } else if (BenchmarkType == 1) { m_textMesh.text = (m_frame % 1000).ToString(); } m_frame += 1; } */ } }

File no 131: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/Benchmark01_UGUI.cs
using UnityEngine; using System.Collections; using UnityEngine.UI; namespace TMPro.Examples { public class Benchmark01_UGUI : MonoBehaviour { public int BenchmarkType = 0; public Canvas canvas; public TMP_FontAsset TMProFont; public Font TextMeshFont; private TextMeshProUGUI m_textMeshPro; //private TextContainer m_textContainer; private Text m_textMesh; private const string label01 = "The <#0050FF>count is: </color>"; private const string label02 = "The <color=#0050FF>count is: </color>"; //private const string label01 = "TextMesh <#0050FF>Pro!</color> The count is: {0}"; //private const string label02 = "Text Mesh<color=#0050FF> The count is: </color>"; //private string m_string; //private int m_frame; private Material m_material01; private Material m_material02; IEnumerator Start() { if (BenchmarkType == 0) // TextMesh Pro Component { m_textMeshPro = gameObject.AddComponent<TextMeshProUGUI>(); //m_textContainer = GetComponent<TextContainer>(); //m_textMeshPro.anchorDampening = true; if (TMProFont != null) m_textMeshPro.font = TMProFont; //m_textMeshPro.font = Resources.Load("Fonts & Materials/Anton SDF", typeof(TextMeshProFont)) as TextMeshProFont; // Make sure the Anton SDF exists before calling this... //m_textMeshPro.fontSharedMaterial = Resources.Load("Fonts & Materials/Anton SDF", typeof(Material)) as Material; // Same as above make sure this material exists. m_textMeshPro.fontSize = 48; m_textMeshPro.alignment = TextAlignmentOptions.Center; //m_textMeshPro.anchor = AnchorPositions.Center; m_textMeshPro.extraPadding = true; //m_textMeshPro.outlineWidth = 0.25f; //m_textMeshPro.fontSharedMaterial.SetFloat("_OutlineWidth", 0.2f); //m_textMeshPro.fontSharedMaterial.EnableKeyword("UNDERLAY_ON"); //m_textMeshPro.lineJustification = LineJustificationTypes.Center; //m_textMeshPro.enableWordWrapping = true; //m_textMeshPro.lineLength = 60; //m_textMeshPro.characterSpacing = 0.2f; //m_textMeshPro.fontColor = new Color32(255, 255, 255, 255); m_material01 = m_textMeshPro.font.material; m_material02 = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - BEVEL"); // Make sure the LiberationSans SDF exists before calling this... } else if (BenchmarkType == 1) // TextMesh { m_textMesh = gameObject.AddComponent<Text>(); if (TextMeshFont != null) { m_textMesh.font = TextMeshFont; //m_textMesh.renderer.sharedMaterial = m_textMesh.font.material; } else { //m_textMesh.font = Resources.Load("Fonts/ARIAL", typeof(Font)) as Font; //m_textMesh.renderer.sharedMaterial = m_textMesh.font.material; } m_textMesh.fontSize = 48; m_textMesh.alignment = TextAnchor.MiddleCenter; //m_textMesh.color = new Color32(255, 255, 0, 255); } for (int i = 0; i <= 1000000; i++) { if (BenchmarkType == 0) { m_textMeshPro.text = label01 + (i % 1000); if (i % 1000 == 999) m_textMeshPro.fontSharedMaterial = m_textMeshPro.fontSharedMaterial == m_material01 ? m_textMeshPro.fontSharedMaterial = m_material02 : m_textMeshPro.fontSharedMaterial = m_material01; } else if (BenchmarkType == 1) m_textMesh.text = label02 + (i % 1000).ToString(); yield return null; } yield return null; } /* void Update() { if (BenchmarkType == 0) { m_textMeshPro.text = (m_frame % 1000).ToString(); } else if (BenchmarkType == 1) { m_textMesh.text = (m_frame % 1000).ToString(); } m_frame += 1; } */ } }

File no 132: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/Benchmark02.cs
using UnityEngine; using System.Collections; namespace TMPro.Examples { public class Benchmark02 : MonoBehaviour { public int SpawnType = 0; public int NumberOfNPC = 12; private TextMeshProFloatingText floatingText_Script; void Start() { for (int i = 0; i < NumberOfNPC; i++) { if (SpawnType == 0) { // TextMesh Pro Implementation GameObject go = new GameObject(); go.transform.position = new Vector3(Random.Range(-95f, 95f), 0.25f, Random.Range(-95f, 95f)); TextMeshPro textMeshPro = go.AddComponent<TextMeshPro>(); textMeshPro.autoSizeTextContainer = true; textMeshPro.rectTransform.pivot = new Vector2(0.5f, 0); textMeshPro.alignment = TextAlignmentOptions.Bottom; textMeshPro.fontSize = 96; textMeshPro.enableKerning = false; textMeshPro.color = new Color32(255, 255, 0, 255); textMeshPro.text = "!"; // Spawn Floating Text floatingText_Script = go.AddComponent<TextMeshProFloatingText>(); floatingText_Script.SpawnType = 0; } else if (SpawnType == 1) { // TextMesh Implementation GameObject go = new GameObject(); go.transform.position = new Vector3(Random.Range(-95f, 95f), 0.25f, Random.Range(-95f, 95f)); TextMesh textMesh = go.AddComponent<TextMesh>(); textMesh.font = Resources.Load<Font>("Fonts/ARIAL"); textMesh.GetComponent<Renderer>().sharedMaterial = textMesh.font.material; textMesh.anchor = TextAnchor.LowerCenter; textMesh.fontSize = 96; textMesh.color = new Color32(255, 255, 0, 255); textMesh.text = "!"; // Spawn Floating Text floatingText_Script = go.AddComponent<TextMeshProFloatingText>(); floatingText_Script.SpawnType = 1; } else if (SpawnType == 2) { // Canvas WorldSpace Camera GameObject go = new GameObject(); Canvas canvas = go.AddComponent<Canvas>(); canvas.worldCamera = Camera.main; go.transform.localScale = new Vector3(0.1f, 0.1f, 0.1f); go.transform.position = new Vector3(Random.Range(-95f, 95f), 5f, Random.Range(-95f, 95f)); TextMeshProUGUI textObject = new GameObject().AddComponent<TextMeshProUGUI>(); textObject.rectTransform.SetParent(go.transform, false); textObject.color = new Color32(255, 255, 0, 255); textObject.alignment = TextAlignmentOptions.Bottom; textObject.fontSize = 96; textObject.text = "!"; // Spawn Floating Text floatingText_Script = go.AddComponent<TextMeshProFloatingText>(); floatingText_Script.SpawnType = 0; } } } } }

File no 133: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/Benchmark03.cs
using UnityEngine; using System.Collections; namespace TMPro.Examples { public class Benchmark03 : MonoBehaviour { public int SpawnType = 0; public int NumberOfNPC = 12; public Font TheFont; //private TextMeshProFloatingText floatingText_Script; void Awake() { } void Start() { for (int i = 0; i < NumberOfNPC; i++) { if (SpawnType == 0) { // TextMesh Pro Implementation //go.transform.localScale = new Vector3(2, 2, 2); GameObject go = new GameObject(); //"NPC " + i); //go.transform.position = new Vector3(Random.Range(-95f, 95f), 0.5f, Random.Range(-95f, 95f)); go.transform.position = new Vector3(0, 0, 0); //go.renderer.castShadows = false; //go.renderer.receiveShadows = false; //go.transform.rotation = Quaternion.Euler(0, Random.Range(0, 360), 0); TextMeshPro textMeshPro = go.AddComponent<TextMeshPro>(); //textMeshPro.FontAsset = Resources.Load("Fonts & Materials/LiberationSans SDF", typeof(TextMeshProFont)) as TextMeshProFont; textMeshPro.alignment = TextAlignmentOptions.Center; textMeshPro.fontSize = 96; textMeshPro.text = "@"; textMeshPro.color = new Color32(255, 255, 0, 255); //textMeshPro.Text = "!"; // Spawn Floating Text //floatingText_Script = go.AddComponent<TextMeshProFloatingText>(); //floatingText_Script.SpawnType = 0; } else { // TextMesh Implementation GameObject go = new GameObject(); //"NPC " + i); //go.transform.position = new Vector3(Random.Range(-95f, 95f), 0.5f, Random.Range(-95f, 95f)); go.transform.position = new Vector3(0, 0, 0); TextMesh textMesh = go.AddComponent<TextMesh>(); textMesh.GetComponent<Renderer>().sharedMaterial = TheFont.material; textMesh.font = TheFont; textMesh.anchor = TextAnchor.MiddleCenter; textMesh.fontSize = 96; textMesh.color = new Color32(255, 255, 0, 255); textMesh.text = "@"; // Spawn Floating Text //floatingText_Script = go.AddComponent<TextMeshProFloatingText>(); //floatingText_Script.SpawnType = 1; } } } } }

File no 134: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/Benchmark04.cs
using UnityEngine; using System.Collections; namespace TMPro.Examples { public class Benchmark04 : MonoBehaviour { public int SpawnType = 0; public int MinPointSize = 12; public int MaxPointSize = 64; public int Steps = 4; private Transform m_Transform; //private TextMeshProFloatingText floatingText_Script; //public Material material; void Start() { m_Transform = transform; float lineHeight = 0; float orthoSize = Camera.main.orthographicSize = Screen.height / 2; float ratio = (float)Screen.width / Screen.height; for (int i = MinPointSize; i <= MaxPointSize; i += Steps) { if (SpawnType == 0) { // TextMesh Pro Implementation GameObject go = new GameObject("Text - " + i + " Pts"); if (lineHeight > orthoSize * 2) return; go.transform.position = m_Transform.position + new Vector3(ratio * -orthoSize * 0.975f, orthoSize * 0.975f - lineHeight, 0); TextMeshPro textMeshPro = go.AddComponent<TextMeshPro>(); //textMeshPro.fontSharedMaterial = material; //textMeshPro.font = Resources.Load("Fonts & Materials/LiberationSans SDF", typeof(TextMeshProFont)) as TextMeshProFont; //textMeshPro.anchor = AnchorPositions.Left; textMeshPro.rectTransform.pivot = new Vector2(0, 0.5f); textMeshPro.enableWordWrapping = false; textMeshPro.extraPadding = true; textMeshPro.isOrthographic = true; textMeshPro.fontSize = i; textMeshPro.text = i + " pts - Lorem ipsum dolor sit..."; textMeshPro.color = new Color32(255, 255, 255, 255); lineHeight += i; } else { // TextMesh Implementation // Causes crashes since atlas needed exceeds 4096 X 4096 /* GameObject go = new GameObject("Arial " + i); //if (lineHeight > orthoSize * 2 * 0.9f) return; go.transform.position = m_Transform.position + new Vector3(ratio * -orthoSize * 0.975f, orthoSize * 0.975f - lineHeight, 1); TextMesh textMesh = go.AddComponent<TextMesh>(); textMesh.font = Resources.Load("Fonts/ARIAL", typeof(Font)) as Font; textMesh.renderer.sharedMaterial = textMesh.font.material; textMesh.anchor = TextAnchor.MiddleLeft; textMesh.fontSize = i * 10; textMesh.color = new Color32(255, 255, 255, 255); textMesh.text = i + " pts - Lorem ipsum dolor sit..."; lineHeight += i; */ } } } } }

File no 135: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/CameraController.cs
using UnityEngine; using System.Collections; namespace TMPro.Examples { public class CameraController : MonoBehaviour { public enum CameraModes { Follow, Isometric, Free } private Transform cameraTransform; private Transform dummyTarget; public Transform CameraTarget; public float FollowDistance = 30.0f; public float MaxFollowDistance = 100.0f; public float MinFollowDistance = 2.0f; public float ElevationAngle = 30.0f; public float MaxElevationAngle = 85.0f; public float MinElevationAngle = 0f; public float OrbitalAngle = 0f; public CameraModes CameraMode = CameraModes.Follow; public bool MovementSmoothing = true; public bool RotationSmoothing = false; private bool previousSmoothing; public float MovementSmoothingValue = 25f; public float RotationSmoothingValue = 5.0f; public float MoveSensitivity = 2.0f; private Vector3 currentVelocity = Vector3.zero; private Vector3 desiredPosition; private float mouseX; private float mouseY; private Vector3 moveVector; private float mouseWheel; // Controls for Touches on Mobile devices //private float prev_ZoomDelta; private const string event_SmoothingValue = "Slider - Smoothing Value"; private const string event_FollowDistance = "Slider - Camera Zoom"; void Awake() { if (QualitySettings.vSyncCount > 0) Application.targetFrameRate = 60; else Application.targetFrameRate = -1; if (Application.platform == RuntimePlatform.IPhonePlayer || Application.platform == RuntimePlatform.Android) Input.simulateMouseWithTouches = false; cameraTransform = transform; previousSmoothing = MovementSmoothing; } // Use this for initialization void Start() { if (CameraTarget == null) { // If we don't have a target (assigned by the player, create a dummy in the center of the scene). dummyTarget = new GameObject("Camera Target").transform; CameraTarget = dummyTarget; } } // Update is called once per frame void LateUpdate() { GetPlayerInput(); // Check if we still have a valid target if (CameraTarget != null) { if (CameraMode == CameraModes.Isometric) { desiredPosition = CameraTarget.position + Quaternion.Euler(ElevationAngle, OrbitalAngle, 0f) * new Vector3(0, 0, -FollowDistance); } else if (CameraMode == CameraModes.Follow) { desiredPosition = CameraTarget.position + CameraTarget.TransformDirection(Quaternion.Euler(ElevationAngle, OrbitalAngle, 0f) * (new Vector3(0, 0, -FollowDistance))); } else { // Free Camera implementation } if (MovementSmoothing == true) { // Using Smoothing cameraTransform.position = Vector3.SmoothDamp(cameraTransform.position, desiredPosition, ref currentVelocity, MovementSmoothingValue * Time.fixedDeltaTime); //cameraTransform.position = Vector3.Lerp(cameraTransform.position, desiredPosition, Time.deltaTime * 5.0f); } else { // Not using Smoothing cameraTransform.position = desiredPosition; } if (RotationSmoothing == true) cameraTransform.rotation = Quaternion.Lerp(cameraTransform.rotation, Quaternion.LookRotation(CameraTarget.position - cameraTransform.position), RotationSmoothingValue * Time.deltaTime); else { cameraTransform.LookAt(CameraTarget); } } } void GetPlayerInput() { moveVector = Vector3.zero; // Check Mouse Wheel Input prior to Shift Key so we can apply multiplier on Shift for Scrolling mouseWheel = Input.GetAxis("Mouse ScrollWheel"); float touchCount = Input.touchCount; if (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift) || touchCount > 0) { mouseWheel *= 10; if (Input.GetKeyDown(KeyCode.I)) CameraMode = CameraModes.Isometric; if (Input.GetKeyDown(KeyCode.F)) CameraMode = CameraModes.Follow; if (Input.GetKeyDown(KeyCode.S)) MovementSmoothing = !MovementSmoothing; // Check for right mouse button to change camera follow and elevation angle if (Input.GetMouseButton(1)) { mouseY = Input.GetAxis("Mouse Y"); mouseX = Input.GetAxis("Mouse X"); if (mouseY > 0.01f || mouseY < -0.01f) { ElevationAngle -= mouseY * MoveSensitivity; // Limit Elevation angle between min & max values. ElevationAngle = Mathf.Clamp(ElevationAngle, MinElevationAngle, MaxElevationAngle); } if (mouseX > 0.01f || mouseX < -0.01f) { OrbitalAngle += mouseX * MoveSensitivity; if (OrbitalAngle > 360) OrbitalAngle -= 360; if (OrbitalAngle < 0) OrbitalAngle += 360; } } // Get Input from Mobile Device if (touchCount == 1 && Input.GetTouch(0).phase == TouchPhase.Moved) { Vector2 deltaPosition = Input.GetTouch(0).deltaPosition; // Handle elevation changes if (deltaPosition.y > 0.01f || deltaPosition.y < -0.01f) { ElevationAngle -= deltaPosition.y * 0.1f; // Limit Elevation angle between min & max values. ElevationAngle = Mathf.Clamp(ElevationAngle, MinElevationAngle, MaxElevationAngle); } // Handle left & right if (deltaPosition.x > 0.01f || deltaPosition.x < -0.01f) { OrbitalAngle += deltaPosition.x * 0.1f; if (OrbitalAngle > 360) OrbitalAngle -= 360; if (OrbitalAngle < 0) OrbitalAngle += 360; } } // Check for left mouse button to select a new CameraTarget or to reset Follow position if (Input.GetMouseButton(0)) { Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; if (Physics.Raycast(ray, out hit, 300, 1 << 10 | 1 << 11 | 1 << 12 | 1 << 14)) { if (hit.transform == CameraTarget) { // Reset Follow Position OrbitalAngle = 0; } else { CameraTarget = hit.transform; OrbitalAngle = 0; MovementSmoothing = previousSmoothing; } } } if (Input.GetMouseButton(2)) { if (dummyTarget == null) { // We need a Dummy Target to anchor the Camera dummyTarget = new GameObject("Camera Target").transform; dummyTarget.position = CameraTarget.position; dummyTarget.rotation = CameraTarget.rotation; CameraTarget = dummyTarget; previousSmoothing = MovementSmoothing; MovementSmoothing = false; } else if (dummyTarget != CameraTarget) { // Move DummyTarget to CameraTarget dummyTarget.position = CameraTarget.position; dummyTarget.rotation = CameraTarget.rotation; CameraTarget = dummyTarget; previousSmoothing = MovementSmoothing; MovementSmoothing = false; } mouseY = Input.GetAxis("Mouse Y"); mouseX = Input.GetAxis("Mouse X"); moveVector = cameraTransform.TransformDirection(mouseX, mouseY, 0); dummyTarget.Translate(-moveVector, Space.World); } } // Check Pinching to Zoom in - out on Mobile device if (touchCount == 2) { Touch touch0 = Input.GetTouch(0); Touch touch1 = Input.GetTouch(1); Vector2 touch0PrevPos = touch0.position - touch0.deltaPosition; Vector2 touch1PrevPos = touch1.position - touch1.deltaPosition; float prevTouchDelta = (touch0PrevPos - touch1PrevPos).magnitude; float touchDelta = (touch0.position - touch1.position).magnitude; float zoomDelta = prevTouchDelta - touchDelta; if (zoomDelta > 0.01f || zoomDelta < -0.01f) { FollowDistance += zoomDelta * 0.25f; // Limit FollowDistance between min & max values. FollowDistance = Mathf.Clamp(FollowDistance, MinFollowDistance, MaxFollowDistance); } } // Check MouseWheel to Zoom in-out if (mouseWheel < -0.01f || mouseWheel > 0.01f) { FollowDistance -= mouseWheel * 5.0f; // Limit FollowDistance between min & max values. FollowDistance = Mathf.Clamp(FollowDistance, MinFollowDistance, MaxFollowDistance); } } } }

File no 136: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/ChatController.cs
﻿using UnityEngine; using UnityEngine.UI; using System.Collections; using TMPro; public class ChatController : MonoBehaviour { public TMP_InputField TMP_ChatInput; public TMP_Text TMP_ChatOutput; public Scrollbar ChatScrollbar; void OnEnable() { TMP_ChatInput.onSubmit.AddListener(AddToChatOutput); } void OnDisable() { TMP_ChatInput.onSubmit.RemoveListener(AddToChatOutput); } void AddToChatOutput(string newText) { // Clear Input Field TMP_ChatInput.text = string.Empty; var timeNow = System.DateTime.Now; TMP_ChatOutput.text += "[<#FFFF80>" + timeNow.Hour.ToString("d2") + ":" + timeNow.Minute.ToString("d2") + ":" + timeNow.Second.ToString("d2") + "</color>] " + newText + "\n"; TMP_ChatInput.ActivateInputField(); // Set the scrollbar to the bottom when next text is submitted. ChatScrollbar.value = 0; } }

File no 137: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/EnvMapAnimator.cs
﻿using UnityEngine; using System.Collections; using TMPro; public class EnvMapAnimator : MonoBehaviour { //private Vector3 TranslationSpeeds; public Vector3 RotationSpeeds; private TMP_Text m_textMeshPro; private Material m_material; void Awake() { //Debug.Log("Awake() on Script called."); m_textMeshPro = GetComponent<TMP_Text>(); m_material = m_textMeshPro.fontSharedMaterial; } // Use this for initialization IEnumerator Start () { Matrix4x4 matrix = new Matrix4x4(); while (true) { //matrix.SetTRS(new Vector3 (Time.time * TranslationSpeeds.x, Time.time * TranslationSpeeds.y, Time.time * TranslationSpeeds.z), Quaternion.Euler(Time.time * RotationSpeeds.x, Time.time * RotationSpeeds.y , Time.time * RotationSpeeds.z), Vector3.one); matrix.SetTRS(Vector3.zero, Quaternion.Euler(Time.time * RotationSpeeds.x, Time.time * RotationSpeeds.y , Time.time * RotationSpeeds.z), Vector3.one); m_material.SetMatrix("_EnvMatrix", matrix); yield return null; } } }

File no 138: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/ObjectSpin.cs
﻿using UnityEngine; using System.Collections; namespace TMPro.Examples { public class ObjectSpin : MonoBehaviour { #pragma warning disable 0414 public float SpinSpeed = 5; public int RotationRange = 15; private Transform m_transform; private float m_time; private Vector3 m_prevPOS; private Vector3 m_initial_Rotation; private Vector3 m_initial_Position; private Color32 m_lightColor; private int frames = 0; public enum MotionType { Rotation, BackAndForth, Translation }; public MotionType Motion; void Awake() { m_transform = transform; m_initial_Rotation = m_transform.rotation.eulerAngles; m_initial_Position = m_transform.position; Light light = GetComponent<Light>(); m_lightColor = light != null ? light.color : Color.black; } // Update is called once per frame void Update() { if (Motion == MotionType.Rotation) { m_transform.Rotate(0, SpinSpeed * Time.deltaTime, 0); } else if (Motion == MotionType.BackAndForth) { m_time += SpinSpeed * Time.deltaTime; m_transform.rotation = Quaternion.Euler(m_initial_Rotation.x, Mathf.Sin(m_time) * RotationRange + m_initial_Rotation.y, m_initial_Rotation.z); } else { m_time += SpinSpeed * Time.deltaTime; float x = 15 * Mathf.Cos(m_time * .95f); float y = 10; // *Mathf.Sin(m_time * 1f) * Mathf.Cos(m_time * 1f); float z = 0f; // *Mathf.Sin(m_time * .9f); m_transform.position = m_initial_Position + new Vector3(x, z, y); // Drawing light patterns because they can be cool looking. //if (frames > 2) // Debug.DrawLine(m_transform.position, m_prevPOS, m_lightColor, 100f); m_prevPOS = m_transform.position; frames += 1; } } } }

File no 139: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/ShaderPropAnimator.cs
﻿using UnityEngine; using System.Collections; namespace TMPro.Examples { public class ShaderPropAnimator : MonoBehaviour { private Renderer m_Renderer; private Material m_Material; public AnimationCurve GlowCurve; public float m_frame; void Awake() { // Cache a reference to object's renderer m_Renderer = GetComponent<Renderer>(); // Cache a reference to object's material and create an instance by doing so. m_Material = m_Renderer.material; } void Start() { StartCoroutine(AnimateProperties()); } IEnumerator AnimateProperties() { //float lightAngle; float glowPower; m_frame = Random.Range(0f, 1f); while (true) { //lightAngle = (m_Material.GetFloat(ShaderPropertyIDs.ID_LightAngle) + Time.deltaTime) % 6.2831853f; //m_Material.SetFloat(ShaderPropertyIDs.ID_LightAngle, lightAngle); glowPower = GlowCurve.Evaluate(m_frame); m_Material.SetFloat(ShaderUtilities.ID_GlowPower, glowPower); m_frame += Time.deltaTime * Random.Range(0.2f, 0.3f); yield return new WaitForEndOfFrame(); } } } }

File no 140: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/SimpleScript.cs
using UnityEngine; using System.Collections; namespace TMPro.Examples { public class SimpleScript : MonoBehaviour { private TextMeshPro m_textMeshPro; //private TMP_FontAsset m_FontAsset; private const string label = "The <#0050FF>count is: </color>{0:2}"; private float m_frame; void Start() { // Add new TextMesh Pro Component m_textMeshPro = gameObject.AddComponent<TextMeshPro>(); m_textMeshPro.autoSizeTextContainer = true; // Load the Font Asset to be used. //m_FontAsset = Resources.Load("Fonts & Materials/LiberationSans SDF", typeof(TMP_FontAsset)) as TMP_FontAsset; //m_textMeshPro.font = m_FontAsset; // Assign Material to TextMesh Pro Component //m_textMeshPro.fontSharedMaterial = Resources.Load("Fonts & Materials/LiberationSans SDF - Bevel", typeof(Material)) as Material; //m_textMeshPro.fontSharedMaterial.EnableKeyword("BEVEL_ON"); // Set various font settings. m_textMeshPro.fontSize = 48; m_textMeshPro.alignment = TextAlignmentOptions.Center; //m_textMeshPro.anchorDampening = true; // Has been deprecated but under consideration for re-implementation. //m_textMeshPro.enableAutoSizing = true; //m_textMeshPro.characterSpacing = 0.2f; //m_textMeshPro.wordSpacing = 0.1f; //m_textMeshPro.enableCulling = true; m_textMeshPro.enableWordWrapping = false; //textMeshPro.fontColor = new Color32(255, 255, 255, 255); } void Update() { m_textMeshPro.SetText(label, m_frame % 1000); m_frame += 1 * Time.deltaTime; } } }

File no 141: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/SkewTextExample.cs
﻿using UnityEngine; using System.Collections; namespace TMPro.Examples { public class SkewTextExample : MonoBehaviour { private TMP_Text m_TextComponent; public AnimationCurve VertexCurve = new AnimationCurve(new Keyframe(0, 0), new Keyframe(0.25f, 2.0f), new Keyframe(0.5f, 0), new Keyframe(0.75f, 2.0f), new Keyframe(1, 0f)); //public float AngleMultiplier = 1.0f; //public float SpeedMultiplier = 1.0f; public float CurveScale = 1.0f; public float ShearAmount = 1.0f; void Awake() { m_TextComponent = gameObject.GetComponent<TMP_Text>(); } void Start() { StartCoroutine(WarpText()); } private AnimationCurve CopyAnimationCurve(AnimationCurve curve) { AnimationCurve newCurve = new AnimationCurve(); newCurve.keys = curve.keys; return newCurve; } /// <summary> /// Method to curve text along a Unity animation curve. /// </summary> /// <param name="textComponent"></param> /// <returns></returns> IEnumerator WarpText() { VertexCurve.preWrapMode = WrapMode.Clamp; VertexCurve.postWrapMode = WrapMode.Clamp; //Mesh mesh = m_TextComponent.textInfo.meshInfo[0].mesh; Vector3[] vertices; Matrix4x4 matrix; m_TextComponent.havePropertiesChanged = true; // Need to force the TextMeshPro Object to be updated. CurveScale *= 10; float old_CurveScale = CurveScale; float old_ShearValue = ShearAmount; AnimationCurve old_curve = CopyAnimationCurve(VertexCurve); while (true) { if (!m_TextComponent.havePropertiesChanged && old_CurveScale == CurveScale && old_curve.keys[1].value == VertexCurve.keys[1].value && old_ShearValue == ShearAmount) { yield return null; continue; } old_CurveScale = CurveScale; old_curve = CopyAnimationCurve(VertexCurve); old_ShearValue = ShearAmount; m_TextComponent.ForceMeshUpdate(); // Generate the mesh and populate the textInfo with data we can use and manipulate. TMP_TextInfo textInfo = m_TextComponent.textInfo; int characterCount = textInfo.characterCount; if (characterCount == 0) continue; //vertices = textInfo.meshInfo[0].vertices; //int lastVertexIndex = textInfo.characterInfo[characterCount - 1].vertexIndex; float boundsMinX = m_TextComponent.bounds.min.x; //textInfo.meshInfo[0].mesh.bounds.min.x; float boundsMaxX = m_TextComponent.bounds.max.x; //textInfo.meshInfo[0].mesh.bounds.max.x; for (int i = 0; i < characterCount; i++) { if (!textInfo.characterInfo[i].isVisible) continue; int vertexIndex = textInfo.characterInfo[i].vertexIndex; // Get the index of the mesh used by this character. int materialIndex = textInfo.characterInfo[i].materialReferenceIndex; vertices = textInfo.meshInfo[materialIndex].vertices; // Compute the baseline mid point for each character Vector3 offsetToMidBaseline = new Vector2((vertices[vertexIndex + 0].x + vertices[vertexIndex + 2].x) / 2, textInfo.characterInfo[i].baseLine); //float offsetY = VertexCurve.Evaluate((float)i / characterCount + loopCount / 50f); // Random.Range(-0.25f, 0.25f); // Apply offset to adjust our pivot point. vertices[vertexIndex + 0] += -offsetToMidBaseline; vertices[vertexIndex + 1] += -offsetToMidBaseline; vertices[vertexIndex + 2] += -offsetToMidBaseline; vertices[vertexIndex + 3] += -offsetToMidBaseline; // Apply the Shearing FX float shear_value = ShearAmount * 0.01f; Vector3 topShear = new Vector3(shear_value * (textInfo.characterInfo[i].topRight.y - textInfo.characterInfo[i].baseLine), 0, 0); Vector3 bottomShear = new Vector3(shear_value * (textInfo.characterInfo[i].baseLine - textInfo.characterInfo[i].bottomRight.y), 0, 0); vertices[vertexIndex + 0] += -bottomShear; vertices[vertexIndex + 1] += topShear; vertices[vertexIndex + 2] += topShear; vertices[vertexIndex + 3] += -bottomShear; // Compute the angle of rotation for each character based on the animation curve float x0 = (offsetToMidBaseline.x - boundsMinX) / (boundsMaxX - boundsMinX); // Character's position relative to the bounds of the mesh. float x1 = x0 + 0.0001f; float y0 = VertexCurve.Evaluate(x0) * CurveScale; float y1 = VertexCurve.Evaluate(x1) * CurveScale; Vector3 horizontal = new Vector3(1, 0, 0); //Vector3 normal = new Vector3(-(y1 - y0), (x1 * (boundsMaxX - boundsMinX) + boundsMinX) - offsetToMidBaseline.x, 0); Vector3 tangent = new Vector3(x1 * (boundsMaxX - boundsMinX) + boundsMinX, y1) - new Vector3(offsetToMidBaseline.x, y0); float dot = Mathf.Acos(Vector3.Dot(horizontal, tangent.normalized)) * 57.2957795f; Vector3 cross = Vector3.Cross(horizontal, tangent); float angle = cross.z > 0 ? dot : 360 - dot; matrix = Matrix4x4.TRS(new Vector3(0, y0, 0), Quaternion.Euler(0, 0, angle), Vector3.one); vertices[vertexIndex + 0] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 0]); vertices[vertexIndex + 1] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 1]); vertices[vertexIndex + 2] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 2]); vertices[vertexIndex + 3] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 3]); vertices[vertexIndex + 0] += offsetToMidBaseline; vertices[vertexIndex + 1] += offsetToMidBaseline; vertices[vertexIndex + 2] += offsetToMidBaseline; vertices[vertexIndex + 3] += offsetToMidBaseline; } // Upload the mesh with the revised information m_TextComponent.UpdateVertexData(); yield return null; // new WaitForSeconds(0.025f); } } } }

File no 142: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_DigitValidator.cs
﻿using UnityEngine; using System; namespace TMPro { /// <summary> /// EXample of a Custom Character Input Validator to only allow digits from 0 to 9. /// </summary> [Serializable] //[CreateAssetMenu(fileName = "InputValidator - Digits.asset", menuName = "TextMeshPro/Input Validators/Digits", order = 100)] public class TMP_DigitValidator : TMP_InputValidator { // Custom text input validation function public override char Validate(ref string text, ref int pos, char ch) { if (ch >= '0' && ch <= '9') { pos += 1; return ch; } return (char)0; } } }

File no 143: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_ExampleScript_01.cs
﻿using UnityEngine; using UnityEngine.UI; using System.Collections; using TMPro; namespace TMPro.Examples { public class TMP_ExampleScript_01 : MonoBehaviour { public enum objectType { TextMeshPro = 0, TextMeshProUGUI = 1 }; public objectType ObjectType; public bool isStatic; private TMP_Text m_text; //private TMP_InputField m_inputfield; private const string k_label = "The count is <#0080ff>{0}</color>"; private int count; void Awake() { // Get a reference to the TMP text component if one already exists otherwise add one. // This example show the convenience of having both TMP components derive from TMP_Text. if (ObjectType == 0) m_text = GetComponent<TextMeshPro>() ?? gameObject.AddComponent<TextMeshPro>(); else m_text = GetComponent<TextMeshProUGUI>() ?? gameObject.AddComponent<TextMeshProUGUI>(); // Load a new font asset and assign it to the text object. m_text.font = Resources.Load<TMP_FontAsset>("Fonts & Materials/Anton SDF"); // Load a new material preset which was created with the context menu duplicate. m_text.fontSharedMaterial = Resources.Load<Material>("Fonts & Materials/Anton SDF - Drop Shadow"); // Set the size of the font. m_text.fontSize = 120; // Set the text m_text.text = "A <#0080ff>simple</color> line of text."; // Get the preferred width and height based on the supplied width and height as opposed to the actual size of the current text container. Vector2 size = m_text.GetPreferredValues(Mathf.Infinity, Mathf.Infinity); // Set the size of the RectTransform based on the new calculated values. m_text.rectTransform.sizeDelta = new Vector2(size.x, size.y); } void Update() { if (!isStatic) { m_text.SetText(k_label, count % 1000); count += 1; } } } }

File no 144: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_FrameRateCounter.cs
﻿using UnityEngine; using System.Collections; namespace TMPro.Examples { public class TMP_FrameRateCounter : MonoBehaviour { public float UpdateInterval = 5.0f; private float m_LastInterval = 0; private int m_Frames = 0; public enum FpsCounterAnchorPositions { TopLeft, BottomLeft, TopRight, BottomRight }; public FpsCounterAnchorPositions AnchorPosition = FpsCounterAnchorPositions.TopRight; private string htmlColorTag; private const string fpsLabel = "{0:2}</color> <#8080ff>FPS \n<#FF8000>{1:2} <#8080ff>MS"; private TextMeshPro m_TextMeshPro; private Transform m_frameCounter_transform; private Camera m_camera; private FpsCounterAnchorPositions last_AnchorPosition; void Awake() { if (!enabled) return; m_camera = Camera.main; Application.targetFrameRate = -1; GameObject frameCounter = new GameObject("Frame Counter"); m_TextMeshPro = frameCounter.AddComponent<TextMeshPro>(); m_TextMeshPro.font = Resources.Load<TMP_FontAsset>("Fonts & Materials/LiberationSans SDF"); m_TextMeshPro.fontSharedMaterial = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - Overlay"); m_frameCounter_transform = frameCounter.transform; m_frameCounter_transform.SetParent(m_camera.transform); m_frameCounter_transform.localRotation = Quaternion.identity; m_TextMeshPro.enableWordWrapping = false; m_TextMeshPro.fontSize = 24; //m_TextMeshPro.FontColor = new Color32(255, 255, 255, 128); //m_TextMeshPro.edgeWidth = .15f; m_TextMeshPro.isOverlay = true; //m_TextMeshPro.FaceColor = new Color32(255, 128, 0, 0); //m_TextMeshPro.EdgeColor = new Color32(0, 255, 0, 255); //m_TextMeshPro.FontMaterial.renderQueue = 4000; //m_TextMeshPro.CreateSoftShadowClone(new Vector2(1f, -1f)); Set_FrameCounter_Position(AnchorPosition); last_AnchorPosition = AnchorPosition; } void Start() { m_LastInterval = Time.realtimeSinceStartup; m_Frames = 0; } void Update() { if (AnchorPosition != last_AnchorPosition) Set_FrameCounter_Position(AnchorPosition); last_AnchorPosition = AnchorPosition; m_Frames += 1; float timeNow = Time.realtimeSinceStartup; if (timeNow > m_LastInterval + UpdateInterval) { // display two fractional digits (f2 format) float fps = m_Frames / (timeNow - m_LastInterval); float ms = 1000.0f / Mathf.Max(fps, 0.00001f); if (fps < 30) htmlColorTag = "<color=yellow>"; else if (fps < 10) htmlColorTag = "<color=red>"; else htmlColorTag = "<color=green>"; //string format = System.String.Format(htmlColorTag + "{0:F2} </color>FPS \n{1:F2} <#8080ff>MS",fps, ms); //m_TextMeshPro.text = format; m_TextMeshPro.SetText(htmlColorTag + fpsLabel, fps, ms); m_Frames = 0; m_LastInterval = timeNow; } } void Set_FrameCounter_Position(FpsCounterAnchorPositions anchor_position) { //Debug.Log("Changing frame counter anchor position."); m_TextMeshPro.margin = new Vector4(1f, 1f, 1f, 1f); switch (anchor_position) { case FpsCounterAnchorPositions.TopLeft: m_TextMeshPro.alignment = TextAlignmentOptions.TopLeft; m_TextMeshPro.rectTransform.pivot = new Vector2(0, 1); m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(0, 1, 100.0f)); break; case FpsCounterAnchorPositions.BottomLeft: m_TextMeshPro.alignment = TextAlignmentOptions.BottomLeft; m_TextMeshPro.rectTransform.pivot = new Vector2(0, 0); m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(0, 0, 100.0f)); break; case FpsCounterAnchorPositions.TopRight: m_TextMeshPro.alignment = TextAlignmentOptions.TopRight; m_TextMeshPro.rectTransform.pivot = new Vector2(1, 1); m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(1, 1, 100.0f)); break; case FpsCounterAnchorPositions.BottomRight: m_TextMeshPro.alignment = TextAlignmentOptions.BottomRight; m_TextMeshPro.rectTransform.pivot = new Vector2(1, 0); m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(1, 0, 100.0f)); break; } } } }

File no 145: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_PhoneNumberValidator.cs
﻿using UnityEngine; using System.Collections; using System; namespace TMPro { /// <summary> /// Example of a Custom Character Input Validator to only allow phone number in the (800) 555-1212 format. /// </summary> [Serializable] //[CreateAssetMenu(fileName = "InputValidator - Phone Numbers.asset", menuName = "TextMeshPro/Input Validators/Phone Numbers")] public class TMP_PhoneNumberValidator : TMP_InputValidator { // Custom text input validation function public override char Validate(ref string text, ref int pos, char ch) { Debug.Log("Trying to validate..."); // Return unless the character is a valid digit if (ch < '0' && ch > '9') return (char)0; int length = text.Length; // Enforce Phone Number format for every character input. for (int i = 0; i < length + 1; i++) { switch (i) { case 0: if (i == length) text = "(" + ch; pos = 2; break; case 1: if (i == length) text += ch; pos = 2; break; case 2: if (i == length) text += ch; pos = 3; break; case 3: if (i == length) text += ch + ") "; pos = 6; break; case 4: if (i == length) text += ") " + ch; pos = 7; break; case 5: if (i == length) text += " " + ch; pos = 7; break; case 6: if (i == length) text += ch; pos = 7; break; case 7: if (i == length) text += ch; pos = 8; break; case 8: if (i == length) text += ch + "-"; pos = 10; break; case 9: if (i == length) text += "-" + ch; pos = 11; break; case 10: if (i == length) text += ch; pos = 11; break; case 11: if (i == length) text += ch; pos = 12; break; case 12: if (i == length) text += ch; pos = 13; break; case 13: if (i == length) text += ch; pos = 14; break; } } return ch; } } }

File no 146: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_TextEventCheck.cs
﻿using UnityEngine; namespace TMPro.Examples { public class TMP_TextEventCheck : MonoBehaviour { public TMP_TextEventHandler TextEventHandler; void OnEnable() { if (TextEventHandler != null) { TextEventHandler.onCharacterSelection.AddListener(OnCharacterSelection); TextEventHandler.onSpriteSelection.AddListener(OnSpriteSelection); TextEventHandler.onWordSelection.AddListener(OnWordSelection); TextEventHandler.onLineSelection.AddListener(OnLineSelection); TextEventHandler.onLinkSelection.AddListener(OnLinkSelection); } } void OnDisable() { if (TextEventHandler != null) { TextEventHandler.onCharacterSelection.RemoveListener(OnCharacterSelection); TextEventHandler.onSpriteSelection.RemoveListener(OnSpriteSelection); TextEventHandler.onWordSelection.RemoveListener(OnWordSelection); TextEventHandler.onLineSelection.RemoveListener(OnLineSelection); TextEventHandler.onLinkSelection.RemoveListener(OnLinkSelection); } } void OnCharacterSelection(char c, int index) { Debug.Log("Character [" + c + "] at Index: " + index + " has been selected."); } void OnSpriteSelection(char c, int index) { Debug.Log("Sprite [" + c + "] at Index: " + index + " has been selected."); } void OnWordSelection(string word, int firstCharacterIndex, int length) { Debug.Log("Word [" + word + "] with first character index of " + firstCharacterIndex + " and length of " + length + " has been selected."); } void OnLineSelection(string lineText, int firstCharacterIndex, int length) { Debug.Log("Line [" + lineText + "] with first character index of " + firstCharacterIndex + " and length of " + length + " has been selected."); } void OnLinkSelection(string linkID, string linkText, int linkIndex) { Debug.Log("Link Index: " + linkIndex + " with ID [" + linkID + "] and Text \"" + linkText + "\" has been selected."); } } }

File no 147: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_TextEventHandler.cs
﻿using UnityEngine; using UnityEngine.Events; using UnityEngine.EventSystems; using System; namespace TMPro { public class TMP_TextEventHandler : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler { [Serializable] public class CharacterSelectionEvent : UnityEvent<char, int> { } [Serializable] public class SpriteSelectionEvent : UnityEvent<char, int> { } [Serializable] public class WordSelectionEvent : UnityEvent<string, int, int> { } [Serializable] public class LineSelectionEvent : UnityEvent<string, int, int> { } [Serializable] public class LinkSelectionEvent : UnityEvent<string, string, int> { } /// <summary> /// Event delegate triggered when pointer is over a character. /// </summary> public CharacterSelectionEvent onCharacterSelection { get { return m_OnCharacterSelection; } set { m_OnCharacterSelection = value; } } [SerializeField] private CharacterSelectionEvent m_OnCharacterSelection = new CharacterSelectionEvent(); /// <summary> /// Event delegate triggered when pointer is over a sprite. /// </summary> public SpriteSelectionEvent onSpriteSelection { get { return m_OnSpriteSelection; } set { m_OnSpriteSelection = value; } } [SerializeField] private SpriteSelectionEvent m_OnSpriteSelection = new SpriteSelectionEvent(); /// <summary> /// Event delegate triggered when pointer is over a word. /// </summary> public WordSelectionEvent onWordSelection { get { return m_OnWordSelection; } set { m_OnWordSelection = value; } } [SerializeField] private WordSelectionEvent m_OnWordSelection = new WordSelectionEvent(); /// <summary> /// Event delegate triggered when pointer is over a line. /// </summary> public LineSelectionEvent onLineSelection { get { return m_OnLineSelection; } set { m_OnLineSelection = value; } } [SerializeField] private LineSelectionEvent m_OnLineSelection = new LineSelectionEvent(); /// <summary> /// Event delegate triggered when pointer is over a link. /// </summary> public LinkSelectionEvent onLinkSelection { get { return m_OnLinkSelection; } set { m_OnLinkSelection = value; } } [SerializeField] private LinkSelectionEvent m_OnLinkSelection = new LinkSelectionEvent(); private TMP_Text m_TextComponent; private Camera m_Camera; private Canvas m_Canvas; private int m_selectedLink = -1; private int m_lastCharIndex = -1; private int m_lastWordIndex = -1; private int m_lastLineIndex = -1; void Awake() { // Get a reference to the text component. m_TextComponent = gameObject.GetComponent<TMP_Text>(); // Get a reference to the camera rendering the text taking into consideration the text component type. if (m_TextComponent.GetType() == typeof(TextMeshProUGUI)) { m_Canvas = gameObject.GetComponentInParent<Canvas>(); if (m_Canvas != null) { if (m_Canvas.renderMode == RenderMode.ScreenSpaceOverlay) m_Camera = null; else m_Camera = m_Canvas.worldCamera; } } else { m_Camera = Camera.main; } } void LateUpdate() { if (TMP_TextUtilities.IsIntersectingRectTransform(m_TextComponent.rectTransform, Input.mousePosition, m_Camera)) { #region Example of Character or Sprite Selection int charIndex = TMP_TextUtilities.FindIntersectingCharacter(m_TextComponent, Input.mousePosition, m_Camera, true); if (charIndex != -1 && charIndex != m_lastCharIndex) { m_lastCharIndex = charIndex; TMP_TextElementType elementType = m_TextComponent.textInfo.characterInfo[charIndex].elementType; // Send event to any event listeners depending on whether it is a character or sprite. if (elementType == TMP_TextElementType.Character) SendOnCharacterSelection(m_TextComponent.textInfo.characterInfo[charIndex].character, charIndex); else if (elementType == TMP_TextElementType.Sprite) SendOnSpriteSelection(m_TextComponent.textInfo.characterInfo[charIndex].character, charIndex); } #endregion #region Example of Word Selection // Check if Mouse intersects any words and if so assign a random color to that word. int wordIndex = TMP_TextUtilities.FindIntersectingWord(m_TextComponent, Input.mousePosition, m_Camera); if (wordIndex != -1 && wordIndex != m_lastWordIndex) { m_lastWordIndex = wordIndex; // Get the information about the selected word. TMP_WordInfo wInfo = m_TextComponent.textInfo.wordInfo[wordIndex]; // Send the event to any listeners. SendOnWordSelection(wInfo.GetWord(), wInfo.firstCharacterIndex, wInfo.characterCount); } #endregion #region Example of Line Selection // Check if Mouse intersects any words and if so assign a random color to that word. int lineIndex = TMP_TextUtilities.FindIntersectingLine(m_TextComponent, Input.mousePosition, m_Camera); if (lineIndex != -1 && lineIndex != m_lastLineIndex) { m_lastLineIndex = lineIndex; // Get the information about the selected word. TMP_LineInfo lineInfo = m_TextComponent.textInfo.lineInfo[lineIndex]; // Send the event to any listeners. char[] buffer = new char[lineInfo.characterCount]; for (int i = 0; i < lineInfo.characterCount && i < m_TextComponent.textInfo.characterInfo.Length; i++) { buffer[i] = m_TextComponent.textInfo.characterInfo[i + lineInfo.firstCharacterIndex].character; } string lineText = new string(buffer); SendOnLineSelection(lineText, lineInfo.firstCharacterIndex, lineInfo.characterCount); } #endregion #region Example of Link Handling // Check if mouse intersects with any links. int linkIndex = TMP_TextUtilities.FindIntersectingLink(m_TextComponent, Input.mousePosition, m_Camera); // Handle new Link selection. if (linkIndex != -1 && linkIndex != m_selectedLink) { m_selectedLink = linkIndex; // Get information about the link. TMP_LinkInfo linkInfo = m_TextComponent.textInfo.linkInfo[linkIndex]; // Send the event to any listeners. SendOnLinkSelection(linkInfo.GetLinkID(), linkInfo.GetLinkText(), linkIndex); } #endregion } } public void OnPointerEnter(PointerEventData eventData) { //Debug.Log("OnPointerEnter()"); } public void OnPointerExit(PointerEventData eventData) { //Debug.Log("OnPointerExit()"); } private void SendOnCharacterSelection(char character, int characterIndex) { if (onCharacterSelection != null) onCharacterSelection.Invoke(character, characterIndex); } private void SendOnSpriteSelection(char character, int characterIndex) { if (onSpriteSelection != null) onSpriteSelection.Invoke(character, characterIndex); } private void SendOnWordSelection(string word, int charIndex, int length) { if (onWordSelection != null) onWordSelection.Invoke(word, charIndex, length); } private void SendOnLineSelection(string line, int charIndex, int length) { if (onLineSelection != null) onLineSelection.Invoke(line, charIndex, length); } private void SendOnLinkSelection(string linkID, string linkText, int linkIndex) { if (onLinkSelection != null) onLinkSelection.Invoke(linkID, linkText, linkIndex); } } }

File no 148: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_TextInfoDebugTool.cs
﻿using UnityEngine; using System.Collections; namespace TMPro.Examples { public class TMP_TextInfoDebugTool : MonoBehaviour { // Since this script is used for debugging, we exclude it from builds. // TODO: Rework this script to make it into an editor utility. #if UNITY_EDITOR public bool ShowCharacters; public bool ShowWords; public bool ShowLinks; public bool ShowLines; public bool ShowMeshBounds; public bool ShowTextBounds; [Space(10)] [TextArea(2, 2)] public string ObjectStats; [SerializeField] private TMP_Text m_TextComponent; [SerializeField] private Transform m_Transform; void OnDrawGizmos() { if (m_TextComponent == null) { m_TextComponent = gameObject.GetComponent<TMP_Text>(); if (m_TextComponent == null) return; if (m_Transform == null) m_Transform = gameObject.GetComponent<Transform>(); } // Update Text Statistics TMP_TextInfo textInfo = m_TextComponent.textInfo; ObjectStats = "Characters: " + textInfo.characterCount + " Words: " + textInfo.wordCount + " Spaces: " + textInfo.spaceCount + " Sprites: " + textInfo.spriteCount + " Links: " + textInfo.linkCount + "\nLines: " + textInfo.lineCount + " Pages: " + textInfo.pageCount; // Draw Quads around each of the Characters #region Draw Characters if (ShowCharacters) DrawCharactersBounds(); #endregion // Draw Quads around each of the words #region Draw Words if (ShowWords) DrawWordBounds(); #endregion // Draw Quads around each of the words #region Draw Links if (ShowLinks) DrawLinkBounds(); #endregion // Draw Quads around each line #region Draw Lines if (ShowLines) DrawLineBounds(); #endregion // Draw Quad around the bounds of the text #region Draw Bounds if (ShowMeshBounds) DrawBounds(); #endregion // Draw Quad around the rendered region of the text. #region Draw Text Bounds if (ShowTextBounds) DrawTextBounds(); #endregion } /// <summary> /// Method to draw a rectangle around each character. /// </summary> /// <param name="text"></param> void DrawCharactersBounds() { TMP_TextInfo textInfo = m_TextComponent.textInfo; for (int i = 0; i < textInfo.characterCount; i++) { // Draw visible as well as invisible characters TMP_CharacterInfo cInfo = textInfo.characterInfo[i]; bool isCharacterVisible = i >= m_TextComponent.maxVisibleCharacters || cInfo.lineNumber >= m_TextComponent.maxVisibleLines || (m_TextComponent.overflowMode == TextOverflowModes.Page && cInfo.pageNumber + 1 != m_TextComponent.pageToDisplay) ? false : true; if (!isCharacterVisible) continue; // Get Bottom Left and Top Right position of the current character Vector3 bottomLeft = m_Transform.TransformPoint(cInfo.bottomLeft); Vector3 topLeft = m_Transform.TransformPoint(new Vector3(cInfo.topLeft.x, cInfo.topLeft.y, 0)); Vector3 topRight = m_Transform.TransformPoint(cInfo.topRight); Vector3 bottomRight = m_Transform.TransformPoint(new Vector3(cInfo.bottomRight.x, cInfo.bottomRight.y, 0)); Color color = cInfo.isVisible ? Color.yellow : Color.grey; DrawRectangle(bottomLeft, topLeft, topRight, bottomRight, color); // Baseline Vector3 baselineStart = new Vector3(topLeft.x, m_Transform.TransformPoint(new Vector3(0, cInfo.baseLine, 0)).y, 0); Vector3 baselineEnd = new Vector3(topRight.x, m_Transform.TransformPoint(new Vector3(0, cInfo.baseLine, 0)).y, 0); Gizmos.color = Color.cyan; Gizmos.DrawLine(baselineStart, baselineEnd); // Draw Ascender & Descender for each character. Vector3 ascenderStart = new Vector3(topLeft.x, m_Transform.TransformPoint(new Vector3(0, cInfo.ascender, 0)).y, 0); Vector3 ascenderEnd = new Vector3(topRight.x, m_Transform.TransformPoint(new Vector3(0, cInfo.ascender, 0)).y, 0); Vector3 descenderStart = new Vector3(bottomLeft.x, m_Transform.TransformPoint(new Vector3(0, cInfo.descender, 0)).y, 0); Vector3 descenderEnd = new Vector3(bottomRight.x, m_Transform.TransformPoint(new Vector3(0, cInfo.descender, 0)).y, 0); Gizmos.color = Color.cyan; Gizmos.DrawLine(ascenderStart, ascenderEnd); Gizmos.DrawLine(descenderStart, descenderEnd); // Draw Cap Height float capHeight = cInfo.baseLine + cInfo.fontAsset.faceInfo.capLine * cInfo.scale; Vector3 capHeightStart = new Vector3(topLeft.x, m_Transform.TransformPoint(new Vector3(0, capHeight, 0)).y, 0); Vector3 capHeightEnd = new Vector3(topRight.x, m_Transform.TransformPoint(new Vector3(0, capHeight, 0)).y, 0); Gizmos.color = Color.cyan; Gizmos.DrawLine(capHeightStart, capHeightEnd); // Draw Centerline float meanline = cInfo.baseLine + cInfo.fontAsset.faceInfo.meanLine * cInfo.scale; Vector3 centerlineStart = new Vector3(topLeft.x, m_Transform.TransformPoint(new Vector3(0, meanline, 0)).y, 0); Vector3 centerlineEnd = new Vector3(topRight.x, m_Transform.TransformPoint(new Vector3(0, meanline, 0)).y, 0); Gizmos.color = Color.cyan; Gizmos.DrawLine(centerlineStart, centerlineEnd); // Draw Origin for each character. float gizmoSize = (ascenderEnd.y - descenderEnd.y) * 0.02f; Vector3 origin = m_Transform.TransformPoint(cInfo.origin, cInfo.baseLine, 0); Vector3 originBL = new Vector3(origin.x - gizmoSize, origin.y - gizmoSize, 0); Vector3 originTL = new Vector3(originBL.x, origin.y + gizmoSize, 0); Vector3 originTR = new Vector3(origin.x + gizmoSize, originTL.y, 0); Vector3 originBR = new Vector3(originTR.x, originBL.y, 0); Gizmos.color = new Color(1, 0.5f, 0); Gizmos.DrawLine(originBL, originTL); Gizmos.DrawLine(originTL, originTR); Gizmos.DrawLine(originTR, originBR); Gizmos.DrawLine(originBR, originBL); // Draw xAdvance for each character. gizmoSize = (ascenderEnd.y - descenderEnd.y) * 0.04f; float xAdvance = m_Transform.TransformPoint(cInfo.xAdvance, 0, 0).x; Vector3 topAdvance = new Vector3(xAdvance, baselineStart.y + gizmoSize, 0); Vector3 bottomAdvance = new Vector3(xAdvance, baselineStart.y - gizmoSize, 0); Vector3 leftAdvance = new Vector3(xAdvance - gizmoSize, baselineStart.y, 0); Vector3 rightAdvance = new Vector3(xAdvance + gizmoSize, baselineStart.y, 0); Gizmos.color = Color.green; Gizmos.DrawLine(topAdvance, bottomAdvance); Gizmos.DrawLine(leftAdvance, rightAdvance); } } /// <summary> /// Method to draw rectangles around each word of the text. /// </summary> /// <param name="text"></param> void DrawWordBounds() { TMP_TextInfo textInfo = m_TextComponent.textInfo; for (int i = 0; i < textInfo.wordCount; i++) { TMP_WordInfo wInfo = textInfo.wordInfo[i]; bool isBeginRegion = false; Vector3 bottomLeft = Vector3.zero; Vector3 topLeft = Vector3.zero; Vector3 bottomRight = Vector3.zero; Vector3 topRight = Vector3.zero; float maxAscender = -Mathf.Infinity; float minDescender = Mathf.Infinity; Color wordColor = Color.green; // Iterate through each character of the word for (int j = 0; j < wInfo.characterCount; j++) { int characterIndex = wInfo.firstCharacterIndex + j; TMP_CharacterInfo currentCharInfo = textInfo.characterInfo[characterIndex]; int currentLine = currentCharInfo.lineNumber; bool isCharacterVisible = characterIndex > m_TextComponent.maxVisibleCharacters || currentCharInfo.lineNumber > m_TextComponent.maxVisibleLines || (m_TextComponent.overflowMode == TextOverflowModes.Page && currentCharInfo.pageNumber + 1 != m_TextComponent.pageToDisplay) ? false : true; // Track Max Ascender and Min Descender maxAscender = Mathf.Max(maxAscender, currentCharInfo.ascender); minDescender = Mathf.Min(minDescender, currentCharInfo.descender); if (isBeginRegion == false && isCharacterVisible) { isBeginRegion = true; bottomLeft = new Vector3(currentCharInfo.bottomLeft.x, currentCharInfo.descender, 0); topLeft = new Vector3(currentCharInfo.bottomLeft.x, currentCharInfo.ascender, 0); //Debug.Log("Start Word Region at [" + currentCharInfo.character + "]"); // If Word is one character if (wInfo.characterCount == 1) { isBeginRegion = false; topLeft = m_Transform.TransformPoint(new Vector3(topLeft.x, maxAscender, 0)); bottomLeft = m_Transform.TransformPoint(new Vector3(bottomLeft.x, minDescender, 0)); bottomRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, minDescender, 0)); topRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, maxAscender, 0)); // Draw Region DrawRectangle(bottomLeft, topLeft, topRight, bottomRight, wordColor); //Debug.Log("End Word Region at [" + currentCharInfo.character + "]"); } } // Last Character of Word if (isBeginRegion && j == wInfo.characterCount - 1) { isBeginRegion = false; topLeft = m_Transform.TransformPoint(new Vector3(topLeft.x, maxAscender, 0)); bottomLeft = m_Transform.TransformPoint(new Vector3(bottomLeft.x, minDescender, 0)); bottomRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, minDescender, 0)); topRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, maxAscender, 0)); // Draw Region DrawRectangle(bottomLeft, topLeft, topRight, bottomRight, wordColor); //Debug.Log("End Word Region at [" + currentCharInfo.character + "]"); } // If Word is split on more than one line. else if (isBeginRegion && currentLine != textInfo.characterInfo[characterIndex + 1].lineNumber) { isBeginRegion = false; topLeft = m_Transform.TransformPoint(new Vector3(topLeft.x, maxAscender, 0)); bottomLeft = m_Transform.TransformPoint(new Vector3(bottomLeft.x, minDescender, 0)); bottomRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, minDescender, 0)); topRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, maxAscender, 0)); // Draw Region DrawRectangle(bottomLeft, topLeft, topRight, bottomRight, wordColor); //Debug.Log("End Word Region at [" + currentCharInfo.character + "]"); maxAscender = -Mathf.Infinity; minDescender = Mathf.Infinity; } } //Debug.Log(wInfo.GetWord(m_TextMeshPro.textInfo.characterInfo)); } } /// <summary> /// Draw rectangle around each of the links contained in the text. /// </summary> /// <param name="text"></param> void DrawLinkBounds() { TMP_TextInfo textInfo = m_TextComponent.textInfo; for (int i = 0; i < textInfo.linkCount; i++) { TMP_LinkInfo linkInfo = textInfo.linkInfo[i]; bool isBeginRegion = false; Vector3 bottomLeft = Vector3.zero; Vector3 topLeft = Vector3.zero; Vector3 bottomRight = Vector3.zero; Vector3 topRight = Vector3.zero; float maxAscender = -Mathf.Infinity; float minDescender = Mathf.Infinity; Color32 linkColor = Color.cyan; // Iterate through each character of the link text for (int j = 0; j < linkInfo.linkTextLength; j++) { int characterIndex = linkInfo.linkTextfirstCharacterIndex + j; TMP_CharacterInfo currentCharInfo = textInfo.characterInfo[characterIndex]; int currentLine = currentCharInfo.lineNumber; bool isCharacterVisible = characterIndex > m_TextComponent.maxVisibleCharacters || currentCharInfo.lineNumber > m_TextComponent.maxVisibleLines || (m_TextComponent.overflowMode == TextOverflowModes.Page && currentCharInfo.pageNumber + 1 != m_TextComponent.pageToDisplay) ? false : true; // Track Max Ascender and Min Descender maxAscender = Mathf.Max(maxAscender, currentCharInfo.ascender); minDescender = Mathf.Min(minDescender, currentCharInfo.descender); if (isBeginRegion == false && isCharacterVisible) { isBeginRegion = true; bottomLeft = new Vector3(currentCharInfo.bottomLeft.x, currentCharInfo.descender, 0); topLeft = new Vector3(currentCharInfo.bottomLeft.x, currentCharInfo.ascender, 0); //Debug.Log("Start Word Region at [" + currentCharInfo.character + "]"); // If Link is one character if (linkInfo.linkTextLength == 1) { isBeginRegion = false; topLeft = m_Transform.TransformPoint(new Vector3(topLeft.x, maxAscender, 0)); bottomLeft = m_Transform.TransformPoint(new Vector3(bottomLeft.x, minDescender, 0)); bottomRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, minDescender, 0)); topRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, maxAscender, 0)); // Draw Region DrawRectangle(bottomLeft, topLeft, topRight, bottomRight, linkColor); //Debug.Log("End Word Region at [" + currentCharInfo.character + "]"); } } // Last Character of Link if (isBeginRegion && j == linkInfo.linkTextLength - 1) { isBeginRegion = false; topLeft = m_Transform.TransformPoint(new Vector3(topLeft.x, maxAscender, 0)); bottomLeft = m_Transform.TransformPoint(new Vector3(bottomLeft.x, minDescender, 0)); bottomRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, minDescender, 0)); topRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, maxAscender, 0)); // Draw Region DrawRectangle(bottomLeft, topLeft, topRight, bottomRight, linkColor); //Debug.Log("End Word Region at [" + currentCharInfo.character + "]"); } // If Link is split on more than one line. else if (isBeginRegion && currentLine != textInfo.characterInfo[characterIndex + 1].lineNumber) { isBeginRegion = false; topLeft = m_Transform.TransformPoint(new Vector3(topLeft.x, maxAscender, 0)); bottomLeft = m_Transform.TransformPoint(new Vector3(bottomLeft.x, minDescender, 0)); bottomRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, minDescender, 0)); topRight = m_Transform.TransformPoint(new Vector3(currentCharInfo.topRight.x, maxAscender, 0)); // Draw Region DrawRectangle(bottomLeft, topLeft, topRight, bottomRight, linkColor); maxAscender = -Mathf.Infinity; minDescender = Mathf.Infinity; //Debug.Log("End Word Region at [" + currentCharInfo.character + "]"); } } //Debug.Log(wInfo.GetWord(m_TextMeshPro.textInfo.characterInfo)); } } /// <summary> /// Draw Rectangles around each lines of the text. /// </summary> /// <param name="text"></param> void DrawLineBounds() { TMP_TextInfo textInfo = m_TextComponent.textInfo; for (int i = 0; i < textInfo.lineCount; i++) { TMP_LineInfo lineInfo = textInfo.lineInfo[i]; bool isLineVisible = (lineInfo.characterCount == 1 && textInfo.characterInfo[lineInfo.firstCharacterIndex].character == 10) || i > m_TextComponent.maxVisibleLines || (m_TextComponent.overflowMode == TextOverflowModes.Page && textInfo.characterInfo[lineInfo.firstCharacterIndex].pageNumber + 1 != m_TextComponent.pageToDisplay) ? false : true; if (!isLineVisible) continue; //if (!ShowLinesOnlyVisibleCharacters) //{ // Get Bottom Left and Top Right position of each line float ascender = lineInfo.ascender; float descender = lineInfo.descender; float baseline = lineInfo.baseline; float maxAdvance = lineInfo.maxAdvance; Vector3 bottomLeft = m_Transform.TransformPoint(new Vector3(textInfo.characterInfo[lineInfo.firstCharacterIndex].bottomLeft.x, descender, 0)); Vector3 topLeft = m_Transform.TransformPoint(new Vector3(textInfo.characterInfo[lineInfo.firstCharacterIndex].bottomLeft.x, ascender, 0)); Vector3 topRight = m_Transform.TransformPoint(new Vector3(textInfo.characterInfo[lineInfo.lastCharacterIndex].topRight.x, ascender, 0)); Vector3 bottomRight = m_Transform.TransformPoint(new Vector3(textInfo.characterInfo[lineInfo.lastCharacterIndex].topRight.x, descender, 0)); DrawRectangle(bottomLeft, topLeft, topRight, bottomRight, Color.green); Vector3 bottomOrigin = m_Transform.TransformPoint(new Vector3(textInfo.characterInfo[lineInfo.firstCharacterIndex].origin, descender, 0)); Vector3 topOrigin = m_Transform.TransformPoint(new Vector3(textInfo.characterInfo[lineInfo.firstCharacterIndex].origin, ascender, 0)); Vector3 bottomAdvance = m_Transform.TransformPoint(new Vector3(textInfo.characterInfo[lineInfo.firstCharacterIndex].origin + maxAdvance, descender, 0)); Vector3 topAdvance = m_Transform.TransformPoint(new Vector3(textInfo.characterInfo[lineInfo.firstCharacterIndex].origin + maxAdvance, ascender, 0)); DrawDottedRectangle(bottomOrigin, topOrigin, topAdvance, bottomAdvance, Color.green); Vector3 baselineStart = m_Transform.TransformPoint(new Vector3(textInfo.characterInfo[lineInfo.firstCharacterIndex].bottomLeft.x, baseline, 0)); Vector3 baselineEnd = m_Transform.TransformPoint(new Vector3(textInfo.characterInfo[lineInfo.lastCharacterIndex].topRight.x, baseline, 0)); Gizmos.color = Color.cyan; Gizmos.DrawLine(baselineStart, baselineEnd); // Draw LineExtents Gizmos.color = Color.grey; Gizmos.DrawLine(m_Transform.TransformPoint(lineInfo.lineExtents.min), m_Transform.TransformPoint(lineInfo.lineExtents.max)); //} //else //{ //// Get Bottom Left and Top Right position of each line //float ascender = lineInfo.ascender; //float descender = lineInfo.descender; //Vector3 bottomLeft = m_Transform.TransformPoint(new Vector3(textInfo.characterInfo[lineInfo.firstVisibleCharacterIndex].bottomLeft.x, descender, 0)); //Vector3 topLeft = m_Transform.TransformPoint(new Vector3(textInfo.characterInfo[lineInfo.firstVisibleCharacterIndex].bottomLeft.x, ascender, 0)); //Vector3 topRight = m_Transform.TransformPoint(new Vector3(textInfo.characterInfo[lineInfo.lastVisibleCharacterIndex].topRight.x, ascender, 0)); //Vector3 bottomRight = m_Transform.TransformPoint(new Vector3(textInfo.characterInfo[lineInfo.lastVisibleCharacterIndex].topRight.x, descender, 0)); //DrawRectangle(bottomLeft, topLeft, topRight, bottomRight, Color.green); //Vector3 baselineStart = m_Transform.TransformPoint(new Vector3(textInfo.characterInfo[lineInfo.firstVisibleCharacterIndex].bottomLeft.x, textInfo.characterInfo[lineInfo.firstVisibleCharacterIndex].baseLine, 0)); //Vector3 baselineEnd = m_Transform.TransformPoint(new Vector3(textInfo.characterInfo[lineInfo.lastVisibleCharacterIndex].topRight.x, textInfo.characterInfo[lineInfo.lastVisibleCharacterIndex].baseLine, 0)); //Gizmos.color = Color.cyan; //Gizmos.DrawLine(baselineStart, baselineEnd); //} } } /// <summary> /// Draw Rectangle around the bounds of the text object. /// </summary> void DrawBounds() { Bounds meshBounds = m_TextComponent.bounds; // Get Bottom Left and Top Right position of each word Vector3 bottomLeft = m_TextComponent.transform.position + (meshBounds.center - meshBounds.extents); Vector3 topRight = m_TextComponent.transform.position + (meshBounds.center + meshBounds.extents); DrawRectangle(bottomLeft, topRight, new Color(1, 0.5f, 0)); } void DrawTextBounds() { Bounds textBounds = m_TextComponent.textBounds; Vector3 bottomLeft = m_TextComponent.transform.position + (textBounds.center - textBounds.extents); Vector3 topRight = m_TextComponent.transform.position + (textBounds.center + textBounds.extents); DrawRectangle(bottomLeft, topRight, new Color(0f, 0.5f, 0.5f)); } // Draw Rectangles void DrawRectangle(Vector3 BL, Vector3 TR, Color color) { Gizmos.color = color; Gizmos.DrawLine(new Vector3(BL.x, BL.y, 0), new Vector3(BL.x, TR.y, 0)); Gizmos.DrawLine(new Vector3(BL.x, TR.y, 0), new Vector3(TR.x, TR.y, 0)); Gizmos.DrawLine(new Vector3(TR.x, TR.y, 0), new Vector3(TR.x, BL.y, 0)); Gizmos.DrawLine(new Vector3(TR.x, BL.y, 0), new Vector3(BL.x, BL.y, 0)); } // Draw Rectangles void DrawRectangle(Vector3 bl, Vector3 tl, Vector3 tr, Vector3 br, Color color) { Gizmos.color = color; Gizmos.DrawLine(bl, tl); Gizmos.DrawLine(tl, tr); Gizmos.DrawLine(tr, br); Gizmos.DrawLine(br, bl); } // Draw Rectangles void DrawDottedRectangle(Vector3 bl, Vector3 tl, Vector3 tr, Vector3 br, Color color) { var cam = Camera.current; float dotSpacing = (cam.WorldToScreenPoint(br).x - cam.WorldToScreenPoint(bl).x) / 75f; UnityEditor.Handles.color = color; UnityEditor.Handles.DrawDottedLine(bl, tl, dotSpacing); UnityEditor.Handles.DrawDottedLine(tl, tr, dotSpacing); UnityEditor.Handles.DrawDottedLine(tr, br, dotSpacing); UnityEditor.Handles.DrawDottedLine(br, bl, dotSpacing); } #endif } }

File no 149: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_TextSelector_A.cs
﻿using UnityEngine; using UnityEngine.EventSystems; using System.Collections; namespace TMPro.Examples { public class TMP_TextSelector_A : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler { private TextMeshPro m_TextMeshPro; private Camera m_Camera; private bool m_isHoveringObject; private int m_selectedLink = -1; private int m_lastCharIndex = -1; private int m_lastWordIndex = -1; void Awake() { m_TextMeshPro = gameObject.GetComponent<TextMeshPro>(); m_Camera = Camera.main; // Force generation of the text object so we have valid data to work with. This is needed since LateUpdate() will be called before the text object has a chance to generated when entering play mode. m_TextMeshPro.ForceMeshUpdate(); } void LateUpdate() { m_isHoveringObject = false; if (TMP_TextUtilities.IsIntersectingRectTransform(m_TextMeshPro.rectTransform, Input.mousePosition, Camera.main)) { m_isHoveringObject = true; } if (m_isHoveringObject) { #region Example of Character Selection int charIndex = TMP_TextUtilities.FindIntersectingCharacter(m_TextMeshPro, Input.mousePosition, Camera.main, true); if (charIndex != -1 && charIndex != m_lastCharIndex && (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift))) { //Debug.Log("[" + m_TextMeshPro.textInfo.characterInfo[charIndex].character + "] has been selected."); m_lastCharIndex = charIndex; int meshIndex = m_TextMeshPro.textInfo.characterInfo[charIndex].materialReferenceIndex; int vertexIndex = m_TextMeshPro.textInfo.characterInfo[charIndex].vertexIndex; Color32 c = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), 255); Color32[] vertexColors = m_TextMeshPro.textInfo.meshInfo[meshIndex].colors32; vertexColors[vertexIndex + 0] = c; vertexColors[vertexIndex + 1] = c; vertexColors[vertexIndex + 2] = c; vertexColors[vertexIndex + 3] = c; //m_TextMeshPro.mesh.colors32 = vertexColors; m_TextMeshPro.textInfo.meshInfo[meshIndex].mesh.colors32 = vertexColors; } #endregion #region Example of Link Handling // Check if mouse intersects with any links. int linkIndex = TMP_TextUtilities.FindIntersectingLink(m_TextMeshPro, Input.mousePosition, m_Camera); // Clear previous link selection if one existed. if ((linkIndex == -1 && m_selectedLink != -1) || linkIndex != m_selectedLink) { //m_TextPopup_RectTransform.gameObject.SetActive(false); m_selectedLink = -1; } // Handle new Link selection. if (linkIndex != -1 && linkIndex != m_selectedLink) { m_selectedLink = linkIndex; TMP_LinkInfo linkInfo = m_TextMeshPro.textInfo.linkInfo[linkIndex]; // The following provides an example of how to access the link properties. //Debug.Log("Link ID: \"" + linkInfo.GetLinkID() + "\" Link Text: \"" + linkInfo.GetLinkText() + "\""); // Example of how to retrieve the Link ID and Link Text. Vector3 worldPointInRectangle; RectTransformUtility.ScreenPointToWorldPointInRectangle(m_TextMeshPro.rectTransform, Input.mousePosition, m_Camera, out worldPointInRectangle); switch (linkInfo.GetLinkID()) { case "id_01": // 100041637: // id_01 //m_TextPopup_RectTransform.position = worldPointInRectangle; //m_TextPopup_RectTransform.gameObject.SetActive(true); //m_TextPopup_TMPComponent.text = k_LinkText + " ID 01"; break; case "id_02": // 100041638: // id_02 //m_TextPopup_RectTransform.position = worldPointInRectangle; //m_TextPopup_RectTransform.gameObject.SetActive(true); //m_TextPopup_TMPComponent.text = k_LinkText + " ID 02"; break; } } #endregion #region Example of Word Selection // Check if Mouse intersects any words and if so assign a random color to that word. int wordIndex = TMP_TextUtilities.FindIntersectingWord(m_TextMeshPro, Input.mousePosition, Camera.main); if (wordIndex != -1 && wordIndex != m_lastWordIndex) { m_lastWordIndex = wordIndex; TMP_WordInfo wInfo = m_TextMeshPro.textInfo.wordInfo[wordIndex]; Vector3 wordPOS = m_TextMeshPro.transform.TransformPoint(m_TextMeshPro.textInfo.characterInfo[wInfo.firstCharacterIndex].bottomLeft); wordPOS = Camera.main.WorldToScreenPoint(wordPOS); //Debug.Log("Mouse Position: " + Input.mousePosition.ToString("f3") + " Word Position: " + wordPOS.ToString("f3")); Color32[] vertexColors = m_TextMeshPro.textInfo.meshInfo[0].colors32; Color32 c = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), 255); for (int i = 0; i < wInfo.characterCount; i++) { int vertexIndex = m_TextMeshPro.textInfo.characterInfo[wInfo.firstCharacterIndex + i].vertexIndex; vertexColors[vertexIndex + 0] = c; vertexColors[vertexIndex + 1] = c; vertexColors[vertexIndex + 2] = c; vertexColors[vertexIndex + 3] = c; } m_TextMeshPro.mesh.colors32 = vertexColors; } #endregion } } public void OnPointerEnter(PointerEventData eventData) { Debug.Log("OnPointerEnter()"); m_isHoveringObject = true; } public void OnPointerExit(PointerEventData eventData) { Debug.Log("OnPointerExit()"); m_isHoveringObject = false; } } }

File no 150: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_TextSelector_B.cs
﻿using UnityEngine; using UnityEngine.Events; using UnityEngine.EventSystems; using System.Collections; using System.Collections.Generic; #pragma warning disable 0618 // Disabled warning due to SetVertices being deprecated until new release with SetMesh() is available. namespace TMPro.Examples { public class TMP_TextSelector_B : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IPointerClickHandler, IPointerUpHandler { public RectTransform TextPopup_Prefab_01; private RectTransform m_TextPopup_RectTransform; private TextMeshProUGUI m_TextPopup_TMPComponent; private const string k_LinkText = "You have selected link <#ffff00>"; private const string k_WordText = "Word Index: <#ffff00>"; private TextMeshProUGUI m_TextMeshPro; private Canvas m_Canvas; private Camera m_Camera; // Flags private bool isHoveringObject; private int m_selectedWord = -1; private int m_selectedLink = -1; private int m_lastIndex = -1; private Matrix4x4 m_matrix; private TMP_MeshInfo[] m_cachedMeshInfoVertexData; void Awake() { m_TextMeshPro = gameObject.GetComponent<TextMeshProUGUI>(); m_Canvas = gameObject.GetComponentInParent<Canvas>(); // Get a reference to the camera if Canvas Render Mode is not ScreenSpace Overlay. if (m_Canvas.renderMode == RenderMode.ScreenSpaceOverlay) m_Camera = null; else m_Camera = m_Canvas.worldCamera; // Create pop-up text object which is used to show the link information. m_TextPopup_RectTransform = Instantiate(TextPopup_Prefab_01) as RectTransform; m_TextPopup_RectTransform.SetParent(m_Canvas.transform, false); m_TextPopup_TMPComponent = m_TextPopup_RectTransform.GetComponentInChildren<TextMeshProUGUI>(); m_TextPopup_RectTransform.gameObject.SetActive(false); } void OnEnable() { // Subscribe to event fired when text object has been regenerated. TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED); } void OnDisable() { // UnSubscribe to event fired when text object has been regenerated. TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED); } void ON_TEXT_CHANGED(Object obj) { if (obj == m_TextMeshPro) { // Update cached vertex data. m_cachedMeshInfoVertexData = m_TextMeshPro.textInfo.CopyMeshInfoVertexData(); } } void LateUpdate() { if (isHoveringObject) { // Check if Mouse Intersects any of the characters. If so, assign a random color. #region Handle Character Selection int charIndex = TMP_TextUtilities.FindIntersectingCharacter(m_TextMeshPro, Input.mousePosition, m_Camera, true); // Undo Swap and Vertex Attribute changes. if (charIndex == -1 || charIndex != m_lastIndex) { RestoreCachedVertexAttributes(m_lastIndex); m_lastIndex = -1; } if (charIndex != -1 && charIndex != m_lastIndex && (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift))) { m_lastIndex = charIndex; // Get the index of the material / sub text object used by this character. int materialIndex = m_TextMeshPro.textInfo.characterInfo[charIndex].materialReferenceIndex; // Get the index of the first vertex of the selected character. int vertexIndex = m_TextMeshPro.textInfo.characterInfo[charIndex].vertexIndex; // Get a reference to the vertices array. Vector3[] vertices = m_TextMeshPro.textInfo.meshInfo[materialIndex].vertices; // Determine the center point of the character. Vector2 charMidBasline = (vertices[vertexIndex + 0] + vertices[vertexIndex + 2]) / 2; // Need to translate all 4 vertices of the character to aligned with middle of character / baseline. // This is needed so the matrix TRS is applied at the origin for each character. Vector3 offset = charMidBasline; // Translate the character to the middle baseline. vertices[vertexIndex + 0] = vertices[vertexIndex + 0] - offset; vertices[vertexIndex + 1] = vertices[vertexIndex + 1] - offset; vertices[vertexIndex + 2] = vertices[vertexIndex + 2] - offset; vertices[vertexIndex + 3] = vertices[vertexIndex + 3] - offset; float zoomFactor = 1.5f; // Setup the Matrix for the scale change. m_matrix = Matrix4x4.TRS(Vector3.zero, Quaternion.identity, Vector3.one * zoomFactor); // Apply Matrix operation on the given character. vertices[vertexIndex + 0] = m_matrix.MultiplyPoint3x4(vertices[vertexIndex + 0]); vertices[vertexIndex + 1] = m_matrix.MultiplyPoint3x4(vertices[vertexIndex + 1]); vertices[vertexIndex + 2] = m_matrix.MultiplyPoint3x4(vertices[vertexIndex + 2]); vertices[vertexIndex + 3] = m_matrix.MultiplyPoint3x4(vertices[vertexIndex + 3]); // Translate the character back to its original position. vertices[vertexIndex + 0] = vertices[vertexIndex + 0] + offset; vertices[vertexIndex + 1] = vertices[vertexIndex + 1] + offset; vertices[vertexIndex + 2] = vertices[vertexIndex + 2] + offset; vertices[vertexIndex + 3] = vertices[vertexIndex + 3] + offset; // Change Vertex Colors of the highlighted character Color32 c = new Color32(255, 255, 192, 255); // Get a reference to the vertex color Color32[] vertexColors = m_TextMeshPro.textInfo.meshInfo[materialIndex].colors32; vertexColors[vertexIndex + 0] = c; vertexColors[vertexIndex + 1] = c; vertexColors[vertexIndex + 2] = c; vertexColors[vertexIndex + 3] = c; // Get a reference to the meshInfo of the selected character. TMP_MeshInfo meshInfo = m_TextMeshPro.textInfo.meshInfo[materialIndex]; // Get the index of the last character's vertex attributes. int lastVertexIndex = vertices.Length - 4; // Swap the current character's vertex attributes with those of the last element in the vertex attribute arrays. // We do this to make sure this character is rendered last and over other characters. meshInfo.SwapVertexData(vertexIndex, lastVertexIndex); // Need to update the appropriate m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All); } #endregion #region Word Selection Handling //Check if Mouse intersects any words and if so assign a random color to that word. int wordIndex = TMP_TextUtilities.FindIntersectingWord(m_TextMeshPro, Input.mousePosition, m_Camera); // Clear previous word selection. if (m_TextPopup_RectTransform != null && m_selectedWord != -1 && (wordIndex == -1 || wordIndex != m_selectedWord)) { TMP_WordInfo wInfo = m_TextMeshPro.textInfo.wordInfo[m_selectedWord]; // Iterate through each of the characters of the word. for (int i = 0; i < wInfo.characterCount; i++) { int characterIndex = wInfo.firstCharacterIndex + i; // Get the index of the material / sub text object used by this character. int meshIndex = m_TextMeshPro.textInfo.characterInfo[characterIndex].materialReferenceIndex; // Get the index of the first vertex of this character. int vertexIndex = m_TextMeshPro.textInfo.characterInfo[characterIndex].vertexIndex; // Get a reference to the vertex color Color32[] vertexColors = m_TextMeshPro.textInfo.meshInfo[meshIndex].colors32; Color32 c = vertexColors[vertexIndex + 0].Tint(1.33333f); vertexColors[vertexIndex + 0] = c; vertexColors[vertexIndex + 1] = c; vertexColors[vertexIndex + 2] = c; vertexColors[vertexIndex + 3] = c; } // Update Geometry m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All); m_selectedWord = -1; } // Word Selection Handling if (wordIndex != -1 && wordIndex != m_selectedWord && !(Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift))) { m_selectedWord = wordIndex; TMP_WordInfo wInfo = m_TextMeshPro.textInfo.wordInfo[wordIndex]; // Iterate through each of the characters of the word. for (int i = 0; i < wInfo.characterCount; i++) { int characterIndex = wInfo.firstCharacterIndex + i; // Get the index of the material / sub text object used by this character. int meshIndex = m_TextMeshPro.textInfo.characterInfo[characterIndex].materialReferenceIndex; int vertexIndex = m_TextMeshPro.textInfo.characterInfo[characterIndex].vertexIndex; // Get a reference to the vertex color Color32[] vertexColors = m_TextMeshPro.textInfo.meshInfo[meshIndex].colors32; Color32 c = vertexColors[vertexIndex + 0].Tint(0.75f); vertexColors[vertexIndex + 0] = c; vertexColors[vertexIndex + 1] = c; vertexColors[vertexIndex + 2] = c; vertexColors[vertexIndex + 3] = c; } // Update Geometry m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All); } #endregion #region Example of Link Handling // Check if mouse intersects with any links. int linkIndex = TMP_TextUtilities.FindIntersectingLink(m_TextMeshPro, Input.mousePosition, m_Camera); // Clear previous link selection if one existed. if ((linkIndex == -1 && m_selectedLink != -1) || linkIndex != m_selectedLink) { m_TextPopup_RectTransform.gameObject.SetActive(false); m_selectedLink = -1; } // Handle new Link selection. if (linkIndex != -1 && linkIndex != m_selectedLink) { m_selectedLink = linkIndex; TMP_LinkInfo linkInfo = m_TextMeshPro.textInfo.linkInfo[linkIndex]; // Debug.Log("Link ID: \"" + linkInfo.GetLinkID() + "\" Link Text: \"" + linkInfo.GetLinkText() + "\""); // Example of how to retrieve the Link ID and Link Text. Vector3 worldPointInRectangle; RectTransformUtility.ScreenPointToWorldPointInRectangle(m_TextMeshPro.rectTransform, Input.mousePosition, m_Camera, out worldPointInRectangle); switch (linkInfo.GetLinkID()) { case "id_01": // 100041637: // id_01 m_TextPopup_RectTransform.position = worldPointInRectangle; m_TextPopup_RectTransform.gameObject.SetActive(true); m_TextPopup_TMPComponent.text = k_LinkText + " ID 01"; break; case "id_02": // 100041638: // id_02 m_TextPopup_RectTransform.position = worldPointInRectangle; m_TextPopup_RectTransform.gameObject.SetActive(true); m_TextPopup_TMPComponent.text = k_LinkText + " ID 02"; break; } } #endregion } else { // Restore any character that may have been modified if (m_lastIndex != -1) { RestoreCachedVertexAttributes(m_lastIndex); m_lastIndex = -1; } } } public void OnPointerEnter(PointerEventData eventData) { //Debug.Log("OnPointerEnter()"); isHoveringObject = true; } public void OnPointerExit(PointerEventData eventData) { //Debug.Log("OnPointerExit()"); isHoveringObject = false; } public void OnPointerClick(PointerEventData eventData) { //Debug.Log("Click at POS: " + eventData.position + " World POS: " + eventData.worldPosition); // Check if Mouse Intersects any of the characters. If so, assign a random color. #region Character Selection Handling /* int charIndex = TMP_TextUtilities.FindIntersectingCharacter(m_TextMeshPro, Input.mousePosition, m_Camera, true); if (charIndex != -1 && charIndex != m_lastIndex) { //Debug.Log("Character [" + m_TextMeshPro.textInfo.characterInfo[index].character + "] was selected at POS: " + eventData.position); m_lastIndex = charIndex; Color32 c = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), 255); int vertexIndex = m_TextMeshPro.textInfo.characterInfo[charIndex].vertexIndex; UIVertex[] uiVertices = m_TextMeshPro.textInfo.meshInfo.uiVertices; uiVertices[vertexIndex + 0].color = c; uiVertices[vertexIndex + 1].color = c; uiVertices[vertexIndex + 2].color = c; uiVertices[vertexIndex + 3].color = c; m_TextMeshPro.canvasRenderer.SetVertices(uiVertices, uiVertices.Length); } */ #endregion #region Word Selection Handling //Check if Mouse intersects any words and if so assign a random color to that word. /* int wordIndex = TMP_TextUtilities.FindIntersectingWord(m_TextMeshPro, Input.mousePosition, m_Camera); // Clear previous word selection. if (m_TextPopup_RectTransform != null && m_selectedWord != -1 && (wordIndex == -1 || wordIndex != m_selectedWord)) { TMP_WordInfo wInfo = m_TextMeshPro.textInfo.wordInfo[m_selectedWord]; // Get a reference to the uiVertices array. UIVertex[] uiVertices = m_TextMeshPro.textInfo.meshInfo.uiVertices; // Iterate through each of the characters of the word. for (int i = 0; i < wInfo.characterCount; i++) { int vertexIndex = m_TextMeshPro.textInfo.characterInfo[wInfo.firstCharacterIndex + i].vertexIndex; Color32 c = uiVertices[vertexIndex + 0].color.Tint(1.33333f); uiVertices[vertexIndex + 0].color = c; uiVertices[vertexIndex + 1].color = c; uiVertices[vertexIndex + 2].color = c; uiVertices[vertexIndex + 3].color = c; } m_TextMeshPro.canvasRenderer.SetVertices(uiVertices, uiVertices.Length); m_selectedWord = -1; } // Handle word selection if (wordIndex != -1 && wordIndex != m_selectedWord) { m_selectedWord = wordIndex; TMP_WordInfo wInfo = m_TextMeshPro.textInfo.wordInfo[wordIndex]; // Get a reference to the uiVertices array. UIVertex[] uiVertices = m_TextMeshPro.textInfo.meshInfo.uiVertices; // Iterate through each of the characters of the word. for (int i = 0; i < wInfo.characterCount; i++) { int vertexIndex = m_TextMeshPro.textInfo.characterInfo[wInfo.firstCharacterIndex + i].vertexIndex; Color32 c = uiVertices[vertexIndex + 0].color.Tint(0.75f); uiVertices[vertexIndex + 0].color = c; uiVertices[vertexIndex + 1].color = c; uiVertices[vertexIndex + 2].color = c; uiVertices[vertexIndex + 3].color = c; } m_TextMeshPro.canvasRenderer.SetVertices(uiVertices, uiVertices.Length); } */ #endregion #region Link Selection Handling /* // Check if Mouse intersects any words and if so assign a random color to that word. int linkIndex = TMP_TextUtilities.FindIntersectingLink(m_TextMeshPro, Input.mousePosition, m_Camera); if (linkIndex != -1) { TMP_LinkInfo linkInfo = m_TextMeshPro.textInfo.linkInfo[linkIndex]; int linkHashCode = linkInfo.hashCode; //Debug.Log(TMP_TextUtilities.GetSimpleHashCode("id_02")); switch (linkHashCode) { case 291445: // id_01 if (m_LinkObject01 == null) m_LinkObject01 = Instantiate(Link_01_Prefab); else { m_LinkObject01.gameObject.SetActive(true); } break; case 291446: // id_02 break; } // Example of how to modify vertex attributes like colors #region Vertex Attribute Modification Example UIVertex[] uiVertices = m_TextMeshPro.textInfo.meshInfo.uiVertices; Color32 c = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), 255); for (int i = 0; i < linkInfo.characterCount; i++) { TMP_CharacterInfo cInfo = m_TextMeshPro.textInfo.characterInfo[linkInfo.firstCharacterIndex + i]; if (!cInfo.isVisible) continue; // Skip invisible characters. int vertexIndex = cInfo.vertexIndex; uiVertices[vertexIndex + 0].color = c; uiVertices[vertexIndex + 1].color = c; uiVertices[vertexIndex + 2].color = c; uiVertices[vertexIndex + 3].color = c; } m_TextMeshPro.canvasRenderer.SetVertices(uiVertices, uiVertices.Length); #endregion } */ #endregion } public void OnPointerUp(PointerEventData eventData) { //Debug.Log("OnPointerUp()"); } void RestoreCachedVertexAttributes(int index) { if (index == -1 || index > m_TextMeshPro.textInfo.characterCount - 1) return; // Get the index of the material / sub text object used by this character. int materialIndex = m_TextMeshPro.textInfo.characterInfo[index].materialReferenceIndex; // Get the index of the first vertex of the selected character. int vertexIndex = m_TextMeshPro.textInfo.characterInfo[index].vertexIndex; // Restore Vertices // Get a reference to the cached / original vertices. Vector3[] src_vertices = m_cachedMeshInfoVertexData[materialIndex].vertices; // Get a reference to the vertices that we need to replace. Vector3[] dst_vertices = m_TextMeshPro.textInfo.meshInfo[materialIndex].vertices; // Restore / Copy vertices from source to destination dst_vertices[vertexIndex + 0] = src_vertices[vertexIndex + 0]; dst_vertices[vertexIndex + 1] = src_vertices[vertexIndex + 1]; dst_vertices[vertexIndex + 2] = src_vertices[vertexIndex + 2]; dst_vertices[vertexIndex + 3] = src_vertices[vertexIndex + 3]; // Restore Vertex Colors // Get a reference to the vertex colors we need to replace. Color32[] dst_colors = m_TextMeshPro.textInfo.meshInfo[materialIndex].colors32; // Get a reference to the cached / original vertex colors. Color32[] src_colors = m_cachedMeshInfoVertexData[materialIndex].colors32; // Copy the vertex colors from source to destination. dst_colors[vertexIndex + 0] = src_colors[vertexIndex + 0]; dst_colors[vertexIndex + 1] = src_colors[vertexIndex + 1]; dst_colors[vertexIndex + 2] = src_colors[vertexIndex + 2]; dst_colors[vertexIndex + 3] = src_colors[vertexIndex + 3]; // Restore UV0S // UVS0 Vector2[] src_uv0s = m_cachedMeshInfoVertexData[materialIndex].uvs0; Vector2[] dst_uv0s = m_TextMeshPro.textInfo.meshInfo[materialIndex].uvs0; dst_uv0s[vertexIndex + 0] = src_uv0s[vertexIndex + 0]; dst_uv0s[vertexIndex + 1] = src_uv0s[vertexIndex + 1]; dst_uv0s[vertexIndex + 2] = src_uv0s[vertexIndex + 2]; dst_uv0s[vertexIndex + 3] = src_uv0s[vertexIndex + 3]; // UVS2 Vector2[] src_uv2s = m_cachedMeshInfoVertexData[materialIndex].uvs2; Vector2[] dst_uv2s = m_TextMeshPro.textInfo.meshInfo[materialIndex].uvs2; dst_uv2s[vertexIndex + 0] = src_uv2s[vertexIndex + 0]; dst_uv2s[vertexIndex + 1] = src_uv2s[vertexIndex + 1]; dst_uv2s[vertexIndex + 2] = src_uv2s[vertexIndex + 2]; dst_uv2s[vertexIndex + 3] = src_uv2s[vertexIndex + 3]; // Restore last vertex attribute as we swapped it as well int lastIndex = (src_vertices.Length / 4 - 1) * 4; // Vertices dst_vertices[lastIndex + 0] = src_vertices[lastIndex + 0]; dst_vertices[lastIndex + 1] = src_vertices[lastIndex + 1]; dst_vertices[lastIndex + 2] = src_vertices[lastIndex + 2]; dst_vertices[lastIndex + 3] = src_vertices[lastIndex + 3]; // Vertex Colors src_colors = m_cachedMeshInfoVertexData[materialIndex].colors32; dst_colors = m_TextMeshPro.textInfo.meshInfo[materialIndex].colors32; dst_colors[lastIndex + 0] = src_colors[lastIndex + 0]; dst_colors[lastIndex + 1] = src_colors[lastIndex + 1]; dst_colors[lastIndex + 2] = src_colors[lastIndex + 2]; dst_colors[lastIndex + 3] = src_colors[lastIndex + 3]; // UVS0 src_uv0s = m_cachedMeshInfoVertexData[materialIndex].uvs0; dst_uv0s = m_TextMeshPro.textInfo.meshInfo[materialIndex].uvs0; dst_uv0s[lastIndex + 0] = src_uv0s[lastIndex + 0]; dst_uv0s[lastIndex + 1] = src_uv0s[lastIndex + 1]; dst_uv0s[lastIndex + 2] = src_uv0s[lastIndex + 2]; dst_uv0s[lastIndex + 3] = src_uv0s[lastIndex + 3]; // UVS2 src_uv2s = m_cachedMeshInfoVertexData[materialIndex].uvs2; dst_uv2s = m_TextMeshPro.textInfo.meshInfo[materialIndex].uvs2; dst_uv2s[lastIndex + 0] = src_uv2s[lastIndex + 0]; dst_uv2s[lastIndex + 1] = src_uv2s[lastIndex + 1]; dst_uv2s[lastIndex + 2] = src_uv2s[lastIndex + 2]; dst_uv2s[lastIndex + 3] = src_uv2s[lastIndex + 3]; // Need to update the appropriate m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All); } } }

File no 151: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TMP_UiFrameRateCounter.cs
﻿using UnityEngine; using System.Collections; namespace TMPro.Examples { public class TMP_UiFrameRateCounter : MonoBehaviour { public float UpdateInterval = 5.0f; private float m_LastInterval = 0; private int m_Frames = 0; public enum FpsCounterAnchorPositions { TopLeft, BottomLeft, TopRight, BottomRight }; public FpsCounterAnchorPositions AnchorPosition = FpsCounterAnchorPositions.TopRight; private string htmlColorTag; private const string fpsLabel = "{0:2}</color> <#8080ff>FPS \n<#FF8000>{1:2} <#8080ff>MS"; private TextMeshProUGUI m_TextMeshPro; private RectTransform m_frameCounter_transform; private FpsCounterAnchorPositions last_AnchorPosition; void Awake() { if (!enabled) return; Application.targetFrameRate = 1000; GameObject frameCounter = new GameObject("Frame Counter"); m_frameCounter_transform = frameCounter.AddComponent<RectTransform>(); m_frameCounter_transform.SetParent(this.transform, false); m_TextMeshPro = frameCounter.AddComponent<TextMeshProUGUI>(); m_TextMeshPro.font = Resources.Load<TMP_FontAsset>("Fonts & Materials/LiberationSans SDF"); m_TextMeshPro.fontSharedMaterial = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - Overlay"); m_TextMeshPro.enableWordWrapping = false; m_TextMeshPro.fontSize = 36; m_TextMeshPro.isOverlay = true; Set_FrameCounter_Position(AnchorPosition); last_AnchorPosition = AnchorPosition; } void Start() { m_LastInterval = Time.realtimeSinceStartup; m_Frames = 0; } void Update() { if (AnchorPosition != last_AnchorPosition) Set_FrameCounter_Position(AnchorPosition); last_AnchorPosition = AnchorPosition; m_Frames += 1; float timeNow = Time.realtimeSinceStartup; if (timeNow > m_LastInterval + UpdateInterval) { // display two fractional digits (f2 format) float fps = m_Frames / (timeNow - m_LastInterval); float ms = 1000.0f / Mathf.Max(fps, 0.00001f); if (fps < 30) htmlColorTag = "<color=yellow>"; else if (fps < 10) htmlColorTag = "<color=red>"; else htmlColorTag = "<color=green>"; m_TextMeshPro.SetText(htmlColorTag + fpsLabel, fps, ms); m_Frames = 0; m_LastInterval = timeNow; } } void Set_FrameCounter_Position(FpsCounterAnchorPositions anchor_position) { switch (anchor_position) { case FpsCounterAnchorPositions.TopLeft: m_TextMeshPro.alignment = TextAlignmentOptions.TopLeft; m_frameCounter_transform.pivot = new Vector2(0, 1); m_frameCounter_transform.anchorMin = new Vector2(0.01f, 0.99f); m_frameCounter_transform.anchorMax = new Vector2(0.01f, 0.99f); m_frameCounter_transform.anchoredPosition = new Vector2(0, 1); break; case FpsCounterAnchorPositions.BottomLeft: m_TextMeshPro.alignment = TextAlignmentOptions.BottomLeft; m_frameCounter_transform.pivot = new Vector2(0, 0); m_frameCounter_transform.anchorMin = new Vector2(0.01f, 0.01f); m_frameCounter_transform.anchorMax = new Vector2(0.01f, 0.01f); m_frameCounter_transform.anchoredPosition = new Vector2(0, 0); break; case FpsCounterAnchorPositions.TopRight: m_TextMeshPro.alignment = TextAlignmentOptions.TopRight; m_frameCounter_transform.pivot = new Vector2(1, 1); m_frameCounter_transform.anchorMin = new Vector2(0.99f, 0.99f); m_frameCounter_transform.anchorMax = new Vector2(0.99f, 0.99f); m_frameCounter_transform.anchoredPosition = new Vector2(1, 1); break; case FpsCounterAnchorPositions.BottomRight: m_TextMeshPro.alignment = TextAlignmentOptions.BottomRight; m_frameCounter_transform.pivot = new Vector2(1, 0); m_frameCounter_transform.anchorMin = new Vector2(0.99f, 0.01f); m_frameCounter_transform.anchorMax = new Vector2(0.99f, 0.01f); m_frameCounter_transform.anchoredPosition = new Vector2(1, 0); break; } } } }

File no 152: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TMPro_InstructionOverlay.cs
﻿using UnityEngine; using System.Collections; namespace TMPro.Examples { public class TMPro_InstructionOverlay : MonoBehaviour { public enum FpsCounterAnchorPositions { TopLeft, BottomLeft, TopRight, BottomRight }; public FpsCounterAnchorPositions AnchorPosition = FpsCounterAnchorPositions.BottomLeft; private const string instructions = "Camera Control - <#ffff00>Shift + RMB\n</color>Zoom - <#ffff00>Mouse wheel."; private TextMeshPro m_TextMeshPro; private TextContainer m_textContainer; private Transform m_frameCounter_transform; private Camera m_camera; //private FpsCounterAnchorPositions last_AnchorPosition; void Awake() { if (!enabled) return; m_camera = Camera.main; GameObject frameCounter = new GameObject("Frame Counter"); m_frameCounter_transform = frameCounter.transform; m_frameCounter_transform.parent = m_camera.transform; m_frameCounter_transform.localRotation = Quaternion.identity; m_TextMeshPro = frameCounter.AddComponent<TextMeshPro>(); m_TextMeshPro.font = Resources.Load<TMP_FontAsset>("Fonts & Materials/LiberationSans SDF"); m_TextMeshPro.fontSharedMaterial = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - Overlay"); m_TextMeshPro.fontSize = 30; m_TextMeshPro.isOverlay = true; m_textContainer = frameCounter.GetComponent<TextContainer>(); Set_FrameCounter_Position(AnchorPosition); //last_AnchorPosition = AnchorPosition; m_TextMeshPro.text = instructions; } void Set_FrameCounter_Position(FpsCounterAnchorPositions anchor_position) { switch (anchor_position) { case FpsCounterAnchorPositions.TopLeft: //m_TextMeshPro.anchor = AnchorPositions.TopLeft; m_textContainer.anchorPosition = TextContainerAnchors.TopLeft; m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(0, 1, 100.0f)); break; case FpsCounterAnchorPositions.BottomLeft: //m_TextMeshPro.anchor = AnchorPositions.BottomLeft; m_textContainer.anchorPosition = TextContainerAnchors.BottomLeft; m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(0, 0, 100.0f)); break; case FpsCounterAnchorPositions.TopRight: //m_TextMeshPro.anchor = AnchorPositions.TopRight; m_textContainer.anchorPosition = TextContainerAnchors.TopRight; m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(1, 1, 100.0f)); break; case FpsCounterAnchorPositions.BottomRight: //m_TextMeshPro.anchor = AnchorPositions.BottomRight; m_textContainer.anchorPosition = TextContainerAnchors.BottomRight; m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(1, 0, 100.0f)); break; } } } }

File no 153: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TeleType.cs
using UnityEngine; using System.Collections; namespace TMPro.Examples { public class TeleType : MonoBehaviour { //[Range(0, 100)] //public int RevealSpeed = 50; private string label01 = "Example <sprite=2> of using <sprite=7> <#ffa000>Graphics Inline</color> <sprite=5> with Text in <font=\"Bangers SDF\" material=\"Bangers SDF - Drop Shadow\">TextMesh<#40a0ff>Pro</color></font><sprite=0> and Unity<sprite=1>"; private string label02 = "Example <sprite=2> of using <sprite=7> <#ffa000>Graphics Inline</color> <sprite=5> with Text in <font=\"Bangers SDF\" material=\"Bangers SDF - Drop Shadow\">TextMesh<#40a0ff>Pro</color></font><sprite=0> and Unity<sprite=2>"; private TMP_Text m_textMeshPro; void Awake() { // Get Reference to TextMeshPro Component m_textMeshPro = GetComponent<TMP_Text>(); m_textMeshPro.text = label01; m_textMeshPro.enableWordWrapping = true; m_textMeshPro.alignment = TextAlignmentOptions.Top; //if (GetComponentInParent(typeof(Canvas)) as Canvas == null) //{ // GameObject canvas = new GameObject("Canvas", typeof(Canvas)); // gameObject.transform.SetParent(canvas.transform); // canvas.GetComponent<Canvas>().renderMode = RenderMode.ScreenSpaceOverlay; // // Set RectTransform Size // gameObject.GetComponent<RectTransform>().sizeDelta = new Vector2(500, 300); // m_textMeshPro.fontSize = 48; //} } IEnumerator Start() { // Force and update of the mesh to get valid information. m_textMeshPro.ForceMeshUpdate(); int totalVisibleCharacters = m_textMeshPro.textInfo.characterCount; // Get # of Visible Character in text object int counter = 0; int visibleCount = 0; while (true) { visibleCount = counter % (totalVisibleCharacters + 1); m_textMeshPro.maxVisibleCharacters = visibleCount; // How many characters should TextMeshPro display? // Once the last character has been revealed, wait 1.0 second and start over. if (visibleCount >= totalVisibleCharacters) { yield return new WaitForSeconds(1.0f); m_textMeshPro.text = label02; yield return new WaitForSeconds(1.0f); m_textMeshPro.text = label01; yield return new WaitForSeconds(1.0f); } counter += 1; yield return new WaitForSeconds(0.05f); } //Debug.Log("Done revealing the text."); } } }

File no 154: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TextConsoleSimulator.cs
using UnityEngine; using System.Collections; namespace TMPro.Examples { public class TextConsoleSimulator : MonoBehaviour { private TMP_Text m_TextComponent; private bool hasTextChanged; void Awake() { m_TextComponent = gameObject.GetComponent<TMP_Text>(); } void Start() { StartCoroutine(RevealCharacters(m_TextComponent)); //StartCoroutine(RevealWords(m_TextComponent)); } void OnEnable() { // Subscribe to event fired when text object has been regenerated. TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED); } void OnDisable() { TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED); } // Event received when the text object has changed. void ON_TEXT_CHANGED(Object obj) { hasTextChanged = true; } /// <summary> /// Method revealing the text one character at a time. /// </summary> /// <returns></returns> IEnumerator RevealCharacters(TMP_Text textComponent) { textComponent.ForceMeshUpdate(); TMP_TextInfo textInfo = textComponent.textInfo; int totalVisibleCharacters = textInfo.characterCount; // Get # of Visible Character in text object int visibleCount = 0; while (true) { if (hasTextChanged) { totalVisibleCharacters = textInfo.characterCount; // Update visible character count. hasTextChanged = false; } if (visibleCount > totalVisibleCharacters) { yield return new WaitForSeconds(1.0f); visibleCount = 0; } textComponent.maxVisibleCharacters = visibleCount; // How many characters should TextMeshPro display? visibleCount += 1; yield return null; } } /// <summary> /// Method revealing the text one word at a time. /// </summary> /// <returns></returns> IEnumerator RevealWords(TMP_Text textComponent) { textComponent.ForceMeshUpdate(); int totalWordCount = textComponent.textInfo.wordCount; int totalVisibleCharacters = textComponent.textInfo.characterCount; // Get # of Visible Character in text object int counter = 0; int currentWord = 0; int visibleCount = 0; while (true) { currentWord = counter % (totalWordCount + 1); // Get last character index for the current word. if (currentWord == 0) // Display no words. visibleCount = 0; else if (currentWord < totalWordCount) // Display all other words with the exception of the last one. visibleCount = textComponent.textInfo.wordInfo[currentWord - 1].lastCharacterIndex + 1; else if (currentWord == totalWordCount) // Display last word and all remaining characters. visibleCount = totalVisibleCharacters; textComponent.maxVisibleCharacters = visibleCount; // How many characters should TextMeshPro display? // Once the last character has been revealed, wait 1.0 second and start over. if (visibleCount >= totalVisibleCharacters) { yield return new WaitForSeconds(1.0f); } counter += 1; yield return new WaitForSeconds(0.1f); } } } }

File no 155: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TextMeshProFloatingText.cs
using UnityEngine; using System.Collections; namespace TMPro.Examples { public class TextMeshProFloatingText : MonoBehaviour { public Font TheFont; private GameObject m_floatingText; private TextMeshPro m_textMeshPro; private TextMesh m_textMesh; private Transform m_transform; private Transform m_floatingText_Transform; private Transform m_cameraTransform; Vector3 lastPOS = Vector3.zero; Quaternion lastRotation = Quaternion.identity; public int SpawnType; //private int m_frame = 0; void Awake() { m_transform = transform; m_floatingText = new GameObject(this.name + " floating text"); // Reference to Transform is lost when TMP component is added since it replaces it by a RectTransform. //m_floatingText_Transform = m_floatingText.transform; //m_floatingText_Transform.position = m_transform.position + new Vector3(0, 15f, 0); m_cameraTransform = Camera.main.transform; } void Start() { if (SpawnType == 0) { // TextMesh Pro Implementation m_textMeshPro = m_floatingText.AddComponent<TextMeshPro>(); m_textMeshPro.rectTransform.sizeDelta = new Vector2(3, 3); m_floatingText_Transform = m_floatingText.transform; m_floatingText_Transform.position = m_transform.position + new Vector3(0, 15f, 0); //m_textMeshPro.fontAsset = Resources.Load("Fonts & Materials/JOKERMAN SDF", typeof(TextMeshProFont)) as TextMeshProFont; // User should only provide a string to the resource. //m_textMeshPro.fontSharedMaterial = Resources.Load("Fonts & Materials/LiberationSans SDF", typeof(Material)) as Material; m_textMeshPro.alignment = TextAlignmentOptions.Center; m_textMeshPro.color = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), 255); m_textMeshPro.fontSize = 24; //m_textMeshPro.enableExtraPadding = true; //m_textMeshPro.enableShadows = false; m_textMeshPro.enableKerning = false; m_textMeshPro.text = string.Empty; StartCoroutine(DisplayTextMeshProFloatingText()); } else if (SpawnType == 1) { //Debug.Log("Spawning TextMesh Objects."); m_floatingText_Transform = m_floatingText.transform; m_floatingText_Transform.position = m_transform.position + new Vector3(0, 15f, 0); m_textMesh = m_floatingText.AddComponent<TextMesh>(); m_textMesh.font = Resources.Load<Font>("Fonts/ARIAL"); m_textMesh.GetComponent<Renderer>().sharedMaterial = m_textMesh.font.material; m_textMesh.color = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), 255); m_textMesh.anchor = TextAnchor.LowerCenter; m_textMesh.fontSize = 24; StartCoroutine(DisplayTextMeshFloatingText()); } else if (SpawnType == 2) { } } //void Update() //{ // if (SpawnType == 0) // { // m_textMeshPro.SetText("{0}", m_frame); // } // else // { // m_textMesh.text = m_frame.ToString(); // } // m_frame = (m_frame + 1) % 1000; //} public IEnumerator DisplayTextMeshProFloatingText() { float CountDuration = 2.0f; // How long is the countdown alive. float starting_Count = Random.Range(5f, 20f); // At what number is the counter starting at. float current_Count = starting_Count; Vector3 start_pos = m_floatingText_Transform.position; Color32 start_color = m_textMeshPro.color; float alpha = 255; int int_counter = 0; float fadeDuration = 3 / starting_Count * CountDuration; while (current_Count > 0) { current_Count -= (Time.deltaTime / CountDuration) * starting_Count; if (current_Count <= 3) { //Debug.Log("Fading Counter ... " + current_Count.ToString("f2")); alpha = Mathf.Clamp(alpha - (Time.deltaTime / fadeDuration) * 255, 0, 255); } int_counter = (int)current_Count; m_textMeshPro.text = int_counter.ToString(); //m_textMeshPro.SetText("{0}", (int)current_Count); m_textMeshPro.color = new Color32(start_color.r, start_color.g, start_color.b, (byte)alpha); // Move the floating text upward each update m_floatingText_Transform.position += new Vector3(0, starting_Count * Time.deltaTime, 0); // Align floating text perpendicular to Camera. if (!lastPOS.Compare(m_cameraTransform.position, 1000) || !lastRotation.Compare(m_cameraTransform.rotation, 1000)) { lastPOS = m_cameraTransform.position; lastRotation = m_cameraTransform.rotation; m_floatingText_Transform.rotation = lastRotation; Vector3 dir = m_transform.position - lastPOS; m_transform.forward = new Vector3(dir.x, 0, dir.z); } yield return new WaitForEndOfFrame(); } //Debug.Log("Done Counting down."); yield return new WaitForSeconds(Random.Range(0.1f, 1.0f)); m_floatingText_Transform.position = start_pos; StartCoroutine(DisplayTextMeshProFloatingText()); } public IEnumerator DisplayTextMeshFloatingText() { float CountDuration = 2.0f; // How long is the countdown alive. float starting_Count = Random.Range(5f, 20f); // At what number is the counter starting at. float current_Count = starting_Count; Vector3 start_pos = m_floatingText_Transform.position; Color32 start_color = m_textMesh.color; float alpha = 255; int int_counter = 0; float fadeDuration = 3 / starting_Count * CountDuration; while (current_Count > 0) { current_Count -= (Time.deltaTime / CountDuration) * starting_Count; if (current_Count <= 3) { //Debug.Log("Fading Counter ... " + current_Count.ToString("f2")); alpha = Mathf.Clamp(alpha - (Time.deltaTime / fadeDuration) * 255, 0, 255); } int_counter = (int)current_Count; m_textMesh.text = int_counter.ToString(); //Debug.Log("Current Count:" + current_Count.ToString("f2")); m_textMesh.color = new Color32(start_color.r, start_color.g, start_color.b, (byte)alpha); // Move the floating text upward each update m_floatingText_Transform.position += new Vector3(0, starting_Count * Time.deltaTime, 0); // Align floating text perpendicular to Camera. if (!lastPOS.Compare(m_cameraTransform.position, 1000) || !lastRotation.Compare(m_cameraTransform.rotation, 1000)) { lastPOS = m_cameraTransform.position; lastRotation = m_cameraTransform.rotation; m_floatingText_Transform.rotation = lastRotation; Vector3 dir = m_transform.position - lastPOS; m_transform.forward = new Vector3(dir.x, 0, dir.z); } yield return new WaitForEndOfFrame(); } //Debug.Log("Done Counting down."); yield return new WaitForSeconds(Random.Range(0.1f, 1.0f)); m_floatingText_Transform.position = start_pos; StartCoroutine(DisplayTextMeshFloatingText()); } } }

File no 156: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/TextMeshSpawner.cs
using UnityEngine; using System.Collections; namespace TMPro.Examples { public class TextMeshSpawner : MonoBehaviour { public int SpawnType = 0; public int NumberOfNPC = 12; public Font TheFont; private TextMeshProFloatingText floatingText_Script; void Awake() { } void Start() { for (int i = 0; i < NumberOfNPC; i++) { if (SpawnType == 0) { // TextMesh Pro Implementation //go.transform.localScale = new Vector3(2, 2, 2); GameObject go = new GameObject(); //"NPC " + i); go.transform.position = new Vector3(Random.Range(-95f, 95f), 0.5f, Random.Range(-95f, 95f)); //go.transform.position = new Vector3(0, 1.01f, 0); //go.renderer.castShadows = false; //go.renderer.receiveShadows = false; //go.transform.rotation = Quaternion.Euler(0, Random.Range(0, 360), 0); TextMeshPro textMeshPro = go.AddComponent<TextMeshPro>(); //textMeshPro.FontAsset = Resources.Load("Fonts & Materials/LiberationSans SDF", typeof(TextMeshProFont)) as TextMeshProFont; //textMeshPro.anchor = AnchorPositions.Bottom; textMeshPro.fontSize = 96; textMeshPro.text = "!"; textMeshPro.color = new Color32(255, 255, 0, 255); //textMeshPro.Text = "!"; // Spawn Floating Text floatingText_Script = go.AddComponent<TextMeshProFloatingText>(); floatingText_Script.SpawnType = 0; } else { // TextMesh Implementation GameObject go = new GameObject(); //"NPC " + i); go.transform.position = new Vector3(Random.Range(-95f, 95f), 0.5f, Random.Range(-95f, 95f)); //go.transform.position = new Vector3(0, 1.01f, 0); TextMesh textMesh = go.AddComponent<TextMesh>(); textMesh.GetComponent<Renderer>().sharedMaterial = TheFont.material; textMesh.font = TheFont; textMesh.anchor = TextAnchor.LowerCenter; textMesh.fontSize = 96; textMesh.color = new Color32(255, 255, 0, 255); textMesh.text = "!"; // Spawn Floating Text floatingText_Script = go.AddComponent<TextMeshProFloatingText>(); floatingText_Script.SpawnType = 1; } } } } }

File no 157: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/VertexColorCycler.cs
﻿using UnityEngine; using System.Collections; namespace TMPro.Examples { public class VertexColorCycler : MonoBehaviour { private TMP_Text m_TextComponent; void Awake() { m_TextComponent = GetComponent<TMP_Text>(); } void Start() { StartCoroutine(AnimateVertexColors()); } /// <summary> /// Method to animate vertex colors of a TMP Text object. /// </summary> /// <returns></returns> IEnumerator AnimateVertexColors() { // Force the text object to update right away so we can have geometry to modify right from the start. m_TextComponent.ForceMeshUpdate(); TMP_TextInfo textInfo = m_TextComponent.textInfo; int currentCharacter = 0; Color32[] newVertexColors; Color32 c0 = m_TextComponent.color; while (true) { int characterCount = textInfo.characterCount; // If No Characters then just yield and wait for some text to be added if (characterCount == 0) { yield return new WaitForSeconds(0.25f); continue; } // Get the index of the material used by the current character. int materialIndex = textInfo.characterInfo[currentCharacter].materialReferenceIndex; // Get the vertex colors of the mesh used by this text element (character or sprite). newVertexColors = textInfo.meshInfo[materialIndex].colors32; // Get the index of the first vertex used by this text element. int vertexIndex = textInfo.characterInfo[currentCharacter].vertexIndex; // Only change the vertex color if the text element is visible. if (textInfo.characterInfo[currentCharacter].isVisible) { c0 = new Color32((byte)Random.Range(0, 255), (byte)Random.Range(0, 255), (byte)Random.Range(0, 255), 255); newVertexColors[vertexIndex + 0] = c0; newVertexColors[vertexIndex + 1] = c0; newVertexColors[vertexIndex + 2] = c0; newVertexColors[vertexIndex + 3] = c0; // New function which pushes (all) updated vertex data to the appropriate meshes when using either the Mesh Renderer or CanvasRenderer. m_TextComponent.UpdateVertexData(TMP_VertexDataUpdateFlags.Colors32); // This last process could be done to only update the vertex data that has changed as opposed to all of the vertex data but it would require extra steps and knowing what type of renderer is used. // These extra steps would be a performance optimization but it is unlikely that such optimization will be necessary. } currentCharacter = (currentCharacter + 1) % characterCount; yield return new WaitForSeconds(0.05f); } } } }

File no 158: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/VertexJitter.cs
﻿using UnityEngine; using System.Collections; namespace TMPro.Examples { public class VertexJitter : MonoBehaviour { public float AngleMultiplier = 1.0f; public float SpeedMultiplier = 1.0f; public float CurveScale = 1.0f; private TMP_Text m_TextComponent; private bool hasTextChanged; /// <summary> /// Structure to hold pre-computed animation data. /// </summary> private struct VertexAnim { public float angleRange; public float angle; public float speed; } void Awake() { m_TextComponent = GetComponent<TMP_Text>(); } void OnEnable() { // Subscribe to event fired when text object has been regenerated. TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED); } void OnDisable() { TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED); } void Start() { StartCoroutine(AnimateVertexColors()); } void ON_TEXT_CHANGED(Object obj) { if (obj == m_TextComponent) hasTextChanged = true; } /// <summary> /// Method to animate vertex colors of a TMP Text object. /// </summary> /// <returns></returns> IEnumerator AnimateVertexColors() { // We force an update of the text object since it would only be updated at the end of the frame. Ie. before this code is executed on the first frame. // Alternatively, we could yield and wait until the end of the frame when the text object will be generated. m_TextComponent.ForceMeshUpdate(); TMP_TextInfo textInfo = m_TextComponent.textInfo; Matrix4x4 matrix; int loopCount = 0; hasTextChanged = true; // Create an Array which contains pre-computed Angle Ranges and Speeds for a bunch of characters. VertexAnim[] vertexAnim = new VertexAnim[1024]; for (int i = 0; i < 1024; i++) { vertexAnim[i].angleRange = Random.Range(10f, 25f); vertexAnim[i].speed = Random.Range(1f, 3f); } // Cache the vertex data of the text object as the Jitter FX is applied to the original position of the characters. TMP_MeshInfo[] cachedMeshInfo = textInfo.CopyMeshInfoVertexData(); while (true) { // Get new copy of vertex data if the text has changed. if (hasTextChanged) { // Update the copy of the vertex data for the text object. cachedMeshInfo = textInfo.CopyMeshInfoVertexData(); hasTextChanged = false; } int characterCount = textInfo.characterCount; // If No Characters then just yield and wait for some text to be added if (characterCount == 0) { yield return new WaitForSeconds(0.25f); continue; } for (int i = 0; i < characterCount; i++) { TMP_CharacterInfo charInfo = textInfo.characterInfo[i]; // Skip characters that are not visible and thus have no geometry to manipulate. if (!charInfo.isVisible) continue; // Retrieve the pre-computed animation data for the given character. VertexAnim vertAnim = vertexAnim[i]; // Get the index of the material used by the current character. int materialIndex = textInfo.characterInfo[i].materialReferenceIndex; // Get the index of the first vertex used by this text element. int vertexIndex = textInfo.characterInfo[i].vertexIndex; // Get the cached vertices of the mesh used by this text element (character or sprite). Vector3[] sourceVertices = cachedMeshInfo[materialIndex].vertices; // Determine the center point of each character at the baseline. //Vector2 charMidBasline = new Vector2((sourceVertices[vertexIndex + 0].x + sourceVertices[vertexIndex + 2].x) / 2, charInfo.baseLine); // Determine the center point of each character. Vector2 charMidBasline = (sourceVertices[vertexIndex + 0] + sourceVertices[vertexIndex + 2]) / 2; // Need to translate all 4 vertices of each quad to aligned with middle of character / baseline. // This is needed so the matrix TRS is applied at the origin for each character. Vector3 offset = charMidBasline; Vector3[] destinationVertices = textInfo.meshInfo[materialIndex].vertices; destinationVertices[vertexIndex + 0] = sourceVertices[vertexIndex + 0] - offset; destinationVertices[vertexIndex + 1] = sourceVertices[vertexIndex + 1] - offset; destinationVertices[vertexIndex + 2] = sourceVertices[vertexIndex + 2] - offset; destinationVertices[vertexIndex + 3] = sourceVertices[vertexIndex + 3] - offset; vertAnim.angle = Mathf.SmoothStep(-vertAnim.angleRange, vertAnim.angleRange, Mathf.PingPong(loopCount / 25f * vertAnim.speed, 1f)); Vector3 jitterOffset = new Vector3(Random.Range(-.25f, .25f), Random.Range(-.25f, .25f), 0); matrix = Matrix4x4.TRS(jitterOffset * CurveScale, Quaternion.Euler(0, 0, Random.Range(-5f, 5f) * AngleMultiplier), Vector3.one); destinationVertices[vertexIndex + 0] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 0]); destinationVertices[vertexIndex + 1] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 1]); destinationVertices[vertexIndex + 2] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 2]); destinationVertices[vertexIndex + 3] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 3]); destinationVertices[vertexIndex + 0] += offset; destinationVertices[vertexIndex + 1] += offset; destinationVertices[vertexIndex + 2] += offset; destinationVertices[vertexIndex + 3] += offset; vertexAnim[i] = vertAnim; } // Push changes into meshes for (int i = 0; i < textInfo.meshInfo.Length; i++) { textInfo.meshInfo[i].mesh.vertices = textInfo.meshInfo[i].vertices; m_TextComponent.UpdateGeometry(textInfo.meshInfo[i].mesh, i); } loopCount += 1; yield return new WaitForSeconds(0.1f); } } } }

File no 159: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/VertexShakeA.cs
﻿using UnityEngine; using System.Collections; namespace TMPro.Examples { public class VertexShakeA : MonoBehaviour { public float AngleMultiplier = 1.0f; public float SpeedMultiplier = 1.0f; public float ScaleMultiplier = 1.0f; public float RotationMultiplier = 1.0f; private TMP_Text m_TextComponent; private bool hasTextChanged; void Awake() { m_TextComponent = GetComponent<TMP_Text>(); } void OnEnable() { // Subscribe to event fired when text object has been regenerated. TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED); } void OnDisable() { TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED); } void Start() { StartCoroutine(AnimateVertexColors()); } void ON_TEXT_CHANGED(Object obj) { if (obj = m_TextComponent) hasTextChanged = true; } /// <summary> /// Method to animate vertex colors of a TMP Text object. /// </summary> /// <returns></returns> IEnumerator AnimateVertexColors() { // We force an update of the text object since it would only be updated at the end of the frame. Ie. before this code is executed on the first frame. // Alternatively, we could yield and wait until the end of the frame when the text object will be generated. m_TextComponent.ForceMeshUpdate(); TMP_TextInfo textInfo = m_TextComponent.textInfo; Matrix4x4 matrix; Vector3[][] copyOfVertices = new Vector3[0][]; hasTextChanged = true; while (true) { // Allocate new vertices if (hasTextChanged) { if (copyOfVertices.Length < textInfo.meshInfo.Length) copyOfVertices = new Vector3[textInfo.meshInfo.Length][]; for (int i = 0; i < textInfo.meshInfo.Length; i++) { int length = textInfo.meshInfo[i].vertices.Length; copyOfVertices[i] = new Vector3[length]; } hasTextChanged = false; } int characterCount = textInfo.characterCount; // If No Characters then just yield and wait for some text to be added if (characterCount == 0) { yield return new WaitForSeconds(0.25f); continue; } int lineCount = textInfo.lineCount; // Iterate through each line of the text. for (int i = 0; i < lineCount; i++) { int first = textInfo.lineInfo[i].firstCharacterIndex; int last = textInfo.lineInfo[i].lastCharacterIndex; // Determine the center of each line Vector3 centerOfLine = (textInfo.characterInfo[first].bottomLeft + textInfo.characterInfo[last].topRight) / 2; Quaternion rotation = Quaternion.Euler(0, 0, Random.Range(-0.25f, 0.25f) * RotationMultiplier); // Iterate through each character of the line. for (int j = first; j <= last; j++) { // Skip characters that are not visible and thus have no geometry to manipulate. if (!textInfo.characterInfo[j].isVisible) continue; // Get the index of the material used by the current character. int materialIndex = textInfo.characterInfo[j].materialReferenceIndex; // Get the index of the first vertex used by this text element. int vertexIndex = textInfo.characterInfo[j].vertexIndex; // Get the vertices of the mesh used by this text element (character or sprite). Vector3[] sourceVertices = textInfo.meshInfo[materialIndex].vertices; // Need to translate all 4 vertices of each quad to aligned with center of character. // This is needed so the matrix TRS is applied at the origin for each character. copyOfVertices[materialIndex][vertexIndex + 0] = sourceVertices[vertexIndex + 0] - centerOfLine; copyOfVertices[materialIndex][vertexIndex + 1] = sourceVertices[vertexIndex + 1] - centerOfLine; copyOfVertices[materialIndex][vertexIndex + 2] = sourceVertices[vertexIndex + 2] - centerOfLine; copyOfVertices[materialIndex][vertexIndex + 3] = sourceVertices[vertexIndex + 3] - centerOfLine; // Determine the random scale change for each character. float randomScale = Random.Range(0.995f - 0.001f * ScaleMultiplier, 1.005f + 0.001f * ScaleMultiplier); // Setup the matrix rotation. matrix = Matrix4x4.TRS(Vector3.one, rotation, Vector3.one * randomScale); // Apply the matrix TRS to the individual characters relative to the center of the current line. copyOfVertices[materialIndex][vertexIndex + 0] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 0]); copyOfVertices[materialIndex][vertexIndex + 1] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 1]); copyOfVertices[materialIndex][vertexIndex + 2] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 2]); copyOfVertices[materialIndex][vertexIndex + 3] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 3]); // Revert the translation change. copyOfVertices[materialIndex][vertexIndex + 0] += centerOfLine; copyOfVertices[materialIndex][vertexIndex + 1] += centerOfLine; copyOfVertices[materialIndex][vertexIndex + 2] += centerOfLine; copyOfVertices[materialIndex][vertexIndex + 3] += centerOfLine; } } // Push changes into meshes for (int i = 0; i < textInfo.meshInfo.Length; i++) { textInfo.meshInfo[i].mesh.vertices = copyOfVertices[i]; m_TextComponent.UpdateGeometry(textInfo.meshInfo[i].mesh, i); } yield return new WaitForSeconds(0.1f); } } } }

File no 160: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/VertexShakeB.cs
﻿using UnityEngine; using System.Collections; namespace TMPro.Examples { public class VertexShakeB : MonoBehaviour { public float AngleMultiplier = 1.0f; public float SpeedMultiplier = 1.0f; public float CurveScale = 1.0f; private TMP_Text m_TextComponent; private bool hasTextChanged; void Awake() { m_TextComponent = GetComponent<TMP_Text>(); } void OnEnable() { // Subscribe to event fired when text object has been regenerated. TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED); } void OnDisable() { TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED); } void Start() { StartCoroutine(AnimateVertexColors()); } void ON_TEXT_CHANGED(Object obj) { if (obj = m_TextComponent) hasTextChanged = true; } /// <summary> /// Method to animate vertex colors of a TMP Text object. /// </summary> /// <returns></returns> IEnumerator AnimateVertexColors() { // We force an update of the text object since it would only be updated at the end of the frame. Ie. before this code is executed on the first frame. // Alternatively, we could yield and wait until the end of the frame when the text object will be generated. m_TextComponent.ForceMeshUpdate(); TMP_TextInfo textInfo = m_TextComponent.textInfo; Matrix4x4 matrix; Vector3[][] copyOfVertices = new Vector3[0][]; hasTextChanged = true; while (true) { // Allocate new vertices if (hasTextChanged) { if (copyOfVertices.Length < textInfo.meshInfo.Length) copyOfVertices = new Vector3[textInfo.meshInfo.Length][]; for (int i = 0; i < textInfo.meshInfo.Length; i++) { int length = textInfo.meshInfo[i].vertices.Length; copyOfVertices[i] = new Vector3[length]; } hasTextChanged = false; } int characterCount = textInfo.characterCount; // If No Characters then just yield and wait for some text to be added if (characterCount == 0) { yield return new WaitForSeconds(0.25f); continue; } int lineCount = textInfo.lineCount; // Iterate through each line of the text. for (int i = 0; i < lineCount; i++) { int first = textInfo.lineInfo[i].firstCharacterIndex; int last = textInfo.lineInfo[i].lastCharacterIndex; // Determine the center of each line Vector3 centerOfLine = (textInfo.characterInfo[first].bottomLeft + textInfo.characterInfo[last].topRight) / 2; Quaternion rotation = Quaternion.Euler(0, 0, Random.Range(-0.25f, 0.25f)); // Iterate through each character of the line. for (int j = first; j <= last; j++) { // Skip characters that are not visible and thus have no geometry to manipulate. if (!textInfo.characterInfo[j].isVisible) continue; // Get the index of the material used by the current character. int materialIndex = textInfo.characterInfo[j].materialReferenceIndex; // Get the index of the first vertex used by this text element. int vertexIndex = textInfo.characterInfo[j].vertexIndex; // Get the vertices of the mesh used by this text element (character or sprite). Vector3[] sourceVertices = textInfo.meshInfo[materialIndex].vertices; // Determine the center point of each character at the baseline. Vector3 charCenter = (sourceVertices[vertexIndex + 0] + sourceVertices[vertexIndex + 2]) / 2; // Need to translate all 4 vertices of each quad to aligned with center of character. // This is needed so the matrix TRS is applied at the origin for each character. copyOfVertices[materialIndex][vertexIndex + 0] = sourceVertices[vertexIndex + 0] - charCenter; copyOfVertices[materialIndex][vertexIndex + 1] = sourceVertices[vertexIndex + 1] - charCenter; copyOfVertices[materialIndex][vertexIndex + 2] = sourceVertices[vertexIndex + 2] - charCenter; copyOfVertices[materialIndex][vertexIndex + 3] = sourceVertices[vertexIndex + 3] - charCenter; // Determine the random scale change for each character. float randomScale = Random.Range(0.95f, 1.05f); // Setup the matrix for the scale change. matrix = Matrix4x4.TRS(Vector3.one, Quaternion.identity, Vector3.one * randomScale); // Apply the scale change relative to the center of each character. copyOfVertices[materialIndex][vertexIndex + 0] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 0]); copyOfVertices[materialIndex][vertexIndex + 1] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 1]); copyOfVertices[materialIndex][vertexIndex + 2] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 2]); copyOfVertices[materialIndex][vertexIndex + 3] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 3]); // Revert the translation change. copyOfVertices[materialIndex][vertexIndex + 0] += charCenter; copyOfVertices[materialIndex][vertexIndex + 1] += charCenter; copyOfVertices[materialIndex][vertexIndex + 2] += charCenter; copyOfVertices[materialIndex][vertexIndex + 3] += charCenter; // Need to translate all 4 vertices of each quad to aligned with the center of the line. // This is needed so the matrix TRS is applied from the center of the line. copyOfVertices[materialIndex][vertexIndex + 0] -= centerOfLine; copyOfVertices[materialIndex][vertexIndex + 1] -= centerOfLine; copyOfVertices[materialIndex][vertexIndex + 2] -= centerOfLine; copyOfVertices[materialIndex][vertexIndex + 3] -= centerOfLine; // Setup the matrix rotation. matrix = Matrix4x4.TRS(Vector3.one, rotation, Vector3.one); // Apply the matrix TRS to the individual characters relative to the center of the current line. copyOfVertices[materialIndex][vertexIndex + 0] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 0]); copyOfVertices[materialIndex][vertexIndex + 1] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 1]); copyOfVertices[materialIndex][vertexIndex + 2] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 2]); copyOfVertices[materialIndex][vertexIndex + 3] = matrix.MultiplyPoint3x4(copyOfVertices[materialIndex][vertexIndex + 3]); // Revert the translation change. copyOfVertices[materialIndex][vertexIndex + 0] += centerOfLine; copyOfVertices[materialIndex][vertexIndex + 1] += centerOfLine; copyOfVertices[materialIndex][vertexIndex + 2] += centerOfLine; copyOfVertices[materialIndex][vertexIndex + 3] += centerOfLine; } } // Push changes into meshes for (int i = 0; i < textInfo.meshInfo.Length; i++) { textInfo.meshInfo[i].mesh.vertices = copyOfVertices[i]; m_TextComponent.UpdateGeometry(textInfo.meshInfo[i].mesh, i); } yield return new WaitForSeconds(0.1f); } } } }

File no 161: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/VertexZoom.cs
﻿using UnityEngine; using System.Linq; using System.Collections; using System.Collections.Generic; namespace TMPro.Examples { public class VertexZoom : MonoBehaviour { public float AngleMultiplier = 1.0f; public float SpeedMultiplier = 1.0f; public float CurveScale = 1.0f; private TMP_Text m_TextComponent; private bool hasTextChanged; void Awake() { m_TextComponent = GetComponent<TMP_Text>(); } void OnEnable() { // Subscribe to event fired when text object has been regenerated. TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED); } void OnDisable() { // UnSubscribe to event fired when text object has been regenerated. TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED); } void Start() { StartCoroutine(AnimateVertexColors()); } void ON_TEXT_CHANGED(Object obj) { if (obj == m_TextComponent) hasTextChanged = true; } /// <summary> /// Method to animate vertex colors of a TMP Text object. /// </summary> /// <returns></returns> IEnumerator AnimateVertexColors() { // We force an update of the text object since it would only be updated at the end of the frame. Ie. before this code is executed on the first frame. // Alternatively, we could yield and wait until the end of the frame when the text object will be generated. m_TextComponent.ForceMeshUpdate(); TMP_TextInfo textInfo = m_TextComponent.textInfo; Matrix4x4 matrix; TMP_MeshInfo[] cachedMeshInfoVertexData = textInfo.CopyMeshInfoVertexData(); // Allocations for sorting of the modified scales List<float> modifiedCharScale = new List<float>(); List<int> scaleSortingOrder = new List<int>(); hasTextChanged = true; while (true) { // Allocate new vertices if (hasTextChanged) { // Get updated vertex data cachedMeshInfoVertexData = textInfo.CopyMeshInfoVertexData(); hasTextChanged = false; } int characterCount = textInfo.characterCount; // If No Characters then just yield and wait for some text to be added if (characterCount == 0) { yield return new WaitForSeconds(0.25f); continue; } // Clear list of character scales modifiedCharScale.Clear(); scaleSortingOrder.Clear(); for (int i = 0; i < characterCount; i++) { TMP_CharacterInfo charInfo = textInfo.characterInfo[i]; // Skip characters that are not visible and thus have no geometry to manipulate. if (!charInfo.isVisible) continue; // Get the index of the material used by the current character. int materialIndex = textInfo.characterInfo[i].materialReferenceIndex; // Get the index of the first vertex used by this text element. int vertexIndex = textInfo.characterInfo[i].vertexIndex; // Get the cached vertices of the mesh used by this text element (character or sprite). Vector3[] sourceVertices = cachedMeshInfoVertexData[materialIndex].vertices; // Determine the center point of each character at the baseline. //Vector2 charMidBasline = new Vector2((sourceVertices[vertexIndex + 0].x + sourceVertices[vertexIndex + 2].x) / 2, charInfo.baseLine); // Determine the center point of each character. Vector2 charMidBasline = (sourceVertices[vertexIndex + 0] + sourceVertices[vertexIndex + 2]) / 2; // Need to translate all 4 vertices of each quad to aligned with middle of character / baseline. // This is needed so the matrix TRS is applied at the origin for each character. Vector3 offset = charMidBasline; Vector3[] destinationVertices = textInfo.meshInfo[materialIndex].vertices; destinationVertices[vertexIndex + 0] = sourceVertices[vertexIndex + 0] - offset; destinationVertices[vertexIndex + 1] = sourceVertices[vertexIndex + 1] - offset; destinationVertices[vertexIndex + 2] = sourceVertices[vertexIndex + 2] - offset; destinationVertices[vertexIndex + 3] = sourceVertices[vertexIndex + 3] - offset; //Vector3 jitterOffset = new Vector3(Random.Range(-.25f, .25f), Random.Range(-.25f, .25f), 0); // Determine the random scale change for each character. float randomScale = Random.Range(1f, 1.5f); // Add modified scale and index modifiedCharScale.Add(randomScale); scaleSortingOrder.Add(modifiedCharScale.Count - 1); // Setup the matrix for the scale change. //matrix = Matrix4x4.TRS(jitterOffset, Quaternion.Euler(0, 0, Random.Range(-5f, 5f)), Vector3.one * randomScale); matrix = Matrix4x4.TRS(new Vector3(0, 0, 0), Quaternion.identity, Vector3.one * randomScale); destinationVertices[vertexIndex + 0] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 0]); destinationVertices[vertexIndex + 1] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 1]); destinationVertices[vertexIndex + 2] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 2]); destinationVertices[vertexIndex + 3] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 3]); destinationVertices[vertexIndex + 0] += offset; destinationVertices[vertexIndex + 1] += offset; destinationVertices[vertexIndex + 2] += offset; destinationVertices[vertexIndex + 3] += offset; // Restore Source UVS which have been modified by the sorting Vector2[] sourceUVs0 = cachedMeshInfoVertexData[materialIndex].uvs0; Vector2[] destinationUVs0 = textInfo.meshInfo[materialIndex].uvs0; destinationUVs0[vertexIndex + 0] = sourceUVs0[vertexIndex + 0]; destinationUVs0[vertexIndex + 1] = sourceUVs0[vertexIndex + 1]; destinationUVs0[vertexIndex + 2] = sourceUVs0[vertexIndex + 2]; destinationUVs0[vertexIndex + 3] = sourceUVs0[vertexIndex + 3]; // Restore Source Vertex Colors Color32[] sourceColors32 = cachedMeshInfoVertexData[materialIndex].colors32; Color32[] destinationColors32 = textInfo.meshInfo[materialIndex].colors32; destinationColors32[vertexIndex + 0] = sourceColors32[vertexIndex + 0]; destinationColors32[vertexIndex + 1] = sourceColors32[vertexIndex + 1]; destinationColors32[vertexIndex + 2] = sourceColors32[vertexIndex + 2]; destinationColors32[vertexIndex + 3] = sourceColors32[vertexIndex + 3]; } // Push changes into meshes for (int i = 0; i < textInfo.meshInfo.Length; i++) { //// Sort Quads based modified scale scaleSortingOrder.Sort((a, b) => modifiedCharScale[a].CompareTo(modifiedCharScale[b])); textInfo.meshInfo[i].SortGeometry(scaleSortingOrder); // Updated modified vertex attributes textInfo.meshInfo[i].mesh.vertices = textInfo.meshInfo[i].vertices; textInfo.meshInfo[i].mesh.uv = textInfo.meshInfo[i].uvs0; textInfo.meshInfo[i].mesh.colors32 = textInfo.meshInfo[i].colors32; m_TextComponent.UpdateGeometry(textInfo.meshInfo[i].mesh, i); } yield return new WaitForSeconds(0.1f); } } } }

File no 162: /colame/Assets/TextMesh Pro/Examples & Extras/Scripts/WarpTextExample.cs
﻿using UnityEngine; using System.Collections; namespace TMPro.Examples { public class WarpTextExample : MonoBehaviour { private TMP_Text m_TextComponent; public AnimationCurve VertexCurve = new AnimationCurve(new Keyframe(0, 0), new Keyframe(0.25f, 2.0f), new Keyframe(0.5f, 0), new Keyframe(0.75f, 2.0f), new Keyframe(1, 0f)); public float AngleMultiplier = 1.0f; public float SpeedMultiplier = 1.0f; public float CurveScale = 1.0f; void Awake() { m_TextComponent = gameObject.GetComponent<TMP_Text>(); } void Start() { StartCoroutine(WarpText()); } private AnimationCurve CopyAnimationCurve(AnimationCurve curve) { AnimationCurve newCurve = new AnimationCurve(); newCurve.keys = curve.keys; return newCurve; } /// <summary> /// Method to curve text along a Unity animation curve. /// </summary> /// <param name="textComponent"></param> /// <returns></returns> IEnumerator WarpText() { VertexCurve.preWrapMode = WrapMode.Clamp; VertexCurve.postWrapMode = WrapMode.Clamp; //Mesh mesh = m_TextComponent.textInfo.meshInfo[0].mesh; Vector3[] vertices; Matrix4x4 matrix; m_TextComponent.havePropertiesChanged = true; // Need to force the TextMeshPro Object to be updated. CurveScale *= 10; float old_CurveScale = CurveScale; AnimationCurve old_curve = CopyAnimationCurve(VertexCurve); while (true) { if (!m_TextComponent.havePropertiesChanged && old_CurveScale == CurveScale && old_curve.keys[1].value == VertexCurve.keys[1].value) { yield return null; continue; } old_CurveScale = CurveScale; old_curve = CopyAnimationCurve(VertexCurve); m_TextComponent.ForceMeshUpdate(); // Generate the mesh and populate the textInfo with data we can use and manipulate. TMP_TextInfo textInfo = m_TextComponent.textInfo; int characterCount = textInfo.characterCount; if (characterCount == 0) continue; //vertices = textInfo.meshInfo[0].vertices; //int lastVertexIndex = textInfo.characterInfo[characterCount - 1].vertexIndex; float boundsMinX = m_TextComponent.bounds.min.x; //textInfo.meshInfo[0].mesh.bounds.min.x; float boundsMaxX = m_TextComponent.bounds.max.x; //textInfo.meshInfo[0].mesh.bounds.max.x; for (int i = 0; i < characterCount; i++) { if (!textInfo.characterInfo[i].isVisible) continue; int vertexIndex = textInfo.characterInfo[i].vertexIndex; // Get the index of the mesh used by this character. int materialIndex = textInfo.characterInfo[i].materialReferenceIndex; vertices = textInfo.meshInfo[materialIndex].vertices; // Compute the baseline mid point for each character Vector3 offsetToMidBaseline = new Vector2((vertices[vertexIndex + 0].x + vertices[vertexIndex + 2].x) / 2, textInfo.characterInfo[i].baseLine); //float offsetY = VertexCurve.Evaluate((float)i / characterCount + loopCount / 50f); // Random.Range(-0.25f, 0.25f); // Apply offset to adjust our pivot point. vertices[vertexIndex + 0] += -offsetToMidBaseline; vertices[vertexIndex + 1] += -offsetToMidBaseline; vertices[vertexIndex + 2] += -offsetToMidBaseline; vertices[vertexIndex + 3] += -offsetToMidBaseline; // Compute the angle of rotation for each character based on the animation curve float x0 = (offsetToMidBaseline.x - boundsMinX) / (boundsMaxX - boundsMinX); // Character's position relative to the bounds of the mesh. float x1 = x0 + 0.0001f; float y0 = VertexCurve.Evaluate(x0) * CurveScale; float y1 = VertexCurve.Evaluate(x1) * CurveScale; Vector3 horizontal = new Vector3(1, 0, 0); //Vector3 normal = new Vector3(-(y1 - y0), (x1 * (boundsMaxX - boundsMinX) + boundsMinX) - offsetToMidBaseline.x, 0); Vector3 tangent = new Vector3(x1 * (boundsMaxX - boundsMinX) + boundsMinX, y1) - new Vector3(offsetToMidBaseline.x, y0); float dot = Mathf.Acos(Vector3.Dot(horizontal, tangent.normalized)) * 57.2957795f; Vector3 cross = Vector3.Cross(horizontal, tangent); float angle = cross.z > 0 ? dot : 360 - dot; matrix = Matrix4x4.TRS(new Vector3(0, y0, 0), Quaternion.Euler(0, 0, angle), Vector3.one); vertices[vertexIndex + 0] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 0]); vertices[vertexIndex + 1] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 1]); vertices[vertexIndex + 2] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 2]); vertices[vertexIndex + 3] = matrix.MultiplyPoint3x4(vertices[vertexIndex + 3]); vertices[vertexIndex + 0] += offsetToMidBaseline; vertices[vertexIndex + 1] += offsetToMidBaseline; vertices[vertexIndex + 2] += offsetToMidBaseline; vertices[vertexIndex + 3] += offsetToMidBaseline; } // Upload the mesh with the revised information m_TextComponent.UpdateVertexData(); yield return new WaitForSeconds(0.025f); } } } }

File no 163: /colame/Assets/TextMesh Pro/Fonts/LiberationSans - OFL.txt
Digitized data copyright (c) 2010 Google Corporation with Reserved Font Arimo, Tinos and Cousine. Copyright (c) 2012 Red Hat, Inc. with Reserved Font Name Liberation. This Font Software is licensed under the SIL Open Font License, Version 1.1. This license is copied below, and is also available with a FAQ at: http://scripts.sil.org/OFL ----------------------------------------------------------- SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007 ----------------------------------------------------------- PREAMBLE The goals of the Open Font License (OFL) are to stimulate worldwide development of collaborative font projects, to support the font creation efforts of academic and linguistic communities, and to provide a free and open framework in which fonts may be shared and improved in partnership with others. The OFL allows the licensed fonts to be used, studied, modified and redistributed freely as long as they are not sold by themselves. The fonts, including any derivative works, can be bundled, embedded, redistributed and/or sold with any software provided that any reserved names are not used by derivative works. The fonts and derivatives, however, cannot be released under any other type of license. The requirement for fonts to remain under this license does not apply to any document created using the fonts or their derivatives. DEFINITIONS "Font Software" refers to the set of files released by the Copyright Holder(s) under this license and clearly marked as such. This may include source files, build scripts and documentation. "Reserved Font Name" refers to any names specified as such after the copyright statement(s). "Original Version" refers to the collection of Font Software components as distributed by the Copyright Holder(s). "Modified Version" refers to any derivative made by adding to, deleting, or substituting -- in part or in whole -- any of the components of the Original Version, by changing formats or by porting the Font Software to a new environment. "Author" refers to any designer, engineer, programmer, technical writer or other person who contributed to the Font Software. PERMISSION & CONDITIONS Permission is hereby granted, free of charge, to any person obtaining a copy of the Font Software, to use, study, copy, merge, embed, modify, redistribute, and sell modified and unmodified copies of the Font Software, subject to the following conditions: 1) Neither the Font Software nor any of its individual components, in Original or Modified Versions, may be sold by itself. 2) Original or Modified Versions of the Font Software may be bundled, redistributed and/or sold with any software, provided that each copy contains the above copyright notice and this license. These can be included either as stand-alone text files, human-readable headers or in the appropriate machine-readable metadata fields within text or binary files as long as those fields can be easily viewed by the user. 3) No Modified Version of the Font Software may use the Reserved Font Name(s) unless explicit written permission is granted by the corresponding Copyright Holder. This restriction only applies to the primary font name as presented to the users. 4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font Software shall not be used to promote, endorse or advertise any Modified Version, except to acknowledge the contribution(s) of the Copyright Holder(s) and the Author(s) or with their explicit written permission. 5) The Font Software, modified or unmodified, in part or in whole, must be distributed entirely under this license, and must not be distributed under any other license. The requirement for fonts to remain under this license does not apply to any document created using the Font Software. TERMINATION This license becomes null and void if any of the above conditions are not met. DISCLAIMER THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.

File no 164: /colame/Assets/TextMesh Pro/Resources/LineBreaking Following Characters.txt
﻿)]｝〕〉》」』】〙〗〟’”｠»ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻‐゠–〜?!‼⁇⁈⁉・、%,.:;。！？］）：；＝}¢°"†‡℃〆％，．

File no 165: /colame/Assets/TextMesh Pro/Resources/LineBreaking Leading Characters.txt
﻿([｛〔〈《「『【〘〖〝‘“｟«$—…‥〳〴〵\［（{£¥"々〇〉》」＄｠￥￦ #

File no 166: /colame/Assets/TextMesh Pro/Sprites/EmojiOne Attribution.txt
This sample of beautiful emojis are provided by EmojiOne https://www.emojione.com/ Please visit their website to view the complete set of their emojis and review their licensing terms.

File no 167: /colame/Assets/TextMesh Pro/Sprites/EmojiOne.json
{"frames": [ { "filename": "1f60a.png", "frame": {"x":0,"y":0,"w":128,"h":128}, "rotated": false, "trimmed": false, "spriteSourceSize": {"x":0,"y":0,"w":128,"h":128}, "sourceSize": {"w":128,"h":128}, "pivot": {"x":0.5,"y":0.5} }, { "filename": "1f60b.png", "frame": {"x":128,"y":0,"w":128,"h":128}, "rotated": false, "trimmed": false, "spriteSourceSize": {"x":0,"y":0,"w":128,"h":128}, "sourceSize": {"w":128,"h":128}, "pivot": {"x":0.5,"y":0.5} }, { "filename": "1f60d.png", "frame": {"x":256,"y":0,"w":128,"h":128}, "rotated": false, "trimmed": false, "spriteSourceSize": {"x":0,"y":0,"w":128,"h":128}, "sourceSize": {"w":128,"h":128}, "pivot": {"x":0.5,"y":0.5} }, { "filename": "1f60e.png", "frame": {"x":384,"y":0,"w":128,"h":128}, "rotated": false, "trimmed": false, "spriteSourceSize": {"x":0,"y":0,"w":128,"h":128}, "sourceSize": {"w":128,"h":128}, "pivot": {"x":0.5,"y":0.5} }, { "filename": "1f600.png", "frame": {"x":0,"y":128,"w":128,"h":128}, "rotated": false, "trimmed": false, "spriteSourceSize": {"x":0,"y":0,"w":128,"h":128}, "sourceSize": {"w":128,"h":128}, "pivot": {"x":0.5,"y":0.5} }, { "filename": "1f601.png", "frame": {"x":128,"y":128,"w":128,"h":128}, "rotated": false, "trimmed": false, "spriteSourceSize": {"x":0,"y":0,"w":128,"h":128}, "sourceSize": {"w":128,"h":128}, "pivot": {"x":0.5,"y":0.5} }, { "filename": "1f602.png", "frame": {"x":256,"y":128,"w":128,"h":128}, "rotated": false, "trimmed": false, "spriteSourceSize": {"x":0,"y":0,"w":128,"h":128}, "sourceSize": {"w":128,"h":128}, "pivot": {"x":0.5,"y":0.5} }, { "filename": "1f603.png", "frame": {"x":384,"y":128,"w":128,"h":128}, "rotated": false, "trimmed": false, "spriteSourceSize": {"x":0,"y":0,"w":128,"h":128}, "sourceSize": {"w":128,"h":128}, "pivot": {"x":0.5,"y":0.5} }, { "filename": "1f604.png", "frame": {"x":0,"y":256,"w":128,"h":128}, "rotated": false, "trimmed": false, "spriteSourceSize": {"x":0,"y":0,"w":128,"h":128}, "sourceSize": {"w":128,"h":128}, "pivot": {"x":0.5,"y":0.5} }, { "filename": "1f605.png", "frame": {"x":128,"y":256,"w":128,"h":128}, "rotated": false, "trimmed": false, "spriteSourceSize": {"x":0,"y":0,"w":128,"h":128}, "sourceSize": {"w":128,"h":128}, "pivot": {"x":0.5,"y":0.5} }, { "filename": "1f606.png", "frame": {"x":256,"y":256,"w":128,"h":128}, "rotated": false, "trimmed": false, "spriteSourceSize": {"x":0,"y":0,"w":128,"h":128}, "sourceSize": {"w":128,"h":128}, "pivot": {"x":0.5,"y":0.5} }, { "filename": "1f609.png", "frame": {"x":384,"y":256,"w":128,"h":128}, "rotated": false, "trimmed": false, "spriteSourceSize": {"x":0,"y":0,"w":128,"h":128}, "sourceSize": {"w":128,"h":128}, "pivot": {"x":0.5,"y":0.5} }, { "filename": "1f618.png", "frame": {"x":0,"y":384,"w":128,"h":128}, "rotated": false, "trimmed": false, "spriteSourceSize": {"x":0,"y":0,"w":128,"h":128}, "sourceSize": {"w":128,"h":128}, "pivot": {"x":0.5,"y":0.5} }, { "filename": "1f923.png", "frame": {"x":128,"y":384,"w":128,"h":128}, "rotated": false, "trimmed": false, "spriteSourceSize": {"x":0,"y":0,"w":128,"h":128}, "sourceSize": {"w":128,"h":128}, "pivot": {"x":0.5,"y":0.5} }, { "filename": "263a.png", "frame": {"x":256,"y":384,"w":128,"h":128}, "rotated": false, "trimmed": false, "spriteSourceSize": {"x":0,"y":0,"w":128,"h":128}, "sourceSize": {"w":128,"h":128}, "pivot": {"x":0.5,"y":0.5} }, { "filename": "2639.png", "frame": {"x":384,"y":384,"w":128,"h":128}, "rotated": false, "trimmed": false, "spriteSourceSize": {"x":0,"y":0,"w":128,"h":128}, "sourceSize": {"w":128,"h":128}, "pivot": {"x":0.5,"y":0.5} }], "meta": { "app": "http://www.codeandweb.com/texturepacker", "version": "1.0", "image": "EmojiOne.png", "format": "RGBA8888", "size": {"w":512,"h":512}, "scale": "1", "smartupdate": "$TexturePacker:SmartUpdate:196a26a2e149d875b91ffc8fa3581e76:fc928c7e275404b7e0649307410475cb:424723c3774975ddb2053fd5c4b85f6e$" } }

File no 168: /colame/Assets/UI FOLDER/BUTTONS/freefantasygui/png/README.txt
- To separate the image, use this tool: http://renderhjs.net/shoebox/ - Just in case the tool failed to extract the sprites, usually it's because the image resolution is too big, then resize the image using this tool first: http://www.highmotionsoftware.com/products/imbatch - Both FREE

File no 169: /colame/Assets/UI FOLDER/TEXTfONTS/need-for-font/license.txt
My Fonts Are free to use personal and commercial works to. But you can't sell them direktly. Please don't make illegal copies of th fonts. Thankx and regards: Koczman Bálint (Cpr.Sparhelt)

File no 170: /colame/Assets/UI FOLDER/TEXTfONTS/perfect-dark-brk/perfectdark.txt
___________________________________ Perfect Dark Created by Brian Kent ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ Thanks for Downloading Perfect Dark. This Font is based on the Logo from the game Perfect Dark. This Font uses Character Extenders [ !@#$%^ ] to give some of the characters in the Font a longer TOP (when you have the letters A, a, D and/or d in your text). For example, if you type out Perfect Dark", type it out like this, Perfect D@a%rk" to give the a and r in Dark extenders. Each Extender is a different size: ! =x1 length @ =x2 length # =x3 length $ =x4 length % =x5 length ^ =x6 length The following characters do not use extenders: CcGgjOoQqSsXx0589"',. The whole Font is made with Capital letters but some of the Characters have more than 1 letter Character. They are: Ee [the e has a slightly higher middle prong like in the PD LOGO] Ff [the f has a slightly higher lower prong like in the PD LOGO] Gg Hh Ii Jj Nn Oo [you can also use 0 and ) for the O's or 0's] Ss [you can also use 5 for an S and vice versa] Uu Vv Xx A few last things. This Font uses A LOT of Kerning to make the Characters fit correctly so make sure what ever program you're using have Character Kerning ON (sometimes if you're using a text editor like Microsoft Word, you usualy have turn the Kerning ON). Finally, to make the Font look more like the Games Logo (slanted), use Italic on the Font. If you have any questions or comments, you can e-mail me at kentpw@norwich.net You can visit my Homepage <ÆNIGMA GAMES & FONTS> at http://aenigma.cellosoft.com/ ________________ INSTALLING FONTS ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯ There's a couple of ways to install Fonts. The 'easy' way to install fonts is to just Unzip/place the font file [.ttf] into your Windows\Fonts directory (I always use this method). If you're unable to do it the 'easy' way, then try to do it this way (for Windows 95/98/NT): 1] Unzip the Font(s) to a folder (or somewhere, just remember where you unzipped it) on your Computer. 2] Next, click on the START button, then select SETTINGS then CONTROL PANEL. 3] When the Control Panel Window pops up, Double Click on FONTS. 4] When the FONTS window pops up, select File then Install New Font... 5] A Add Fonts window will pop up, just go to the folder that you unzipped the Font(s) to, select the Font(s) and then click on OK. Now the Font(s) are installed. Now you can use the Font(s) in programs the utilize Fonts. Make sure that you install the font(s) first, then open up your apps (so the app will recognize the font). Sometimes you'll have to wait until you computer 'auto-refreshes' for programs to recognize fonts (Windows is sometimes slow to do that). You can refresh your computer quicker by going into Windows Explorer -or- My Computer and press ALT + V, then R (or in the menubar select VIEW then REFRESH). __________ DISCLAIMER ¯¯¯¯¯¯¯¯¯¯ -The font(s) in this zip file were created by me (Brian Kent). All of my Fonts are Freeware, you can use them any way you want to (Personal use, Commercial use, or whatever). -If you have a Font related site and would like to offer my fonts on your site, go right ahead. All I ask is that you keep this text file intact with the Font. -You may not Sell or Distribute my Fonts for profit or alter them in any way without asking me first. [e-mail - kentpw@norwich.net]

File no 171: /colame/Assets/dg.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class dg : MonoBehaviour { // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { transform.Translate(-.1f, 0, 0); } void OnTriggerExit(Collider other) { //Destroy(other.gameObject); other.gameObject.GetComponent<Renderer>().material.color = Color.red; Debug.Log("checkedddddddddddddddddddd"); if (other.gameObject.tag == "c") { //Destroy(other.gameObject); other.gameObject.GetComponent<Renderer>().material.color = Color.red; Debug.Log("checkedddddddddddddddddddd"); } } private void OnTriggerEnter(Collider other) { other.gameObject.GetComponent<Renderer>().material.color = Color.yellow; } }

File no 172: /colame/Packages/manifest.json
{ "dependencies": { "com.unity.2d.sprite": "1.0.0", "com.unity.collab-proxy": "1.2.16", "com.unity.ide.rider": "1.1.4", "com.unity.ide.vscode": "1.1.4", "com.unity.test-framework": "1.1.13", "com.unity.textmeshpro": "2.0.1", "com.unity.timeline": "1.2.14", "com.unity.ugui": "1.0.0", "com.unity.modules.ai": "1.0.0", "com.unity.modules.androidjni": "1.0.0", "com.unity.modules.animation": "1.0.0", "com.unity.modules.assetbundle": "1.0.0", "com.unity.modules.audio": "1.0.0", "com.unity.modules.cloth": "1.0.0", "com.unity.modules.director": "1.0.0", "com.unity.modules.imageconversion": "1.0.0", "com.unity.modules.imgui": "1.0.0", "com.unity.modules.jsonserialize": "1.0.0", "com.unity.modules.particlesystem": "1.0.0", "com.unity.modules.physics": "1.0.0", "com.unity.modules.physics2d": "1.0.0", "com.unity.modules.screencapture": "1.0.0", "com.unity.modules.terrain": "1.0.0", "com.unity.modules.terrainphysics": "1.0.0", "com.unity.modules.tilemap": "1.0.0", "com.unity.modules.ui": "1.0.0", "com.unity.modules.uielements": "1.0.0", "com.unity.modules.umbra": "1.0.0", "com.unity.modules.unityanalytics": "1.0.0", "com.unity.modules.unitywebrequest": "1.0.0", "com.unity.modules.unitywebrequestassetbundle": "1.0.0", "com.unity.modules.unitywebrequestaudio": "1.0.0", "com.unity.modules.unitywebrequesttexture": "1.0.0", "com.unity.modules.unitywebrequestwww": "1.0.0", "com.unity.modules.vehicles": "1.0.0", "com.unity.modules.video": "1.0.0", "com.unity.modules.vr": "1.0.0", "com.unity.modules.wind": "1.0.0", "com.unity.modules.xr": "1.0.0" } }

File no 173: /colame/ProjectSettings/ProjectVersion.txt
m_EditorVersion: 2019.3.9f1 m_EditorVersionWithRevision: 2019.3.9f1 (e6e740a1c473)

File no 174: /README.md
COLAME This is a 3D game made with unity. In this person has to move on bridge without colliding with different color obstacle along with collecting coins. Go You can’t perform that action at this time.

20: Project Name : Cat-vs-Dog-Binary-Classifier
This project contains 1 main files, namely /README.md
Below we will get details about each of these files one by one:
	
File no 1: /README.md
Cat-vs-Dog-Binary-Classifier In this project, We use transfer learning to create a Cat or not Cat binary classifier. Go You can’t perform that action at this time.

21: Project Name : ZIG-ZAC
This project contains 11 main files, namely /moving ball/Assets/scripts/UIManager.cs, /moving ball/Assets/scripts/crossing.cs, /moving ball/Assets/scripts/followPlayer.cs, /moving ball/Assets/scripts/gameManager.cs, /moving ball/Assets/scripts/player.cs, /moving ball/Assets/scripts/points.cs, /moving ball/Assets/scripts/spawnPaths.cs, /moving ball/Assets/score.cs, /moving ball/Packages/manifest.json, /moving ball/ProjectSettings/ProjectVersion.txt, /README.md
Below we will get details about each of these files one by one:
	
File no 1: /moving ball/Assets/scripts/UIManager.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.SceneManagement; using UnityEngine.UI; public class UIManager : MonoBehaviour { public Text scoreS; public Text scoreSS; public Text highscore; public GameObject gameoverpanel; public GameObject fallingpanel; public GameObject restartbutton; public GameObject exitbutton; public GameObject gamestartpanel; public GameObject taptoPlay; public static UIManager instance; int i = 0; private void Awake() { //UIManager instance; if (instance == null) { instance = this; } scoreS.text = PlayerPrefs.GetInt("highestscore").ToString(); } // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { //scoreS.text = score.instance.Score.ToString(); //scoreSS.text = score.instance.Score.ToString(); //highscore.text = score.instance.highestscore.ToString(); } public void gamestart() { taptoPlay.SetActive(false); // when we want to make it stop at some frame in between and not make it invisible ...taptoPlay.GetComponent<Animator>().enabled = false; gamestartpanel.GetComponent<Animator>().Play("Up"); } public void gameover() { highscore.text = PlayerPrefs.GetInt("highestscore").ToString(); scoreSS.text = PlayerPrefs.GetInt("Score").ToString(); Invoke("invokegameoverpanel", .2f); // was popping very early...gameoverpanel.SetActive(true); fallingpanel.SetActive(true); restartbutton.SetActive(true); exitbutton.SetActive(true); } public void restart() { SceneManager.LoadScene(0); } public void exitgame() { Application.Quit(); } void invokegameoverpanel() { gameoverpanel.SetActive(true); } }

File no 2: /moving ball/Assets/scripts/crossing.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class crossing : MonoBehaviour { GameObject fall; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { } void OnTriggerExit(Collider a) { if (a.gameObject.tag == "pathzone") { Invoke("falling", .2f); //falling(); } } private void falling() { GetComponentInParent<Rigidbody>().useGravity = true; GetComponentInParent<Rigidbody>().isKinematic = false; Destroy(transform.parent.gameObject, 2f); } }

File no 3: /moving ball/Assets/scripts/followPlayer.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class followPlayer : MonoBehaviour { public GameObject player; Vector3 playerpos; Vector3 camerapos; Vector3 difference; // Start is called before the first frame update void Start() { playerpos = player.transform.position; camerapos = transform.position; difference = playerpos - camerapos; } // Update is called once per frame void Update() { if (!player.GetComponent<player>().gameover) { playerpos = player.transform.position; Vector3 instance = playerpos - difference; transform.position=Vector3.Lerp(camerapos, instance, .1f); //camerapos = instance; camerapos = transform.position; } } }

File no 4: /moving ball/Assets/scripts/gameManager.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class gameManager : MonoBehaviour { public static gameManager instance; private void Awake() { if (instance == null) { instance = this; } } // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { } public void startgame() { UIManager.instance.gamestart(); score.instance.invokeincreamentscore(); spawnPaths.instance.invokesp(); } public void gameover() { //Invoke("UIManager.instance.gameover()", 1f); UIManager.instance.gameover(); } }

File no 5: /moving ball/Assets/scripts/player.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class player : MonoBehaviour { player instance; Rigidbody rb; public bool gameover; [SerializeField] int speed; int a = 0; private void Awake() { if (instance == null) { instance = this; } rb = gameObject.GetComponent<Rigidbody>(); } // Start is called before the first frame update void Start() { gameover = false; } // Update is called once per frame void Update() { Debug.DrawRay(transform.position, Vector3.down, Color.red); if(!Physics.Raycast(transform.position, Vector3.down, 1f)) { gameover = true; rb.velocity = new Vector3(0, -20f, 0); gameManager.instance.gameover(); score.instance.cancelinvokescore(); } if (Input.GetMouseButtonDown(0)&& !gameover) { gameManager.instance.startgame(); if (a == 0) { movex(); } else if (a == 1) { movez(); } } } void movex() { rb.velocity = new Vector3(speed, 0, 0); a = 1; } void movez() { rb.velocity = new Vector3(0,0,speed); a = 0; } }

File no 6: /moving ball/Assets/scripts/points.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class points : MonoBehaviour { public GameObject particle; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { } private void OnTriggerEnter(Collider other) { if (other.gameObject.tag == "pathzone") { GameObject tod = Instantiate(particle, transform.position, Quaternion.identity); Destroy(gameObject); Destroy(tod, 1f); } } }

File no 7: /moving ball/Assets/scripts/spawnPaths.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class spawnPaths : MonoBehaviour { public GameObject diamond; public GameObject path; public GameObject p; player over; float pathsize; Vector3 initialpos; public static spawnPaths instance; // Start is called before the first frame update void Start() { if (instance == null) { instance = this; } pathsize = transform.localScale.x; for(int i = 0; i < 10; i++) { spawn(); } } private void Awake() { over = p.GetComponent<player>(); } public void invokesp() { InvokeRepeating("spawn", 2f, .3f); } // Update is called once per frame void Update() { if (over.gameover) { CancelInvoke("spawn"); } //spawn(); } private void spawn() { initialpos = transform.position; int rand = Random.Range(0, 6); if (rand < 3) { //spawnx(); initialpos = new Vector3(initialpos.x + pathsize, initialpos.y, initialpos.z); Instantiate(path, initialpos, Quaternion.identity); transform.position = initialpos; int ran = Random.Range(0, 10); if (ran < 2) { Vector3 a = transform.position; Instantiate(diamond, new Vector3(a.x,a.y+1,a.z), diamond.transform.rotation); } } else if (rand >= 3) { //spawnz(); initialpos = new Vector3(initialpos.x , initialpos.y, initialpos.z + pathsize); Instantiate(path, initialpos, Quaternion.identity); transform.position = initialpos; int ran = Random.Range(0, 10); if (ran<2) { Vector3 a = transform.position; Instantiate(diamond, new Vector3(a.x, a.y + 1, a.z), diamond.transform.rotation); } } } }

File no 8: /moving ball/Assets/score.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class score : MonoBehaviour { public int Score = 0; public int highestscore; public static score instance; private void Awake() { if (instance == null) { instance = this; } } // Start is called before the first frame update void Start() { PlayerPrefs.SetInt("Score", Score); } // Update is called once per frame void Update() { } void increamentscore() { Score =Score+1; } public void invokeincreamentscore() { InvokeRepeating("increamentscore", .1f, 1f); } public void cancelinvokescore() { CancelInvoke("increamentscore"); PlayerPrefs.SetInt("Score", Score); if (PlayerPrefs.HasKey("highestscore")) { if (Score > PlayerPrefs.GetInt("highestscore")) { PlayerPrefs.SetInt("highestscore", Score); } else { } } else { PlayerPrefs.SetInt("highestscore", Score); } } }

File no 9: /moving ball/Packages/manifest.json
{ "dependencies": { "com.unity.collab-proxy": "1.2.16", "com.unity.ide.rider": "1.1.4", "com.unity.ide.vscode": "1.1.4", "com.unity.test-framework": "1.1.13", "com.unity.textmeshpro": "2.0.1", "com.unity.timeline": "1.2.14", "com.unity.ugui": "1.0.0", "com.unity.modules.ai": "1.0.0", "com.unity.modules.androidjni": "1.0.0", "com.unity.modules.animation": "1.0.0", "com.unity.modules.assetbundle": "1.0.0", "com.unity.modules.audio": "1.0.0", "com.unity.modules.cloth": "1.0.0", "com.unity.modules.director": "1.0.0", "com.unity.modules.imageconversion": "1.0.0", "com.unity.modules.imgui": "1.0.0", "com.unity.modules.jsonserialize": "1.0.0", "com.unity.modules.particlesystem": "1.0.0", "com.unity.modules.physics": "1.0.0", "com.unity.modules.physics2d": "1.0.0", "com.unity.modules.screencapture": "1.0.0", "com.unity.modules.terrain": "1.0.0", "com.unity.modules.terrainphysics": "1.0.0", "com.unity.modules.tilemap": "1.0.0", "com.unity.modules.ui": "1.0.0", "com.unity.modules.uielements": "1.0.0", "com.unity.modules.umbra": "1.0.0", "com.unity.modules.unityanalytics": "1.0.0", "com.unity.modules.unitywebrequest": "1.0.0", "com.unity.modules.unitywebrequestassetbundle": "1.0.0", "com.unity.modules.unitywebrequestaudio": "1.0.0", "com.unity.modules.unitywebrequesttexture": "1.0.0", "com.unity.modules.unitywebrequestwww": "1.0.0", "com.unity.modules.vehicles": "1.0.0", "com.unity.modules.video": "1.0.0", "com.unity.modules.vr": "1.0.0", "com.unity.modules.wind": "1.0.0", "com.unity.modules.xr": "1.0.0" } }

File no 10: /moving ball/ProjectSettings/ProjectVersion.txt
m_EditorVersion: 2019.3.9f1 m_EditorVersionWithRevision: 2019.3.9f1 (e6e740a1c473)

File no 11: /README.md
ZIG-ZAC This is a 3D game made with unity. Go You can’t perform that action at this time.

22: Project Name : HalloweenNight
This project contains 10 main files, namely /Halloween Night/Assets/Destroy.cs, /Halloween Night/Assets/ManageScore.cs, /Halloween Night/Assets/Player.cs, /Halloween Night/Assets/SpawnEnemy.cs, /Halloween Night/Assets/VelocityOfEnemy.cs, /Halloween Night/Assets/collision.cs, /Halloween Night/Assets/pointsIncrease.cs, /Halloween Night/Packages/manifest.json, /Halloween Night/ProjectSettings/ProjectVersion.txt, /README.md
Below we will get details about each of these files one by one:
	
File no 1: /Halloween Night/Assets/Destroy.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class Destroy : MonoBehaviour { // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { } private void OnTriggerEnter2D(Collider2D collision) { Debug.Log("trigger is being entered"); if (collision.gameObject.tag == "Enemy" || collision.gameObject.tag == "Points") { Destroy(collision.gameObject); } } }

File no 2: /Halloween Night/Assets/ManageScore.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; public class ManageScore : MonoBehaviour { public AudioSource whipSound,gameoverSound; public int GameState = 0; //0 not started , 1 to be started , 2 started ,3 to be finished, 4 game is over public GameObject PanelGameOver, PanelGameStarted , RestartButton; //MANAGE UI public Text ScoreText, LivesNo ,HighScoreTextPanel , ScorePanel; public int collisionStatus = 0; public int life = 3; public static ManageScore instance; public float speed=30f; public int score , HighestScore; float timePassedInGame; private void Awake() { if (instance == null) { instance = this; } } // Start is called before the first frame update void Start() { life = 3; LivesNo.text = 3.ToString(); } // Update is called once per frame void Update() { if (GameState == 1) { // to be started InvokeRepeating("scoreIncrease", .5f, .2f); GameState = 2; } if (GameState == 3) { // to be finished CancelInvoke("scoreIncrease"); GameState = 4; } timePassedInGame += Time.deltaTime; if(life<3&& GameState==2) { if (score > 30) { // lets make it interesting if (score > 100) { int x = 100; while (score/x > 0) { x = x * 10; } score = score%(x/10) ; life += 1; LivesNo.text = life.ToString(); } else { score -= 30; life += 1; LivesNo.text = life.ToString(); } } } if (collisionStatus == 1&&GameState==2) { Debug.Log("enter here"); collisionStatus = 0; if (life > 1) { life -= 1; LivesNo.text = life.ToString(); } else { // add sound whipSound.Play(); gameoverSound.Play(); //gameover GameState = 3; life = 0; ; LivesNo.text = life.ToString(); PanelGameOver.gameObject.SetActive(false); // set score ScorePanel.text = score.ToString(); // set HighScore if (PlayerPrefs.HasKey("HS")) { int tempHighScore = PlayerPrefs.GetInt("HS"); if (tempHighScore > score) { HighestScore = tempHighScore; } else { HighestScore = score; PlayerPrefs.SetInt("HS", HighestScore); // new High score } } else { HighestScore = score; PlayerPrefs.SetInt("HS", HighestScore); // new High score } HighScoreTextPanel.text = HighestScore.ToString(); // this will set the highest score PanelGameOver.gameObject.SetActive(true); Debug.Log("game over Panel set active"); RestartButton.SetActive(true); } } if(collisionStatus ==2 && GameState == 2) { collisionStatus = 0; score += 30; } } private void scoreIncrease() { score += 1; ScoreText.text = score.ToString(); // displays score } public void gameStarted() { GameState = 1; PanelGameStarted.GetComponent<Animator>().Play("GameStarted"); whipSound.Play(); } public void gameRestart() { PanelGameOver.GetComponent<Animator>().Play("GameRestart"); whipSound.Play(); //add music GameState = 2; RestartButton.SetActive(false); life = 3; LivesNo.text = life.ToString(); score = 0; ScoreText.text = score.ToString(); // make speed also 0 so that spawning is slow in restarting speed = 30f; InvokeRepeating("scoreIncrease", .5f, .2f); } }

File no 3: /Halloween Night/Assets/Player.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class Player : MonoBehaviour { public GameObject PlayerHorizontal; public AudioSource WhipSound; // define stage of Horzontal bar int StateOfPlayer = 0; //0 for right and 1 for left // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { } public void FlipButtonPressed() { WhipSound.Play(); if (StateOfPlayer == 0) { //Player is in right PlayerHorizontal.transform.position = new Vector2(-1.234f, -1.32f); StateOfPlayer = 1; } else { //Player is in left PlayerHorizontal.transform.position = new Vector2(1.234f, -1.32f); StateOfPlayer = 0; } } }

File no 4: /Halloween Night/Assets/SpawnEnemy.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class SpawnEnemy : MonoBehaviour { public GameObject enemyList; GameObject[] enemy = new GameObject[20]; int LastSpawwnedPos = 0; // 0 for not spawned , 1 for spawned in right , 2 for spawned in left int SecondLastSpawwnedPos = 0; // 0 for not spawned , 1 for spawned in right , 2 for spawned in left float TimeCalculate = 0; // Start is called before the first frame update void Start() { for(int i=0; i<20; i++) { enemy[i] = enemyList.transform.GetChild(i).gameObject; // access all the children gameobjects of the parent gameobject } } // Update is called once per frame void Update() { TimeCalculate += Time.deltaTime; Debug.Log(TimeCalculate); if (TimeCalculate >= .5f&& (ManageScore.instance.GameState==2)) { SpawnTheEnemy(); ManageScore.instance.speed += .1f; } } private void SpawnTheEnemy() { int spawningEnemyNo = Random.Range(0, 20); Debug.Log("hello"); int randomNo = Random.Range(1, 10); if (randomNo <= 9) { // we will spawn the enemy if (LastSpawwnedPos == 0) { // enemy was not spawned SecondLastSpawwnedPos = 0; int x = Random.Range(1, 3); if (x == 1) { // spawn enemy at left Instantiate(enemy[spawningEnemyNo], transform.position - new Vector3(3f, 0f, 0), Quaternion.identity); LastSpawwnedPos = 2; } else { // spawn enemy at right Instantiate(enemy[spawningEnemyNo], transform.position, Quaternion.identity); LastSpawwnedPos = 1; } } else if(LastSpawwnedPos == 1) { // enemy was spawned in right SecondLastSpawwnedPos = 1; if (SecondLastSpawwnedPos == 1) { // two already // enemy was not spawned it is equivalent int x = Random.Range(1, 3); if (x == 1) { // spawn enemy at left Instantiate(enemy[spawningEnemyNo], transform.position - new Vector3(3f, 0f, 0), Quaternion.identity); LastSpawwnedPos = 2; } else { // spawn enemy at right Instantiate(enemy[spawningEnemyNo], transform.position, Quaternion.identity); LastSpawwnedPos = 1; } } else { int x = Random.Range(1, 3); if (x == 1) { // don't spawn //Instantiate(enemy[spawningEnemyNo], transform.position - new Vector3(3f, 0f, 0), Quaternion.identity); LastSpawwnedPos = 0; } else { // spawn enemy at right Instantiate(enemy[spawningEnemyNo], transform.position, Quaternion.identity); LastSpawwnedPos = 1; } } } else { // enemy was spawned in left SecondLastSpawwnedPos = 2; if (SecondLastSpawwnedPos == 2) { // two already // enemy was not spawned int x = Random.Range(1, 3); if (x == 1) { // spawn enemy at left Instantiate(enemy[spawningEnemyNo], transform.position - new Vector3(3f, 0f, 0), Quaternion.identity); LastSpawwnedPos = 2; } else { // spawn enemy at right Instantiate(enemy[spawningEnemyNo], transform.position, Quaternion.identity); LastSpawwnedPos = 1; } } else { int x = Random.Range(1, 3); if (x == 1) { // don't spawn //Instantiate(enemy[spawningEnemyNo], transform.position, Quaternion.identity); LastSpawwnedPos = 0; } else { // spawn enemy at left Instantiate(enemy[spawningEnemyNo], transform.position - new Vector3(3f, 0f, 0), Quaternion.identity); LastSpawwnedPos = 2; } } } } else { // we will not spawn the enemy LastSpawwnedPos = 0; } // spawn the enemy //Instantiate(enemy1, transform.position, Quaternion.identity); //Instantiate(enemy[spawningEnemyNo], transform.position - new Vector3(3f, 0f, 0), Quaternion.identity); //reset the time TimeCalculate = 0; } }

File no 5: /Halloween Night/Assets/VelocityOfEnemy.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class VelocityOfEnemy : MonoBehaviour { // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { transform.Translate( 0, -ManageScore.instance.speed*Time.deltaTime*.2f, 0); } }

File no 6: /Halloween Night/Assets/collision.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class collision : MonoBehaviour { public AudioSource LoosePoints, GainPoints; public GameObject particle , verticalBar; private void Awake() { // gameObject.GetComponent<Rigidbody2D>().gravityScale = 0f; } // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { } private void OnTriggerEnter2D(Collider2D collision) { Debug.Log("trigger is being entered"); if (collision.gameObject.tag == "Enemy" && ManageScore.instance.GameState == 2) { verticalBar.gameObject.GetComponent<Renderer>().material.color = Color.white; gameObject.GetComponent<Renderer>().material.color = Color.white; Invoke("ChangeColorBack", .1f); Invoke("ChangeColorToWhite", .2f); Invoke("ChangeColorBack", .3f); Invoke("ChangeColorToWhite", .4f); Invoke("ChangeColorBack", .5f); //decrease lives ManageScore.instance.collisionStatus =1; LoosePoints.Play(); LoosePoints.volume = 5; } if (collision.gameObject.tag == "Points" && ManageScore.instance.GameState==2) { // show particle effect GameObject tempParticle = Instantiate(particle, collision.gameObject.transform.position, Quaternion.identity); tempParticle.transform.Rotate(90, 0, 0); Destroy(tempParticle, 1f); ManageScore.instance.collisionStatus = 2; Destroy(collision.gameObject); GainPoints.Play(); } } private void ChangeColorBack() { string htmlValue = "#DD3131"; Color newCol; if (ColorUtility.TryParseHtmlString(htmlValue, out newCol)) { gameObject.GetComponent<Renderer>().material.color = newCol; verticalBar.gameObject.GetComponent<Renderer>().material.color = newCol; } ///gameObject.GetComponent<Renderer>().material.color = #DD3131; } private void ChangeColorToWhite() { verticalBar.gameObject.GetComponent<Renderer>().material.color = Color.white; gameObject.GetComponent<Renderer>().material.color = Color.white; } }

File no 7: /Halloween Night/Assets/pointsIncrease.cs
﻿using System.Collections; using System.Collections.Generic; using UnityEngine; public class pointsIncrease : MonoBehaviour { public AudioSource GainPoints; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { } private void OnTriggerEnter2D(Collider2D collision) { Debug.Log("trigger is being entered"); if (collision.gameObject.tag == "Enemy") { //decrease lives ManageScore.instance.collisionStatus = 1; GainPoints.Play(); } } }

File no 8: /Halloween Night/Packages/manifest.json
{ "dependencies": { "com.unity.2d.animation": "3.2.1", "com.unity.2d.pixel-perfect": "2.0.4", "com.unity.2d.psdimporter": "2.1.3", "com.unity.2d.sprite": "1.0.0", "com.unity.2d.spriteshape": "3.0.10", "com.unity.2d.tilemap": "1.0.0", "com.unity.collab-proxy": "1.2.16", "com.unity.ide.rider": "1.1.4", "com.unity.ide.vscode": "1.1.4", "com.unity.test-framework": "1.1.13", "com.unity.textmeshpro": "2.0.1", "com.unity.timeline": "1.2.14", "com.unity.ugui": "1.0.0", "com.unity.modules.ai": "1.0.0", "com.unity.modules.androidjni": "1.0.0", "com.unity.modules.animation": "1.0.0", "com.unity.modules.assetbundle": "1.0.0", "com.unity.modules.audio": "1.0.0", "com.unity.modules.cloth": "1.0.0", "com.unity.modules.director": "1.0.0", "com.unity.modules.imageconversion": "1.0.0", "com.unity.modules.imgui": "1.0.0", "com.unity.modules.jsonserialize": "1.0.0", "com.unity.modules.particlesystem": "1.0.0", "com.unity.modules.physics": "1.0.0", "com.unity.modules.physics2d": "1.0.0", "com.unity.modules.screencapture": "1.0.0", "com.unity.modules.terrain": "1.0.0", "com.unity.modules.terrainphysics": "1.0.0", "com.unity.modules.tilemap": "1.0.0", "com.unity.modules.ui": "1.0.0", "com.unity.modules.uielements": "1.0.0", "com.unity.modules.umbra": "1.0.0", "com.unity.modules.unityanalytics": "1.0.0", "com.unity.modules.unitywebrequest": "1.0.0", "com.unity.modules.unitywebrequestassetbundle": "1.0.0", "com.unity.modules.unitywebrequestaudio": "1.0.0", "com.unity.modules.unitywebrequesttexture": "1.0.0", "com.unity.modules.unitywebrequestwww": "1.0.0", "com.unity.modules.vehicles": "1.0.0", "com.unity.modules.video": "1.0.0", "com.unity.modules.vr": "1.0.0", "com.unity.modules.wind": "1.0.0", "com.unity.modules.xr": "1.0.0" } }

File no 9: /Halloween Night/ProjectSettings/ProjectVersion.txt
m_EditorVersion: 2019.3.9f1 m_EditorVersionWithRevision: 2019.3.9f1 (e6e740a1c473)

File no 10: /README.md
HalloweenNight This is a unity game based on halloween night theme. Go You can’t perform that action at this time.

23: Project Name : Product-Recommender
This project contains 1 main files, namely /README.md
Below we will get details about each of these files one by one:
	
File no 1: /README.md
Product-Recommender This project is part of Product Recommender Hackathon of UNIV.ai. Go You can’t perform that action at this time.
